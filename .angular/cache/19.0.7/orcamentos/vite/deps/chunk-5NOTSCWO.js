import {
  NavigationCancel,
  NavigationEnd,
  Router,
  RouterLink,
  RouterModule
} from "./chunk-VPN5U3B3.js";
import {
  ControlContainer,
  DefaultValueAccessor,
  FormsModule,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControl,
  NgControlStatus,
  NgControlStatusGroup,
  NgForm,
  NgModel,
  NgSelectOption,
  Validators,
  ɵNgNoValidate,
  ɵNgSelectMultipleOption
} from "./chunk-IVDRIKP7.js";
import {
  AnimationBuilder,
  animate,
  animateChild,
  group,
  keyframes,
  query,
  state,
  style,
  transition,
  trigger
} from "./chunk-AZ3XQYKP.js";
import {
  DomSanitizer,
  Title
} from "./chunk-RTDGWPHK.js";
import {
  HTTP_INTERCEPTORS,
  HttpClient,
  HttpEventType,
  HttpHeaders,
  HttpRequest,
  HttpResponse
} from "./chunk-MDAOPEH3.js";
import {
  AsyncPipe,
  CommonModule,
  CurrencyPipe,
  DOCUMENT,
  DatePipe,
  DecimalPipe,
  JsonPipe,
  Location,
  LowerCasePipe,
  NgClass,
  NgForOf,
  NgIf,
  NgOptimizedImage,
  NgPlural,
  NgPluralCase,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet,
  TitleCasePipe,
  isPlatformBrowser
} from "./chunk-RVEK7RBB.js";
import {
  ANIMATION_MODULE_TYPE,
  APP_ID,
  ApplicationRef,
  CSP_NONCE,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EnvironmentInjector,
  EventEmitter,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  NgModule,
  NgModuleRef$1,
  NgZone,
  Optional,
  Output,
  PLATFORM_ID,
  Pipe,
  QueryList,
  Renderer2,
  RendererFactory2,
  TemplateRef,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation,
  afterNextRender,
  afterRender,
  booleanAttribute,
  createComponent,
  effect,
  forwardRef,
  inject,
  isSignal,
  numberAttribute,
  provideAppInitializer,
  setClassMetadata,
  signal,
  untracked,
  ɵsetClassDebugInfo,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassMapInterpolate2,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵpipeBind4,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpropertyInterpolate1,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction5,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveDocument,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵsetComponentScope,
  ɵɵsetNgModuleScope,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-ANYRM7NB.js";
import {
  animationFrameScheduler,
  asapScheduler,
  defer,
  fromEvent,
  isObservable,
  merge
} from "./chunk-JINMNLB2.js";
import {
  BehaviorSubject,
  ConnectableObservable,
  Observable,
  ReplaySubject,
  Subject,
  Subscription,
  __async,
  __objRest,
  __spreadProps,
  __spreadValues,
  auditTime,
  catchError,
  combineLatest,
  concat2 as concat,
  concatMap,
  debounceTime,
  delay,
  distinctUntilChanged,
  filter,
  finalize,
  from,
  interval,
  map,
  mapTo,
  mergeMap,
  of,
  pairwise,
  scan,
  shareReplay,
  skip,
  startWith,
  switchMap,
  take,
  takeUntil,
  takeWhile,
  tap,
  throwError,
  timer
} from "./chunk-2C44WUKA.js";

// node_modules/@angular/cdk/fesm2022/platform.mjs
var hasV8BreakIterator;
try {
  hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
} catch {
  hasV8BreakIterator = false;
}
var Platform = class _Platform {
  _platformId = inject(PLATFORM_ID);
  // We want to use the Angular platform check because if the Document is shimmed
  // without the navigator, the following checks will fail. This is preferred because
  // sometimes the Document may be shimmed without the user's knowledge or intention
  /** Whether the Angular application is being rendered in the browser. */
  isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : typeof document === "object" && !!document;
  /** Whether the current browser is Microsoft Edge. */
  EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
  /** Whether the current rendering engine is Microsoft Trident. */
  TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
  // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.
  /** Whether the current rendering engine is Blink. */
  BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !this.EDGE && !this.TRIDENT;
  // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
  // ensure that Webkit runs standalone and is not used as another engine's base.
  /** Whether the current rendering engine is WebKit. */
  WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
  /** Whether the current platform is Apple iOS. */
  IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
  // It's difficult to detect the plain Gecko engine, because most of the browsers identify
  // them self as Gecko-like browsers and modify the userAgent's according to that.
  // Since we only cover one explicit Firefox case, we can simply check for Firefox
  // instead of having an unstable check for Gecko.
  /** Whether the current browser is Firefox. */
  FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
  /** Whether the current platform is Android. */
  // Trident on mobile adds the android platform to the userAgent to trick detections.
  ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
  // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
  // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
  // Safari browser should also use Webkit as its layout engine.
  /** Whether the current browser is Safari. */
  SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
  constructor() {
  }
  static ɵfac = function Platform_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Platform)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _Platform,
    factory: _Platform.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Platform, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var PlatformModule = class _PlatformModule {
  static ɵfac = function PlatformModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PlatformModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PlatformModule
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var supportsPassiveEvents;
function supportsPassiveEventListeners() {
  if (supportsPassiveEvents == null && typeof window !== "undefined") {
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get: () => supportsPassiveEvents = true
      }));
    } finally {
      supportsPassiveEvents = supportsPassiveEvents || false;
    }
  }
  return supportsPassiveEvents;
}
function normalizePassiveListenerOptions(options) {
  return supportsPassiveEventListeners() ? options : !!options.capture;
}
var RtlScrollAxisType;
(function(RtlScrollAxisType2) {
  RtlScrollAxisType2[RtlScrollAxisType2["NORMAL"] = 0] = "NORMAL";
  RtlScrollAxisType2[RtlScrollAxisType2["NEGATED"] = 1] = "NEGATED";
  RtlScrollAxisType2[RtlScrollAxisType2["INVERTED"] = 2] = "INVERTED";
})(RtlScrollAxisType || (RtlScrollAxisType = {}));
var rtlScrollAxisType;
var scrollBehaviorSupported;
function supportsScrollBehavior() {
  if (scrollBehaviorSupported == null) {
    if (typeof document !== "object" || !document || typeof Element !== "function" || !Element) {
      scrollBehaviorSupported = false;
      return scrollBehaviorSupported;
    }
    if ("scrollBehavior" in document.documentElement.style) {
      scrollBehaviorSupported = true;
    } else {
      const scrollToFunction = Element.prototype.scrollTo;
      if (scrollToFunction) {
        scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
      } else {
        scrollBehaviorSupported = false;
      }
    }
  }
  return scrollBehaviorSupported;
}
function getRtlScrollAxisType() {
  if (typeof document !== "object" || !document) {
    return RtlScrollAxisType.NORMAL;
  }
  if (rtlScrollAxisType == null) {
    const scrollContainer = document.createElement("div");
    const containerStyle = scrollContainer.style;
    scrollContainer.dir = "rtl";
    containerStyle.width = "1px";
    containerStyle.overflow = "auto";
    containerStyle.visibility = "hidden";
    containerStyle.pointerEvents = "none";
    containerStyle.position = "absolute";
    const content = document.createElement("div");
    const contentStyle = content.style;
    contentStyle.width = "2px";
    contentStyle.height = "1px";
    scrollContainer.appendChild(content);
    document.body.appendChild(scrollContainer);
    rtlScrollAxisType = RtlScrollAxisType.NORMAL;
    if (scrollContainer.scrollLeft === 0) {
      scrollContainer.scrollLeft = 1;
      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;
    }
    scrollContainer.remove();
  }
  return rtlScrollAxisType;
}
var shadowDomIsSupported;
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
function _getFocusedElementPierceShadowDom() {
  let activeElement = typeof document !== "undefined" && document ? document.activeElement : null;
  while (activeElement && activeElement.shadowRoot) {
    const newActiveElement = activeElement.shadowRoot.activeElement;
    if (newActiveElement === activeElement) {
      break;
    } else {
      activeElement = newActiveElement;
    }
  }
  return activeElement;
}
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}
function _isTestEnvironment() {
  return (
    // @ts-ignore
    typeof __karma__ !== "undefined" && !!__karma__ || // @ts-ignore
    typeof jasmine !== "undefined" && !!jasmine || // @ts-ignore
    typeof jest !== "undefined" && !!jest || // @ts-ignore
    typeof Mocha !== "undefined" && !!Mocha
  );
}

// node_modules/@angular/cdk/fesm2022/private.mjs
var appsWithLoaders = /* @__PURE__ */ new WeakMap();
var _CdkPrivateStyleLoader = class __CdkPrivateStyleLoader {
  _appRef;
  _injector = inject(Injector);
  _environmentInjector = inject(EnvironmentInjector);
  /**
   * Loads a set of styles.
   * @param loader Component which will be instantiated to load the styles.
   */
  load(loader) {
    const appRef = this._appRef = this._appRef || this._injector.get(ApplicationRef);
    let data = appsWithLoaders.get(appRef);
    if (!data) {
      data = {
        loaders: /* @__PURE__ */ new Set(),
        refs: []
      };
      appsWithLoaders.set(appRef, data);
      appRef.onDestroy(() => {
        appsWithLoaders.get(appRef)?.refs.forEach((ref) => ref.destroy());
        appsWithLoaders.delete(appRef);
      });
    }
    if (!data.loaders.has(loader)) {
      data.loaders.add(loader);
      data.refs.push(createComponent(loader, {
        environmentInjector: this._environmentInjector
      }));
    }
  }
  static ɵfac = function _CdkPrivateStyleLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __CdkPrivateStyleLoader)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: __CdkPrivateStyleLoader,
    factory: __CdkPrivateStyleLoader.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CdkPrivateStyleLoader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _VisuallyHiddenLoader = class __VisuallyHiddenLoader {
  static ɵfac = function _VisuallyHiddenLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __VisuallyHiddenLoader)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: __VisuallyHiddenLoader,
    selectors: [["ng-component"]],
    exportAs: ["cdkVisuallyHidden"],
    decls: 0,
    vars: 0,
    template: function _VisuallyHiddenLoader_Template(rf, ctx) {
    },
    styles: [".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_VisuallyHiddenLoader, [{
    type: Component,
    args: [{
      exportAs: "cdkVisuallyHidden",
      encapsulation: ViewEncapsulation.None,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}"]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/keycodes.mjs
var TAB = 9;
var ENTER = 13;
var SHIFT = 16;
var CONTROL = 17;
var ALT = 18;
var ESCAPE = 27;
var SPACE = 32;
var PAGE_UP = 33;
var PAGE_DOWN = 34;
var END = 35;
var HOME = 36;
var LEFT_ARROW = 37;
var UP_ARROW = 38;
var RIGHT_ARROW = 39;
var DOWN_ARROW = 40;
var ZERO = 48;
var NINE = 57;
var A = 65;
var Z = 90;
var META = 91;
var MAC_META = 224;
function hasModifierKey(event, ...modifiers) {
  if (modifiers.length) {
    return modifiers.some((modifier) => event[modifier]);
  }
  return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;
}

// node_modules/@angular/cdk/fesm2022/coercion/private.mjs
function coerceObservable(data) {
  if (!isObservable(data)) {
    return of(data);
  }
  return data;
}

// node_modules/@angular/cdk/fesm2022/coercion.mjs
function coerceNumberProperty(value, fallbackValue = 0) {
  if (_isNumberValue(value)) {
    return Number(value);
  }
  return arguments.length === 2 ? fallbackValue : 0;
}
function _isNumberValue(value) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value));
}
function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}
function coerceCssPixelValue(value) {
  if (value == null) {
    return "";
  }
  return typeof value === "string" ? value : `${value}px`;
}
function coerceElement(elementOrRef) {
  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;
}

// node_modules/@angular/cdk/fesm2022/observers.mjs
function shouldIgnoreRecord(record) {
  if (record.type === "characterData" && record.target instanceof Comment) {
    return true;
  }
  if (record.type === "childList") {
    for (let i = 0; i < record.addedNodes.length; i++) {
      if (!(record.addedNodes[i] instanceof Comment)) {
        return false;
      }
    }
    for (let i = 0; i < record.removedNodes.length; i++) {
      if (!(record.removedNodes[i] instanceof Comment)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var MutationObserverFactory = class _MutationObserverFactory {
  create(callback) {
    return typeof MutationObserver === "undefined" ? null : new MutationObserver(callback);
  }
  static ɵfac = function MutationObserverFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MutationObserverFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MutationObserverFactory,
    factory: _MutationObserverFactory.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MutationObserverFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ContentObserver = class _ContentObserver {
  _mutationObserverFactory = inject(MutationObserverFactory);
  /** Keeps track of the existing MutationObservers so they can be reused. */
  _observedElements = /* @__PURE__ */ new Map();
  _ngZone = inject(NgZone);
  constructor() {
  }
  ngOnDestroy() {
    this._observedElements.forEach((_, element) => this._cleanupObserver(element));
  }
  observe(elementOrRef) {
    const element = coerceElement(elementOrRef);
    return new Observable((observer) => {
      const stream = this._observeElement(element);
      const subscription = stream.pipe(map((records) => records.filter((record) => !shouldIgnoreRecord(record))), filter((records) => !!records.length)).subscribe((records) => {
        this._ngZone.run(() => {
          observer.next(records);
        });
      });
      return () => {
        subscription.unsubscribe();
        this._unobserveElement(element);
      };
    });
  }
  /**
   * Observes the given element by using the existing MutationObserver if available, or creating a
   * new one if not.
   */
  _observeElement(element) {
    return this._ngZone.runOutsideAngular(() => {
      if (!this._observedElements.has(element)) {
        const stream = new Subject();
        const observer = this._mutationObserverFactory.create((mutations) => stream.next(mutations));
        if (observer) {
          observer.observe(element, {
            characterData: true,
            childList: true,
            subtree: true
          });
        }
        this._observedElements.set(element, {
          observer,
          stream,
          count: 1
        });
      } else {
        this._observedElements.get(element).count++;
      }
      return this._observedElements.get(element).stream;
    });
  }
  /**
   * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
   * observing this element.
   */
  _unobserveElement(element) {
    if (this._observedElements.has(element)) {
      this._observedElements.get(element).count--;
      if (!this._observedElements.get(element).count) {
        this._cleanupObserver(element);
      }
    }
  }
  /** Clean up the underlying MutationObserver for the specified element. */
  _cleanupObserver(element) {
    if (this._observedElements.has(element)) {
      const {
        observer,
        stream
      } = this._observedElements.get(element);
      if (observer) {
        observer.disconnect();
      }
      stream.complete();
      this._observedElements.delete(element);
    }
  }
  static ɵfac = function ContentObserver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContentObserver)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ContentObserver,
    factory: _ContentObserver.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkObserveContent = class _CdkObserveContent {
  _contentObserver = inject(ContentObserver);
  _elementRef = inject(ElementRef);
  /** Event emitted for each change in the element's content. */
  event = new EventEmitter();
  /**
   * Whether observing content is disabled. This option can be used
   * to disconnect the underlying MutationObserver until it is needed.
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._disabled ? this._unsubscribe() : this._subscribe();
  }
  _disabled = false;
  /** Debounce interval for emitting the changes. */
  get debounce() {
    return this._debounce;
  }
  set debounce(value) {
    this._debounce = coerceNumberProperty(value);
    this._subscribe();
  }
  _debounce;
  _currentSubscription = null;
  constructor() {
  }
  ngAfterContentInit() {
    if (!this._currentSubscription && !this.disabled) {
      this._subscribe();
    }
  }
  ngOnDestroy() {
    this._unsubscribe();
  }
  _subscribe() {
    this._unsubscribe();
    const stream = this._contentObserver.observe(this._elementRef);
    this._currentSubscription = (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);
  }
  _unsubscribe() {
    this._currentSubscription?.unsubscribe();
  }
  static ɵfac = function CdkObserveContent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkObserveContent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkObserveContent,
    selectors: [["", "cdkObserveContent", ""]],
    inputs: {
      disabled: [2, "cdkObserveContentDisabled", "disabled", booleanAttribute],
      debounce: "debounce"
    },
    outputs: {
      event: "cdkObserveContent"
    },
    exportAs: ["cdkObserveContent"],
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkObserveContent, [{
    type: Directive,
    args: [{
      selector: "[cdkObserveContent]",
      exportAs: "cdkObserveContent"
    }]
  }], () => [], {
    event: [{
      type: Output,
      args: ["cdkObserveContent"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkObserveContentDisabled",
        transform: booleanAttribute
      }]
    }],
    debounce: [{
      type: Input
    }]
  });
})();
var ObserversModule = class _ObserversModule {
  static ɵfac = function ObserversModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ObserversModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ObserversModule,
    imports: [CdkObserveContent],
    exports: [CdkObserveContent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [MutationObserverFactory]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObserversModule, [{
    type: NgModule,
    args: [{
      imports: [CdkObserveContent],
      exports: [CdkObserveContent],
      providers: [MutationObserverFactory]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/layout.mjs
var LayoutModule = class _LayoutModule {
  static ɵfac = function LayoutModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LayoutModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _LayoutModule
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var mediaQueriesForWebkitCompatibility = /* @__PURE__ */ new Set();
var mediaQueryStyleNode;
var MediaMatcher = class _MediaMatcher {
  _platform = inject(Platform);
  _nonce = inject(CSP_NONCE, {
    optional: true
  });
  /** The internal matchMedia method to return back a MediaQueryList like object. */
  _matchMedia;
  constructor() {
    this._matchMedia = this._platform.isBrowser && window.matchMedia ? (
      // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
      // call it from a different scope.
      window.matchMedia.bind(window)
    ) : noopMatchMedia;
  }
  /**
   * Evaluates the given media query and returns the native MediaQueryList from which results
   * can be retrieved.
   * Confirms the layout engine will trigger for the selector query provided and returns the
   * MediaQueryList for the query provided.
   */
  matchMedia(query2) {
    if (this._platform.WEBKIT || this._platform.BLINK) {
      createEmptyStyleRule(query2, this._nonce);
    }
    return this._matchMedia(query2);
  }
  static ɵfac = function MediaMatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MediaMatcher)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MediaMatcher,
    factory: _MediaMatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaMatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function createEmptyStyleRule(query2, nonce) {
  if (mediaQueriesForWebkitCompatibility.has(query2)) {
    return;
  }
  try {
    if (!mediaQueryStyleNode) {
      mediaQueryStyleNode = document.createElement("style");
      if (nonce) {
        mediaQueryStyleNode.setAttribute("nonce", nonce);
      }
      mediaQueryStyleNode.setAttribute("type", "text/css");
      document.head.appendChild(mediaQueryStyleNode);
    }
    if (mediaQueryStyleNode.sheet) {
      mediaQueryStyleNode.sheet.insertRule(`@media ${query2} {body{ }}`, 0);
      mediaQueriesForWebkitCompatibility.add(query2);
    }
  } catch (e) {
    console.error(e);
  }
}
function noopMatchMedia(query2) {
  return {
    matches: query2 === "all" || query2 === "",
    media: query2,
    addListener: () => {
    },
    removeListener: () => {
    }
  };
}
var BreakpointObserver = class _BreakpointObserver {
  _mediaMatcher = inject(MediaMatcher);
  _zone = inject(NgZone);
  /**  A map of all media queries currently being listened for. */
  _queries = /* @__PURE__ */ new Map();
  /** A subject for all other observables to takeUntil based on. */
  _destroySubject = new Subject();
  constructor() {
  }
  /** Completes the active subject, signalling to all other observables to complete. */
  ngOnDestroy() {
    this._destroySubject.next();
    this._destroySubject.complete();
  }
  /**
   * Whether one or more media queries match the current viewport size.
   * @param value One or more media queries to check.
   * @returns Whether any of the media queries match.
   */
  isMatched(value) {
    const queries = splitQueries(coerceArray(value));
    return queries.some((mediaQuery) => this._registerQuery(mediaQuery).mql.matches);
  }
  /**
   * Gets an observable of results for the given queries that will emit new results for any changes
   * in matching of the given queries.
   * @param value One or more media queries to check.
   * @returns A stream of matches for the given queries.
   */
  observe(value) {
    const queries = splitQueries(coerceArray(value));
    const observables = queries.map((query2) => this._registerQuery(query2).observable);
    let stateObservable = combineLatest(observables);
    stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));
    return stateObservable.pipe(map((breakpointStates) => {
      const response = {
        matches: false,
        breakpoints: {}
      };
      breakpointStates.forEach(({
        matches,
        query: query2
      }) => {
        response.matches = response.matches || matches;
        response.breakpoints[query2] = matches;
      });
      return response;
    }));
  }
  /** Registers a specific query to be listened for. */
  _registerQuery(query2) {
    if (this._queries.has(query2)) {
      return this._queries.get(query2);
    }
    const mql = this._mediaMatcher.matchMedia(query2);
    const queryObservable = new Observable((observer) => {
      const handler = (e) => this._zone.run(() => observer.next(e));
      mql.addListener(handler);
      return () => {
        mql.removeListener(handler);
      };
    }).pipe(startWith(mql), map(({
      matches
    }) => ({
      query: query2,
      matches
    })), takeUntil(this._destroySubject));
    const output = {
      observable: queryObservable,
      mql
    };
    this._queries.set(query2, output);
    return output;
  }
  static ɵfac = function BreakpointObserver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreakpointObserver)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _BreakpointObserver,
    factory: _BreakpointObserver.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreakpointObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function splitQueries(queries) {
  return queries.map((query2) => query2.split(",")).reduce((a1, a2) => a1.concat(a2)).map((query2) => query2.trim());
}

// node_modules/@angular/cdk/fesm2022/a11y.mjs
var ID_DELIMITER = " ";
function addAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  if (ids.some((existingId) => existingId.trim() === id)) {
    return;
  }
  ids.push(id);
  el.setAttribute(attr, ids.join(ID_DELIMITER));
}
function removeAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  const filteredIds = ids.filter((val) => val !== id);
  if (filteredIds.length) {
    el.setAttribute(attr, filteredIds.join(ID_DELIMITER));
  } else {
    el.removeAttribute(attr);
  }
}
function getAriaReferenceIds(el, attr) {
  const attrValue = el.getAttribute(attr);
  return attrValue?.match(/\S+/g) ?? [];
}
var CDK_DESCRIBEDBY_ID_PREFIX = "cdk-describedby-message";
var CDK_DESCRIBEDBY_HOST_ATTRIBUTE = "cdk-describedby-host";
var nextId = 0;
var AriaDescriber = class _AriaDescriber {
  _platform = inject(Platform);
  _document = inject(DOCUMENT);
  /** Map of all registered message elements that have been placed into the document. */
  _messageRegistry = /* @__PURE__ */ new Map();
  /** Container for all registered messages. */
  _messagesContainer = null;
  /** Unique ID for the service. */
  _id = `${nextId++}`;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
    this._id = inject(APP_ID) + "-" + nextId++;
  }
  describe(hostElement, message, role) {
    if (!this._canBeDescribed(hostElement, message)) {
      return;
    }
    const key = getKey(message, role);
    if (typeof message !== "string") {
      setMessageId(message, this._id);
      this._messageRegistry.set(key, {
        messageElement: message,
        referenceCount: 0
      });
    } else if (!this._messageRegistry.has(key)) {
      this._createMessageElement(message, role);
    }
    if (!this._isElementDescribedByMessage(hostElement, key)) {
      this._addMessageReference(hostElement, key);
    }
  }
  removeDescription(hostElement, message, role) {
    if (!message || !this._isElementNode(hostElement)) {
      return;
    }
    const key = getKey(message, role);
    if (this._isElementDescribedByMessage(hostElement, key)) {
      this._removeMessageReference(hostElement, key);
    }
    if (typeof message === "string") {
      const registeredMessage = this._messageRegistry.get(key);
      if (registeredMessage && registeredMessage.referenceCount === 0) {
        this._deleteMessageElement(key);
      }
    }
    if (this._messagesContainer?.childNodes.length === 0) {
      this._messagesContainer.remove();
      this._messagesContainer = null;
    }
  }
  /** Unregisters all created message elements and removes the message container. */
  ngOnDestroy() {
    const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}="${this._id}"]`);
    for (let i = 0; i < describedElements.length; i++) {
      this._removeCdkDescribedByReferenceIds(describedElements[i]);
      describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
    }
    this._messagesContainer?.remove();
    this._messagesContainer = null;
    this._messageRegistry.clear();
  }
  /**
   * Creates a new element in the visually hidden message container element with the message
   * as its content and adds it to the message registry.
   */
  _createMessageElement(message, role) {
    const messageElement = this._document.createElement("div");
    setMessageId(messageElement, this._id);
    messageElement.textContent = message;
    if (role) {
      messageElement.setAttribute("role", role);
    }
    this._createMessagesContainer();
    this._messagesContainer.appendChild(messageElement);
    this._messageRegistry.set(getKey(message, role), {
      messageElement,
      referenceCount: 0
    });
  }
  /** Deletes the message element from the global messages container. */
  _deleteMessageElement(key) {
    this._messageRegistry.get(key)?.messageElement?.remove();
    this._messageRegistry.delete(key);
  }
  /** Creates the global container for all aria-describedby messages. */
  _createMessagesContainer() {
    if (this._messagesContainer) {
      return;
    }
    const containerClassName = "cdk-describedby-message-container";
    const serverContainers = this._document.querySelectorAll(`.${containerClassName}[platform="server"]`);
    for (let i = 0; i < serverContainers.length; i++) {
      serverContainers[i].remove();
    }
    const messagesContainer = this._document.createElement("div");
    messagesContainer.style.visibility = "hidden";
    messagesContainer.classList.add(containerClassName);
    messagesContainer.classList.add("cdk-visually-hidden");
    if (!this._platform.isBrowser) {
      messagesContainer.setAttribute("platform", "server");
    }
    this._document.body.appendChild(messagesContainer);
    this._messagesContainer = messagesContainer;
  }
  /** Removes all cdk-describedby messages that are hosted through the element. */
  _removeCdkDescribedByReferenceIds(element) {
    const originalReferenceIds = getAriaReferenceIds(element, "aria-describedby").filter((id) => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);
    element.setAttribute("aria-describedby", originalReferenceIds.join(" "));
  }
  /**
   * Adds a message reference to the element using aria-describedby and increments the registered
   * message's reference count.
   */
  _addMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    addAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);
    registeredMessage.referenceCount++;
  }
  /**
   * Removes a message reference from the element using aria-describedby
   * and decrements the registered message's reference count.
   */
  _removeMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    registeredMessage.referenceCount--;
    removeAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
  }
  /** Returns true if the element has been described by the provided message ID. */
  _isElementDescribedByMessage(element, key) {
    const referenceIds = getAriaReferenceIds(element, "aria-describedby");
    const registeredMessage = this._messageRegistry.get(key);
    const messageId = registeredMessage && registeredMessage.messageElement.id;
    return !!messageId && referenceIds.indexOf(messageId) != -1;
  }
  /** Determines whether a message can be described on a particular element. */
  _canBeDescribed(element, message) {
    if (!this._isElementNode(element)) {
      return false;
    }
    if (message && typeof message === "object") {
      return true;
    }
    const trimmedMessage = message == null ? "" : `${message}`.trim();
    const ariaLabel = element.getAttribute("aria-label");
    return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;
  }
  /** Checks whether a node is an Element node. */
  _isElementNode(element) {
    return element.nodeType === this._document.ELEMENT_NODE;
  }
  static ɵfac = function AriaDescriber_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AriaDescriber)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AriaDescriber,
    factory: _AriaDescriber.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AriaDescriber, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function getKey(message, role) {
  return typeof message === "string" ? `${role || ""}/${message}` : message;
}
function setMessageId(element, serviceId) {
  if (!element.id) {
    element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;
  }
}
var DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS = 200;
var Typeahead = class {
  _letterKeyStream = new Subject();
  _items = [];
  _selectedItemIndex = -1;
  /** Buffer for the letters that the user has pressed */
  _pressedLetters = [];
  _skipPredicateFn;
  _selectedItem = new Subject();
  selectedItem = this._selectedItem;
  constructor(initialItems, config) {
    const typeAheadInterval = typeof config?.debounceInterval === "number" ? config.debounceInterval : DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS;
    if (config?.skipPredicate) {
      this._skipPredicateFn = config.skipPredicate;
    }
    if ((typeof ngDevMode === "undefined" || ngDevMode) && initialItems.length && initialItems.some((item) => typeof item.getLabel !== "function")) {
      throw new Error("KeyManager items in typeahead mode must implement the `getLabel` method.");
    }
    this.setItems(initialItems);
    this._setupKeyHandler(typeAheadInterval);
  }
  destroy() {
    this._pressedLetters = [];
    this._letterKeyStream.complete();
    this._selectedItem.complete();
  }
  setCurrentSelectedItemIndex(index) {
    this._selectedItemIndex = index;
  }
  setItems(items) {
    this._items = items;
  }
  handleKey(event) {
    const keyCode = event.keyCode;
    if (event.key && event.key.length === 1) {
      this._letterKeyStream.next(event.key.toLocaleUpperCase());
    } else if (keyCode >= A && keyCode <= Z || keyCode >= ZERO && keyCode <= NINE) {
      this._letterKeyStream.next(String.fromCharCode(keyCode));
    }
  }
  /** Gets whether the user is currently typing into the manager using the typeahead feature. */
  isTyping() {
    return this._pressedLetters.length > 0;
  }
  /** Resets the currently stored sequence of typed letters. */
  reset() {
    this._pressedLetters = [];
  }
  _setupKeyHandler(typeAheadInterval) {
    this._letterKeyStream.pipe(tap((letter) => this._pressedLetters.push(letter)), debounceTime(typeAheadInterval), filter(() => this._pressedLetters.length > 0), map(() => this._pressedLetters.join("").toLocaleUpperCase())).subscribe((inputString) => {
      for (let i = 1; i < this._items.length + 1; i++) {
        const index = (this._selectedItemIndex + i) % this._items.length;
        const item = this._items[index];
        if (!this._skipPredicateFn?.(item) && item.getLabel?.().toLocaleUpperCase().trim().indexOf(inputString) === 0) {
          this._selectedItem.next(item);
          break;
        }
      }
      this._pressedLetters = [];
    });
  }
};
var ListKeyManager = class {
  _items;
  _activeItemIndex = -1;
  _activeItem = signal(null);
  _wrap = false;
  _typeaheadSubscription = Subscription.EMPTY;
  _itemChangesSubscription;
  _vertical = true;
  _horizontal;
  _allowedModifierKeys = [];
  _homeAndEnd = false;
  _pageUpAndDown = {
    enabled: false,
    delta: 10
  };
  _effectRef;
  _typeahead;
  /**
   * Predicate function that can be used to check whether an item should be skipped
   * by the key manager. By default, disabled items are skipped.
   */
  _skipPredicateFn = (item) => item.disabled;
  constructor(_items, injector) {
    this._items = _items;
    if (_items instanceof QueryList) {
      this._itemChangesSubscription = _items.changes.subscribe((newItems) => this._itemsChanged(newItems.toArray()));
    } else if (isSignal(_items)) {
      if (!injector && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw new Error("ListKeyManager constructed with a signal must receive an injector");
      }
      this._effectRef = effect(() => this._itemsChanged(_items()), {
        injector
      });
    }
  }
  /**
   * Stream that emits any time the TAB key is pressed, so components can react
   * when focus is shifted off of the list.
   */
  tabOut = new Subject();
  /** Stream that emits whenever the active item of the list manager changes. */
  change = new Subject();
  /**
   * Sets the predicate function that determines which items should be skipped by the
   * list key manager.
   * @param predicate Function that determines whether the given item should be skipped.
   */
  skipPredicate(predicate) {
    this._skipPredicateFn = predicate;
    return this;
  }
  /**
   * Configures wrapping mode, which determines whether the active item will wrap to
   * the other end of list when there are no more items in the given direction.
   * @param shouldWrap Whether the list should wrap when reaching the end.
   */
  withWrap(shouldWrap = true) {
    this._wrap = shouldWrap;
    return this;
  }
  /**
   * Configures whether the key manager should be able to move the selection vertically.
   * @param enabled Whether vertical selection should be enabled.
   */
  withVerticalOrientation(enabled = true) {
    this._vertical = enabled;
    return this;
  }
  /**
   * Configures the key manager to move the selection horizontally.
   * Passing in `null` will disable horizontal movement.
   * @param direction Direction in which the selection can be moved.
   */
  withHorizontalOrientation(direction) {
    this._horizontal = direction;
    return this;
  }
  /**
   * Modifier keys which are allowed to be held down and whose default actions will be prevented
   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.
   */
  withAllowedModifierKeys(keys) {
    this._allowedModifierKeys = keys;
    return this;
  }
  /**
   * Turns on typeahead mode which allows users to set the active item by typing.
   * @param debounceInterval Time to wait after the last keystroke before setting the active item.
   */
  withTypeAhead(debounceInterval = 200) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const items2 = this._getItemsArray();
      if (items2.length > 0 && items2.some((item) => typeof item.getLabel !== "function")) {
        throw Error("ListKeyManager items in typeahead mode must implement the `getLabel` method.");
      }
    }
    this._typeaheadSubscription.unsubscribe();
    const items = this._getItemsArray();
    this._typeahead = new Typeahead(items, {
      debounceInterval: typeof debounceInterval === "number" ? debounceInterval : void 0,
      skipPredicate: (item) => this._skipPredicateFn(item)
    });
    this._typeaheadSubscription = this._typeahead.selectedItem.subscribe((item) => {
      this.setActiveItem(item);
    });
    return this;
  }
  /** Cancels the current typeahead sequence. */
  cancelTypeahead() {
    this._typeahead?.reset();
    return this;
  }
  /**
   * Configures the key manager to activate the first and last items
   * respectively when the Home or End key is pressed.
   * @param enabled Whether pressing the Home or End key activates the first/last item.
   */
  withHomeAndEnd(enabled = true) {
    this._homeAndEnd = enabled;
    return this;
  }
  /**
   * Configures the key manager to activate every 10th, configured or first/last element in up/down direction
   * respectively when the Page-Up or Page-Down key is pressed.
   * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.
   * @param delta Whether pressing the Home or End key activates the first/last item.
   */
  withPageUpDown(enabled = true, delta = 10) {
    this._pageUpAndDown = {
      enabled,
      delta
    };
    return this;
  }
  setActiveItem(item) {
    const previousActiveItem = this._activeItem();
    this.updateActiveItem(item);
    if (this._activeItem() !== previousActiveItem) {
      this.change.next(this._activeItemIndex);
    }
  }
  /**
   * Sets the active item depending on the key event passed in.
   * @param event Keyboard event to be used for determining which element should be active.
   */
  onKeydown(event) {
    const keyCode = event.keyCode;
    const modifiers = ["altKey", "ctrlKey", "metaKey", "shiftKey"];
    const isModifierAllowed = modifiers.every((modifier) => {
      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;
    });
    switch (keyCode) {
      case TAB:
        this.tabOut.next();
        return;
      case DOWN_ARROW:
        if (this._vertical && isModifierAllowed) {
          this.setNextItemActive();
          break;
        } else {
          return;
        }
      case UP_ARROW:
        if (this._vertical && isModifierAllowed) {
          this.setPreviousItemActive();
          break;
        } else {
          return;
        }
      case RIGHT_ARROW:
        if (this._horizontal && isModifierAllowed) {
          this._horizontal === "rtl" ? this.setPreviousItemActive() : this.setNextItemActive();
          break;
        } else {
          return;
        }
      case LEFT_ARROW:
        if (this._horizontal && isModifierAllowed) {
          this._horizontal === "rtl" ? this.setNextItemActive() : this.setPreviousItemActive();
          break;
        } else {
          return;
        }
      case HOME:
        if (this._homeAndEnd && isModifierAllowed) {
          this.setFirstItemActive();
          break;
        } else {
          return;
        }
      case END:
        if (this._homeAndEnd && isModifierAllowed) {
          this.setLastItemActive();
          break;
        } else {
          return;
        }
      case PAGE_UP:
        if (this._pageUpAndDown.enabled && isModifierAllowed) {
          const targetIndex = this._activeItemIndex - this._pageUpAndDown.delta;
          this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);
          break;
        } else {
          return;
        }
      case PAGE_DOWN:
        if (this._pageUpAndDown.enabled && isModifierAllowed) {
          const targetIndex = this._activeItemIndex + this._pageUpAndDown.delta;
          const itemsLength = this._getItemsArray().length;
          this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);
          break;
        } else {
          return;
        }
      default:
        if (isModifierAllowed || hasModifierKey(event, "shiftKey")) {
          this._typeahead?.handleKey(event);
        }
        return;
    }
    this._typeahead?.reset();
    event.preventDefault();
  }
  /** Index of the currently active item. */
  get activeItemIndex() {
    return this._activeItemIndex;
  }
  /** The active item. */
  get activeItem() {
    return this._activeItem();
  }
  /** Gets whether the user is currently typing into the manager using the typeahead feature. */
  isTyping() {
    return !!this._typeahead && this._typeahead.isTyping();
  }
  /** Sets the active item to the first enabled item in the list. */
  setFirstItemActive() {
    this._setActiveItemByIndex(0, 1);
  }
  /** Sets the active item to the last enabled item in the list. */
  setLastItemActive() {
    this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);
  }
  /** Sets the active item to the next enabled item in the list. */
  setNextItemActive() {
    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);
  }
  /** Sets the active item to a previous enabled item in the list. */
  setPreviousItemActive() {
    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1);
  }
  updateActiveItem(item) {
    const itemArray = this._getItemsArray();
    const index = typeof item === "number" ? item : itemArray.indexOf(item);
    const activeItem = itemArray[index];
    this._activeItem.set(activeItem == null ? null : activeItem);
    this._activeItemIndex = index;
    this._typeahead?.setCurrentSelectedItemIndex(index);
  }
  /** Cleans up the key manager. */
  destroy() {
    this._typeaheadSubscription.unsubscribe();
    this._itemChangesSubscription?.unsubscribe();
    this._effectRef?.destroy();
    this._typeahead?.destroy();
    this.tabOut.complete();
    this.change.complete();
  }
  /**
   * This method sets the active item, given a list of items and the delta between the
   * currently active item and the new active item. It will calculate differently
   * depending on whether wrap mode is turned on.
   */
  _setActiveItemByDelta(delta) {
    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);
  }
  /**
   * Sets the active item properly given "wrap" mode. In other words, it will continue to move
   * down the list until it finds an item that is not disabled, and it will wrap if it
   * encounters either end of the list.
   */
  _setActiveInWrapMode(delta) {
    const items = this._getItemsArray();
    for (let i = 1; i <= items.length; i++) {
      const index = (this._activeItemIndex + delta * i + items.length) % items.length;
      const item = items[index];
      if (!this._skipPredicateFn(item)) {
        this.setActiveItem(index);
        return;
      }
    }
  }
  /**
   * Sets the active item properly given the default mode. In other words, it will
   * continue to move down the list until it finds an item that is not disabled. If
   * it encounters either end of the list, it will stop and not wrap.
   */
  _setActiveInDefaultMode(delta) {
    this._setActiveItemByIndex(this._activeItemIndex + delta, delta);
  }
  /**
   * Sets the active item to the first enabled item starting at the index specified. If the
   * item is disabled, it will move in the fallbackDelta direction until it either
   * finds an enabled item or encounters the end of the list.
   */
  _setActiveItemByIndex(index, fallbackDelta) {
    const items = this._getItemsArray();
    if (!items[index]) {
      return;
    }
    while (this._skipPredicateFn(items[index])) {
      index += fallbackDelta;
      if (!items[index]) {
        return;
      }
    }
    this.setActiveItem(index);
  }
  /** Returns the items as an array. */
  _getItemsArray() {
    if (isSignal(this._items)) {
      return this._items();
    }
    return this._items instanceof QueryList ? this._items.toArray() : this._items;
  }
  /** Callback for when the items have changed. */
  _itemsChanged(newItems) {
    this._typeahead?.setItems(newItems);
    const activeItem = this._activeItem();
    if (activeItem) {
      const newIndex = newItems.indexOf(activeItem);
      if (newIndex > -1 && newIndex !== this._activeItemIndex) {
        this._activeItemIndex = newIndex;
        this._typeahead?.setCurrentSelectedItemIndex(newIndex);
      }
    }
  }
};
var ActiveDescendantKeyManager = class extends ListKeyManager {
  setActiveItem(index) {
    if (this.activeItem) {
      this.activeItem.setInactiveStyles();
    }
    super.setActiveItem(index);
    if (this.activeItem) {
      this.activeItem.setActiveStyles();
    }
  }
};
var TreeKeyManager = class {
  /** The index of the currently active (focused) item. */
  _activeItemIndex = -1;
  /** The currently active (focused) item. */
  _activeItem = null;
  /** Whether or not we activate the item when it's focused. */
  _shouldActivationFollowFocus = false;
  /**
   * The orientation that the tree is laid out in. In `rtl` mode, the behavior of Left and
   * Right arrow are switched.
   */
  _horizontalOrientation = "ltr";
  /**
   * Predicate function that can be used to check whether an item should be skipped
   * by the key manager.
   *
   * The default value for this doesn't skip any elements in order to keep tree items focusable
   * when disabled. This aligns with ARIA guidelines:
   * https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols.
   */
  _skipPredicateFn = (_item) => false;
  /** Function to determine equivalent items. */
  _trackByFn = (item) => item;
  /** Synchronous cache of the items to manage. */
  _items = [];
  _typeahead;
  _typeaheadSubscription = Subscription.EMPTY;
  _hasInitialFocused = false;
  _initializeFocus() {
    if (this._hasInitialFocused || this._items.length === 0) {
      return;
    }
    let activeIndex = 0;
    for (let i = 0; i < this._items.length; i++) {
      if (!this._skipPredicateFn(this._items[i]) && !this._isItemDisabled(this._items[i])) {
        activeIndex = i;
        break;
      }
    }
    const activeItem = this._items[activeIndex];
    if (activeItem.makeFocusable) {
      this._activeItem?.unfocus();
      this._activeItemIndex = activeIndex;
      this._activeItem = activeItem;
      this._typeahead?.setCurrentSelectedItemIndex(activeIndex);
      activeItem.makeFocusable();
    } else {
      this.focusItem(activeIndex);
    }
    this._hasInitialFocused = true;
  }
  /**
   *
   * @param items List of TreeKeyManager options. Can be synchronous or asynchronous.
   * @param config Optional configuration options. By default, use 'ltr' horizontal orientation. By
   * default, do not skip any nodes. By default, key manager only calls `focus` method when items
   * are focused and does not call `activate`. If `typeaheadDefaultInterval` is `true`, use a
   * default interval of 200ms.
   */
  constructor(items, config) {
    if (items instanceof QueryList) {
      this._items = items.toArray();
      items.changes.subscribe((newItems) => {
        this._items = newItems.toArray();
        this._typeahead?.setItems(this._items);
        this._updateActiveItemIndex(this._items);
        this._initializeFocus();
      });
    } else if (isObservable(items)) {
      items.subscribe((newItems) => {
        this._items = newItems;
        this._typeahead?.setItems(newItems);
        this._updateActiveItemIndex(newItems);
        this._initializeFocus();
      });
    } else {
      this._items = items;
      this._initializeFocus();
    }
    if (typeof config.shouldActivationFollowFocus === "boolean") {
      this._shouldActivationFollowFocus = config.shouldActivationFollowFocus;
    }
    if (config.horizontalOrientation) {
      this._horizontalOrientation = config.horizontalOrientation;
    }
    if (config.skipPredicate) {
      this._skipPredicateFn = config.skipPredicate;
    }
    if (config.trackBy) {
      this._trackByFn = config.trackBy;
    }
    if (typeof config.typeAheadDebounceInterval !== "undefined") {
      this._setTypeAhead(config.typeAheadDebounceInterval);
    }
  }
  /** Stream that emits any time the focused item changes. */
  change = new Subject();
  /** Cleans up the key manager. */
  destroy() {
    this._typeaheadSubscription.unsubscribe();
    this._typeahead?.destroy();
    this.change.complete();
  }
  /**
   * Handles a keyboard event on the tree.
   * @param event Keyboard event that represents the user interaction with the tree.
   */
  onKeydown(event) {
    const key = event.key;
    switch (key) {
      case "Tab":
        return;
      case "ArrowDown":
        this._focusNextItem();
        break;
      case "ArrowUp":
        this._focusPreviousItem();
        break;
      case "ArrowRight":
        this._horizontalOrientation === "rtl" ? this._collapseCurrentItem() : this._expandCurrentItem();
        break;
      case "ArrowLeft":
        this._horizontalOrientation === "rtl" ? this._expandCurrentItem() : this._collapseCurrentItem();
        break;
      case "Home":
        this._focusFirstItem();
        break;
      case "End":
        this._focusLastItem();
        break;
      case "Enter":
      case " ":
        this._activateCurrentItem();
        break;
      default:
        if (event.key === "*") {
          this._expandAllItemsAtCurrentItemLevel();
          break;
        }
        this._typeahead?.handleKey(event);
        return;
    }
    this._typeahead?.reset();
    event.preventDefault();
  }
  /** Index of the currently active item. */
  getActiveItemIndex() {
    return this._activeItemIndex;
  }
  /** The currently active item. */
  getActiveItem() {
    return this._activeItem;
  }
  /** Focus the first available item. */
  _focusFirstItem() {
    this.focusItem(this._findNextAvailableItemIndex(-1));
  }
  /** Focus the last available item. */
  _focusLastItem() {
    this.focusItem(this._findPreviousAvailableItemIndex(this._items.length));
  }
  /** Focus the next available item. */
  _focusNextItem() {
    this.focusItem(this._findNextAvailableItemIndex(this._activeItemIndex));
  }
  /** Focus the previous available item. */
  _focusPreviousItem() {
    this.focusItem(this._findPreviousAvailableItemIndex(this._activeItemIndex));
  }
  focusItem(itemOrIndex, options = {}) {
    options.emitChangeEvent ??= true;
    let index = typeof itemOrIndex === "number" ? itemOrIndex : this._items.findIndex((item) => this._trackByFn(item) === this._trackByFn(itemOrIndex));
    if (index < 0 || index >= this._items.length) {
      return;
    }
    const activeItem = this._items[index];
    if (this._activeItem !== null && this._trackByFn(activeItem) === this._trackByFn(this._activeItem)) {
      return;
    }
    const previousActiveItem = this._activeItem;
    this._activeItem = activeItem ?? null;
    this._activeItemIndex = index;
    this._typeahead?.setCurrentSelectedItemIndex(index);
    this._activeItem?.focus();
    previousActiveItem?.unfocus();
    if (options.emitChangeEvent) {
      this.change.next(this._activeItem);
    }
    if (this._shouldActivationFollowFocus) {
      this._activateCurrentItem();
    }
  }
  _updateActiveItemIndex(newItems) {
    const activeItem = this._activeItem;
    if (!activeItem) {
      return;
    }
    const newIndex = newItems.findIndex((item) => this._trackByFn(item) === this._trackByFn(activeItem));
    if (newIndex > -1 && newIndex !== this._activeItemIndex) {
      this._activeItemIndex = newIndex;
      this._typeahead?.setCurrentSelectedItemIndex(newIndex);
    }
  }
  _setTypeAhead(debounceInterval) {
    this._typeahead = new Typeahead(this._items, {
      debounceInterval: typeof debounceInterval === "number" ? debounceInterval : void 0,
      skipPredicate: (item) => this._skipPredicateFn(item)
    });
    this._typeaheadSubscription = this._typeahead.selectedItem.subscribe((item) => {
      this.focusItem(item);
    });
  }
  _findNextAvailableItemIndex(startingIndex) {
    for (let i = startingIndex + 1; i < this._items.length; i++) {
      if (!this._skipPredicateFn(this._items[i])) {
        return i;
      }
    }
    return startingIndex;
  }
  _findPreviousAvailableItemIndex(startingIndex) {
    for (let i = startingIndex - 1; i >= 0; i--) {
      if (!this._skipPredicateFn(this._items[i])) {
        return i;
      }
    }
    return startingIndex;
  }
  /**
   * If the item is already expanded, we collapse the item. Otherwise, we will focus the parent.
   */
  _collapseCurrentItem() {
    if (!this._activeItem) {
      return;
    }
    if (this._isCurrentItemExpanded()) {
      this._activeItem.collapse();
    } else {
      const parent = this._activeItem.getParent();
      if (!parent || this._skipPredicateFn(parent)) {
        return;
      }
      this.focusItem(parent);
    }
  }
  /**
   * If the item is already collapsed, we expand the item. Otherwise, we will focus the first child.
   */
  _expandCurrentItem() {
    if (!this._activeItem) {
      return;
    }
    if (!this._isCurrentItemExpanded()) {
      this._activeItem.expand();
    } else {
      coerceObservable(this._activeItem.getChildren()).pipe(take(1)).subscribe((children) => {
        const firstChild = children.find((child) => !this._skipPredicateFn(child));
        if (!firstChild) {
          return;
        }
        this.focusItem(firstChild);
      });
    }
  }
  _isCurrentItemExpanded() {
    if (!this._activeItem) {
      return false;
    }
    return typeof this._activeItem.isExpanded === "boolean" ? this._activeItem.isExpanded : this._activeItem.isExpanded();
  }
  _isItemDisabled(item) {
    return typeof item.isDisabled === "boolean" ? item.isDisabled : item.isDisabled?.();
  }
  /** For all items that are the same level as the current item, we expand those items. */
  _expandAllItemsAtCurrentItemLevel() {
    if (!this._activeItem) {
      return;
    }
    const parent = this._activeItem.getParent();
    let itemsToExpand;
    if (!parent) {
      itemsToExpand = of(this._items.filter((item) => item.getParent() === null));
    } else {
      itemsToExpand = coerceObservable(parent.getChildren());
    }
    itemsToExpand.pipe(take(1)).subscribe((items) => {
      for (const item of items) {
        item.expand();
      }
    });
  }
  _activateCurrentItem() {
    this._activeItem?.activate();
  }
};
function TREE_KEY_MANAGER_FACTORY() {
  return (items, options) => new TreeKeyManager(items, options);
}
var TREE_KEY_MANAGER = new InjectionToken("tree-key-manager", {
  providedIn: "root",
  factory: TREE_KEY_MANAGER_FACTORY
});
var InteractivityChecker = class _InteractivityChecker {
  _platform = inject(Platform);
  constructor() {
  }
  /**
   * Gets whether an element is disabled.
   *
   * @param element Element to be checked.
   * @returns Whether the element is disabled.
   */
  isDisabled(element) {
    return element.hasAttribute("disabled");
  }
  /**
   * Gets whether an element is visible for the purposes of interactivity.
   *
   * This will capture states like `display: none` and `visibility: hidden`, but not things like
   * being clipped by an `overflow: hidden` parent or being outside the viewport.
   *
   * @returns Whether the element is visible.
   */
  isVisible(element) {
    return hasGeometry(element) && getComputedStyle(element).visibility === "visible";
  }
  /**
   * Gets whether an element can be reached via Tab key.
   * Assumes that the element has already been checked with isFocusable.
   *
   * @param element Element to be checked.
   * @returns Whether the element is tabbable.
   */
  isTabbable(element) {
    if (!this._platform.isBrowser) {
      return false;
    }
    const frameElement = getFrameElement(getWindow(element));
    if (frameElement) {
      if (getTabIndexValue(frameElement) === -1) {
        return false;
      }
      if (!this.isVisible(frameElement)) {
        return false;
      }
    }
    let nodeName = element.nodeName.toLowerCase();
    let tabIndexValue = getTabIndexValue(element);
    if (element.hasAttribute("contenteditable")) {
      return tabIndexValue !== -1;
    }
    if (nodeName === "iframe" || nodeName === "object") {
      return false;
    }
    if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
      return false;
    }
    if (nodeName === "audio") {
      if (!element.hasAttribute("controls")) {
        return false;
      }
      return tabIndexValue !== -1;
    }
    if (nodeName === "video") {
      if (tabIndexValue === -1) {
        return false;
      }
      if (tabIndexValue !== null) {
        return true;
      }
      return this._platform.FIREFOX || element.hasAttribute("controls");
    }
    return element.tabIndex >= 0;
  }
  /**
   * Gets whether an element can be focused by the user.
   *
   * @param element Element to be checked.
   * @param config The config object with options to customize this method's behavior
   * @returns Whether the element is focusable.
   */
  isFocusable(element, config) {
    return isPotentiallyFocusable(element) && !this.isDisabled(element) && (config?.ignoreVisibility || this.isVisible(element));
  }
  static ɵfac = function InteractivityChecker_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InteractivityChecker)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _InteractivityChecker,
    factory: _InteractivityChecker.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InteractivityChecker, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function getFrameElement(window2) {
  try {
    return window2.frameElement;
  } catch {
    return null;
  }
}
function hasGeometry(element) {
  return !!(element.offsetWidth || element.offsetHeight || typeof element.getClientRects === "function" && element.getClientRects().length);
}
function isNativeFormElement(element) {
  let nodeName = element.nodeName.toLowerCase();
  return nodeName === "input" || nodeName === "select" || nodeName === "button" || nodeName === "textarea";
}
function isHiddenInput(element) {
  return isInputElement(element) && element.type == "hidden";
}
function isAnchorWithHref(element) {
  return isAnchorElement(element) && element.hasAttribute("href");
}
function isInputElement(element) {
  return element.nodeName.toLowerCase() == "input";
}
function isAnchorElement(element) {
  return element.nodeName.toLowerCase() == "a";
}
function hasValidTabIndex(element) {
  if (!element.hasAttribute("tabindex") || element.tabIndex === void 0) {
    return false;
  }
  let tabIndex = element.getAttribute("tabindex");
  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
}
function getTabIndexValue(element) {
  if (!hasValidTabIndex(element)) {
    return null;
  }
  const tabIndex = parseInt(element.getAttribute("tabindex") || "", 10);
  return isNaN(tabIndex) ? -1 : tabIndex;
}
function isPotentiallyTabbableIOS(element) {
  let nodeName = element.nodeName.toLowerCase();
  let inputType = nodeName === "input" && element.type;
  return inputType === "text" || inputType === "password" || nodeName === "select" || nodeName === "textarea";
}
function isPotentiallyFocusable(element) {
  if (isHiddenInput(element)) {
    return false;
  }
  return isNativeFormElement(element) || isAnchorWithHref(element) || element.hasAttribute("contenteditable") || hasValidTabIndex(element);
}
function getWindow(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || window;
}
var FocusTrap = class {
  _element;
  _checker;
  _ngZone;
  _document;
  _injector;
  _startAnchor;
  _endAnchor;
  _hasAttached = false;
  // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.
  startAnchorListener = () => this.focusLastTabbableElement();
  endAnchorListener = () => this.focusFirstTabbableElement();
  /** Whether the focus trap is active. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(value, this._startAnchor);
      this._toggleAnchorTabIndex(value, this._endAnchor);
    }
  }
  _enabled = true;
  constructor(_element, _checker, _ngZone, _document, deferAnchors = false, _injector) {
    this._element = _element;
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._document = _document;
    this._injector = _injector;
    if (!deferAnchors) {
      this.attachAnchors();
    }
  }
  /** Destroys the focus trap by cleaning up the anchors. */
  destroy() {
    const startAnchor = this._startAnchor;
    const endAnchor = this._endAnchor;
    if (startAnchor) {
      startAnchor.removeEventListener("focus", this.startAnchorListener);
      startAnchor.remove();
    }
    if (endAnchor) {
      endAnchor.removeEventListener("focus", this.endAnchorListener);
      endAnchor.remove();
    }
    this._startAnchor = this._endAnchor = null;
    this._hasAttached = false;
  }
  /**
   * Inserts the anchors into the DOM. This is usually done automatically
   * in the constructor, but can be deferred for cases like directives with `*ngIf`.
   * @returns Whether the focus trap managed to attach successfully. This may not be the case
   * if the target element isn't currently in the DOM.
   */
  attachAnchors() {
    if (this._hasAttached) {
      return true;
    }
    this._ngZone.runOutsideAngular(() => {
      if (!this._startAnchor) {
        this._startAnchor = this._createAnchor();
        this._startAnchor.addEventListener("focus", this.startAnchorListener);
      }
      if (!this._endAnchor) {
        this._endAnchor = this._createAnchor();
        this._endAnchor.addEventListener("focus", this.endAnchorListener);
      }
    });
    if (this._element.parentNode) {
      this._element.parentNode.insertBefore(this._startAnchor, this._element);
      this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);
      this._hasAttached = true;
    }
    return this._hasAttached;
  }
  /**
   * Waits for the zone to stabilize, then focuses the first tabbable element.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusInitialElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusInitialElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the first tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusFirstTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the last tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusLastTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));
    });
  }
  /**
   * Get the specified boundary element of the trapped region.
   * @param bound The boundary to get (start or end of trapped region).
   * @returns The boundary element.
   */
  _getRegionBoundary(bound) {
    const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], [cdkFocusRegion${bound}], [cdk-focus-${bound}]`);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      for (let i = 0; i < markers.length; i++) {
        if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        } else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        }
      }
    }
    if (bound == "start") {
      return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);
    }
    return markers.length ? markers[markers.length - 1] : this._getLastTabbableElement(this._element);
  }
  /**
   * Focuses the element that should be focused when the focus trap is initialized.
   * @returns Whether focus was moved successfully.
   */
  focusInitialElement(options) {
    const redirectToElement = this._element.querySelector(`[cdk-focus-initial], [cdkFocusInitial]`);
    if (redirectToElement) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && redirectToElement.hasAttribute(`cdk-focus-initial`)) {
        console.warn(`Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0`, redirectToElement);
      }
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._checker.isFocusable(redirectToElement)) {
        console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);
      }
      if (!this._checker.isFocusable(redirectToElement)) {
        const focusableChild = this._getFirstTabbableElement(redirectToElement);
        focusableChild?.focus(options);
        return !!focusableChild;
      }
      redirectToElement.focus(options);
      return true;
    }
    return this.focusFirstTabbableElement(options);
  }
  /**
   * Focuses the first tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusFirstTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("start");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Focuses the last tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusLastTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("end");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Checks whether the focus trap has successfully been attached.
   */
  hasAttached() {
    return this._hasAttached;
  }
  /** Get the first tabbable element from a DOM subtree (inclusive). */
  _getFirstTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = 0; i < children.length; i++) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Get the last tabbable element from a DOM subtree (inclusive). */
  _getLastTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = children.length - 1; i >= 0; i--) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Creates an anchor element. */
  _createAnchor() {
    const anchor = this._document.createElement("div");
    this._toggleAnchorTabIndex(this._enabled, anchor);
    anchor.classList.add("cdk-visually-hidden");
    anchor.classList.add("cdk-focus-trap-anchor");
    anchor.setAttribute("aria-hidden", "true");
    return anchor;
  }
  /**
   * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.
   * @param isEnabled Whether the focus trap is enabled.
   * @param anchor Anchor on which to toggle the tabindex.
   */
  _toggleAnchorTabIndex(isEnabled, anchor) {
    isEnabled ? anchor.setAttribute("tabindex", "0") : anchor.removeAttribute("tabindex");
  }
  /**
   * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.
   * @param enabled: Whether the anchors should trap Tab.
   */
  toggleAnchors(enabled) {
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(enabled, this._startAnchor);
      this._toggleAnchorTabIndex(enabled, this._endAnchor);
    }
  }
  /** Executes a function when the zone is stable. */
  _executeOnStable(fn) {
    if (this._injector) {
      afterNextRender(fn, {
        injector: this._injector
      });
    } else {
      setTimeout(fn);
    }
  }
};
var FocusTrapFactory = class _FocusTrapFactory {
  _checker = inject(InteractivityChecker);
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  _injector = inject(Injector);
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
  }
  /**
   * Creates a focus-trapped region around the given element.
   * @param element The element around which focus will be trapped.
   * @param deferCaptureElements Defers the creation of focus-capturing elements to be done
   *     manually by the user.
   * @returns The created focus trap instance.
   */
  create(element, deferCaptureElements = false) {
    return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements, this._injector);
  }
  static ɵfac = function FocusTrapFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusTrapFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusTrapFactory,
    factory: _FocusTrapFactory.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkTrapFocus = class _CdkTrapFocus {
  _elementRef = inject(ElementRef);
  _focusTrapFactory = inject(FocusTrapFactory);
  /** Underlying FocusTrap instance. */
  focusTrap;
  /** Previously focused element to restore focus to upon destroy when using autoCapture. */
  _previouslyFocusedElement = null;
  /** Whether the focus trap is active. */
  get enabled() {
    return this.focusTrap?.enabled || false;
  }
  set enabled(value) {
    if (this.focusTrap) {
      this.focusTrap.enabled = value;
    }
  }
  /**
   * Whether the directive should automatically move focus into the trapped region upon
   * initialization and return focus to the previous activeElement upon destruction.
   */
  autoCapture;
  constructor() {
    const platform = inject(Platform);
    if (platform.isBrowser) {
      this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
    }
  }
  ngOnDestroy() {
    this.focusTrap?.destroy();
    if (this._previouslyFocusedElement) {
      this._previouslyFocusedElement.focus();
      this._previouslyFocusedElement = null;
    }
  }
  ngAfterContentInit() {
    this.focusTrap?.attachAnchors();
    if (this.autoCapture) {
      this._captureFocus();
    }
  }
  ngDoCheck() {
    if (this.focusTrap && !this.focusTrap.hasAttached()) {
      this.focusTrap.attachAnchors();
    }
  }
  ngOnChanges(changes) {
    const autoCaptureChange = changes["autoCapture"];
    if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture && this.focusTrap?.hasAttached()) {
      this._captureFocus();
    }
  }
  _captureFocus() {
    this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();
    this.focusTrap?.focusInitialElementWhenReady();
  }
  static ɵfac = function CdkTrapFocus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTrapFocus)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkTrapFocus,
    selectors: [["", "cdkTrapFocus", ""]],
    inputs: {
      enabled: [2, "cdkTrapFocus", "enabled", booleanAttribute],
      autoCapture: [2, "cdkTrapFocusAutoCapture", "autoCapture", booleanAttribute]
    },
    exportAs: ["cdkTrapFocus"],
    features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTrapFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkTrapFocus]",
      exportAs: "cdkTrapFocus"
    }]
  }], () => [], {
    enabled: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocus",
        transform: booleanAttribute
      }]
    }],
    autoCapture: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocusAutoCapture",
        transform: booleanAttribute
      }]
    }]
  });
})();
var ConfigurableFocusTrap = class extends FocusTrap {
  _focusTrapManager;
  _inertStrategy;
  /** Whether the FocusTrap is enabled. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._enabled) {
      this._focusTrapManager.register(this);
    } else {
      this._focusTrapManager.deregister(this);
    }
  }
  constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config, injector) {
    super(_element, _checker, _ngZone, _document, config.defer, injector);
    this._focusTrapManager = _focusTrapManager;
    this._inertStrategy = _inertStrategy;
    this._focusTrapManager.register(this);
  }
  /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */
  destroy() {
    this._focusTrapManager.deregister(this);
    super.destroy();
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _enable() {
    this._inertStrategy.preventFocus(this);
    this.toggleAnchors(true);
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _disable() {
    this._inertStrategy.allowFocus(this);
    this.toggleAnchors(false);
  }
};
var EventListenerFocusTrapInertStrategy = class {
  /** Focus event handler. */
  _listener = null;
  /** Adds a document event listener that keeps focus inside the FocusTrap. */
  preventFocus(focusTrap) {
    if (this._listener) {
      focusTrap._document.removeEventListener("focus", this._listener, true);
    }
    this._listener = (e) => this._trapFocus(focusTrap, e);
    focusTrap._ngZone.runOutsideAngular(() => {
      focusTrap._document.addEventListener("focus", this._listener, true);
    });
  }
  /** Removes the event listener added in preventFocus. */
  allowFocus(focusTrap) {
    if (!this._listener) {
      return;
    }
    focusTrap._document.removeEventListener("focus", this._listener, true);
    this._listener = null;
  }
  /**
   * Refocuses the first element in the FocusTrap if the focus event target was outside
   * the FocusTrap.
   *
   * This is an event listener callback. The event listener is added in runOutsideAngular,
   * so all this code runs outside Angular as well.
   */
  _trapFocus(focusTrap, event) {
    const target = event.target;
    const focusTrapRoot = focusTrap._element;
    if (target && !focusTrapRoot.contains(target) && !target.closest?.("div.cdk-overlay-pane")) {
      setTimeout(() => {
        if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {
          focusTrap.focusFirstTabbableElement();
        }
      });
    }
  }
};
var FOCUS_TRAP_INERT_STRATEGY = new InjectionToken("FOCUS_TRAP_INERT_STRATEGY");
var FocusTrapManager = class _FocusTrapManager {
  // A stack of the FocusTraps on the page. Only the FocusTrap at the
  // top of the stack is active.
  _focusTrapStack = [];
  /**
   * Disables the FocusTrap at the top of the stack, and then pushes
   * the new FocusTrap onto the stack.
   */
  register(focusTrap) {
    this._focusTrapStack = this._focusTrapStack.filter((ft) => ft !== focusTrap);
    let stack = this._focusTrapStack;
    if (stack.length) {
      stack[stack.length - 1]._disable();
    }
    stack.push(focusTrap);
    focusTrap._enable();
  }
  /**
   * Removes the FocusTrap from the stack, and activates the
   * FocusTrap that is the new top of the stack.
   */
  deregister(focusTrap) {
    focusTrap._disable();
    const stack = this._focusTrapStack;
    const i = stack.indexOf(focusTrap);
    if (i !== -1) {
      stack.splice(i, 1);
      if (stack.length) {
        stack[stack.length - 1]._enable();
      }
    }
  }
  static ɵfac = function FocusTrapManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusTrapManager)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusTrapManager,
    factory: _FocusTrapManager.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ConfigurableFocusTrapFactory = class _ConfigurableFocusTrapFactory {
  _checker = inject(InteractivityChecker);
  _ngZone = inject(NgZone);
  _focusTrapManager = inject(FocusTrapManager);
  _document = inject(DOCUMENT);
  _inertStrategy;
  _injector = inject(Injector);
  constructor() {
    const inertStrategy = inject(FOCUS_TRAP_INERT_STRATEGY, {
      optional: true
    });
    this._inertStrategy = inertStrategy || new EventListenerFocusTrapInertStrategy();
  }
  create(element, config = {
    defer: false
  }) {
    let configObject;
    if (typeof config === "boolean") {
      configObject = {
        defer: config
      };
    } else {
      configObject = config;
    }
    return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject, this._injector);
  }
  static ɵfac = function ConfigurableFocusTrapFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ConfigurableFocusTrapFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ConfigurableFocusTrapFactory,
    factory: _ConfigurableFocusTrapFactory.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConfigurableFocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function isFakeMousedownFromScreenReader(event) {
  return event.buttons === 0 || event.detail === 0;
}
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}
var INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken("cdk-input-modality-detector-options");
var INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {
  ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT]
};
var TOUCH_BUFFER_MS = 650;
var modalityEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var InputModalityDetector = class _InputModalityDetector {
  _platform = inject(Platform);
  /** Emits whenever an input modality is detected. */
  modalityDetected;
  /** Emits when the input modality changes. */
  modalityChanged;
  /** The most recently detected input modality. */
  get mostRecentModality() {
    return this._modality.value;
  }
  /**
   * The most recently detected input modality event target. Is null if no input modality has been
   * detected or if the associated event target is null for some unknown reason.
   */
  _mostRecentTarget = null;
  /** The underlying BehaviorSubject that emits whenever an input modality is detected. */
  _modality = new BehaviorSubject(null);
  /** Options for this InputModalityDetector. */
  _options;
  /**
   * The timestamp of the last touch input modality. Used to determine whether mousedown events
   * should be attributed to mouse or touch.
   */
  _lastTouchMs = 0;
  /**
   * Handles keydown events. Must be an arrow function in order to preserve the context when it gets
   * bound.
   */
  _onKeydown = (event) => {
    if (this._options?.ignoreKeys?.some((keyCode) => keyCode === event.keyCode)) {
      return;
    }
    this._modality.next("keyboard");
    this._mostRecentTarget = _getEventTarget(event);
  };
  /**
   * Handles mousedown events. Must be an arrow function in order to preserve the context when it
   * gets bound.
   */
  _onMousedown = (event) => {
    if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {
      return;
    }
    this._modality.next(isFakeMousedownFromScreenReader(event) ? "keyboard" : "mouse");
    this._mostRecentTarget = _getEventTarget(event);
  };
  /**
   * Handles touchstart events. Must be an arrow function in order to preserve the context when it
   * gets bound.
   */
  _onTouchstart = (event) => {
    if (isFakeTouchstartFromScreenReader(event)) {
      this._modality.next("keyboard");
      return;
    }
    this._lastTouchMs = Date.now();
    this._modality.next("touch");
    this._mostRecentTarget = _getEventTarget(event);
  };
  constructor() {
    const ngZone = inject(NgZone);
    const document2 = inject(DOCUMENT);
    const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, {
      optional: true
    });
    this._options = __spreadValues(__spreadValues({}, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS), options);
    this.modalityDetected = this._modality.pipe(skip(1));
    this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());
    if (this._platform.isBrowser) {
      ngZone.runOutsideAngular(() => {
        document2.addEventListener("keydown", this._onKeydown, modalityEventListenerOptions);
        document2.addEventListener("mousedown", this._onMousedown, modalityEventListenerOptions);
        document2.addEventListener("touchstart", this._onTouchstart, modalityEventListenerOptions);
      });
    }
  }
  ngOnDestroy() {
    this._modality.complete();
    if (this._platform.isBrowser) {
      document.removeEventListener("keydown", this._onKeydown, modalityEventListenerOptions);
      document.removeEventListener("mousedown", this._onMousedown, modalityEventListenerOptions);
      document.removeEventListener("touchstart", this._onTouchstart, modalityEventListenerOptions);
    }
  }
  static ɵfac = function InputModalityDetector_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InputModalityDetector)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _InputModalityDetector,
    factory: _InputModalityDetector.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputModalityDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken("liveAnnouncerElement", {
  providedIn: "root",
  factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY
});
function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {
  return null;
}
var LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
var uniqueIds = 0;
var LiveAnnouncer = class _LiveAnnouncer {
  _ngZone = inject(NgZone);
  _defaultOptions = inject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, {
    optional: true
  });
  _liveElement;
  _document = inject(DOCUMENT);
  _previousTimeout;
  _currentPromise;
  _currentResolve;
  constructor() {
    const elementToken = inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, {
      optional: true
    });
    this._liveElement = elementToken || this._createLiveElement();
  }
  announce(message, ...args) {
    const defaultOptions = this._defaultOptions;
    let politeness;
    let duration;
    if (args.length === 1 && typeof args[0] === "number") {
      duration = args[0];
    } else {
      [politeness, duration] = args;
    }
    this.clear();
    clearTimeout(this._previousTimeout);
    if (!politeness) {
      politeness = defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : "polite";
    }
    if (duration == null && defaultOptions) {
      duration = defaultOptions.duration;
    }
    this._liveElement.setAttribute("aria-live", politeness);
    if (this._liveElement.id) {
      this._exposeAnnouncerToModals(this._liveElement.id);
    }
    return this._ngZone.runOutsideAngular(() => {
      if (!this._currentPromise) {
        this._currentPromise = new Promise((resolve) => this._currentResolve = resolve);
      }
      clearTimeout(this._previousTimeout);
      this._previousTimeout = setTimeout(() => {
        this._liveElement.textContent = message;
        if (typeof duration === "number") {
          this._previousTimeout = setTimeout(() => this.clear(), duration);
        }
        this._currentResolve?.();
        this._currentPromise = this._currentResolve = void 0;
      }, 100);
      return this._currentPromise;
    });
  }
  /**
   * Clears the current text from the announcer element. Can be used to prevent
   * screen readers from reading the text out again while the user is going
   * through the page landmarks.
   */
  clear() {
    if (this._liveElement) {
      this._liveElement.textContent = "";
    }
  }
  ngOnDestroy() {
    clearTimeout(this._previousTimeout);
    this._liveElement?.remove();
    this._liveElement = null;
    this._currentResolve?.();
    this._currentPromise = this._currentResolve = void 0;
  }
  _createLiveElement() {
    const elementClass = "cdk-live-announcer-element";
    const previousElements = this._document.getElementsByClassName(elementClass);
    const liveEl = this._document.createElement("div");
    for (let i = 0; i < previousElements.length; i++) {
      previousElements[i].remove();
    }
    liveEl.classList.add(elementClass);
    liveEl.classList.add("cdk-visually-hidden");
    liveEl.setAttribute("aria-atomic", "true");
    liveEl.setAttribute("aria-live", "polite");
    liveEl.id = `cdk-live-announcer-${uniqueIds++}`;
    this._document.body.appendChild(liveEl);
    return liveEl;
  }
  /**
   * Some browsers won't expose the accessibility node of the live announcer element if there is an
   * `aria-modal` and the live announcer is outside of it. This method works around the issue by
   * pointing the `aria-owns` of all modals to the live announcer element.
   */
  _exposeAnnouncerToModals(id) {
    const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');
    for (let i = 0; i < modals.length; i++) {
      const modal = modals[i];
      const ariaOwns = modal.getAttribute("aria-owns");
      if (!ariaOwns) {
        modal.setAttribute("aria-owns", id);
      } else if (ariaOwns.indexOf(id) === -1) {
        modal.setAttribute("aria-owns", ariaOwns + " " + id);
      }
    }
  }
  static ɵfac = function LiveAnnouncer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LiveAnnouncer)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _LiveAnnouncer,
    factory: _LiveAnnouncer.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LiveAnnouncer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkAriaLive = class _CdkAriaLive {
  _elementRef = inject(ElementRef);
  _liveAnnouncer = inject(LiveAnnouncer);
  _contentObserver = inject(ContentObserver);
  _ngZone = inject(NgZone);
  /** The aria-live politeness level to use when announcing messages. */
  get politeness() {
    return this._politeness;
  }
  set politeness(value) {
    this._politeness = value === "off" || value === "assertive" ? value : "polite";
    if (this._politeness === "off") {
      if (this._subscription) {
        this._subscription.unsubscribe();
        this._subscription = null;
      }
    } else if (!this._subscription) {
      this._subscription = this._ngZone.runOutsideAngular(() => {
        return this._contentObserver.observe(this._elementRef).subscribe(() => {
          const elementText = this._elementRef.nativeElement.textContent;
          if (elementText !== this._previousAnnouncedText) {
            this._liveAnnouncer.announce(elementText, this._politeness, this.duration);
            this._previousAnnouncedText = elementText;
          }
        });
      });
    }
  }
  _politeness = "polite";
  /** Time in milliseconds after which to clear out the announcer element. */
  duration;
  _previousAnnouncedText;
  _subscription;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._subscription.unsubscribe();
    }
  }
  static ɵfac = function CdkAriaLive_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkAriaLive)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkAriaLive,
    selectors: [["", "cdkAriaLive", ""]],
    inputs: {
      politeness: [0, "cdkAriaLive", "politeness"],
      duration: [0, "cdkAriaLiveDuration", "duration"]
    },
    exportAs: ["cdkAriaLive"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAriaLive, [{
    type: Directive,
    args: [{
      selector: "[cdkAriaLive]",
      exportAs: "cdkAriaLive"
    }]
  }], () => [], {
    politeness: [{
      type: Input,
      args: ["cdkAriaLive"]
    }],
    duration: [{
      type: Input,
      args: ["cdkAriaLiveDuration"]
    }]
  });
})();
var FocusMonitorDetectionMode;
(function(FocusMonitorDetectionMode2) {
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["IMMEDIATE"] = 0] = "IMMEDIATE";
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["EVENTUAL"] = 1] = "EVENTUAL";
})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));
var FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken("cdk-focus-monitor-default-options");
var captureEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var FocusMonitor = class _FocusMonitor {
  _ngZone = inject(NgZone);
  _platform = inject(Platform);
  _inputModalityDetector = inject(InputModalityDetector);
  /** The focus origin that the next focus event is a result of. */
  _origin = null;
  /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */
  _lastFocusOrigin;
  /** Whether the window has just been focused. */
  _windowFocused = false;
  /** The timeout id of the window focus timeout. */
  _windowFocusTimeoutId;
  /** The timeout id of the origin clearing timeout. */
  _originTimeoutId;
  /**
   * Whether the origin was determined via a touch interaction. Necessary as properly attributing
   * focus events to touch interactions requires special logic.
   */
  _originFromTouchInteraction = false;
  /** Map of elements being monitored to their info. */
  _elementInfo = /* @__PURE__ */ new Map();
  /** The number of elements currently being monitored. */
  _monitoredElementCount = 0;
  /**
   * Keeps track of the root nodes to which we've currently bound a focus/blur handler,
   * as well as the number of monitored elements that they contain. We have to treat focus/blur
   * handlers differently from the rest of the events, because the browser won't emit events
   * to the document when focus moves inside of a shadow root.
   */
  _rootNodeFocusListenerCount = /* @__PURE__ */ new Map();
  /**
   * The specified detection mode, used for attributing the origin of a focus
   * event.
   */
  _detectionMode;
  /**
   * Event listener for `focus` events on the window.
   * Needs to be an arrow function in order to preserve the context when it gets bound.
   */
  _windowFocusListener = () => {
    this._windowFocused = true;
    this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);
  };
  /** Used to reference correct document/window */
  _document = inject(DOCUMENT, {
    optional: true
  });
  /** Subject for stopping our InputModalityDetector subscription. */
  _stopInputModalityDetector = new Subject();
  constructor() {
    const options = inject(FOCUS_MONITOR_DEFAULT_OPTIONS, {
      optional: true
    });
    this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;
  }
  /**
   * Event listener for `focus` and 'blur' events on the document.
   * Needs to be an arrow function in order to preserve the context when it gets bound.
   */
  _rootNodeFocusAndBlurListener = (event) => {
    const target = _getEventTarget(event);
    for (let element = target; element; element = element.parentElement) {
      if (event.type === "focus") {
        this._onFocus(event, element);
      } else {
        this._onBlur(event, element);
      }
    }
  };
  monitor(element, checkChildren = false) {
    const nativeElement = coerceElement(element);
    if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {
      return of();
    }
    const rootNode = _getShadowRoot(nativeElement) || this._getDocument();
    const cachedInfo = this._elementInfo.get(nativeElement);
    if (cachedInfo) {
      if (checkChildren) {
        cachedInfo.checkChildren = true;
      }
      return cachedInfo.subject;
    }
    const info = {
      checkChildren,
      subject: new Subject(),
      rootNode
    };
    this._elementInfo.set(nativeElement, info);
    this._registerGlobalListeners(info);
    return info.subject;
  }
  stopMonitoring(element) {
    const nativeElement = coerceElement(element);
    const elementInfo = this._elementInfo.get(nativeElement);
    if (elementInfo) {
      elementInfo.subject.complete();
      this._setClasses(nativeElement);
      this._elementInfo.delete(nativeElement);
      this._removeGlobalListeners(elementInfo);
    }
  }
  focusVia(element, origin, options) {
    const nativeElement = coerceElement(element);
    const focusedElement = this._getDocument().activeElement;
    if (nativeElement === focusedElement) {
      this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));
    } else {
      this._setOrigin(origin);
      if (typeof nativeElement.focus === "function") {
        nativeElement.focus(options);
      }
    }
  }
  ngOnDestroy() {
    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));
  }
  /** Access injected document if available or fallback to global document reference */
  _getDocument() {
    return this._document || document;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    const doc = this._getDocument();
    return doc.defaultView || window;
  }
  _getFocusOrigin(focusEventTarget) {
    if (this._origin) {
      if (this._originFromTouchInteraction) {
        return this._shouldBeAttributedToTouch(focusEventTarget) ? "touch" : "program";
      } else {
        return this._origin;
      }
    }
    if (this._windowFocused && this._lastFocusOrigin) {
      return this._lastFocusOrigin;
    }
    if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {
      return "mouse";
    }
    return "program";
  }
  /**
   * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a
   * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we
   * handle a focus event following a touch interaction, we need to determine whether (1) the focus
   * event was directly caused by the touch interaction or (2) the focus event was caused by a
   * subsequent programmatic focus call triggered by the touch interaction.
   * @param focusEventTarget The target of the focus event under examination.
   */
  _shouldBeAttributedToTouch(focusEventTarget) {
    return this._detectionMode === FocusMonitorDetectionMode.EVENTUAL || !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget);
  }
  /**
   * Sets the focus classes on the element based on the given focus origin.
   * @param element The element to update the classes on.
   * @param origin The focus origin.
   */
  _setClasses(element, origin) {
    element.classList.toggle("cdk-focused", !!origin);
    element.classList.toggle("cdk-touch-focused", origin === "touch");
    element.classList.toggle("cdk-keyboard-focused", origin === "keyboard");
    element.classList.toggle("cdk-mouse-focused", origin === "mouse");
    element.classList.toggle("cdk-program-focused", origin === "program");
  }
  /**
   * Updates the focus origin. If we're using immediate detection mode, we schedule an async
   * function to clear the origin at the end of a timeout. The duration of the timeout depends on
   * the origin being set.
   * @param origin The origin to set.
   * @param isFromInteraction Whether we are setting the origin from an interaction event.
   */
  _setOrigin(origin, isFromInteraction = false) {
    this._ngZone.runOutsideAngular(() => {
      this._origin = origin;
      this._originFromTouchInteraction = origin === "touch" && isFromInteraction;
      if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {
        clearTimeout(this._originTimeoutId);
        const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;
        this._originTimeoutId = setTimeout(() => this._origin = null, ms);
      }
    });
  }
  /**
   * Handles focus events on a registered element.
   * @param event The focus event.
   * @param element The monitored element.
   */
  _onFocus(event, element) {
    const elementInfo = this._elementInfo.get(element);
    const focusEventTarget = _getEventTarget(event);
    if (!elementInfo || !elementInfo.checkChildren && element !== focusEventTarget) {
      return;
    }
    this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);
  }
  /**
   * Handles blur events on a registered element.
   * @param event The blur event.
   * @param element The monitored element.
   */
  _onBlur(event, element) {
    const elementInfo = this._elementInfo.get(element);
    if (!elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget)) {
      return;
    }
    this._setClasses(element);
    this._emitOrigin(elementInfo, null);
  }
  _emitOrigin(info, origin) {
    if (info.subject.observers.length) {
      this._ngZone.run(() => info.subject.next(origin));
    }
  }
  _registerGlobalListeners(elementInfo) {
    if (!this._platform.isBrowser) {
      return;
    }
    const rootNode = elementInfo.rootNode;
    const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;
    if (!rootNodeFocusListeners) {
      this._ngZone.runOutsideAngular(() => {
        rootNode.addEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.addEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
      });
    }
    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);
    if (++this._monitoredElementCount === 1) {
      this._ngZone.runOutsideAngular(() => {
        const window2 = this._getWindow();
        window2.addEventListener("focus", this._windowFocusListener);
      });
      this._inputModalityDetector.modalityDetected.pipe(takeUntil(this._stopInputModalityDetector)).subscribe((modality) => {
        this._setOrigin(
          modality,
          true
          /* isFromInteraction */
        );
      });
    }
  }
  _removeGlobalListeners(elementInfo) {
    const rootNode = elementInfo.rootNode;
    if (this._rootNodeFocusListenerCount.has(rootNode)) {
      const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);
      if (rootNodeFocusListeners > 1) {
        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);
      } else {
        rootNode.removeEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.removeEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        this._rootNodeFocusListenerCount.delete(rootNode);
      }
    }
    if (!--this._monitoredElementCount) {
      const window2 = this._getWindow();
      window2.removeEventListener("focus", this._windowFocusListener);
      this._stopInputModalityDetector.next();
      clearTimeout(this._windowFocusTimeoutId);
      clearTimeout(this._originTimeoutId);
    }
  }
  /** Updates all the state on an element once its focus origin has changed. */
  _originChanged(element, origin, elementInfo) {
    this._setClasses(element, origin);
    this._emitOrigin(elementInfo, origin);
    this._lastFocusOrigin = origin;
  }
  /**
   * Collects the `MonitoredElementInfo` of a particular element and
   * all of its ancestors that have enabled `checkChildren`.
   * @param element Element from which to start the search.
   */
  _getClosestElementsInfo(element) {
    const results = [];
    this._elementInfo.forEach((info, currentElement) => {
      if (currentElement === element || info.checkChildren && currentElement.contains(element)) {
        results.push([currentElement, info]);
      }
    });
    return results;
  }
  /**
   * Returns whether an interaction is likely to have come from the user clicking the `label` of
   * an `input` or `textarea` in order to focus it.
   * @param focusEventTarget Target currently receiving focus.
   */
  _isLastInteractionFromInputLabel(focusEventTarget) {
    const {
      _mostRecentTarget: mostRecentTarget,
      mostRecentModality
    } = this._inputModalityDetector;
    if (mostRecentModality !== "mouse" || !mostRecentTarget || mostRecentTarget === focusEventTarget || focusEventTarget.nodeName !== "INPUT" && focusEventTarget.nodeName !== "TEXTAREA" || focusEventTarget.disabled) {
      return false;
    }
    const labels = focusEventTarget.labels;
    if (labels) {
      for (let i = 0; i < labels.length; i++) {
        if (labels[i].contains(mostRecentTarget)) {
          return true;
        }
      }
    }
    return false;
  }
  static ɵfac = function FocusMonitor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusMonitor)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusMonitor,
    factory: _FocusMonitor.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusMonitor, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkMonitorFocus = class _CdkMonitorFocus {
  _elementRef = inject(ElementRef);
  _focusMonitor = inject(FocusMonitor);
  _monitorSubscription;
  _focusOrigin = null;
  cdkFocusChange = new EventEmitter();
  constructor() {
  }
  get focusOrigin() {
    return this._focusOrigin;
  }
  ngAfterViewInit() {
    const element = this._elementRef.nativeElement;
    this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute("cdkMonitorSubtreeFocus")).subscribe((origin) => {
      this._focusOrigin = origin;
      this.cdkFocusChange.emit(origin);
    });
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this._elementRef);
    if (this._monitorSubscription) {
      this._monitorSubscription.unsubscribe();
    }
  }
  static ɵfac = function CdkMonitorFocus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkMonitorFocus)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkMonitorFocus,
    selectors: [["", "cdkMonitorElementFocus", ""], ["", "cdkMonitorSubtreeFocus", ""]],
    outputs: {
      cdkFocusChange: "cdkFocusChange"
    },
    exportAs: ["cdkMonitorFocus"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkMonitorFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]",
      exportAs: "cdkMonitorFocus"
    }]
  }], () => [], {
    cdkFocusChange: [{
      type: Output
    }]
  });
})();
var HighContrastMode;
(function(HighContrastMode2) {
  HighContrastMode2[HighContrastMode2["NONE"] = 0] = "NONE";
  HighContrastMode2[HighContrastMode2["BLACK_ON_WHITE"] = 1] = "BLACK_ON_WHITE";
  HighContrastMode2[HighContrastMode2["WHITE_ON_BLACK"] = 2] = "WHITE_ON_BLACK";
})(HighContrastMode || (HighContrastMode = {}));
var BLACK_ON_WHITE_CSS_CLASS = "cdk-high-contrast-black-on-white";
var WHITE_ON_BLACK_CSS_CLASS = "cdk-high-contrast-white-on-black";
var HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = "cdk-high-contrast-active";
var HighContrastModeDetector = class _HighContrastModeDetector {
  _platform = inject(Platform);
  /**
   * Figuring out the high contrast mode and adding the body classes can cause
   * some expensive layouts. This flag is used to ensure that we only do it once.
   */
  _hasCheckedHighContrastMode;
  _document = inject(DOCUMENT);
  _breakpointSubscription;
  constructor() {
    this._breakpointSubscription = inject(BreakpointObserver).observe("(forced-colors: active)").subscribe(() => {
      if (this._hasCheckedHighContrastMode) {
        this._hasCheckedHighContrastMode = false;
        this._applyBodyHighContrastModeCssClasses();
      }
    });
  }
  /** Gets the current high-contrast-mode for the page. */
  getHighContrastMode() {
    if (!this._platform.isBrowser) {
      return HighContrastMode.NONE;
    }
    const testElement = this._document.createElement("div");
    testElement.style.backgroundColor = "rgb(1,2,3)";
    testElement.style.position = "absolute";
    this._document.body.appendChild(testElement);
    const documentWindow = this._document.defaultView || window;
    const computedStyle = documentWindow && documentWindow.getComputedStyle ? documentWindow.getComputedStyle(testElement) : null;
    const computedColor = (computedStyle && computedStyle.backgroundColor || "").replace(/ /g, "");
    testElement.remove();
    switch (computedColor) {
      case "rgb(0,0,0)":
      case "rgb(45,50,54)":
      case "rgb(32,32,32)":
        return HighContrastMode.WHITE_ON_BLACK;
      case "rgb(255,255,255)":
      case "rgb(255,250,239)":
        return HighContrastMode.BLACK_ON_WHITE;
    }
    return HighContrastMode.NONE;
  }
  ngOnDestroy() {
    this._breakpointSubscription.unsubscribe();
  }
  /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */
  _applyBodyHighContrastModeCssClasses() {
    if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {
      const bodyClasses = this._document.body.classList;
      bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      this._hasCheckedHighContrastMode = true;
      const mode = this.getHighContrastMode();
      if (mode === HighContrastMode.BLACK_ON_WHITE) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);
      } else if (mode === HighContrastMode.WHITE_ON_BLACK) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      }
    }
  }
  static ɵfac = function HighContrastModeDetector_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HighContrastModeDetector)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _HighContrastModeDetector,
    factory: _HighContrastModeDetector.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighContrastModeDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var A11yModule = class _A11yModule {
  constructor() {
    inject(HighContrastModeDetector)._applyBodyHighContrastModeCssClasses();
  }
  static ɵfac = function A11yModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _A11yModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _A11yModule,
    imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
    exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ObserversModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(A11yModule, [{
    type: NgModule,
    args: [{
      imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
      exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
    }]
  }], () => [], null);
})();
var counters = {};
var _IdGenerator = class __IdGenerator {
  _appId = inject(APP_ID);
  /**
   * Generates a unique ID with a specific prefix.
   * @param prefix Prefix to add to the ID.
   */
  getId(prefix) {
    if (this._appId !== "ng") {
      prefix += this._appId;
    }
    if (!counters.hasOwnProperty(prefix)) {
      counters[prefix] = 0;
    }
    return `${prefix}${counters[prefix]++}`;
  }
  static ɵfac = function _IdGenerator_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __IdGenerator)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: __IdGenerator,
    factory: __IdGenerator.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_IdGenerator, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/bidi.mjs
var DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
  providedIn: "root",
  factory: DIR_DOCUMENT_FACTORY
});
function DIR_DOCUMENT_FACTORY() {
  return inject(DOCUMENT);
}
var RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
function _resolveDirectionality(rawValue) {
  const value = rawValue?.toLowerCase() || "";
  if (value === "auto" && typeof navigator !== "undefined" && navigator?.language) {
    return RTL_LOCALE_PATTERN.test(navigator.language) ? "rtl" : "ltr";
  }
  return value === "rtl" ? "rtl" : "ltr";
}
var Directionality = class _Directionality {
  /** The current 'ltr' or 'rtl' value. */
  value = "ltr";
  /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */
  change = new EventEmitter();
  constructor() {
    const _document = inject(DIR_DOCUMENT, {
      optional: true
    });
    if (_document) {
      const bodyDir = _document.body ? _document.body.dir : null;
      const htmlDir = _document.documentElement ? _document.documentElement.dir : null;
      this.value = _resolveDirectionality(bodyDir || htmlDir || "ltr");
    }
  }
  ngOnDestroy() {
    this.change.complete();
  }
  static ɵfac = function Directionality_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Directionality)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _Directionality,
    factory: _Directionality.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Directionality, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var Dir = class _Dir {
  /** Normalized direction that accounts for invalid/unsupported values. */
  _dir = "ltr";
  /** Whether the `value` has been set to its initial value. */
  _isInitialized = false;
  /** Direction as passed in by the consumer. */
  _rawDir;
  /** Event emitted when the direction changes. */
  change = new EventEmitter();
  /** @docs-private */
  get dir() {
    return this._dir;
  }
  set dir(value) {
    const previousValue = this._dir;
    this._dir = _resolveDirectionality(value);
    this._rawDir = value;
    if (previousValue !== this._dir && this._isInitialized) {
      this.change.emit(this._dir);
    }
  }
  /** Current layout direction of the element. */
  get value() {
    return this.dir;
  }
  /** Initialize once default value has been set. */
  ngAfterContentInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    this.change.complete();
  }
  static ɵfac = function Dir_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Dir)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _Dir,
    selectors: [["", "dir", ""]],
    hostVars: 1,
    hostBindings: function Dir_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx._rawDir);
      }
    },
    inputs: {
      dir: "dir"
    },
    outputs: {
      change: "dirChange"
    },
    exportAs: ["dir"],
    features: [ɵɵProvidersFeature([{
      provide: Directionality,
      useExisting: _Dir
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dir, [{
    type: Directive,
    args: [{
      selector: "[dir]",
      providers: [{
        provide: Directionality,
        useExisting: Dir
      }],
      host: {
        "[attr.dir]": "_rawDir"
      },
      exportAs: "dir"
    }]
  }], null, {
    change: [{
      type: Output,
      args: ["dirChange"]
    }],
    dir: [{
      type: Input
    }]
  });
})();
var BidiModule = class _BidiModule {
  static ɵfac = function BidiModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BidiModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _BidiModule,
    imports: [Dir],
    exports: [Dir]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BidiModule, [{
    type: NgModule,
    args: [{
      imports: [Dir],
      exports: [Dir]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/collections.mjs
var DataSource = class {
};
function isDataSource(value) {
  return value && typeof value.connect === "function" && !(value instanceof ConnectableObservable);
}
var ArrayDataSource = class extends DataSource {
  _data;
  constructor(_data) {
    super();
    this._data = _data;
  }
  connect() {
    return isObservable(this._data) ? this._data : of(this._data);
  }
  disconnect() {
  }
};
var _ViewRepeaterOperation;
(function(_ViewRepeaterOperation2) {
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REPLACED"] = 0] = "REPLACED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["INSERTED"] = 1] = "INSERTED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["MOVED"] = 2] = "MOVED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REMOVED"] = 3] = "REMOVED";
})(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));
var _VIEW_REPEATER_STRATEGY = new InjectionToken("_ViewRepeater");
var _RecycleViewRepeaterStrategy = class {
  /**
   * The size of the cache used to store unused views.
   * Setting the cache size to `0` will disable caching. Defaults to 20 views.
   */
  viewCacheSize = 20;
  /**
   * View cache that stores embedded view instances that have been previously stamped out,
   * but don't are not currently rendered. The view repeater will reuse these views rather than
   * creating brand new ones.
   *
   * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.
   */
  _viewCache = [];
  /** Apply changes to the DOM. */
  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
      let view;
      let operation;
      if (record.previousIndex == null) {
        const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);
        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;
      } else if (currentIndex == null) {
        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
        operation = _ViewRepeaterOperation.REMOVED;
      } else {
        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = _ViewRepeaterOperation.MOVED;
      }
      if (itemViewChanged) {
        itemViewChanged({
          context: view?.context,
          operation,
          record
        });
      }
    });
  }
  detach() {
    for (const view of this._viewCache) {
      view.destroy();
    }
    this._viewCache = [];
  }
  /**
   * Inserts a view for a new item, either from the cache or by creating a new
   * one. Returns `undefined` if the item was inserted into a cached view.
   */
  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
    if (cachedView) {
      cachedView.context.$implicit = value;
      return void 0;
    }
    const viewArgs = viewArgsFactory();
    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
  }
  /** Detaches the view at the given index and inserts into the view cache. */
  _detachAndCacheView(index, viewContainerRef) {
    const detachedView = viewContainerRef.detach(index);
    this._maybeCacheView(detachedView, viewContainerRef);
  }
  /** Moves view at the previous index to the current index. */
  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
    const view = viewContainerRef.get(adjustedPreviousIndex);
    viewContainerRef.move(view, currentIndex);
    view.context.$implicit = value;
    return view;
  }
  /**
   * Cache the given detached view. If the cache is full, the view will be
   * destroyed.
   */
  _maybeCacheView(view, viewContainerRef) {
    if (this._viewCache.length < this.viewCacheSize) {
      this._viewCache.push(view);
    } else {
      const index = viewContainerRef.indexOf(view);
      if (index === -1) {
        view.destroy();
      } else {
        viewContainerRef.remove(index);
      }
    }
  }
  /** Inserts a recycled view from the cache at the given index. */
  _insertViewFromCache(index, viewContainerRef) {
    const cachedView = this._viewCache.pop();
    if (cachedView) {
      viewContainerRef.insert(cachedView, index);
    }
    return cachedView || null;
  }
};
var SelectionModel = class {
  _multiple;
  _emitChanges;
  compareWith;
  /** Currently-selected values. */
  _selection = /* @__PURE__ */ new Set();
  /** Keeps track of the deselected options that haven't been emitted by the change event. */
  _deselectedToEmit = [];
  /** Keeps track of the selected options that haven't been emitted by the change event. */
  _selectedToEmit = [];
  /** Cache for the array value of the selected items. */
  _selected;
  /** Selected values. */
  get selected() {
    if (!this._selected) {
      this._selected = Array.from(this._selection.values());
    }
    return this._selected;
  }
  /** Event emitted when the value has changed. */
  changed = new Subject();
  constructor(_multiple = false, initiallySelectedValues, _emitChanges = true, compareWith) {
    this._multiple = _multiple;
    this._emitChanges = _emitChanges;
    this.compareWith = compareWith;
    if (initiallySelectedValues && initiallySelectedValues.length) {
      if (_multiple) {
        initiallySelectedValues.forEach((value) => this._markSelected(value));
      } else {
        this._markSelected(initiallySelectedValues[0]);
      }
      this._selectedToEmit.length = 0;
    }
  }
  /**
   * Selects a value or an array of values.
   * @param values The values to select
   * @return Whether the selection changed as a result of this call
   * @breaking-change 16.0.0 make return type boolean
   */
  select(...values) {
    this._verifyValueAssignment(values);
    values.forEach((value) => this._markSelected(value));
    const changed = this._hasQueuedChanges();
    this._emitChangeEvent();
    return changed;
  }
  /**
   * Deselects a value or an array of values.
   * @param values The values to deselect
   * @return Whether the selection changed as a result of this call
   * @breaking-change 16.0.0 make return type boolean
   */
  deselect(...values) {
    this._verifyValueAssignment(values);
    values.forEach((value) => this._unmarkSelected(value));
    const changed = this._hasQueuedChanges();
    this._emitChangeEvent();
    return changed;
  }
  /**
   * Sets the selected values
   * @param values The new selected values
   * @return Whether the selection changed as a result of this call
   * @breaking-change 16.0.0 make return type boolean
   */
  setSelection(...values) {
    this._verifyValueAssignment(values);
    const oldValues = this.selected;
    const newSelectedSet = new Set(values);
    values.forEach((value) => this._markSelected(value));
    oldValues.filter((value) => !newSelectedSet.has(this._getConcreteValue(value, newSelectedSet))).forEach((value) => this._unmarkSelected(value));
    const changed = this._hasQueuedChanges();
    this._emitChangeEvent();
    return changed;
  }
  /**
   * Toggles a value between selected and deselected.
   * @param value The value to toggle
   * @return Whether the selection changed as a result of this call
   * @breaking-change 16.0.0 make return type boolean
   */
  toggle(value) {
    return this.isSelected(value) ? this.deselect(value) : this.select(value);
  }
  /**
   * Clears all of the selected values.
   * @param flushEvent Whether to flush the changes in an event.
   *   If false, the changes to the selection will be flushed along with the next event.
   * @return Whether the selection changed as a result of this call
   * @breaking-change 16.0.0 make return type boolean
   */
  clear(flushEvent = true) {
    this._unmarkAll();
    const changed = this._hasQueuedChanges();
    if (flushEvent) {
      this._emitChangeEvent();
    }
    return changed;
  }
  /**
   * Determines whether a value is selected.
   */
  isSelected(value) {
    return this._selection.has(this._getConcreteValue(value));
  }
  /**
   * Determines whether the model does not have a value.
   */
  isEmpty() {
    return this._selection.size === 0;
  }
  /**
   * Determines whether the model has a value.
   */
  hasValue() {
    return !this.isEmpty();
  }
  /**
   * Sorts the selected values based on a predicate function.
   */
  sort(predicate) {
    if (this._multiple && this.selected) {
      this._selected.sort(predicate);
    }
  }
  /**
   * Gets whether multiple values can be selected.
   */
  isMultipleSelection() {
    return this._multiple;
  }
  /** Emits a change event and clears the records of selected and deselected values. */
  _emitChangeEvent() {
    this._selected = null;
    if (this._selectedToEmit.length || this._deselectedToEmit.length) {
      this.changed.next({
        source: this,
        added: this._selectedToEmit,
        removed: this._deselectedToEmit
      });
      this._deselectedToEmit = [];
      this._selectedToEmit = [];
    }
  }
  /** Selects a value. */
  _markSelected(value) {
    value = this._getConcreteValue(value);
    if (!this.isSelected(value)) {
      if (!this._multiple) {
        this._unmarkAll();
      }
      if (!this.isSelected(value)) {
        this._selection.add(value);
      }
      if (this._emitChanges) {
        this._selectedToEmit.push(value);
      }
    }
  }
  /** Deselects a value. */
  _unmarkSelected(value) {
    value = this._getConcreteValue(value);
    if (this.isSelected(value)) {
      this._selection.delete(value);
      if (this._emitChanges) {
        this._deselectedToEmit.push(value);
      }
    }
  }
  /** Clears out the selected values. */
  _unmarkAll() {
    if (!this.isEmpty()) {
      this._selection.forEach((value) => this._unmarkSelected(value));
    }
  }
  /**
   * Verifies the value assignment and throws an error if the specified value array is
   * including multiple values while the selection model is not supporting multiple values.
   */
  _verifyValueAssignment(values) {
    if (values.length > 1 && !this._multiple && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMultipleValuesInSingleSelectionError();
    }
  }
  /** Whether there are queued up change to be emitted. */
  _hasQueuedChanges() {
    return !!(this._deselectedToEmit.length || this._selectedToEmit.length);
  }
  /** Returns a value that is comparable to inputValue by applying compareWith function, returns the same inputValue otherwise. */
  _getConcreteValue(inputValue, selection) {
    if (!this.compareWith) {
      return inputValue;
    } else {
      selection = selection ?? this._selection;
      for (let selectedValue of selection) {
        if (this.compareWith(inputValue, selectedValue)) {
          return selectedValue;
        }
      }
      return inputValue;
    }
  }
};
function getMultipleValuesInSingleSelectionError() {
  return Error("Cannot pass multiple values into SelectionModel with single-value mode.");
}
var UniqueSelectionDispatcher = class _UniqueSelectionDispatcher {
  _listeners = [];
  /**
   * Notify other items that selection for the given name has been set.
   * @param id ID of the item.
   * @param name Name of the item.
   */
  notify(id, name) {
    for (let listener of this._listeners) {
      listener(id, name);
    }
  }
  /**
   * Listen for future changes to item selection.
   * @return Function used to deregister listener
   */
  listen(listener) {
    this._listeners.push(listener);
    return () => {
      this._listeners = this._listeners.filter((registered) => {
        return listener !== registered;
      });
    };
  }
  ngOnDestroy() {
    this._listeners = [];
  }
  static ɵfac = function UniqueSelectionDispatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UniqueSelectionDispatcher)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _UniqueSelectionDispatcher,
    factory: _UniqueSelectionDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UniqueSelectionDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/listbox.mjs
var ListboxSelectionModel = class extends SelectionModel {
  multiple;
  constructor(multiple = false, initiallySelectedValues, emitChanges = true, compareWith) {
    super(true, initiallySelectedValues, emitChanges, compareWith);
    this.multiple = multiple;
  }
  isMultipleSelection() {
    return this.multiple;
  }
  select(...values) {
    if (this.multiple) {
      return super.select(...values);
    } else {
      return super.setSelection(...values);
    }
  }
};
var CdkOption = class _CdkOption {
  /** The id of the option's host element. */
  get id() {
    return this._id || this._generatedId;
  }
  set id(value) {
    this._id = value;
  }
  _id;
  _generatedId = inject(_IdGenerator).getId("cdk-option-");
  /** The value of this option. */
  value;
  /**
   * The text used to locate this item during listbox typeahead. If not specified,
   * the `textContent` of the item will be used.
   */
  typeaheadLabel;
  /** Whether this option is disabled. */
  get disabled() {
    return this.listbox.disabled || this._disabled();
  }
  set disabled(value) {
    this._disabled.set(value);
  }
  _disabled = signal(false);
  /** The tabindex of the option when it is enabled. */
  get enabledTabIndex() {
    return this._enabledTabIndex() === void 0 ? this.listbox.enabledTabIndex : this._enabledTabIndex();
  }
  set enabledTabIndex(value) {
    this._enabledTabIndex.set(value);
  }
  _enabledTabIndex = signal(void 0);
  /** The option's host element */
  element = inject(ElementRef).nativeElement;
  /** The parent listbox this option belongs to. */
  listbox = inject(CdkListbox);
  /** Emits when the option is destroyed. */
  destroyed = new Subject();
  /** Emits when the option is clicked. */
  _clicked = new Subject();
  ngOnDestroy() {
    this.destroyed.next();
    this.destroyed.complete();
  }
  /** Whether this option is selected. */
  isSelected() {
    return this.listbox.isSelected(this);
  }
  /** Whether this option is active. */
  isActive() {
    return this.listbox.isActive(this);
  }
  /** Toggle the selected state of this option. */
  toggle() {
    this.listbox.toggle(this);
  }
  /** Select this option if it is not selected. */
  select() {
    this.listbox.select(this);
  }
  /** Deselect this option if it is selected. */
  deselect() {
    this.listbox.deselect(this);
  }
  /** Focus this option. */
  focus() {
    this.element.focus();
  }
  /** Get the label for this element which is required by the FocusableOption interface. */
  getLabel() {
    return (this.typeaheadLabel ?? this.element.textContent?.trim()) || "";
  }
  /**
   * No-op implemented as a part of `Highlightable`.
   * @docs-private
   */
  setActiveStyles() {
    if (this.listbox.useActiveDescendant) {
      this.element.scrollIntoView({
        block: "nearest",
        inline: "nearest"
      });
    }
  }
  /**
   * No-op implemented as a part of `Highlightable`.
   * @docs-private
   */
  setInactiveStyles() {
  }
  /** Handle focus events on the option. */
  _handleFocus() {
    if (this.listbox.useActiveDescendant) {
      this.listbox._setActiveOption(this);
      this.listbox.focus();
    }
  }
  /** Get the tabindex for this option. */
  _getTabIndex() {
    if (this.listbox.useActiveDescendant || this.disabled) {
      return -1;
    }
    return this.isActive() ? this.enabledTabIndex : -1;
  }
  static ɵfac = function CdkOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkOption)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkOption,
    selectors: [["", "cdkOption", ""]],
    hostAttrs: ["role", "option", 1, "cdk-option"],
    hostVars: 6,
    hostBindings: function CdkOption_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function CdkOption_click_HostBindingHandler($event) {
          return ctx._clicked.next($event);
        })("focus", function CdkOption_focus_HostBindingHandler() {
          return ctx._handleFocus();
        });
      }
      if (rf & 2) {
        ɵɵhostProperty("id", ctx.id);
        ɵɵattribute("aria-selected", ctx.isSelected())("tabindex", ctx._getTabIndex())("aria-disabled", ctx.disabled);
        ɵɵclassProp("cdk-option-active", ctx.isActive());
      }
    },
    inputs: {
      id: "id",
      value: [0, "cdkOption", "value"],
      typeaheadLabel: [0, "cdkOptionTypeaheadLabel", "typeaheadLabel"],
      disabled: [2, "cdkOptionDisabled", "disabled", booleanAttribute],
      enabledTabIndex: [0, "tabindex", "enabledTabIndex"]
    },
    exportAs: ["cdkOption"],
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkOption, [{
    type: Directive,
    args: [{
      selector: "[cdkOption]",
      exportAs: "cdkOption",
      host: {
        "role": "option",
        "class": "cdk-option",
        "[id]": "id",
        "[attr.aria-selected]": "isSelected()",
        "[attr.tabindex]": "_getTabIndex()",
        "[attr.aria-disabled]": "disabled",
        "[class.cdk-option-active]": "isActive()",
        "(click)": "_clicked.next($event)",
        "(focus)": "_handleFocus()"
      }
    }]
  }], null, {
    id: [{
      type: Input
    }],
    value: [{
      type: Input,
      args: ["cdkOption"]
    }],
    typeaheadLabel: [{
      type: Input,
      args: ["cdkOptionTypeaheadLabel"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkOptionDisabled",
        transform: booleanAttribute
      }]
    }],
    enabledTabIndex: [{
      type: Input,
      args: ["tabindex"]
    }]
  });
})();
var CdkListbox = class _CdkListbox {
  /** The id of the option's host element. */
  get id() {
    return this._id || this._generatedId;
  }
  set id(value) {
    this._id = value;
  }
  _id;
  _generatedId = inject(_IdGenerator).getId("cdk-listbox-");
  /** The tabindex to use when the listbox is enabled. */
  get enabledTabIndex() {
    return this._enabledTabIndex() === void 0 ? 0 : this._enabledTabIndex();
  }
  set enabledTabIndex(value) {
    this._enabledTabIndex.set(value);
  }
  _enabledTabIndex = signal(void 0);
  /** The value selected in the listbox, represented as an array of option values. */
  get value() {
    return this._invalid ? [] : this.selectionModel.selected;
  }
  set value(value) {
    this._setSelection(value);
  }
  /**
   * Whether the listbox allows multiple options to be selected. If the value switches from `true`
   * to `false`, and more than one option is selected, all options are deselected.
   */
  get multiple() {
    return this.selectionModel.multiple;
  }
  set multiple(value) {
    this.selectionModel.multiple = value;
    if (this.options) {
      this._updateInternalValue();
    }
  }
  /** Whether the listbox is disabled. */
  get disabled() {
    return this._disabled();
  }
  set disabled(value) {
    this._disabled.set(value);
  }
  _disabled = signal(false);
  /** Whether the listbox will use active descendant or will move focus onto the options. */
  get useActiveDescendant() {
    return this._useActiveDescendant();
  }
  set useActiveDescendant(value) {
    this._useActiveDescendant.set(value);
  }
  _useActiveDescendant = signal(false);
  /** The orientation of the listbox. Only affects keyboard interaction, not visual layout. */
  get orientation() {
    return this._orientation;
  }
  set orientation(value) {
    this._orientation = value === "horizontal" ? "horizontal" : "vertical";
    if (value === "horizontal") {
      this.listKeyManager?.withHorizontalOrientation(this._dir?.value || "ltr");
    } else {
      this.listKeyManager?.withVerticalOrientation();
    }
  }
  _orientation = "vertical";
  /** The function used to compare option values. */
  get compareWith() {
    return this.selectionModel.compareWith;
  }
  set compareWith(fn) {
    this.selectionModel.compareWith = fn;
  }
  /**
   * Whether the keyboard navigation should wrap when the user presses arrow down on the last item
   * or arrow up on the first item.
   */
  get navigationWrapDisabled() {
    return this._navigationWrapDisabled;
  }
  set navigationWrapDisabled(wrap) {
    this._navigationWrapDisabled = wrap;
    this.listKeyManager?.withWrap(!this._navigationWrapDisabled);
  }
  _navigationWrapDisabled = false;
  /** Whether keyboard navigation should skip over disabled items. */
  get navigateDisabledOptions() {
    return this._navigateDisabledOptions;
  }
  set navigateDisabledOptions(skip2) {
    this._navigateDisabledOptions = skip2;
    this.listKeyManager?.skipPredicate(this._navigateDisabledOptions ? this._skipNonePredicate : this._skipDisabledPredicate);
  }
  _navigateDisabledOptions = false;
  /** Emits when the selected value(s) in the listbox change. */
  valueChange = new Subject();
  /** The child options in this listbox. */
  options;
  /** The selection model used by the listbox. */
  selectionModel = new ListboxSelectionModel();
  /** The key manager that manages keyboard navigation for this listbox. */
  listKeyManager;
  /** Emits when the listbox is destroyed. */
  destroyed = new Subject();
  /** The host element of the listbox. */
  element = inject(ElementRef).nativeElement;
  /** The Angular zone. */
  ngZone = inject(NgZone);
  /** The change detector for this listbox. */
  changeDetectorRef = inject(ChangeDetectorRef);
  /** Whether the currently selected value in the selection model is invalid. */
  _invalid = false;
  /** The last user-triggered option. */
  _lastTriggered = null;
  /** Callback called when the listbox has been touched */
  _onTouched = () => {
  };
  /** Callback called when the listbox value changes */
  _onChange = () => {
  };
  /** Emits when an option has been clicked. */
  _optionClicked = defer(() => this.options.changes.pipe(startWith(this.options), switchMap((options) => merge(...options.map((option) => option._clicked.pipe(map((event) => ({
    option,
    event
  }))))))));
  /** The directionality of the page. */
  _dir = inject(Directionality, {
    optional: true
  });
  /** Whether the component is being rendered in the browser. */
  _isBrowser = inject(Platform).isBrowser;
  /** A predicate that skips disabled options. */
  _skipDisabledPredicate = (option) => option.disabled;
  /** A predicate that does not skip any options. */
  _skipNonePredicate = () => false;
  /** Whether the listbox currently has focus. */
  _hasFocus = false;
  /** A reference to the option that was active before the listbox lost focus. */
  _previousActiveOption = null;
  constructor() {
    if (this._isBrowser) {
      this._setPreviousActiveOptionAsActiveOptionOnWindowBlur();
    }
  }
  ngAfterContentInit() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      this._verifyNoOptionValueCollisions();
      this._verifyOptionValues();
    }
    this._initKeyManager();
    merge(this.selectionModel.changed, this.options.changes).pipe(startWith(null), takeUntil(this.destroyed)).subscribe(() => this._updateInternalValue());
    this._optionClicked.pipe(filter(({
      option
    }) => !option.disabled), takeUntil(this.destroyed)).subscribe(({
      option,
      event
    }) => this._handleOptionClicked(option, event));
  }
  ngOnDestroy() {
    this.listKeyManager?.destroy();
    this.destroyed.next();
    this.destroyed.complete();
  }
  /**
   * Toggle the selected state of the given option.
   * @param option The option to toggle
   */
  toggle(option) {
    this.toggleValue(option.value);
  }
  /**
   * Toggle the selected state of the given value.
   * @param value The value to toggle
   */
  toggleValue(value) {
    if (this._invalid) {
      this.selectionModel.clear(false);
    }
    this.selectionModel.toggle(value);
  }
  /**
   * Select the given option.
   * @param option The option to select
   */
  select(option) {
    this.selectValue(option.value);
  }
  /**
   * Select the given value.
   * @param value The value to select
   */
  selectValue(value) {
    if (this._invalid) {
      this.selectionModel.clear(false);
    }
    this.selectionModel.select(value);
  }
  /**
   * Deselect the given option.
   * @param option The option to deselect
   */
  deselect(option) {
    this.deselectValue(option.value);
  }
  /**
   * Deselect the given value.
   * @param value The value to deselect
   */
  deselectValue(value) {
    if (this._invalid) {
      this.selectionModel.clear(false);
    }
    this.selectionModel.deselect(value);
  }
  /**
   * Set the selected state of all options.
   * @param isSelected The new selected state to set
   */
  setAllSelected(isSelected) {
    if (!isSelected) {
      this.selectionModel.clear();
    } else {
      if (this._invalid) {
        this.selectionModel.clear(false);
      }
      this.selectionModel.select(...this.options.map((option) => option.value));
    }
  }
  /**
   * Get whether the given option is selected.
   * @param option The option to get the selected state of
   */
  isSelected(option) {
    return this.isValueSelected(option.value);
  }
  /**
   * Get whether the given option is active.
   * @param option The option to get the active state of
   */
  isActive(option) {
    return !!(this.listKeyManager?.activeItem === option);
  }
  /**
   * Get whether the given value is selected.
   * @param value The value to get the selected state of
   */
  isValueSelected(value) {
    if (this._invalid) {
      return false;
    }
    return this.selectionModel.isSelected(value);
  }
  /**
   * Registers a callback to be invoked when the listbox's value changes from user input.
   * @param fn The callback to register
   * @docs-private
   */
  registerOnChange(fn) {
    this._onChange = fn;
  }
  /**
   * Registers a callback to be invoked when the listbox is blurred by the user.
   * @param fn The callback to register
   * @docs-private
   */
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  /**
   * Sets the listbox's value.
   * @param value The new value of the listbox
   * @docs-private
   */
  writeValue(value) {
    this._setSelection(value);
    this._verifyOptionValues();
  }
  /**
   * Sets the disabled state of the listbox.
   * @param isDisabled The new disabled state
   * @docs-private
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.changeDetectorRef.markForCheck();
  }
  /** Focus the listbox's host element. */
  focus() {
    this.element.focus();
  }
  /**
   * Triggers the given option in response to user interaction.
   * - In single selection mode: selects the option and deselects any other selected option.
   * - In multi selection mode: toggles the selected state of the option.
   * @param option The option to trigger
   */
  triggerOption(option) {
    if (option && !option.disabled) {
      this._lastTriggered = option;
      const changed = this.multiple ? this.selectionModel.toggle(option.value) : this.selectionModel.select(option.value);
      if (changed) {
        this._onChange(this.value);
        this.valueChange.next({
          value: this.value,
          listbox: this,
          option
        });
      }
    }
  }
  /**
   * Trigger the given range of options in response to user interaction.
   * Should only be called in multi-selection mode.
   * @param trigger The option that was triggered
   * @param from The start index of the options to toggle
   * @param to The end index of the options to toggle
   * @param on Whether to toggle the option range on
   */
  triggerRange(trigger2, from2, to, on) {
    if (this.disabled || trigger2 && trigger2.disabled) {
      return;
    }
    this._lastTriggered = trigger2;
    const isEqual = this.compareWith ?? Object.is;
    const updateValues = [...this.options].slice(Math.max(0, Math.min(from2, to)), Math.min(this.options.length, Math.max(from2, to) + 1)).filter((option) => !option.disabled).map((option) => option.value);
    const selected = [...this.value];
    for (const updateValue of updateValues) {
      const selectedIndex = selected.findIndex((selectedValue) => isEqual(selectedValue, updateValue));
      if (on && selectedIndex === -1) {
        selected.push(updateValue);
      } else if (!on && selectedIndex !== -1) {
        selected.splice(selectedIndex, 1);
      }
    }
    let changed = this.selectionModel.setSelection(...selected);
    if (changed) {
      this._onChange(this.value);
      this.valueChange.next({
        value: this.value,
        listbox: this,
        option: trigger2
      });
    }
  }
  /**
   * Sets the given option as active.
   * @param option The option to make active
   */
  _setActiveOption(option) {
    this.listKeyManager.setActiveItem(option);
  }
  /** Called when the listbox receives focus. */
  _handleFocus() {
    if (!this.useActiveDescendant) {
      if (this.selectionModel.selected.length > 0) {
        this._setNextFocusToSelectedOption();
      } else {
        this.listKeyManager.setNextItemActive();
      }
      this._focusActiveOption();
    }
  }
  /** Called when the user presses keydown on the listbox. */
  _handleKeydown(event) {
    if (this.disabled) {
      return;
    }
    const {
      keyCode
    } = event;
    const previousActiveIndex = this.listKeyManager.activeItemIndex;
    const ctrlKeys = ["ctrlKey", "metaKey"];
    if (this.multiple && keyCode === A && hasModifierKey(event, ...ctrlKeys)) {
      this.triggerRange(null, 0, this.options.length - 1, this.options.length !== this.value.length);
      event.preventDefault();
      return;
    }
    if (this.multiple && (keyCode === SPACE || keyCode === ENTER) && hasModifierKey(event, "shiftKey")) {
      if (this.listKeyManager.activeItem && this.listKeyManager.activeItemIndex != null) {
        this.triggerRange(this.listKeyManager.activeItem, this._getLastTriggeredIndex() ?? this.listKeyManager.activeItemIndex, this.listKeyManager.activeItemIndex, !this.listKeyManager.activeItem.isSelected());
      }
      event.preventDefault();
      return;
    }
    if (this.multiple && keyCode === HOME && hasModifierKey(event, ...ctrlKeys) && hasModifierKey(event, "shiftKey")) {
      const trigger2 = this.listKeyManager.activeItem;
      if (trigger2) {
        const from2 = this.listKeyManager.activeItemIndex;
        this.listKeyManager.setFirstItemActive();
        this.triggerRange(trigger2, from2, this.listKeyManager.activeItemIndex, !trigger2.isSelected());
      }
      event.preventDefault();
      return;
    }
    if (this.multiple && keyCode === END && hasModifierKey(event, ...ctrlKeys) && hasModifierKey(event, "shiftKey")) {
      const trigger2 = this.listKeyManager.activeItem;
      if (trigger2) {
        const from2 = this.listKeyManager.activeItemIndex;
        this.listKeyManager.setLastItemActive();
        this.triggerRange(trigger2, from2, this.listKeyManager.activeItemIndex, !trigger2.isSelected());
      }
      event.preventDefault();
      return;
    }
    if (keyCode === SPACE || keyCode === ENTER) {
      this.triggerOption(this.listKeyManager.activeItem);
      event.preventDefault();
      return;
    }
    const isNavKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW || keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW || keyCode === HOME || keyCode === END;
    this.listKeyManager.onKeydown(event);
    if (isNavKey && event.shiftKey && previousActiveIndex !== this.listKeyManager.activeItemIndex) {
      this.triggerOption(this.listKeyManager.activeItem);
    }
  }
  /** Called when a focus moves into the listbox. */
  _handleFocusIn() {
    this._hasFocus = true;
  }
  /**
   * Called when the focus leaves an element in the listbox.
   * @param event The focusout event
   */
  _handleFocusOut(event) {
    this._previousActiveOption = this.listKeyManager.activeItem;
    const otherElement = event.relatedTarget;
    if (this.element !== otherElement && !this.element.contains(otherElement)) {
      this._onTouched();
      this._hasFocus = false;
      this._setNextFocusToSelectedOption();
    }
  }
  /** Get the id of the active option if active descendant is being used. */
  _getAriaActiveDescendant() {
    return this.useActiveDescendant ? this.listKeyManager?.activeItem?.id : null;
  }
  /** Get the tabindex for the listbox. */
  _getTabIndex() {
    if (this.disabled) {
      return -1;
    }
    return this.useActiveDescendant || !this.listKeyManager.activeItem ? this.enabledTabIndex : -1;
  }
  /** Initialize the key manager. */
  _initKeyManager() {
    this.listKeyManager = new ActiveDescendantKeyManager(this.options).withWrap(!this._navigationWrapDisabled).withTypeAhead().withHomeAndEnd().withAllowedModifierKeys(["shiftKey"]).skipPredicate(this._navigateDisabledOptions ? this._skipNonePredicate : this._skipDisabledPredicate);
    if (this.orientation === "vertical") {
      this.listKeyManager.withVerticalOrientation();
    } else {
      this.listKeyManager.withHorizontalOrientation(this._dir?.value || "ltr");
    }
    if (this.selectionModel.selected.length) {
      Promise.resolve().then(() => this._setNextFocusToSelectedOption());
    }
    this.listKeyManager.change.subscribe(() => this._focusActiveOption());
    this.options.changes.pipe(takeUntil(this.destroyed)).subscribe(() => {
      const activeOption = this.listKeyManager.activeItem;
      if (activeOption && !this.options.find((option) => option === activeOption)) {
        this.listKeyManager.setActiveItem(-1);
        this.changeDetectorRef.markForCheck();
      }
    });
  }
  /** Focus the active option. */
  _focusActiveOption() {
    if (!this.useActiveDescendant) {
      this.listKeyManager.activeItem?.focus();
    }
    this.changeDetectorRef.markForCheck();
  }
  /**
   * Set the selected values.
   * @param value The list of new selected values.
   */
  _setSelection(value) {
    if (this._invalid) {
      this.selectionModel.clear(false);
    }
    this.selectionModel.setSelection(...this._coerceValue(value));
    if (!this._hasFocus) {
      this._setNextFocusToSelectedOption();
    }
  }
  /** Sets the first selected option as first in the keyboard focus order. */
  _setNextFocusToSelectedOption() {
    const selected = this.options?.find((option) => option.isSelected());
    if (selected) {
      this.listKeyManager.updateActiveItem(selected);
    }
  }
  /** Update the internal value of the listbox based on the selection model. */
  _updateInternalValue() {
    const indexCache = /* @__PURE__ */ new Map();
    this.selectionModel.sort((a, b) => {
      const aIndex = this._getIndexForValue(indexCache, a);
      const bIndex = this._getIndexForValue(indexCache, b);
      return aIndex - bIndex;
    });
    const selected = this.selectionModel.selected;
    this._invalid = !this.multiple && selected.length > 1 || !!this._getInvalidOptionValues(selected).length;
    this.changeDetectorRef.markForCheck();
  }
  /**
   * Gets the index of the given value in the given list of options.
   * @param cache The cache of indices found so far
   * @param value The value to find
   * @return The index of the value in the options list
   */
  _getIndexForValue(cache, value) {
    const isEqual = this.compareWith || Object.is;
    if (!cache.has(value)) {
      let index = -1;
      for (let i = 0; i < this.options.length; i++) {
        if (isEqual(value, this.options.get(i).value)) {
          index = i;
          break;
        }
      }
      cache.set(value, index);
    }
    return cache.get(value);
  }
  /**
   * Handle the user clicking an option.
   * @param option The option that was clicked.
   */
  _handleOptionClicked(option, event) {
    event.preventDefault();
    this.listKeyManager.setActiveItem(option);
    if (event.shiftKey && this.multiple) {
      this.triggerRange(option, this._getLastTriggeredIndex() ?? this.listKeyManager.activeItemIndex, this.listKeyManager.activeItemIndex, !option.isSelected());
    } else {
      this.triggerOption(option);
    }
  }
  /** Verifies that no two options represent the same value under the compareWith function. */
  _verifyNoOptionValueCollisions() {
    this.options.changes.pipe(startWith(this.options), takeUntil(this.destroyed)).subscribe(() => {
      const isEqual = this.compareWith ?? Object.is;
      for (let i = 0; i < this.options.length; i++) {
        const option = this.options.get(i);
        let duplicate = null;
        for (let j = i + 1; j < this.options.length; j++) {
          const other = this.options.get(j);
          if (isEqual(option.value, other.value)) {
            duplicate = other;
            break;
          }
        }
        if (duplicate) {
          if (this.compareWith) {
            console.warn(`Found multiple CdkOption representing the same value under the given compareWith function`, {
              option1: option.element,
              option2: duplicate.element,
              compareWith: this.compareWith
            });
          } else {
            console.warn(`Found multiple CdkOption with the same value`, {
              option1: option.element,
              option2: duplicate.element
            });
          }
          return;
        }
      }
    });
  }
  /** Verifies that the option values are valid. */
  _verifyOptionValues() {
    if (this.options && (typeof ngDevMode === "undefined" || ngDevMode)) {
      const selected = this.selectionModel.selected;
      const invalidValues = this._getInvalidOptionValues(selected);
      if (!this.multiple && selected.length > 1) {
        throw Error("Listbox cannot have more than one selected value in multi-selection mode.");
      }
      if (invalidValues.length) {
        throw Error("Listbox has selected values that do not match any of its options.");
      }
    }
  }
  /**
   * Coerces a value into an array representing a listbox selection.
   * @param value The value to coerce
   * @return An array
   */
  _coerceValue(value) {
    return value == null ? [] : coerceArray(value);
  }
  /**
   * Get the sublist of values that do not represent valid option values in this listbox.
   * @param values The list of values
   * @return The sublist of values that are not valid option values
   */
  _getInvalidOptionValues(values) {
    const isEqual = this.compareWith || Object.is;
    const validValues = (this.options || []).map((option) => option.value);
    return values.filter((value) => !validValues.some((validValue2) => isEqual(value, validValue2)));
  }
  /** Get the index of the last triggered option. */
  _getLastTriggeredIndex() {
    const index = this.options.toArray().indexOf(this._lastTriggered);
    return index === -1 ? null : index;
  }
  /**
   * Set previous active option as active option on window blur.
   * This ensures that the `activeOption` matches the actual focused element when the user returns to the document.
   */
  _setPreviousActiveOptionAsActiveOptionOnWindowBlur() {
    this.ngZone.runOutsideAngular(() => {
      fromEvent(window, "blur").pipe(takeUntil(this.destroyed)).subscribe(() => {
        if (this.element.contains(document.activeElement) && this._previousActiveOption) {
          this._setActiveOption(this._previousActiveOption);
          this._previousActiveOption = null;
        }
      });
    });
  }
  static ɵfac = function CdkListbox_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkListbox)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkListbox,
    selectors: [["", "cdkListbox", ""]],
    contentQueries: function CdkListbox_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, CdkOption, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
      }
    },
    hostAttrs: ["role", "listbox", 1, "cdk-listbox"],
    hostVars: 6,
    hostBindings: function CdkListbox_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focus", function CdkListbox_focus_HostBindingHandler() {
          return ctx._handleFocus();
        })("keydown", function CdkListbox_keydown_HostBindingHandler($event) {
          return ctx._handleKeydown($event);
        })("focusout", function CdkListbox_focusout_HostBindingHandler($event) {
          return ctx._handleFocusOut($event);
        })("focusin", function CdkListbox_focusin_HostBindingHandler() {
          return ctx._handleFocusIn();
        });
      }
      if (rf & 2) {
        ɵɵhostProperty("id", ctx.id);
        ɵɵattribute("tabindex", ctx._getTabIndex())("aria-disabled", ctx.disabled)("aria-multiselectable", ctx.multiple)("aria-activedescendant", ctx._getAriaActiveDescendant())("aria-orientation", ctx.orientation);
      }
    },
    inputs: {
      id: "id",
      enabledTabIndex: [0, "tabindex", "enabledTabIndex"],
      value: [0, "cdkListboxValue", "value"],
      multiple: [2, "cdkListboxMultiple", "multiple", booleanAttribute],
      disabled: [2, "cdkListboxDisabled", "disabled", booleanAttribute],
      useActiveDescendant: [2, "cdkListboxUseActiveDescendant", "useActiveDescendant", booleanAttribute],
      orientation: [0, "cdkListboxOrientation", "orientation"],
      compareWith: [0, "cdkListboxCompareWith", "compareWith"],
      navigationWrapDisabled: [2, "cdkListboxNavigationWrapDisabled", "navigationWrapDisabled", booleanAttribute],
      navigateDisabledOptions: [2, "cdkListboxNavigatesDisabledOptions", "navigateDisabledOptions", booleanAttribute]
    },
    outputs: {
      valueChange: "cdkListboxValueChange"
    },
    exportAs: ["cdkListbox"],
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _CdkListbox),
      multi: true
    }]), ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkListbox, [{
    type: Directive,
    args: [{
      selector: "[cdkListbox]",
      exportAs: "cdkListbox",
      host: {
        "role": "listbox",
        "class": "cdk-listbox",
        "[id]": "id",
        "[attr.tabindex]": "_getTabIndex()",
        "[attr.aria-disabled]": "disabled",
        "[attr.aria-multiselectable]": "multiple",
        "[attr.aria-activedescendant]": "_getAriaActiveDescendant()",
        "[attr.aria-orientation]": "orientation",
        "(focus)": "_handleFocus()",
        "(keydown)": "_handleKeydown($event)",
        "(focusout)": "_handleFocusOut($event)",
        "(focusin)": "_handleFocusIn()"
      },
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => CdkListbox),
        multi: true
      }]
    }]
  }], () => [], {
    id: [{
      type: Input
    }],
    enabledTabIndex: [{
      type: Input,
      args: ["tabindex"]
    }],
    value: [{
      type: Input,
      args: ["cdkListboxValue"]
    }],
    multiple: [{
      type: Input,
      args: [{
        alias: "cdkListboxMultiple",
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkListboxDisabled",
        transform: booleanAttribute
      }]
    }],
    useActiveDescendant: [{
      type: Input,
      args: [{
        alias: "cdkListboxUseActiveDescendant",
        transform: booleanAttribute
      }]
    }],
    orientation: [{
      type: Input,
      args: ["cdkListboxOrientation"]
    }],
    compareWith: [{
      type: Input,
      args: ["cdkListboxCompareWith"]
    }],
    navigationWrapDisabled: [{
      type: Input,
      args: [{
        alias: "cdkListboxNavigationWrapDisabled",
        transform: booleanAttribute
      }]
    }],
    navigateDisabledOptions: [{
      type: Input,
      args: [{
        alias: "cdkListboxNavigatesDisabledOptions",
        transform: booleanAttribute
      }]
    }],
    valueChange: [{
      type: Output,
      args: ["cdkListboxValueChange"]
    }],
    options: [{
      type: ContentChildren,
      args: [CdkOption, {
        descendants: true
      }]
    }]
  });
})();
var EXPORTED_DECLARATIONS = [CdkListbox, CdkOption];
var CdkListboxModule = class _CdkListboxModule {
  static ɵfac = function CdkListboxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkListboxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CdkListboxModule,
    imports: [CdkListbox, CdkOption],
    exports: [CdkListbox, CdkOption]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkListboxModule, [{
    type: NgModule,
    args: [{
      imports: [...EXPORTED_DECLARATIONS],
      exports: [...EXPORTED_DECLARATIONS]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/scrolling.mjs
var _c0 = ["contentWrapper"];
var _c1 = ["*"];
var VIRTUAL_SCROLL_STRATEGY = new InjectionToken("VIRTUAL_SCROLL_STRATEGY");
var FixedSizeVirtualScrollStrategy = class {
  _scrolledIndexChange = new Subject();
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());
  /** The attached viewport. */
  _viewport = null;
  /** The size of the items in the virtually scrolling list. */
  _itemSize;
  /** The minimum amount of buffer rendered beyond the viewport (in pixels). */
  _minBufferPx;
  /** The number of buffer items to render beyond the edge of the viewport (in pixels). */
  _maxBufferPx;
  /**
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  constructor(itemSize, minBufferPx, maxBufferPx) {
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
  }
  /**
   * Attaches this scroll strategy to a viewport.
   * @param viewport The viewport to attach this strategy to.
   */
  attach(viewport) {
    this._viewport = viewport;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** Detaches this scroll strategy from the currently attached viewport. */
  detach() {
    this._scrolledIndexChange.complete();
    this._viewport = null;
  }
  /**
   * Update the item size and buffer size.
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
    if (maxBufferPx < minBufferPx && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx");
    }
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentScrolled() {
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onDataLengthChanged() {
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentRendered() {
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onRenderedOffsetChanged() {
  }
  /**
   * Scroll to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling.
   */
  scrollToIndex(index, behavior) {
    if (this._viewport) {
      this._viewport.scrollToOffset(index * this._itemSize, behavior);
    }
  }
  /** Update the viewport's total content size. */
  _updateTotalContentSize() {
    if (!this._viewport) {
      return;
    }
    this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
  }
  /** Update the viewport's rendered range. */
  _updateRenderedRange() {
    if (!this._viewport) {
      return;
    }
    const renderedRange = this._viewport.getRenderedRange();
    const newRange = {
      start: renderedRange.start,
      end: renderedRange.end
    };
    const viewportSize = this._viewport.getViewportSize();
    const dataLength = this._viewport.getDataLength();
    let scrollOffset = this._viewport.measureScrollOffset();
    let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
    if (newRange.end > dataLength) {
      const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
      const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
      if (firstVisibleIndex != newVisibleIndex) {
        firstVisibleIndex = newVisibleIndex;
        scrollOffset = newVisibleIndex * this._itemSize;
        newRange.start = Math.floor(firstVisibleIndex);
      }
      newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
    }
    const startBuffer = scrollOffset - newRange.start * this._itemSize;
    if (startBuffer < this._minBufferPx && newRange.start != 0) {
      const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
      newRange.start = Math.max(0, newRange.start - expandStart);
      newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
    } else {
      const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
      if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
        const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
        if (expandEnd > 0) {
          newRange.end = Math.min(dataLength, newRange.end + expandEnd);
          newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
        }
      }
    }
    this._viewport.setRenderedRange(newRange);
    this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);
    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
  }
};
function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
  return fixedSizeDir._scrollStrategy;
}
var CdkFixedSizeVirtualScroll = class _CdkFixedSizeVirtualScroll {
  /** The size of the items in the list (in pixels). */
  get itemSize() {
    return this._itemSize;
  }
  set itemSize(value) {
    this._itemSize = coerceNumberProperty(value);
  }
  _itemSize = 20;
  /**
   * The minimum amount of buffer rendered beyond the viewport (in pixels).
   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
   */
  get minBufferPx() {
    return this._minBufferPx;
  }
  set minBufferPx(value) {
    this._minBufferPx = coerceNumberProperty(value);
  }
  _minBufferPx = 100;
  /**
   * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
   */
  get maxBufferPx() {
    return this._maxBufferPx;
  }
  set maxBufferPx(value) {
    this._maxBufferPx = coerceNumberProperty(value);
  }
  _maxBufferPx = 200;
  /** The scroll strategy used by this directive. */
  _scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
  ngOnChanges() {
    this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
  }
  static ɵfac = function CdkFixedSizeVirtualScroll_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFixedSizeVirtualScroll)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkFixedSizeVirtualScroll,
    selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
    inputs: {
      itemSize: "itemSize",
      minBufferPx: "minBufferPx",
      maxBufferPx: "maxBufferPx"
    },
    features: [ɵɵProvidersFeature([{
      provide: VIRTUAL_SCROLL_STRATEGY,
      useFactory: _fixedSizeVirtualScrollStrategyFactory,
      deps: [forwardRef(() => _CdkFixedSizeVirtualScroll)]
    }]), ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFixedSizeVirtualScroll, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[itemSize]",
      providers: [{
        provide: VIRTUAL_SCROLL_STRATEGY,
        useFactory: _fixedSizeVirtualScrollStrategyFactory,
        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]
      }]
    }]
  }], null, {
    itemSize: [{
      type: Input
    }],
    minBufferPx: [{
      type: Input
    }],
    maxBufferPx: [{
      type: Input
    }]
  });
})();
var DEFAULT_SCROLL_TIME = 20;
var ScrollDispatcher = class _ScrollDispatcher {
  _ngZone = inject(NgZone);
  _platform = inject(Platform);
  /** Used to reference correct document/window */
  _document = inject(DOCUMENT, {
    optional: true
  });
  constructor() {
  }
  /** Subject for notifying that a registered scrollable reference element has been scrolled. */
  _scrolled = new Subject();
  /** Keeps track of the global `scroll` and `resize` subscriptions. */
  _globalSubscription = null;
  /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */
  _scrolledCount = 0;
  /**
   * Map of all the scrollable references that are registered with the service and their
   * scroll event subscriptions.
   */
  scrollContainers = /* @__PURE__ */ new Map();
  /**
   * Registers a scrollable instance with the service and listens for its scrolled events. When the
   * scrollable is scrolled, the service emits the event to its scrolled observable.
   * @param scrollable Scrollable instance to be registered.
   */
  register(scrollable) {
    if (!this.scrollContainers.has(scrollable)) {
      this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
    }
  }
  /**
   * De-registers a Scrollable reference and unsubscribes from its scroll event observable.
   * @param scrollable Scrollable instance to be deregistered.
   */
  deregister(scrollable) {
    const scrollableReference = this.scrollContainers.get(scrollable);
    if (scrollableReference) {
      scrollableReference.unsubscribe();
      this.scrollContainers.delete(scrollable);
    }
  }
  /**
   * Returns an observable that emits an event whenever any of the registered Scrollable
   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
   * to override the default "throttle" time.
   *
   * **Note:** in order to avoid hitting change detection for every scroll event,
   * all of the events emitted from this stream will be run outside the Angular zone.
   * If you need to update any data bindings as a result of a scroll event, you have
   * to run the callback using `NgZone.run`.
   */
  scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
    if (!this._platform.isBrowser) {
      return of();
    }
    return new Observable((observer) => {
      if (!this._globalSubscription) {
        this._addGlobalListener();
      }
      const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
      this._scrolledCount++;
      return () => {
        subscription.unsubscribe();
        this._scrolledCount--;
        if (!this._scrolledCount) {
          this._removeGlobalListener();
        }
      };
    });
  }
  ngOnDestroy() {
    this._removeGlobalListener();
    this.scrollContainers.forEach((_, container) => this.deregister(container));
    this._scrolled.complete();
  }
  /**
   * Returns an observable that emits whenever any of the
   * scrollable ancestors of an element are scrolled.
   * @param elementOrElementRef Element whose ancestors to listen for.
   * @param auditTimeInMs Time to throttle the scroll events.
   */
  ancestorScrolled(elementOrElementRef, auditTimeInMs) {
    const ancestors = this.getAncestorScrollContainers(elementOrElementRef);
    return this.scrolled(auditTimeInMs).pipe(filter((target) => {
      return !target || ancestors.indexOf(target) > -1;
    }));
  }
  /** Returns all registered Scrollables that contain the provided element. */
  getAncestorScrollContainers(elementOrElementRef) {
    const scrollingContainers = [];
    this.scrollContainers.forEach((_subscription, scrollable) => {
      if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {
        scrollingContainers.push(scrollable);
      }
    });
    return scrollingContainers;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /** Returns true if the element is contained within the provided Scrollable. */
  _scrollableContainsElement(scrollable, elementOrElementRef) {
    let element = coerceElement(elementOrElementRef);
    let scrollableElement = scrollable.getElementRef().nativeElement;
    do {
      if (element == scrollableElement) {
        return true;
      }
    } while (element = element.parentElement);
    return false;
  }
  /** Sets up the global scroll listeners. */
  _addGlobalListener() {
    this._globalSubscription = this._ngZone.runOutsideAngular(() => {
      const window2 = this._getWindow();
      return fromEvent(window2.document, "scroll").subscribe(() => this._scrolled.next());
    });
  }
  /** Cleans up the global scroll listener. */
  _removeGlobalListener() {
    if (this._globalSubscription) {
      this._globalSubscription.unsubscribe();
      this._globalSubscription = null;
    }
  }
  static ɵfac = function ScrollDispatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollDispatcher)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollDispatcher,
    factory: _ScrollDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkScrollable = class _CdkScrollable {
  elementRef = inject(ElementRef);
  scrollDispatcher = inject(ScrollDispatcher);
  ngZone = inject(NgZone);
  dir = inject(Directionality, {
    optional: true
  });
  _destroyed = new Subject();
  _elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, "scroll").pipe(takeUntil(this._destroyed)).subscribe(observer)));
  constructor() {
  }
  ngOnInit() {
    this.scrollDispatcher.register(this);
  }
  ngOnDestroy() {
    this.scrollDispatcher.deregister(this);
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Returns observable that emits when a scroll event is fired on the host element. */
  elementScrolled() {
    return this._elementScrolled;
  }
  /** Gets the ElementRef for the viewport. */
  getElementRef() {
    return this.elementRef;
  }
  /**
   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param options specified the offsets to scroll to.
   */
  scrollTo(options) {
    const el = this.elementRef.nativeElement;
    const isRtl = this.dir && this.dir.value == "rtl";
    if (options.left == null) {
      options.left = isRtl ? options.end : options.start;
    }
    if (options.right == null) {
      options.right = isRtl ? options.start : options.end;
    }
    if (options.bottom != null) {
      options.top = el.scrollHeight - el.clientHeight - options.bottom;
    }
    if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {
      if (options.left != null) {
        options.right = el.scrollWidth - el.clientWidth - options.left;
      }
      if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
        options.left = options.right;
      } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
        options.left = options.right ? -options.right : options.right;
      }
    } else {
      if (options.right != null) {
        options.left = el.scrollWidth - el.clientWidth - options.right;
      }
    }
    this._applyScrollToOptions(options);
  }
  _applyScrollToOptions(options) {
    const el = this.elementRef.nativeElement;
    if (supportsScrollBehavior()) {
      el.scrollTo(options);
    } else {
      if (options.top != null) {
        el.scrollTop = options.top;
      }
      if (options.left != null) {
        el.scrollLeft = options.left;
      }
    }
  }
  /**
   * Measures the scroll offset relative to the specified edge of the viewport. This method can be
   * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
   * about what scrollLeft means in RTL. The values returned by this method are normalized such that
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param from The edge to measure from.
   */
  measureScrollOffset(from2) {
    const LEFT = "left";
    const RIGHT = "right";
    const el = this.elementRef.nativeElement;
    if (from2 == "top") {
      return el.scrollTop;
    }
    if (from2 == "bottom") {
      return el.scrollHeight - el.clientHeight - el.scrollTop;
    }
    const isRtl = this.dir && this.dir.value == "rtl";
    if (from2 == "start") {
      from2 = isRtl ? RIGHT : LEFT;
    } else if (from2 == "end") {
      from2 = isRtl ? LEFT : RIGHT;
    }
    if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
      if (from2 == LEFT) {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      } else {
        return el.scrollLeft;
      }
    } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
      if (from2 == LEFT) {
        return el.scrollLeft + el.scrollWidth - el.clientWidth;
      } else {
        return -el.scrollLeft;
      }
    } else {
      if (from2 == LEFT) {
        return el.scrollLeft;
      } else {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      }
    }
  }
  static ɵfac = function CdkScrollable_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkScrollable)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkScrollable,
    selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollable, [{
    type: Directive,
    args: [{
      selector: "[cdk-scrollable], [cdkScrollable]"
    }]
  }], () => [], null);
})();
var DEFAULT_RESIZE_TIME = 20;
var ViewportRuler = class _ViewportRuler {
  _platform = inject(Platform);
  _listeners;
  /** Cached viewport dimensions. */
  _viewportSize;
  /** Stream of viewport change events. */
  _change = new Subject();
  /** Used to reference correct document/window */
  _document = inject(DOCUMENT, {
    optional: true
  });
  constructor() {
    const ngZone = inject(NgZone);
    const renderer = inject(RendererFactory2).createRenderer(null, null);
    ngZone.runOutsideAngular(() => {
      if (this._platform.isBrowser) {
        const changeListener = (event) => this._change.next(event);
        this._listeners = [renderer.listen("window", "resize", changeListener), renderer.listen("window", "orientationchange", changeListener)];
      }
      this.change().subscribe(() => this._viewportSize = null);
    });
  }
  ngOnDestroy() {
    this._listeners?.forEach((cleanup) => cleanup());
    this._change.complete();
  }
  /** Returns the viewport's width and height. */
  getViewportSize() {
    if (!this._viewportSize) {
      this._updateViewportSize();
    }
    const output = {
      width: this._viewportSize.width,
      height: this._viewportSize.height
    };
    if (!this._platform.isBrowser) {
      this._viewportSize = null;
    }
    return output;
  }
  /** Gets a DOMRect for the viewport's bounds. */
  getViewportRect() {
    const scrollPosition = this.getViewportScrollPosition();
    const {
      width,
      height
    } = this.getViewportSize();
    return {
      top: scrollPosition.top,
      left: scrollPosition.left,
      bottom: scrollPosition.top + height,
      right: scrollPosition.left + width,
      height,
      width
    };
  }
  /** Gets the (top, left) scroll position of the viewport. */
  getViewportScrollPosition() {
    if (!this._platform.isBrowser) {
      return {
        top: 0,
        left: 0
      };
    }
    const document2 = this._document;
    const window2 = this._getWindow();
    const documentElement = document2.documentElement;
    const documentRect = documentElement.getBoundingClientRect();
    const top = -documentRect.top || document2.body.scrollTop || window2.scrollY || documentElement.scrollTop || 0;
    const left = -documentRect.left || document2.body.scrollLeft || window2.scrollX || documentElement.scrollLeft || 0;
    return {
      top,
      left
    };
  }
  /**
   * Returns a stream that emits whenever the size of the viewport changes.
   * This stream emits outside of the Angular zone.
   * @param throttleTime Time in milliseconds to throttle the stream.
   */
  change(throttleTime = DEFAULT_RESIZE_TIME) {
    return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /** Updates the cached viewport size. */
  _updateViewportSize() {
    const window2 = this._getWindow();
    this._viewportSize = this._platform.isBrowser ? {
      width: window2.innerWidth,
      height: window2.innerHeight
    } : {
      width: 0,
      height: 0
    };
  }
  static ɵfac = function ViewportRuler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ViewportRuler)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ViewportRuler,
    factory: _ViewportRuler.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewportRuler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var VIRTUAL_SCROLLABLE = new InjectionToken("VIRTUAL_SCROLLABLE");
var CdkVirtualScrollable = class _CdkVirtualScrollable extends CdkScrollable {
  constructor() {
    super();
  }
  /**
   * Measure the viewport size for the provided orientation.
   *
   * @param orientation The orientation to measure the size from.
   */
  measureViewportSize(orientation) {
    const viewportEl = this.elementRef.nativeElement;
    return orientation === "horizontal" ? viewportEl.clientWidth : viewportEl.clientHeight;
  }
  static ɵfac = function CdkVirtualScrollable_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollable)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualScrollable,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollable, [{
    type: Directive
  }], () => [], null);
})();
function rangesEqual(r1, r2) {
  return r1.start == r2.start && r1.end == r2.end;
}
var SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
var CdkVirtualScrollViewport = class _CdkVirtualScrollViewport extends CdkVirtualScrollable {
  elementRef = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _scrollStrategy = inject(VIRTUAL_SCROLL_STRATEGY, {
    optional: true
  });
  scrollable = inject(VIRTUAL_SCROLLABLE, {
    optional: true
  });
  _platform = inject(Platform);
  /** Emits when the viewport is detached from a CdkVirtualForOf. */
  _detachedSubject = new Subject();
  /** Emits when the rendered range changes. */
  _renderedRangeSubject = new Subject();
  /** The direction the viewport scrolls. */
  get orientation() {
    return this._orientation;
  }
  set orientation(orientation) {
    if (this._orientation !== orientation) {
      this._orientation = orientation;
      this._calculateSpacerSize();
    }
  }
  _orientation = "vertical";
  /**
   * Whether rendered items should persist in the DOM after scrolling out of view. By default, items
   * will be removed.
   */
  appendOnly = false;
  // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll
  // strategy lazily (i.e. only if the user is actually listening to the events). We do this because
  // depending on how the strategy calculates the scrolled index, it may come at a cost to
  // performance.
  /** Emits when the index of the first element visible in the viewport changes. */
  scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe((index) => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));
  /** The element that wraps the rendered content. */
  _contentWrapper;
  /** A stream that emits whenever the rendered range changes. */
  renderedRangeStream = this._renderedRangeSubject;
  /**
   * The total size of all content (in pixels), including content that is not currently rendered.
   */
  _totalContentSize = 0;
  /** A string representing the `style.width` property value to be used for the spacer element. */
  _totalContentWidth = "";
  /** A string representing the `style.height` property value to be used for the spacer element. */
  _totalContentHeight = "";
  /**
   * The CSS transform applied to the rendered subset of items so that they appear within the bounds
   * of the visible viewport.
   */
  _renderedContentTransform;
  /** The currently rendered range of indices. */
  _renderedRange = {
    start: 0,
    end: 0
  };
  /** The length of the data bound to this viewport (in number of items). */
  _dataLength = 0;
  /** The size of the viewport (in pixels). */
  _viewportSize = 0;
  /** the currently attached CdkVirtualScrollRepeater. */
  _forOf;
  /** The last rendered content offset that was set. */
  _renderedContentOffset = 0;
  /**
   * Whether the last rendered content offset was to the end of the content (and therefore needs to
   * be rewritten as an offset to the start of the content).
   */
  _renderedContentOffsetNeedsRewrite = false;
  /** Whether there is a pending change detection cycle. */
  _isChangeDetectionPending = false;
  /** A list of functions to run after the next change detection cycle. */
  _runAfterChangeDetection = [];
  /** Subscription to changes in the viewport size. */
  _viewportChanges = Subscription.EMPTY;
  _injector = inject(Injector);
  _isDestroyed = false;
  constructor() {
    super();
    const viewportRuler = inject(ViewportRuler);
    if (!this._scrollStrategy && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
    }
    this._viewportChanges = viewportRuler.change().subscribe(() => {
      this.checkViewportSize();
    });
    if (!this.scrollable) {
      this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable");
      this.scrollable = this;
    }
  }
  ngOnInit() {
    if (!this._platform.isBrowser) {
      return;
    }
    if (this.scrollable === this) {
      super.ngOnInit();
    }
    this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
      this._measureViewportSize();
      this._scrollStrategy.attach(this);
      this.scrollable.elementScrolled().pipe(
        // Start off with a fake scroll event so we properly detect our initial position.
        startWith(null),
        // Collect multiple events into one until the next animation frame. This way if
        // there are multiple scroll events in the same frame we only need to recheck
        // our layout once.
        auditTime(0, SCROLL_SCHEDULER),
        // Usually `elementScrolled` is completed when the scrollable is destroyed, but
        // that may not be the case if a `CdkVirtualScrollableElement` is used so we have
        // to unsubscribe here just in case.
        takeUntil(this._destroyed)
      ).subscribe(() => this._scrollStrategy.onContentScrolled());
      this._markChangeDetectionNeeded();
    }));
  }
  ngOnDestroy() {
    this.detach();
    this._scrollStrategy.detach();
    this._renderedRangeSubject.complete();
    this._detachedSubject.complete();
    this._viewportChanges.unsubscribe();
    this._isDestroyed = true;
    super.ngOnDestroy();
  }
  /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */
  attach(forOf) {
    if (this._forOf && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CdkVirtualScrollViewport is already attached.");
    }
    this.ngZone.runOutsideAngular(() => {
      this._forOf = forOf;
      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((data) => {
        const newLength = data.length;
        if (newLength !== this._dataLength) {
          this._dataLength = newLength;
          this._scrollStrategy.onDataLengthChanged();
        }
        this._doChangeDetection();
      });
    });
  }
  /** Detaches the current `CdkVirtualForOf`. */
  detach() {
    this._forOf = null;
    this._detachedSubject.next();
  }
  /** Gets the length of the data bound to this viewport (in number of items). */
  getDataLength() {
    return this._dataLength;
  }
  /** Gets the size of the viewport (in pixels). */
  getViewportSize() {
    return this._viewportSize;
  }
  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
  // cycle happens. I'm being careful to only call it after the render cycle is complete and before
  // setting it to something else, but its error prone and should probably be split into
  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
  /** Get the current rendered range of items. */
  getRenderedRange() {
    return this._renderedRange;
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
  }
  /**
   * Sets the total size of all content (in pixels), including content that is not currently
   * rendered.
   */
  setTotalContentSize(size) {
    if (this._totalContentSize !== size) {
      this._totalContentSize = size;
      this._calculateSpacerSize();
      this._markChangeDetectionNeeded();
    }
  }
  /** Sets the currently rendered range of indices. */
  setRenderedRange(range) {
    if (!rangesEqual(this._renderedRange, range)) {
      if (this.appendOnly) {
        range = {
          start: 0,
          end: Math.max(this._renderedRange.end, range.end)
        };
      }
      this._renderedRangeSubject.next(this._renderedRange = range);
      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());
    }
  }
  /**
   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
   */
  getOffsetToRenderedContentStart() {
    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
  }
  /**
   * Sets the offset from the start of the viewport to either the start or end of the rendered data
   * (in pixels).
   */
  setRenderedContentOffset(offset, to = "to-start") {
    offset = this.appendOnly && to === "to-start" ? 0 : offset;
    const isRtl = this.dir && this.dir.value == "rtl";
    const isHorizontal = this.orientation == "horizontal";
    const axis = isHorizontal ? "X" : "Y";
    const axisDirection = isHorizontal && isRtl ? -1 : 1;
    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;
    this._renderedContentOffset = offset;
    if (to === "to-end") {
      transform += ` translate${axis}(-100%)`;
      this._renderedContentOffsetNeedsRewrite = true;
    }
    if (this._renderedContentTransform != transform) {
      this._renderedContentTransform = transform;
      this._markChangeDetectionNeeded(() => {
        if (this._renderedContentOffsetNeedsRewrite) {
          this._renderedContentOffset -= this.measureRenderedContentSize();
          this._renderedContentOffsetNeedsRewrite = false;
          this.setRenderedContentOffset(this._renderedContentOffset);
        } else {
          this._scrollStrategy.onRenderedOffsetChanged();
        }
      });
    }
  }
  /**
   * Scrolls to the given offset from the start of the viewport. Please note that this is not always
   * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
   * direction, this would be the equivalent of setting a fictional `scrollRight` property.
   * @param offset The offset to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToOffset(offset, behavior = "auto") {
    const options = {
      behavior
    };
    if (this.orientation === "horizontal") {
      options.start = offset;
    } else {
      options.top = offset;
    }
    this.scrollable.scrollTo(options);
  }
  /**
   * Scrolls to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToIndex(index, behavior = "auto") {
    this._scrollStrategy.scrollToIndex(index, behavior);
  }
  /**
   * Gets the current scroll offset from the start of the scrollable (in pixels).
   * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
   *     in horizontal mode.
   */
  measureScrollOffset(from2) {
    let measureScrollOffset;
    if (this.scrollable == this) {
      measureScrollOffset = (_from) => super.measureScrollOffset(_from);
    } else {
      measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);
    }
    return Math.max(0, measureScrollOffset(from2 ?? (this.orientation === "horizontal" ? "start" : "top")) - this.measureViewportOffset());
  }
  /**
   * Measures the offset of the viewport from the scrolling container
   * @param from The edge to measure from.
   */
  measureViewportOffset(from2) {
    let fromRect;
    const LEFT = "left";
    const RIGHT = "right";
    const isRtl = this.dir?.value == "rtl";
    if (from2 == "start") {
      fromRect = isRtl ? RIGHT : LEFT;
    } else if (from2 == "end") {
      fromRect = isRtl ? LEFT : RIGHT;
    } else if (from2) {
      fromRect = from2;
    } else {
      fromRect = this.orientation === "horizontal" ? "left" : "top";
    }
    const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);
    const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];
    return viewportClientRect - scrollerClientRect;
  }
  /** Measure the combined size of all of the rendered items. */
  measureRenderedContentSize() {
    const contentEl = this._contentWrapper.nativeElement;
    return this.orientation === "horizontal" ? contentEl.offsetWidth : contentEl.offsetHeight;
  }
  /**
   * Measure the total combined size of the given range. Throws if the range includes items that are
   * not rendered.
   */
  measureRangeSize(range) {
    if (!this._forOf) {
      return 0;
    }
    return this._forOf.measureRangeSize(range, this.orientation);
  }
  /** Update the viewport dimensions and re-render. */
  checkViewportSize() {
    this._measureViewportSize();
    this._scrollStrategy.onDataLengthChanged();
  }
  /** Measure the viewport size. */
  _measureViewportSize() {
    this._viewportSize = this.scrollable.measureViewportSize(this.orientation);
  }
  /** Queue up change detection to run. */
  _markChangeDetectionNeeded(runAfter) {
    if (runAfter) {
      this._runAfterChangeDetection.push(runAfter);
    }
    if (!this._isChangeDetectionPending) {
      this._isChangeDetectionPending = true;
      this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
        this._doChangeDetection();
      }));
    }
  }
  /** Run change detection. */
  _doChangeDetection() {
    if (this._isDestroyed) {
      return;
    }
    this.ngZone.run(() => {
      this._changeDetectorRef.markForCheck();
      this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
      afterNextRender(() => {
        this._isChangeDetectionPending = false;
        const runAfterChangeDetection = this._runAfterChangeDetection;
        this._runAfterChangeDetection = [];
        for (const fn of runAfterChangeDetection) {
          fn();
        }
      }, {
        injector: this._injector
      });
    });
  }
  /** Calculates the `style.width` and `style.height` for the spacer element. */
  _calculateSpacerSize() {
    this._totalContentHeight = this.orientation === "horizontal" ? "" : `${this._totalContentSize}px`;
    this._totalContentWidth = this.orientation === "horizontal" ? `${this._totalContentSize}px` : "";
  }
  static ɵfac = function CdkVirtualScrollViewport_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollViewport)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CdkVirtualScrollViewport,
    selectors: [["cdk-virtual-scroll-viewport"]],
    viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentWrapper = _t.first);
      }
    },
    hostAttrs: [1, "cdk-virtual-scroll-viewport"],
    hostVars: 4,
    hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
      }
    },
    inputs: {
      orientation: "orientation",
      appendOnly: [2, "appendOnly", "appendOnly", booleanAttribute]
    },
    outputs: {
      scrolledIndexChange: "scrolledIndexChange"
    },
    features: [ɵɵProvidersFeature([{
      provide: CdkScrollable,
      useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
      deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], _CdkVirtualScrollViewport]
    }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c1,
    decls: 4,
    vars: 4,
    consts: [["contentWrapper", ""], [1, "cdk-virtual-scroll-content-wrapper"], [1, "cdk-virtual-scroll-spacer"]],
    template: function CdkVirtualScrollViewport_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 1, 0);
        ɵɵprojection(2);
        ɵɵelementEnd();
        ɵɵelement(3, "div", 2);
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵstyleProp("width", ctx._totalContentWidth)("height", ctx._totalContentHeight);
      }
    },
    styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollViewport, [{
    type: Component,
    args: [{
      selector: "cdk-virtual-scroll-viewport",
      host: {
        "class": "cdk-virtual-scroll-viewport",
        "[class.cdk-virtual-scroll-orientation-horizontal]": 'orientation === "horizontal"',
        "[class.cdk-virtual-scroll-orientation-vertical]": 'orientation !== "horizontal"'
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: CdkScrollable,
        useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
        deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]
      }],
      template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth" [style.height]="_totalContentHeight"></div>\n',
      styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"]
    }]
  }], () => [], {
    orientation: [{
      type: Input
    }],
    appendOnly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    scrolledIndexChange: [{
      type: Output
    }],
    _contentWrapper: [{
      type: ViewChild,
      args: ["contentWrapper", {
        static: true
      }]
    }]
  });
})();
function getOffset(orientation, direction, node) {
  const el = node;
  if (!el.getBoundingClientRect) {
    return 0;
  }
  const rect = el.getBoundingClientRect();
  if (orientation === "horizontal") {
    return direction === "start" ? rect.left : rect.right;
  }
  return direction === "start" ? rect.top : rect.bottom;
}
var CdkVirtualForOf = class _CdkVirtualForOf {
  _viewContainerRef = inject(ViewContainerRef);
  _template = inject(TemplateRef);
  _differs = inject(IterableDiffers);
  _viewRepeater = inject(_VIEW_REPEATER_STRATEGY);
  _viewport = inject(CdkVirtualScrollViewport, {
    skipSelf: true
  });
  /** Emits when the rendered view of the data changes. */
  viewChange = new Subject();
  /** Subject that emits when a new DataSource instance is given. */
  _dataSourceChanges = new Subject();
  /** The DataSource to display. */
  get cdkVirtualForOf() {
    return this._cdkVirtualForOf;
  }
  set cdkVirtualForOf(value) {
    this._cdkVirtualForOf = value;
    if (isDataSource(value)) {
      this._dataSourceChanges.next(value);
    } else {
      this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));
    }
  }
  _cdkVirtualForOf;
  /**
   * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
   * the item and produces a value to be used as the item's identity when tracking changes.
   */
  get cdkVirtualForTrackBy() {
    return this._cdkVirtualForTrackBy;
  }
  set cdkVirtualForTrackBy(fn) {
    this._needsUpdate = true;
    this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : void 0;
  }
  _cdkVirtualForTrackBy;
  /** The template used to stamp out new elements. */
  set cdkVirtualForTemplate(value) {
    if (value) {
      this._needsUpdate = true;
      this._template = value;
    }
  }
  /**
   * The size of the cache used to store templates that are not being used for re-use later.
   * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
   */
  get cdkVirtualForTemplateCacheSize() {
    return this._viewRepeater.viewCacheSize;
  }
  set cdkVirtualForTemplateCacheSize(size) {
    this._viewRepeater.viewCacheSize = coerceNumberProperty(size);
  }
  /** Emits whenever the data in the current DataSource changes. */
  dataStream = this._dataSourceChanges.pipe(
    // Start off with null `DataSource`.
    startWith(null),
    // Bundle up the previous and current data sources so we can work with both.
    pairwise(),
    // Use `_changeDataSource` to disconnect from the previous data source and connect to the
    // new one, passing back a stream of data changes which we run through `switchMap` to give
    // us a data stream that emits the latest data from whatever the current `DataSource` is.
    switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),
    // Replay the last emitted data when someone subscribes.
    shareReplay(1)
  );
  /** The differ used to calculate changes to the data. */
  _differ = null;
  /** The most recent data emitted from the DataSource. */
  _data;
  /** The currently rendered items. */
  _renderedItems;
  /** The currently rendered range of indices. */
  _renderedRange;
  /** Whether the rendered data should be updated during the next ngDoCheck cycle. */
  _needsUpdate = false;
  _destroyed = new Subject();
  constructor() {
    const ngZone = inject(NgZone);
    this.dataStream.subscribe((data) => {
      this._data = data;
      this._onRenderedDataChange();
    });
    this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((range) => {
      this._renderedRange = range;
      if (this.viewChange.observers.length) {
        ngZone.run(() => this.viewChange.next(this._renderedRange));
      }
      this._onRenderedDataChange();
    });
    this._viewport.attach(this);
  }
  /**
   * Measures the combined size (width for horizontal orientation, height for vertical) of all items
   * in the specified range. Throws an error if the range includes items that are not currently
   * rendered.
   */
  measureRangeSize(range, orientation) {
    if (range.start >= range.end) {
      return 0;
    }
    if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Error: attempted to measure an item that isn't rendered.`);
    }
    const renderedStartIndex = range.start - this._renderedRange.start;
    const rangeLen = range.end - range.start;
    let firstNode;
    let lastNode;
    for (let i = 0; i < rangeLen; i++) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        firstNode = lastNode = view.rootNodes[0];
        break;
      }
    }
    for (let i = rangeLen - 1; i > -1; i--) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        lastNode = view.rootNodes[view.rootNodes.length - 1];
        break;
      }
    }
    return firstNode && lastNode ? getOffset(orientation, "end", lastNode) - getOffset(orientation, "start", firstNode) : 0;
  }
  ngDoCheck() {
    if (this._differ && this._needsUpdate) {
      const changes = this._differ.diff(this._renderedItems);
      if (!changes) {
        this._updateContext();
      } else {
        this._applyChanges(changes);
      }
      this._needsUpdate = false;
    }
  }
  ngOnDestroy() {
    this._viewport.detach();
    this._dataSourceChanges.next(void 0);
    this._dataSourceChanges.complete();
    this.viewChange.complete();
    this._destroyed.next();
    this._destroyed.complete();
    this._viewRepeater.detach();
  }
  /** React to scroll state changes in the viewport. */
  _onRenderedDataChange() {
    if (!this._renderedRange) {
      return;
    }
    this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
    if (!this._differ) {
      this._differ = this._differs.find(this._renderedItems).create((index, item) => {
        return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;
      });
    }
    this._needsUpdate = true;
  }
  /** Swap out one `DataSource` for another. */
  _changeDataSource(oldDs, newDs) {
    if (oldDs) {
      oldDs.disconnect(this);
    }
    this._needsUpdate = true;
    return newDs ? newDs.connect(this) : of();
  }
  /** Update the `CdkVirtualForOfContext` for all views. */
  _updateContext() {
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
      view.detectChanges();
    }
  }
  /** Apply changes to the DOM. */
  _applyChanges(changes) {
    this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);
    changes.forEachIdentityChange((record) => {
      const view = this._viewContainerRef.get(record.currentIndex);
      view.context.$implicit = record.item;
    });
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
    }
  }
  /** Update the computed properties on the `CdkVirtualForOfContext`. */
  _updateComputedContextProperties(context) {
    context.first = context.index === 0;
    context.last = context.index === context.count - 1;
    context.even = context.index % 2 === 0;
    context.odd = !context.even;
  }
  _getEmbeddedViewArgs(record, index) {
    return {
      templateRef: this._template,
      context: {
        $implicit: record.item,
        // It's guaranteed that the iterable is not "undefined" or "null" because we only
        // generate views for elements if the "cdkVirtualForOf" iterable has elements.
        cdkVirtualForOf: this._cdkVirtualForOf,
        index: -1,
        count: -1,
        first: false,
        last: false,
        odd: false,
        even: false
      },
      index
    };
  }
  static ngTemplateContextGuard(directive, context) {
    return true;
  }
  static ɵfac = function CdkVirtualForOf_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualForOf)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualForOf,
    selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
    inputs: {
      cdkVirtualForOf: "cdkVirtualForOf",
      cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
      cdkVirtualForTemplate: "cdkVirtualForTemplate",
      cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
    },
    features: [ɵɵProvidersFeature([{
      provide: _VIEW_REPEATER_STRATEGY,
      useClass: _RecycleViewRepeaterStrategy
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualForOf, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualFor][cdkVirtualForOf]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }]
    }]
  }], () => [], {
    cdkVirtualForOf: [{
      type: Input
    }],
    cdkVirtualForTrackBy: [{
      type: Input
    }],
    cdkVirtualForTemplate: [{
      type: Input
    }],
    cdkVirtualForTemplateCacheSize: [{
      type: Input
    }]
  });
})();
var CdkVirtualScrollableElement = class _CdkVirtualScrollableElement extends CdkVirtualScrollable {
  constructor() {
    super();
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2] - this.measureScrollOffset(from2);
  }
  static ɵfac = function CdkVirtualScrollableElement_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollableElement)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualScrollableElement,
    selectors: [["", "cdkVirtualScrollingElement", ""]],
    hostAttrs: [1, "cdk-virtual-scrollable"],
    features: [ɵɵProvidersFeature([{
      provide: VIRTUAL_SCROLLABLE,
      useExisting: _CdkVirtualScrollableElement
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableElement, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualScrollingElement]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableElement
      }],
      host: {
        "class": "cdk-virtual-scrollable"
      }
    }]
  }], () => [], null);
})();
var CdkVirtualScrollableWindow = class _CdkVirtualScrollableWindow extends CdkVirtualScrollable {
  _elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(document, "scroll").pipe(takeUntil(this._destroyed)).subscribe(observer)));
  constructor() {
    super();
    this.elementRef = new ElementRef(document.documentElement);
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
  }
  static ɵfac = function CdkVirtualScrollableWindow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollableWindow)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualScrollableWindow,
    selectors: [["cdk-virtual-scroll-viewport", "scrollWindow", ""]],
    features: [ɵɵProvidersFeature([{
      provide: VIRTUAL_SCROLLABLE,
      useExisting: _CdkVirtualScrollableWindow
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableWindow, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[scrollWindow]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableWindow
      }]
    }]
  }], () => [], null);
})();
var CdkScrollableModule = class _CdkScrollableModule {
  static ɵfac = function CdkScrollableModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkScrollableModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CdkScrollableModule,
    imports: [CdkScrollable],
    exports: [CdkScrollable]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollableModule, [{
    type: NgModule,
    args: [{
      exports: [CdkScrollable],
      imports: [CdkScrollable]
    }]
  }], null, null);
})();
var ScrollingModule = class _ScrollingModule {
  static ɵfac = function ScrollingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollingModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ScrollingModule,
    imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
    exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [BidiModule, CdkScrollableModule, BidiModule, CdkScrollableModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
      exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/portal.mjs
function throwNullPortalError() {
  throw Error("Must provide a portal to attach");
}
function throwPortalAlreadyAttachedError() {
  throw Error("Host already has a portal attached");
}
function throwPortalOutletAlreadyDisposedError() {
  throw Error("This PortalOutlet has already been disposed");
}
function throwUnknownPortalTypeError() {
  throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.");
}
function throwNullPortalOutletError() {
  throw Error("Attempting to attach a portal to a null PortalOutlet");
}
function throwNoPortalAttachedError() {
  throw Error("Attempting to detach a portal that is not attached to a host");
}
var Portal = class {
  _attachedHost;
  /** Attach this portal to a host. */
  attach(host) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (host == null) {
        throwNullPortalOutletError();
      }
      if (host.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
    }
    this._attachedHost = host;
    return host.attach(this);
  }
  /** Detach this portal from its host */
  detach() {
    let host = this._attachedHost;
    if (host != null) {
      this._attachedHost = null;
      host.detach();
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwNoPortalAttachedError();
    }
  }
  /** Whether this portal is attached to a host. */
  get isAttached() {
    return this._attachedHost != null;
  }
  /**
   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
   * the PortalOutlet when it is performing an `attach()` or `detach()`.
   */
  setAttachedHost(host) {
    this._attachedHost = host;
  }
};
var ComponentPortal = class extends Portal {
  /** The type of the component that will be instantiated for attachment. */
  component;
  /**
   * Where the attached component should live in Angular's *logical* component tree.
   * This is different from where the component *renders*, which is determined by the PortalOutlet.
   * The origin is necessary when the host is outside of the Angular application context.
   */
  viewContainerRef;
  /** Injector used for the instantiation of the component. */
  injector;
  /**
   * @deprecated No longer in use. To be removed.
   * @breaking-change 18.0.0
   */
  componentFactoryResolver;
  /**
   * List of DOM nodes that should be projected through `<ng-content>` of the attached component.
   */
  projectableNodes;
  constructor(component, viewContainerRef, injector, _componentFactoryResolver, projectableNodes) {
    super();
    this.component = component;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.projectableNodes = projectableNodes;
  }
};
var TemplatePortal = class extends Portal {
  templateRef;
  viewContainerRef;
  context;
  injector;
  constructor(templateRef, viewContainerRef, context, injector) {
    super();
    this.templateRef = templateRef;
    this.viewContainerRef = viewContainerRef;
    this.context = context;
    this.injector = injector;
  }
  get origin() {
    return this.templateRef.elementRef;
  }
  /**
   * Attach the portal to the provided `PortalOutlet`.
   * When a context is provided it will override the `context` property of the `TemplatePortal`
   * instance.
   */
  attach(host, context = this.context) {
    this.context = context;
    return super.attach(host);
  }
  detach() {
    this.context = void 0;
    return super.detach();
  }
};
var DomPortal = class extends Portal {
  /** DOM node hosting the portal's content. */
  element;
  constructor(element) {
    super();
    this.element = element instanceof ElementRef ? element.nativeElement : element;
  }
};
var BasePortalOutlet = class {
  /** The portal currently attached to the host. */
  _attachedPortal;
  /** A function that will permanently dispose this host. */
  _disposeFn;
  /** Whether this host has already been permanently disposed. */
  _isDisposed = false;
  /** Whether this host has an attached portal. */
  hasAttached() {
    return !!this._attachedPortal;
  }
  /** Attaches a portal. */
  attach(portal) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!portal) {
        throwNullPortalError();
      }
      if (this.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
      if (this._isDisposed) {
        throwPortalOutletAlreadyDisposedError();
      }
    }
    if (portal instanceof ComponentPortal) {
      this._attachedPortal = portal;
      return this.attachComponentPortal(portal);
    } else if (portal instanceof TemplatePortal) {
      this._attachedPortal = portal;
      return this.attachTemplatePortal(portal);
    } else if (this.attachDomPortal && portal instanceof DomPortal) {
      this._attachedPortal = portal;
      return this.attachDomPortal(portal);
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwUnknownPortalTypeError();
    }
  }
  // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.
  attachDomPortal = null;
  /** Detaches a previously attached portal. */
  detach() {
    if (this._attachedPortal) {
      this._attachedPortal.setAttachedHost(null);
      this._attachedPortal = null;
    }
    this._invokeDisposeFn();
  }
  /** Permanently dispose of this portal host. */
  dispose() {
    if (this.hasAttached()) {
      this.detach();
    }
    this._invokeDisposeFn();
    this._isDisposed = true;
  }
  /** @docs-private */
  setDisposeFn(fn) {
    this._disposeFn = fn;
  }
  _invokeDisposeFn() {
    if (this._disposeFn) {
      this._disposeFn();
      this._disposeFn = null;
    }
  }
};
var DomPortalOutlet = class extends BasePortalOutlet {
  outletElement;
  _appRef;
  _defaultInjector;
  _document;
  /**
   * @param outletElement Element into which the content is projected.
   * @param _unusedComponentFactoryResolver Used to resolve the component factory.
   *   Only required when attaching component portals.
   * @param _appRef Reference to the application. Only used in component portals when there
   *   is no `ViewContainerRef` available.
   * @param _defaultInjector Injector to use as a fallback when the portal being attached doesn't
   *   have one. Only used for component portals.
   * @param _document Reference to the document. Used when attaching a DOM portal. Will eventually
   *   become a required parameter.
   */
  constructor(outletElement, _unusedComponentFactoryResolver, _appRef, _defaultInjector, _document) {
    super();
    this.outletElement = outletElement;
    this._appRef = _appRef;
    this._defaultInjector = _defaultInjector;
    this._document = _document;
  }
  /**
   * Attach the given ComponentPortal to DOM element.
   * @param portal Portal to be attached
   * @returns Reference to the created component.
   */
  attachComponentPortal(portal) {
    let componentRef;
    if (portal.viewContainerRef) {
      const injector = portal.injector || portal.viewContainerRef.injector;
      const ngModuleRef = injector.get(NgModuleRef$1, null, {
        optional: true
      }) || void 0;
      componentRef = portal.viewContainerRef.createComponent(portal.component, {
        index: portal.viewContainerRef.length,
        injector,
        ngModuleRef,
        projectableNodes: portal.projectableNodes || void 0
      });
      this.setDisposeFn(() => componentRef.destroy());
    } else {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._appRef) {
        throw Error("Cannot attach component portal to outlet without an ApplicationRef.");
      }
      componentRef = createComponent(portal.component, {
        elementInjector: portal.injector || this._defaultInjector || Injector.NULL,
        environmentInjector: this._appRef.injector,
        projectableNodes: portal.projectableNodes || void 0
      });
      this._appRef.attachView(componentRef.hostView);
      this.setDisposeFn(() => {
        if (this._appRef.viewCount > 0) {
          this._appRef.detachView(componentRef.hostView);
        }
        componentRef.destroy();
      });
    }
    this.outletElement.appendChild(this._getComponentRootNode(componentRef));
    this._attachedPortal = portal;
    return componentRef;
  }
  /**
   * Attaches a template portal to the DOM as an embedded view.
   * @param portal Portal to be attached.
   * @returns Reference to the created embedded view.
   */
  attachTemplatePortal(portal) {
    let viewContainer = portal.viewContainerRef;
    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    viewRef.rootNodes.forEach((rootNode) => this.outletElement.appendChild(rootNode));
    viewRef.detectChanges();
    this.setDisposeFn(() => {
      let index = viewContainer.indexOf(viewRef);
      if (index !== -1) {
        viewContainer.remove(index);
      }
    });
    this._attachedPortal = portal;
    return viewRef;
  }
  /**
   * Attaches a DOM portal by transferring its content into the outlet.
   * @param portal Portal to be attached.
   * @deprecated To be turned into a method.
   * @breaking-change 10.0.0
   */
  attachDomPortal = (portal) => {
    const element = portal.element;
    if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("DOM portal content must be attached to a parent node.");
    }
    const anchorNode = this._document.createComment("dom-portal");
    element.parentNode.insertBefore(anchorNode, element);
    this.outletElement.appendChild(element);
    this._attachedPortal = portal;
    super.setDisposeFn(() => {
      if (anchorNode.parentNode) {
        anchorNode.parentNode.replaceChild(element, anchorNode);
      }
    });
  };
  /**
   * Clears out a portal from the DOM.
   */
  dispose() {
    super.dispose();
    this.outletElement.remove();
  }
  /** Gets the root HTMLElement for an instantiated component. */
  _getComponentRootNode(componentRef) {
    return componentRef.hostView.rootNodes[0];
  }
};
var CdkPortal = class _CdkPortal extends TemplatePortal {
  constructor() {
    const templateRef = inject(TemplateRef);
    const viewContainerRef = inject(ViewContainerRef);
    super(templateRef, viewContainerRef);
  }
  static ɵfac = function CdkPortal_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkPortal)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkPortal,
    selectors: [["", "cdkPortal", ""]],
    exportAs: ["cdkPortal"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortal, [{
    type: Directive,
    args: [{
      selector: "[cdkPortal]",
      exportAs: "cdkPortal"
    }]
  }], () => [], null);
})();
var TemplatePortalDirective = class _TemplatePortalDirective extends CdkPortal {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTemplatePortalDirective_BaseFactory;
    return function TemplatePortalDirective_Factory(__ngFactoryType__) {
      return (ɵTemplatePortalDirective_BaseFactory || (ɵTemplatePortalDirective_BaseFactory = ɵɵgetInheritedFactory(_TemplatePortalDirective)))(__ngFactoryType__ || _TemplatePortalDirective);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _TemplatePortalDirective,
    selectors: [["", "cdk-portal", ""], ["", "portal", ""]],
    exportAs: ["cdkPortal"],
    features: [ɵɵProvidersFeature([{
      provide: CdkPortal,
      useExisting: _TemplatePortalDirective
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplatePortalDirective, [{
    type: Directive,
    args: [{
      selector: "[cdk-portal], [portal]",
      exportAs: "cdkPortal",
      providers: [{
        provide: CdkPortal,
        useExisting: TemplatePortalDirective
      }]
    }]
  }], null, null);
})();
var CdkPortalOutlet = class _CdkPortalOutlet extends BasePortalOutlet {
  _moduleRef = inject(NgModuleRef$1, {
    optional: true
  });
  _document = inject(DOCUMENT);
  _viewContainerRef = inject(ViewContainerRef);
  /** Whether the portal component is initialized. */
  _isInitialized = false;
  /** Reference to the currently-attached component/view ref. */
  _attachedRef;
  constructor() {
    super();
  }
  /** Portal associated with the Portal outlet. */
  get portal() {
    return this._attachedPortal;
  }
  set portal(portal) {
    if (this.hasAttached() && !portal && !this._isInitialized) {
      return;
    }
    if (this.hasAttached()) {
      super.detach();
    }
    if (portal) {
      super.attach(portal);
    }
    this._attachedPortal = portal || null;
  }
  /** Emits when a portal is attached to the outlet. */
  attached = new EventEmitter();
  /** Component or view reference that is attached to the portal. */
  get attachedRef() {
    return this._attachedRef;
  }
  ngOnInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    super.dispose();
    this._attachedRef = this._attachedPortal = null;
  }
  /**
   * Attach the given ComponentPortal to this PortalOutlet.
   *
   * @param portal Portal to be attached to the portal outlet.
   * @returns Reference to the created component.
   */
  attachComponentPortal(portal) {
    portal.setAttachedHost(this);
    const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;
    const ref = viewContainerRef.createComponent(portal.component, {
      index: viewContainerRef.length,
      injector: portal.injector || viewContainerRef.injector,
      projectableNodes: portal.projectableNodes || void 0,
      ngModuleRef: this._moduleRef || void 0
    });
    if (viewContainerRef !== this._viewContainerRef) {
      this._getRootNode().appendChild(ref.hostView.rootNodes[0]);
    }
    super.setDisposeFn(() => ref.destroy());
    this._attachedPortal = portal;
    this._attachedRef = ref;
    this.attached.emit(ref);
    return ref;
  }
  /**
   * Attach the given TemplatePortal to this PortalHost as an embedded View.
   * @param portal Portal to be attached.
   * @returns Reference to the created embedded view.
   */
  attachTemplatePortal(portal) {
    portal.setAttachedHost(this);
    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    super.setDisposeFn(() => this._viewContainerRef.clear());
    this._attachedPortal = portal;
    this._attachedRef = viewRef;
    this.attached.emit(viewRef);
    return viewRef;
  }
  /**
   * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.
   * @param portal Portal to be attached.
   * @deprecated To be turned into a method.
   * @breaking-change 10.0.0
   */
  attachDomPortal = (portal) => {
    const element = portal.element;
    if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("DOM portal content must be attached to a parent node.");
    }
    const anchorNode = this._document.createComment("dom-portal");
    portal.setAttachedHost(this);
    element.parentNode.insertBefore(anchorNode, element);
    this._getRootNode().appendChild(element);
    this._attachedPortal = portal;
    super.setDisposeFn(() => {
      if (anchorNode.parentNode) {
        anchorNode.parentNode.replaceChild(element, anchorNode);
      }
    });
  };
  /** Gets the root node of the portal outlet. */
  _getRootNode() {
    const nativeElement = this._viewContainerRef.element.nativeElement;
    return nativeElement.nodeType === nativeElement.ELEMENT_NODE ? nativeElement : nativeElement.parentNode;
  }
  static ɵfac = function CdkPortalOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkPortalOutlet)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkPortalOutlet,
    selectors: [["", "cdkPortalOutlet", ""]],
    inputs: {
      portal: [0, "cdkPortalOutlet", "portal"]
    },
    outputs: {
      attached: "attached"
    },
    exportAs: ["cdkPortalOutlet"],
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortalOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkPortalOutlet]",
      exportAs: "cdkPortalOutlet"
    }]
  }], () => [], {
    portal: [{
      type: Input,
      args: ["cdkPortalOutlet"]
    }],
    attached: [{
      type: Output
    }]
  });
})();
var PortalHostDirective = class _PortalHostDirective extends CdkPortalOutlet {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPortalHostDirective_BaseFactory;
    return function PortalHostDirective_Factory(__ngFactoryType__) {
      return (ɵPortalHostDirective_BaseFactory || (ɵPortalHostDirective_BaseFactory = ɵɵgetInheritedFactory(_PortalHostDirective)))(__ngFactoryType__ || _PortalHostDirective);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _PortalHostDirective,
    selectors: [["", "cdkPortalHost", ""], ["", "portalHost", ""]],
    inputs: {
      portal: [0, "cdkPortalHost", "portal"]
    },
    exportAs: ["cdkPortalHost"],
    features: [ɵɵProvidersFeature([{
      provide: CdkPortalOutlet,
      useExisting: _PortalHostDirective
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PortalHostDirective, [{
    type: Directive,
    args: [{
      selector: "[cdkPortalHost], [portalHost]",
      exportAs: "cdkPortalHost",
      inputs: [{
        name: "portal",
        alias: "cdkPortalHost"
      }],
      providers: [{
        provide: CdkPortalOutlet,
        useExisting: PortalHostDirective
      }]
    }]
  }], null, null);
})();
var PortalModule = class _PortalModule {
  static ɵfac = function PortalModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PortalModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PortalModule,
    imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
    exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PortalModule, [{
    type: NgModule,
    args: [{
      imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
      exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/overlay.mjs
var scrollBehaviorSupported2 = supportsScrollBehavior();
var BlockScrollStrategy = class {
  _viewportRuler;
  _previousHTMLStyles = {
    top: "",
    left: ""
  };
  _previousScrollPosition;
  _isEnabled = false;
  _document;
  constructor(_viewportRuler, document2) {
    this._viewportRuler = _viewportRuler;
    this._document = document2;
  }
  /** Attaches this scroll strategy to an overlay. */
  attach() {
  }
  /** Blocks page-level scroll while the attached overlay is open. */
  enable() {
    if (this._canBeEnabled()) {
      const root = this._document.documentElement;
      this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();
      this._previousHTMLStyles.left = root.style.left || "";
      this._previousHTMLStyles.top = root.style.top || "";
      root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);
      root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);
      root.classList.add("cdk-global-scrollblock");
      this._isEnabled = true;
    }
  }
  /** Unblocks page-level scroll while the attached overlay is open. */
  disable() {
    if (this._isEnabled) {
      const html = this._document.documentElement;
      const body = this._document.body;
      const htmlStyle = html.style;
      const bodyStyle = body.style;
      const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || "";
      const previousBodyScrollBehavior = bodyStyle.scrollBehavior || "";
      this._isEnabled = false;
      htmlStyle.left = this._previousHTMLStyles.left;
      htmlStyle.top = this._previousHTMLStyles.top;
      html.classList.remove("cdk-global-scrollblock");
      if (scrollBehaviorSupported2) {
        htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = "auto";
      }
      window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);
      if (scrollBehaviorSupported2) {
        htmlStyle.scrollBehavior = previousHtmlScrollBehavior;
        bodyStyle.scrollBehavior = previousBodyScrollBehavior;
      }
    }
  }
  _canBeEnabled() {
    const html = this._document.documentElement;
    if (html.classList.contains("cdk-global-scrollblock") || this._isEnabled) {
      return false;
    }
    const body = this._document.body;
    const viewport = this._viewportRuler.getViewportSize();
    return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;
  }
};
function getMatScrollStrategyAlreadyAttachedError() {
  return Error(`Scroll strategy has already been attached.`);
}
var CloseScrollStrategy = class {
  _scrollDispatcher;
  _ngZone;
  _viewportRuler;
  _config;
  _scrollSubscription = null;
  _overlayRef;
  _initialScrollPosition;
  constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {
    this._scrollDispatcher = _scrollDispatcher;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._config = _config;
  }
  /** Attaches this scroll strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatScrollStrategyAlreadyAttachedError();
    }
    this._overlayRef = overlayRef;
  }
  /** Enables the closing of the attached overlay on scroll. */
  enable() {
    if (this._scrollSubscription) {
      return;
    }
    const stream = this._scrollDispatcher.scrolled(0).pipe(filter((scrollable) => {
      return !scrollable || !this._overlayRef.overlayElement.contains(scrollable.getElementRef().nativeElement);
    }));
    if (this._config && this._config.threshold && this._config.threshold > 1) {
      this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;
      this._scrollSubscription = stream.subscribe(() => {
        const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;
        if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {
          this._detach();
        } else {
          this._overlayRef.updatePosition();
        }
      });
    } else {
      this._scrollSubscription = stream.subscribe(this._detach);
    }
  }
  /** Disables the closing the attached overlay on scroll. */
  disable() {
    if (this._scrollSubscription) {
      this._scrollSubscription.unsubscribe();
      this._scrollSubscription = null;
    }
  }
  detach() {
    this.disable();
    this._overlayRef = null;
  }
  /** Detaches the overlay ref and disables the scroll strategy. */
  _detach = () => {
    this.disable();
    if (this._overlayRef.hasAttached()) {
      this._ngZone.run(() => this._overlayRef.detach());
    }
  };
};
var NoopScrollStrategy = class {
  /** Does nothing, as this scroll strategy is a no-op. */
  enable() {
  }
  /** Does nothing, as this scroll strategy is a no-op. */
  disable() {
  }
  /** Does nothing, as this scroll strategy is a no-op. */
  attach() {
  }
};
function isElementScrolledOutsideView(element, scrollContainers) {
  return scrollContainers.some((containerBounds) => {
    const outsideAbove = element.bottom < containerBounds.top;
    const outsideBelow = element.top > containerBounds.bottom;
    const outsideLeft = element.right < containerBounds.left;
    const outsideRight = element.left > containerBounds.right;
    return outsideAbove || outsideBelow || outsideLeft || outsideRight;
  });
}
function isElementClippedByScrolling(element, scrollContainers) {
  return scrollContainers.some((scrollContainerRect) => {
    const clippedAbove = element.top < scrollContainerRect.top;
    const clippedBelow = element.bottom > scrollContainerRect.bottom;
    const clippedLeft = element.left < scrollContainerRect.left;
    const clippedRight = element.right > scrollContainerRect.right;
    return clippedAbove || clippedBelow || clippedLeft || clippedRight;
  });
}
var RepositionScrollStrategy = class {
  _scrollDispatcher;
  _viewportRuler;
  _ngZone;
  _config;
  _scrollSubscription = null;
  _overlayRef;
  constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {
    this._scrollDispatcher = _scrollDispatcher;
    this._viewportRuler = _viewportRuler;
    this._ngZone = _ngZone;
    this._config = _config;
  }
  /** Attaches this scroll strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatScrollStrategyAlreadyAttachedError();
    }
    this._overlayRef = overlayRef;
  }
  /** Enables repositioning of the attached overlay on scroll. */
  enable() {
    if (!this._scrollSubscription) {
      const throttle = this._config ? this._config.scrollThrottle : 0;
      this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {
        this._overlayRef.updatePosition();
        if (this._config && this._config.autoClose) {
          const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();
          const {
            width,
            height
          } = this._viewportRuler.getViewportSize();
          const parentRects = [{
            width,
            height,
            bottom: height,
            right: width,
            top: 0,
            left: 0
          }];
          if (isElementScrolledOutsideView(overlayRect, parentRects)) {
            this.disable();
            this._ngZone.run(() => this._overlayRef.detach());
          }
        }
      });
    }
  }
  /** Disables repositioning of the attached overlay on scroll. */
  disable() {
    if (this._scrollSubscription) {
      this._scrollSubscription.unsubscribe();
      this._scrollSubscription = null;
    }
  }
  detach() {
    this.disable();
    this._overlayRef = null;
  }
};
var ScrollStrategyOptions = class _ScrollStrategyOptions {
  _scrollDispatcher = inject(ScrollDispatcher);
  _viewportRuler = inject(ViewportRuler);
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  constructor() {
  }
  /** Do nothing on scroll. */
  noop = () => new NoopScrollStrategy();
  /**
   * Close the overlay as soon as the user scrolls.
   * @param config Configuration to be used inside the scroll strategy.
   */
  close = (config) => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);
  /** Block scrolling. */
  block = () => new BlockScrollStrategy(this._viewportRuler, this._document);
  /**
   * Update the overlay's position on scroll.
   * @param config Configuration to be used inside the scroll strategy.
   * Allows debouncing the reposition calls.
   */
  reposition = (config) => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);
  static ɵfac = function ScrollStrategyOptions_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollStrategyOptions)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollStrategyOptions,
    factory: _ScrollStrategyOptions.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollStrategyOptions, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var OverlayConfig = class {
  /** Strategy with which to position the overlay. */
  positionStrategy;
  /** Strategy to be used when handling scroll events while the overlay is open. */
  scrollStrategy = new NoopScrollStrategy();
  /** Custom class to add to the overlay pane. */
  panelClass = "";
  /** Whether the overlay has a backdrop. */
  hasBackdrop = false;
  /** Custom class to add to the backdrop */
  backdropClass = "cdk-overlay-dark-backdrop";
  /** The width of the overlay panel. If a number is provided, pixel units are assumed. */
  width;
  /** The height of the overlay panel. If a number is provided, pixel units are assumed. */
  height;
  /** The min-width of the overlay panel. If a number is provided, pixel units are assumed. */
  minWidth;
  /** The min-height of the overlay panel. If a number is provided, pixel units are assumed. */
  minHeight;
  /** The max-width of the overlay panel. If a number is provided, pixel units are assumed. */
  maxWidth;
  /** The max-height of the overlay panel. If a number is provided, pixel units are assumed. */
  maxHeight;
  /**
   * Direction of the text in the overlay panel. If a `Directionality` instance
   * is passed in, the overlay will handle changes to its value automatically.
   */
  direction;
  /**
   * Whether the overlay should be disposed of when the user goes backwards/forwards in history.
   * Note that this usually doesn't include clicking on links (unless the user is using
   * the `HashLocationStrategy`).
   */
  disposeOnNavigation = false;
  constructor(config) {
    if (config) {
      const configKeys = Object.keys(config);
      for (const key of configKeys) {
        if (config[key] !== void 0) {
          this[key] = config[key];
        }
      }
    }
  }
};
var ConnectedOverlayPositionChange = class {
  connectionPair;
  scrollableViewProperties;
  constructor(connectionPair, scrollableViewProperties) {
    this.connectionPair = connectionPair;
    this.scrollableViewProperties = scrollableViewProperties;
  }
};
function validateVerticalPosition(property, value) {
  if (value !== "top" && value !== "bottom" && value !== "center") {
    throw Error(`ConnectedPosition: Invalid ${property} "${value}". Expected "top", "bottom" or "center".`);
  }
}
function validateHorizontalPosition(property, value) {
  if (value !== "start" && value !== "end" && value !== "center") {
    throw Error(`ConnectedPosition: Invalid ${property} "${value}". Expected "start", "end" or "center".`);
  }
}
var BaseOverlayDispatcher = class _BaseOverlayDispatcher {
  /** Currently attached overlays in the order they were attached. */
  _attachedOverlays = [];
  _document = inject(DOCUMENT);
  _isAttached;
  constructor() {
  }
  ngOnDestroy() {
    this.detach();
  }
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    this.remove(overlayRef);
    this._attachedOverlays.push(overlayRef);
  }
  /** Remove an overlay from the list of attached overlay refs. */
  remove(overlayRef) {
    const index = this._attachedOverlays.indexOf(overlayRef);
    if (index > -1) {
      this._attachedOverlays.splice(index, 1);
    }
    if (this._attachedOverlays.length === 0) {
      this.detach();
    }
  }
  static ɵfac = function BaseOverlayDispatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseOverlayDispatcher)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _BaseOverlayDispatcher,
    factory: _BaseOverlayDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseOverlayDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var OverlayKeyboardDispatcher = class _OverlayKeyboardDispatcher extends BaseOverlayDispatcher {
  _ngZone = inject(NgZone);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cleanupKeydown;
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    super.add(overlayRef);
    if (!this._isAttached) {
      this._ngZone.runOutsideAngular(() => {
        this._cleanupKeydown = this._renderer.listen("body", "keydown", this._keydownListener);
      });
      this._isAttached = true;
    }
  }
  /** Detaches the global keyboard event listener. */
  detach() {
    if (this._isAttached) {
      this._cleanupKeydown?.();
      this._isAttached = false;
    }
  }
  /** Keyboard event listener that will be attached to the body. */
  _keydownListener = (event) => {
    const overlays = this._attachedOverlays;
    for (let i = overlays.length - 1; i > -1; i--) {
      if (overlays[i]._keydownEvents.observers.length > 0) {
        this._ngZone.run(() => overlays[i]._keydownEvents.next(event));
        break;
      }
    }
  };
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵOverlayKeyboardDispatcher_BaseFactory;
    return function OverlayKeyboardDispatcher_Factory(__ngFactoryType__) {
      return (ɵOverlayKeyboardDispatcher_BaseFactory || (ɵOverlayKeyboardDispatcher_BaseFactory = ɵɵgetInheritedFactory(_OverlayKeyboardDispatcher)))(__ngFactoryType__ || _OverlayKeyboardDispatcher);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({
    token: _OverlayKeyboardDispatcher,
    factory: _OverlayKeyboardDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayKeyboardDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var OverlayOutsideClickDispatcher = class _OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {
  _platform = inject(Platform);
  _ngZone = inject(NgZone, {
    optional: true
  });
  _cursorOriginalValue;
  _cursorStyleIsSet = false;
  _pointerDownEventTarget;
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    super.add(overlayRef);
    if (!this._isAttached) {
      const body = this._document.body;
      if (this._ngZone) {
        this._ngZone.runOutsideAngular(() => this._addEventListeners(body));
      } else {
        this._addEventListeners(body);
      }
      if (this._platform.IOS && !this._cursorStyleIsSet) {
        this._cursorOriginalValue = body.style.cursor;
        body.style.cursor = "pointer";
        this._cursorStyleIsSet = true;
      }
      this._isAttached = true;
    }
  }
  /** Detaches the global keyboard event listener. */
  detach() {
    if (this._isAttached) {
      const body = this._document.body;
      body.removeEventListener("pointerdown", this._pointerDownListener, true);
      body.removeEventListener("click", this._clickListener, true);
      body.removeEventListener("auxclick", this._clickListener, true);
      body.removeEventListener("contextmenu", this._clickListener, true);
      if (this._platform.IOS && this._cursorStyleIsSet) {
        body.style.cursor = this._cursorOriginalValue;
        this._cursorStyleIsSet = false;
      }
      this._isAttached = false;
    }
  }
  _addEventListeners(body) {
    body.addEventListener("pointerdown", this._pointerDownListener, true);
    body.addEventListener("click", this._clickListener, true);
    body.addEventListener("auxclick", this._clickListener, true);
    body.addEventListener("contextmenu", this._clickListener, true);
  }
  /** Store pointerdown event target to track origin of click. */
  _pointerDownListener = (event) => {
    this._pointerDownEventTarget = _getEventTarget(event);
  };
  /** Click event listener that will be attached to the body propagate phase. */
  _clickListener = (event) => {
    const target = _getEventTarget(event);
    const origin = event.type === "click" && this._pointerDownEventTarget ? this._pointerDownEventTarget : target;
    this._pointerDownEventTarget = null;
    const overlays = this._attachedOverlays.slice();
    for (let i = overlays.length - 1; i > -1; i--) {
      const overlayRef = overlays[i];
      if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {
        continue;
      }
      if (containsPierceShadowDom(overlayRef.overlayElement, target) || containsPierceShadowDom(overlayRef.overlayElement, origin)) {
        break;
      }
      const outsidePointerEvents = overlayRef._outsidePointerEvents;
      if (this._ngZone) {
        this._ngZone.run(() => outsidePointerEvents.next(event));
      } else {
        outsidePointerEvents.next(event);
      }
    }
  };
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵOverlayOutsideClickDispatcher_BaseFactory;
    return function OverlayOutsideClickDispatcher_Factory(__ngFactoryType__) {
      return (ɵOverlayOutsideClickDispatcher_BaseFactory || (ɵOverlayOutsideClickDispatcher_BaseFactory = ɵɵgetInheritedFactory(_OverlayOutsideClickDispatcher)))(__ngFactoryType__ || _OverlayOutsideClickDispatcher);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({
    token: _OverlayOutsideClickDispatcher,
    factory: _OverlayOutsideClickDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayOutsideClickDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function containsPierceShadowDom(parent, child) {
  const supportsShadowRoot = typeof ShadowRoot !== "undefined" && ShadowRoot;
  let current = child;
  while (current) {
    if (current === parent) {
      return true;
    }
    current = supportsShadowRoot && current instanceof ShadowRoot ? current.host : current.parentNode;
  }
  return false;
}
var _CdkOverlayStyleLoader = class __CdkOverlayStyleLoader {
  static ɵfac = function _CdkOverlayStyleLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __CdkOverlayStyleLoader)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: __CdkOverlayStyleLoader,
    selectors: [["ng-component"]],
    hostAttrs: ["cdk-overlay-style-loader", ""],
    decls: 0,
    vars: 0,
    template: function _CdkOverlayStyleLoader_Template(rf, ctx) {
    },
    styles: [".cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed}@layer cdk-overlay{.cdk-overlay-container{z-index:1000}}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute}@layer cdk-overlay{.cdk-global-overlay-wrapper{z-index:1000}}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;display:flex;max-width:100%;max-height:100%}@layer cdk-overlay{.cdk-overlay-pane{z-index:1000}}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:auto;-webkit-tap-highlight-color:rgba(0,0,0,0);opacity:0}@layer cdk-overlay{.cdk-overlay-backdrop{z-index:1000;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}}.cdk-overlay-backdrop-showing{opacity:1}@media(forced-colors: active){.cdk-overlay-backdrop-showing{opacity:.6}}@layer cdk-overlay{.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing,.cdk-high-contrast-active .cdk-overlay-transparent-backdrop{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;display:flex;flex-direction:column;min-width:1px;min-height:1px}@layer cdk-overlay{.cdk-overlay-connected-position-bounding-box{z-index:1000}}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CdkOverlayStyleLoader, [{
    type: Component,
    args: [{
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "cdk-overlay-style-loader": ""
      },
      styles: [".cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed}@layer cdk-overlay{.cdk-overlay-container{z-index:1000}}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute}@layer cdk-overlay{.cdk-global-overlay-wrapper{z-index:1000}}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;display:flex;max-width:100%;max-height:100%}@layer cdk-overlay{.cdk-overlay-pane{z-index:1000}}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:auto;-webkit-tap-highlight-color:rgba(0,0,0,0);opacity:0}@layer cdk-overlay{.cdk-overlay-backdrop{z-index:1000;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}}.cdk-overlay-backdrop-showing{opacity:1}@media(forced-colors: active){.cdk-overlay-backdrop-showing{opacity:.6}}@layer cdk-overlay{.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing,.cdk-high-contrast-active .cdk-overlay-transparent-backdrop{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;display:flex;flex-direction:column;min-width:1px;min-height:1px}@layer cdk-overlay{.cdk-overlay-connected-position-bounding-box{z-index:1000}}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}"]
    }]
  }], null, null);
})();
var OverlayContainer = class _OverlayContainer {
  _platform = inject(Platform);
  _containerElement;
  _document = inject(DOCUMENT);
  _styleLoader = inject(_CdkPrivateStyleLoader);
  constructor() {
  }
  ngOnDestroy() {
    this._containerElement?.remove();
  }
  /**
   * This method returns the overlay container element. It will lazily
   * create the element the first time it is called to facilitate using
   * the container in non-browser environments.
   * @returns the container element
   */
  getContainerElement() {
    this._loadStyles();
    if (!this._containerElement) {
      this._createContainer();
    }
    return this._containerElement;
  }
  /**
   * Create the overlay container element, which is simply a div
   * with the 'cdk-overlay-container' class on the document body.
   */
  _createContainer() {
    const containerClass = "cdk-overlay-container";
    if (this._platform.isBrowser || _isTestEnvironment()) {
      const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform="server"], .${containerClass}[platform="test"]`);
      for (let i = 0; i < oppositePlatformContainers.length; i++) {
        oppositePlatformContainers[i].remove();
      }
    }
    const container = this._document.createElement("div");
    container.classList.add(containerClass);
    if (_isTestEnvironment()) {
      container.setAttribute("platform", "test");
    } else if (!this._platform.isBrowser) {
      container.setAttribute("platform", "server");
    }
    this._document.body.appendChild(container);
    this._containerElement = container;
  }
  /** Loads the structural styles necessary for the overlay to work. */
  _loadStyles() {
    this._styleLoader.load(_CdkOverlayStyleLoader);
  }
  static ɵfac = function OverlayContainer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OverlayContainer)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _OverlayContainer,
    factory: _OverlayContainer.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayContainer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var OverlayRef = class {
  _portalOutlet;
  _host;
  _pane;
  _config;
  _ngZone;
  _keyboardDispatcher;
  _document;
  _location;
  _outsideClickDispatcher;
  _animationsDisabled;
  _injector;
  _renderer;
  _backdropElement = null;
  _backdropTimeout;
  _backdropClick = new Subject();
  _attachments = new Subject();
  _detachments = new Subject();
  _positionStrategy;
  _scrollStrategy;
  _locationChanges = Subscription.EMPTY;
  _cleanupBackdropClick;
  _cleanupBackdropTransitionEnd;
  /**
   * Reference to the parent of the `_host` at the time it was detached. Used to restore
   * the `_host` to its original position in the DOM when it gets re-attached.
   */
  _previousHostParent;
  /** Stream of keydown events dispatched to this overlay. */
  _keydownEvents = new Subject();
  /** Stream of mouse outside events dispatched to this overlay. */
  _outsidePointerEvents = new Subject();
  _renders = new Subject();
  _afterRenderRef;
  /** Reference to the currently-running `afterNextRender` call. */
  _afterNextRenderRef;
  constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location, _outsideClickDispatcher, _animationsDisabled = false, _injector, _renderer) {
    this._portalOutlet = _portalOutlet;
    this._host = _host;
    this._pane = _pane;
    this._config = _config;
    this._ngZone = _ngZone;
    this._keyboardDispatcher = _keyboardDispatcher;
    this._document = _document;
    this._location = _location;
    this._outsideClickDispatcher = _outsideClickDispatcher;
    this._animationsDisabled = _animationsDisabled;
    this._injector = _injector;
    this._renderer = _renderer;
    if (_config.scrollStrategy) {
      this._scrollStrategy = _config.scrollStrategy;
      this._scrollStrategy.attach(this);
    }
    this._positionStrategy = _config.positionStrategy;
    this._afterRenderRef = untracked(() => afterRender(() => {
      this._renders.next();
    }, {
      injector: this._injector
    }));
  }
  /** The overlay's HTML element */
  get overlayElement() {
    return this._pane;
  }
  /** The overlay's backdrop HTML element. */
  get backdropElement() {
    return this._backdropElement;
  }
  /**
   * Wrapper around the panel element. Can be used for advanced
   * positioning where a wrapper with specific styling is
   * required around the overlay pane.
   */
  get hostElement() {
    return this._host;
  }
  /**
   * Attaches content, given via a Portal, to the overlay.
   * If the overlay is configured to have a backdrop, it will be created.
   *
   * @param portal Portal instance to which to attach the overlay.
   * @returns The portal attachment result.
   */
  attach(portal) {
    if (!this._host.parentElement && this._previousHostParent) {
      this._previousHostParent.appendChild(this._host);
    }
    const attachResult = this._portalOutlet.attach(portal);
    if (this._positionStrategy) {
      this._positionStrategy.attach(this);
    }
    this._updateStackingOrder();
    this._updateElementSize();
    this._updateElementDirection();
    if (this._scrollStrategy) {
      this._scrollStrategy.enable();
    }
    this._afterNextRenderRef?.destroy();
    this._afterNextRenderRef = afterNextRender(() => {
      if (this.hasAttached()) {
        this.updatePosition();
      }
    }, {
      injector: this._injector
    });
    this._togglePointerEvents(true);
    if (this._config.hasBackdrop) {
      this._attachBackdrop();
    }
    if (this._config.panelClass) {
      this._toggleClasses(this._pane, this._config.panelClass, true);
    }
    this._attachments.next();
    this._keyboardDispatcher.add(this);
    if (this._config.disposeOnNavigation) {
      this._locationChanges = this._location.subscribe(() => this.dispose());
    }
    this._outsideClickDispatcher.add(this);
    if (typeof attachResult?.onDestroy === "function") {
      attachResult.onDestroy(() => {
        if (this.hasAttached()) {
          this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()));
        }
      });
    }
    return attachResult;
  }
  /**
   * Detaches an overlay from a portal.
   * @returns The portal detachment result.
   */
  detach() {
    if (!this.hasAttached()) {
      return;
    }
    this.detachBackdrop();
    this._togglePointerEvents(false);
    if (this._positionStrategy && this._positionStrategy.detach) {
      this._positionStrategy.detach();
    }
    if (this._scrollStrategy) {
      this._scrollStrategy.disable();
    }
    const detachmentResult = this._portalOutlet.detach();
    this._detachments.next();
    this._keyboardDispatcher.remove(this);
    this._detachContentWhenEmpty();
    this._locationChanges.unsubscribe();
    this._outsideClickDispatcher.remove(this);
    return detachmentResult;
  }
  /** Cleans up the overlay from the DOM. */
  dispose() {
    const isAttached = this.hasAttached();
    if (this._positionStrategy) {
      this._positionStrategy.dispose();
    }
    this._disposeScrollStrategy();
    this._disposeBackdrop(this._backdropElement);
    this._locationChanges.unsubscribe();
    this._keyboardDispatcher.remove(this);
    this._portalOutlet.dispose();
    this._attachments.complete();
    this._backdropClick.complete();
    this._keydownEvents.complete();
    this._outsidePointerEvents.complete();
    this._outsideClickDispatcher.remove(this);
    this._host?.remove();
    this._afterNextRenderRef?.destroy();
    this._previousHostParent = this._pane = this._host = null;
    if (isAttached) {
      this._detachments.next();
    }
    this._detachments.complete();
    this._afterRenderRef.destroy();
    this._renders.complete();
  }
  /** Whether the overlay has attached content. */
  hasAttached() {
    return this._portalOutlet.hasAttached();
  }
  /** Gets an observable that emits when the backdrop has been clicked. */
  backdropClick() {
    return this._backdropClick;
  }
  /** Gets an observable that emits when the overlay has been attached. */
  attachments() {
    return this._attachments;
  }
  /** Gets an observable that emits when the overlay has been detached. */
  detachments() {
    return this._detachments;
  }
  /** Gets an observable of keydown events targeted to this overlay. */
  keydownEvents() {
    return this._keydownEvents;
  }
  /** Gets an observable of pointer events targeted outside this overlay. */
  outsidePointerEvents() {
    return this._outsidePointerEvents;
  }
  /** Gets the current overlay configuration, which is immutable. */
  getConfig() {
    return this._config;
  }
  /** Updates the position of the overlay based on the position strategy. */
  updatePosition() {
    if (this._positionStrategy) {
      this._positionStrategy.apply();
    }
  }
  /** Switches to a new position strategy and updates the overlay position. */
  updatePositionStrategy(strategy) {
    if (strategy === this._positionStrategy) {
      return;
    }
    if (this._positionStrategy) {
      this._positionStrategy.dispose();
    }
    this._positionStrategy = strategy;
    if (this.hasAttached()) {
      strategy.attach(this);
      this.updatePosition();
    }
  }
  /** Update the size properties of the overlay. */
  updateSize(sizeConfig) {
    this._config = __spreadValues(__spreadValues({}, this._config), sizeConfig);
    this._updateElementSize();
  }
  /** Sets the LTR/RTL direction for the overlay. */
  setDirection(dir) {
    this._config = __spreadProps(__spreadValues({}, this._config), {
      direction: dir
    });
    this._updateElementDirection();
  }
  /** Add a CSS class or an array of classes to the overlay pane. */
  addPanelClass(classes) {
    if (this._pane) {
      this._toggleClasses(this._pane, classes, true);
    }
  }
  /** Remove a CSS class or an array of classes from the overlay pane. */
  removePanelClass(classes) {
    if (this._pane) {
      this._toggleClasses(this._pane, classes, false);
    }
  }
  /**
   * Returns the layout direction of the overlay panel.
   */
  getDirection() {
    const direction = this._config.direction;
    if (!direction) {
      return "ltr";
    }
    return typeof direction === "string" ? direction : direction.value;
  }
  /** Switches to a new scroll strategy. */
  updateScrollStrategy(strategy) {
    if (strategy === this._scrollStrategy) {
      return;
    }
    this._disposeScrollStrategy();
    this._scrollStrategy = strategy;
    if (this.hasAttached()) {
      strategy.attach(this);
      strategy.enable();
    }
  }
  /** Updates the text direction of the overlay panel. */
  _updateElementDirection() {
    this._host.setAttribute("dir", this.getDirection());
  }
  /** Updates the size of the overlay element based on the overlay config. */
  _updateElementSize() {
    if (!this._pane) {
      return;
    }
    const style2 = this._pane.style;
    style2.width = coerceCssPixelValue(this._config.width);
    style2.height = coerceCssPixelValue(this._config.height);
    style2.minWidth = coerceCssPixelValue(this._config.minWidth);
    style2.minHeight = coerceCssPixelValue(this._config.minHeight);
    style2.maxWidth = coerceCssPixelValue(this._config.maxWidth);
    style2.maxHeight = coerceCssPixelValue(this._config.maxHeight);
  }
  /** Toggles the pointer events for the overlay pane element. */
  _togglePointerEvents(enablePointer) {
    this._pane.style.pointerEvents = enablePointer ? "" : "none";
  }
  /** Attaches a backdrop for this overlay. */
  _attachBackdrop() {
    const showingClass = "cdk-overlay-backdrop-showing";
    this._backdropElement = this._document.createElement("div");
    this._backdropElement.classList.add("cdk-overlay-backdrop");
    if (this._animationsDisabled) {
      this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation");
    }
    if (this._config.backdropClass) {
      this._toggleClasses(this._backdropElement, this._config.backdropClass, true);
    }
    this._host.parentElement.insertBefore(this._backdropElement, this._host);
    this._cleanupBackdropClick?.();
    this._cleanupBackdropClick = this._renderer.listen(this._backdropElement, "click", (event) => this._backdropClick.next(event));
    if (!this._animationsDisabled && typeof requestAnimationFrame !== "undefined") {
      this._ngZone.runOutsideAngular(() => {
        requestAnimationFrame(() => {
          if (this._backdropElement) {
            this._backdropElement.classList.add(showingClass);
          }
        });
      });
    } else {
      this._backdropElement.classList.add(showingClass);
    }
  }
  /**
   * Updates the stacking order of the element, moving it to the top if necessary.
   * This is required in cases where one overlay was detached, while another one,
   * that should be behind it, was destroyed. The next time both of them are opened,
   * the stacking will be wrong, because the detached element's pane will still be
   * in its original DOM position.
   */
  _updateStackingOrder() {
    if (this._host.nextSibling) {
      this._host.parentNode.appendChild(this._host);
    }
  }
  /** Detaches the backdrop (if any) associated with the overlay. */
  detachBackdrop() {
    const backdropToDetach = this._backdropElement;
    if (!backdropToDetach) {
      return;
    }
    if (this._animationsDisabled) {
      this._disposeBackdrop(backdropToDetach);
      return;
    }
    backdropToDetach.classList.remove("cdk-overlay-backdrop-showing");
    this._ngZone.runOutsideAngular(() => {
      this._cleanupBackdropTransitionEnd?.();
      this._cleanupBackdropTransitionEnd = this._renderer.listen(backdropToDetach, "transitionend", (event) => {
        this._disposeBackdrop(event.target);
      });
    });
    backdropToDetach.style.pointerEvents = "none";
    this._backdropTimeout = this._ngZone.runOutsideAngular(() => setTimeout(() => {
      this._disposeBackdrop(backdropToDetach);
    }, 500));
  }
  /** Toggles a single CSS class or an array of classes on an element. */
  _toggleClasses(element, cssClasses, isAdd) {
    const classes = coerceArray(cssClasses || []).filter((c) => !!c);
    if (classes.length) {
      isAdd ? element.classList.add(...classes) : element.classList.remove(...classes);
    }
  }
  /** Detaches the overlay content next time the zone stabilizes. */
  _detachContentWhenEmpty() {
    this._ngZone.runOutsideAngular(() => {
      const subscription = this._renders.pipe(takeUntil(merge(this._attachments, this._detachments))).subscribe(() => {
        if (!this._pane || !this._host || this._pane.children.length === 0) {
          if (this._pane && this._config.panelClass) {
            this._toggleClasses(this._pane, this._config.panelClass, false);
          }
          if (this._host && this._host.parentElement) {
            this._previousHostParent = this._host.parentElement;
            this._host.remove();
          }
          subscription.unsubscribe();
        }
      });
    });
  }
  /** Disposes of a scroll strategy. */
  _disposeScrollStrategy() {
    const scrollStrategy = this._scrollStrategy;
    if (scrollStrategy) {
      scrollStrategy.disable();
      if (scrollStrategy.detach) {
        scrollStrategy.detach();
      }
    }
  }
  /** Removes a backdrop element from the DOM. */
  _disposeBackdrop(backdrop) {
    this._cleanupBackdropClick?.();
    this._cleanupBackdropTransitionEnd?.();
    if (backdrop) {
      backdrop.remove();
      if (this._backdropElement === backdrop) {
        this._backdropElement = null;
      }
    }
    if (this._backdropTimeout) {
      clearTimeout(this._backdropTimeout);
      this._backdropTimeout = void 0;
    }
  }
};
var boundingBoxClass = "cdk-overlay-connected-position-bounding-box";
var cssUnitPattern = /([A-Za-z%]+)$/;
var FlexibleConnectedPositionStrategy = class {
  _viewportRuler;
  _document;
  _platform;
  _overlayContainer;
  /** The overlay to which this strategy is attached. */
  _overlayRef;
  /** Whether we're performing the very first positioning of the overlay. */
  _isInitialRender;
  /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */
  _lastBoundingBoxSize = {
    width: 0,
    height: 0
  };
  /** Whether the overlay was pushed in a previous positioning. */
  _isPushed = false;
  /** Whether the overlay can be pushed on-screen on the initial open. */
  _canPush = true;
  /** Whether the overlay can grow via flexible width/height after the initial open. */
  _growAfterOpen = false;
  /** Whether the overlay's width and height can be constrained to fit within the viewport. */
  _hasFlexibleDimensions = true;
  /** Whether the overlay position is locked. */
  _positionLocked = false;
  /** Cached origin dimensions */
  _originRect;
  /** Cached overlay dimensions */
  _overlayRect;
  /** Cached viewport dimensions */
  _viewportRect;
  /** Cached container dimensions */
  _containerRect;
  /** Amount of space that must be maintained between the overlay and the edge of the viewport. */
  _viewportMargin = 0;
  /** The Scrollable containers used to check scrollable view properties on position change. */
  _scrollables = [];
  /** Ordered list of preferred positions, from most to least desirable. */
  _preferredPositions = [];
  /** The origin element against which the overlay will be positioned. */
  _origin;
  /** The overlay pane element. */
  _pane;
  /** Whether the strategy has been disposed of already. */
  _isDisposed;
  /**
   * Parent element for the overlay panel used to constrain the overlay panel's size to fit
   * within the viewport.
   */
  _boundingBox;
  /** The last position to have been calculated as the best fit position. */
  _lastPosition;
  /** The last calculated scroll visibility. Only tracked  */
  _lastScrollVisibility;
  /** Subject that emits whenever the position changes. */
  _positionChanges = new Subject();
  /** Subscription to viewport size changes. */
  _resizeSubscription = Subscription.EMPTY;
  /** Default offset for the overlay along the x axis. */
  _offsetX = 0;
  /** Default offset for the overlay along the y axis. */
  _offsetY = 0;
  /** Selector to be used when finding the elements on which to set the transform origin. */
  _transformOriginSelector;
  /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */
  _appliedPanelClasses = [];
  /** Amount by which the overlay was pushed in each axis during the last time it was positioned. */
  _previousPushAmount;
  /** Observable sequence of position changes. */
  positionChanges = this._positionChanges;
  /** Ordered list of preferred positions, from most to least desirable. */
  get positions() {
    return this._preferredPositions;
  }
  constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {
    this._viewportRuler = _viewportRuler;
    this._document = _document;
    this._platform = _platform;
    this._overlayContainer = _overlayContainer;
    this.setOrigin(connectedTo);
  }
  /** Attaches this position strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && overlayRef !== this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("This position strategy is already attached to an overlay");
    }
    this._validatePositions();
    overlayRef.hostElement.classList.add(boundingBoxClass);
    this._overlayRef = overlayRef;
    this._boundingBox = overlayRef.hostElement;
    this._pane = overlayRef.overlayElement;
    this._isDisposed = false;
    this._isInitialRender = true;
    this._lastPosition = null;
    this._resizeSubscription.unsubscribe();
    this._resizeSubscription = this._viewportRuler.change().subscribe(() => {
      this._isInitialRender = true;
      this.apply();
    });
  }
  /**
   * Updates the position of the overlay element, using whichever preferred position relative
   * to the origin best fits on-screen.
   *
   * The selection of a position goes as follows:
   *  - If any positions fit completely within the viewport as-is,
   *      choose the first position that does so.
   *  - If flexible dimensions are enabled and at least one satisfies the given minimum width/height,
   *      choose the position with the greatest available size modified by the positions' weight.
   *  - If pushing is enabled, take the position that went off-screen the least and push it
   *      on-screen.
   *  - If none of the previous criteria were met, use the position that goes off-screen the least.
   * @docs-private
   */
  apply() {
    if (this._isDisposed || !this._platform.isBrowser) {
      return;
    }
    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
      this.reapplyLastPosition();
      return;
    }
    this._clearPanelClasses();
    this._resetOverlayElementStyles();
    this._resetBoundingBoxStyles();
    this._viewportRect = this._getNarrowedViewportRect();
    this._originRect = this._getOriginRect();
    this._overlayRect = this._pane.getBoundingClientRect();
    this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
    const originRect = this._originRect;
    const overlayRect = this._overlayRect;
    const viewportRect = this._viewportRect;
    const containerRect = this._containerRect;
    const flexibleFits = [];
    let fallback;
    for (let pos of this._preferredPositions) {
      let originPoint = this._getOriginPoint(originRect, containerRect, pos);
      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);
      let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);
      if (overlayFit.isCompletelyWithinViewport) {
        this._isPushed = false;
        this._applyPosition(pos, originPoint);
        return;
      }
      if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {
        flexibleFits.push({
          position: pos,
          origin: originPoint,
          overlayRect,
          boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)
        });
        continue;
      }
      if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {
        fallback = {
          overlayFit,
          overlayPoint,
          originPoint,
          position: pos,
          overlayRect
        };
      }
    }
    if (flexibleFits.length) {
      let bestFit = null;
      let bestScore = -1;
      for (const fit of flexibleFits) {
        const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);
        if (score > bestScore) {
          bestScore = score;
          bestFit = fit;
        }
      }
      this._isPushed = false;
      this._applyPosition(bestFit.position, bestFit.origin);
      return;
    }
    if (this._canPush) {
      this._isPushed = true;
      this._applyPosition(fallback.position, fallback.originPoint);
      return;
    }
    this._applyPosition(fallback.position, fallback.originPoint);
  }
  detach() {
    this._clearPanelClasses();
    this._lastPosition = null;
    this._previousPushAmount = null;
    this._resizeSubscription.unsubscribe();
  }
  /** Cleanup after the element gets destroyed. */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    if (this._boundingBox) {
      extendStyles(this._boundingBox.style, {
        top: "",
        left: "",
        right: "",
        bottom: "",
        height: "",
        width: "",
        alignItems: "",
        justifyContent: ""
      });
    }
    if (this._pane) {
      this._resetOverlayElementStyles();
    }
    if (this._overlayRef) {
      this._overlayRef.hostElement.classList.remove(boundingBoxClass);
    }
    this.detach();
    this._positionChanges.complete();
    this._overlayRef = this._boundingBox = null;
    this._isDisposed = true;
  }
  /**
   * This re-aligns the overlay element with the trigger in its last calculated position,
   * even if a position higher in the "preferred positions" list would now fit. This
   * allows one to re-align the panel without changing the orientation of the panel.
   */
  reapplyLastPosition() {
    if (this._isDisposed || !this._platform.isBrowser) {
      return;
    }
    const lastPosition = this._lastPosition;
    if (lastPosition) {
      this._originRect = this._getOriginRect();
      this._overlayRect = this._pane.getBoundingClientRect();
      this._viewportRect = this._getNarrowedViewportRect();
      this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
      const originPoint = this._getOriginPoint(this._originRect, this._containerRect, lastPosition);
      this._applyPosition(lastPosition, originPoint);
    } else {
      this.apply();
    }
  }
  /**
   * Sets the list of Scrollable containers that host the origin element so that
   * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
   * Scrollable must be an ancestor element of the strategy's origin element.
   */
  withScrollableContainers(scrollables) {
    this._scrollables = scrollables;
    return this;
  }
  /**
   * Adds new preferred positions.
   * @param positions List of positions options for this overlay.
   */
  withPositions(positions) {
    this._preferredPositions = positions;
    if (positions.indexOf(this._lastPosition) === -1) {
      this._lastPosition = null;
    }
    this._validatePositions();
    return this;
  }
  /**
   * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
   * @param margin Required margin between the overlay and the viewport edge in pixels.
   */
  withViewportMargin(margin) {
    this._viewportMargin = margin;
    return this;
  }
  /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */
  withFlexibleDimensions(flexibleDimensions = true) {
    this._hasFlexibleDimensions = flexibleDimensions;
    return this;
  }
  /** Sets whether the overlay can grow after the initial open via flexible width/height. */
  withGrowAfterOpen(growAfterOpen = true) {
    this._growAfterOpen = growAfterOpen;
    return this;
  }
  /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */
  withPush(canPush = true) {
    this._canPush = canPush;
    return this;
  }
  /**
   * Sets whether the overlay's position should be locked in after it is positioned
   * initially. When an overlay is locked in, it won't attempt to reposition itself
   * when the position is re-applied (e.g. when the user scrolls away).
   * @param isLocked Whether the overlay should locked in.
   */
  withLockedPosition(isLocked = true) {
    this._positionLocked = isLocked;
    return this;
  }
  /**
   * Sets the origin, relative to which to position the overlay.
   * Using an element origin is useful for building components that need to be positioned
   * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be
   * used for cases like contextual menus which open relative to the user's pointer.
   * @param origin Reference to the new origin.
   */
  setOrigin(origin) {
    this._origin = origin;
    return this;
  }
  /**
   * Sets the default offset for the overlay's connection point on the x-axis.
   * @param offset New offset in the X axis.
   */
  withDefaultOffsetX(offset) {
    this._offsetX = offset;
    return this;
  }
  /**
   * Sets the default offset for the overlay's connection point on the y-axis.
   * @param offset New offset in the Y axis.
   */
  withDefaultOffsetY(offset) {
    this._offsetY = offset;
    return this;
  }
  /**
   * Configures that the position strategy should set a `transform-origin` on some elements
   * inside the overlay, depending on the current position that is being applied. This is
   * useful for the cases where the origin of an animation can change depending on the
   * alignment of the overlay.
   * @param selector CSS selector that will be used to find the target
   *    elements onto which to set the transform origin.
   */
  withTransformOriginOn(selector) {
    this._transformOriginSelector = selector;
    return this;
  }
  /**
   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
   */
  _getOriginPoint(originRect, containerRect, pos) {
    let x;
    if (pos.originX == "center") {
      x = originRect.left + originRect.width / 2;
    } else {
      const startX = this._isRtl() ? originRect.right : originRect.left;
      const endX = this._isRtl() ? originRect.left : originRect.right;
      x = pos.originX == "start" ? startX : endX;
    }
    if (containerRect.left < 0) {
      x -= containerRect.left;
    }
    let y;
    if (pos.originY == "center") {
      y = originRect.top + originRect.height / 2;
    } else {
      y = pos.originY == "top" ? originRect.top : originRect.bottom;
    }
    if (containerRect.top < 0) {
      y -= containerRect.top;
    }
    return {
      x,
      y
    };
  }
  /**
   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
   * origin point to which the overlay should be connected.
   */
  _getOverlayPoint(originPoint, overlayRect, pos) {
    let overlayStartX;
    if (pos.overlayX == "center") {
      overlayStartX = -overlayRect.width / 2;
    } else if (pos.overlayX === "start") {
      overlayStartX = this._isRtl() ? -overlayRect.width : 0;
    } else {
      overlayStartX = this._isRtl() ? 0 : -overlayRect.width;
    }
    let overlayStartY;
    if (pos.overlayY == "center") {
      overlayStartY = -overlayRect.height / 2;
    } else {
      overlayStartY = pos.overlayY == "top" ? 0 : -overlayRect.height;
    }
    return {
      x: originPoint.x + overlayStartX,
      y: originPoint.y + overlayStartY
    };
  }
  /** Gets how well an overlay at the given point will fit within the viewport. */
  _getOverlayFit(point, rawOverlayRect, viewport, position) {
    const overlay = getRoundedBoundingClientRect(rawOverlayRect);
    let {
      x,
      y
    } = point;
    let offsetX = this._getOffset(position, "x");
    let offsetY = this._getOffset(position, "y");
    if (offsetX) {
      x += offsetX;
    }
    if (offsetY) {
      y += offsetY;
    }
    let leftOverflow = 0 - x;
    let rightOverflow = x + overlay.width - viewport.width;
    let topOverflow = 0 - y;
    let bottomOverflow = y + overlay.height - viewport.height;
    let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);
    let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);
    let visibleArea = visibleWidth * visibleHeight;
    return {
      visibleArea,
      isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,
      fitsInViewportVertically: visibleHeight === overlay.height,
      fitsInViewportHorizontally: visibleWidth == overlay.width
    };
  }
  /**
   * Whether the overlay can fit within the viewport when it may resize either its width or height.
   * @param fit How well the overlay fits in the viewport at some position.
   * @param point The (x, y) coordinates of the overlay at some position.
   * @param viewport The geometry of the viewport.
   */
  _canFitWithFlexibleDimensions(fit, point, viewport) {
    if (this._hasFlexibleDimensions) {
      const availableHeight = viewport.bottom - point.y;
      const availableWidth = viewport.right - point.x;
      const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);
      const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);
      const verticalFit = fit.fitsInViewportVertically || minHeight != null && minHeight <= availableHeight;
      const horizontalFit = fit.fitsInViewportHorizontally || minWidth != null && minWidth <= availableWidth;
      return verticalFit && horizontalFit;
    }
    return false;
  }
  /**
   * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
   * the viewport, the top-left corner will be pushed on-screen (with overflow occurring on the
   * right and bottom).
   *
   * @param start Starting point from which the overlay is pushed.
   * @param rawOverlayRect Dimensions of the overlay.
   * @param scrollPosition Current viewport scroll position.
   * @returns The point at which to position the overlay after pushing. This is effectively a new
   *     originPoint.
   */
  _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {
    if (this._previousPushAmount && this._positionLocked) {
      return {
        x: start.x + this._previousPushAmount.x,
        y: start.y + this._previousPushAmount.y
      };
    }
    const overlay = getRoundedBoundingClientRect(rawOverlayRect);
    const viewport = this._viewportRect;
    const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);
    const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);
    const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);
    const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);
    let pushX = 0;
    let pushY = 0;
    if (overlay.width <= viewport.width) {
      pushX = overflowLeft || -overflowRight;
    } else {
      pushX = start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0;
    }
    if (overlay.height <= viewport.height) {
      pushY = overflowTop || -overflowBottom;
    } else {
      pushY = start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0;
    }
    this._previousPushAmount = {
      x: pushX,
      y: pushY
    };
    return {
      x: start.x + pushX,
      y: start.y + pushY
    };
  }
  /**
   * Applies a computed position to the overlay and emits a position change.
   * @param position The position preference
   * @param originPoint The point on the origin element where the overlay is connected.
   */
  _applyPosition(position, originPoint) {
    this._setTransformOrigin(position);
    this._setOverlayElementStyles(originPoint, position);
    this._setBoundingBoxStyles(originPoint, position);
    if (position.panelClass) {
      this._addPanelClasses(position.panelClass);
    }
    if (this._positionChanges.observers.length) {
      const scrollVisibility = this._getScrollVisibility();
      if (position !== this._lastPosition || !this._lastScrollVisibility || !compareScrollVisibility(this._lastScrollVisibility, scrollVisibility)) {
        const changeEvent = new ConnectedOverlayPositionChange(position, scrollVisibility);
        this._positionChanges.next(changeEvent);
      }
      this._lastScrollVisibility = scrollVisibility;
    }
    this._lastPosition = position;
    this._isInitialRender = false;
  }
  /** Sets the transform origin based on the configured selector and the passed-in position.  */
  _setTransformOrigin(position) {
    if (!this._transformOriginSelector) {
      return;
    }
    const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);
    let xOrigin;
    let yOrigin = position.overlayY;
    if (position.overlayX === "center") {
      xOrigin = "center";
    } else if (this._isRtl()) {
      xOrigin = position.overlayX === "start" ? "right" : "left";
    } else {
      xOrigin = position.overlayX === "start" ? "left" : "right";
    }
    for (let i = 0; i < elements.length; i++) {
      elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;
    }
  }
  /**
   * Gets the position and size of the overlay's sizing container.
   *
   * This method does no measuring and applies no styles so that we can cheaply compute the
   * bounds for all positions and choose the best fit based on these results.
   */
  _calculateBoundingBoxRect(origin, position) {
    const viewport = this._viewportRect;
    const isRtl = this._isRtl();
    let height, top, bottom;
    if (position.overlayY === "top") {
      top = origin.y;
      height = viewport.height - top + this._viewportMargin;
    } else if (position.overlayY === "bottom") {
      bottom = viewport.height - origin.y + this._viewportMargin * 2;
      height = viewport.height - bottom + this._viewportMargin;
    } else {
      const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);
      const previousHeight = this._lastBoundingBoxSize.height;
      height = smallestDistanceToViewportEdge * 2;
      top = origin.y - smallestDistanceToViewportEdge;
      if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {
        top = origin.y - previousHeight / 2;
      }
    }
    const isBoundedByRightViewportEdge = position.overlayX === "start" && !isRtl || position.overlayX === "end" && isRtl;
    const isBoundedByLeftViewportEdge = position.overlayX === "end" && !isRtl || position.overlayX === "start" && isRtl;
    let width, left, right;
    if (isBoundedByLeftViewportEdge) {
      right = viewport.width - origin.x + this._viewportMargin * 2;
      width = origin.x - this._viewportMargin;
    } else if (isBoundedByRightViewportEdge) {
      left = origin.x;
      width = viewport.right - origin.x;
    } else {
      const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);
      const previousWidth = this._lastBoundingBoxSize.width;
      width = smallestDistanceToViewportEdge * 2;
      left = origin.x - smallestDistanceToViewportEdge;
      if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {
        left = origin.x - previousWidth / 2;
      }
    }
    return {
      top,
      left,
      bottom,
      right,
      width,
      height
    };
  }
  /**
   * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
   * origin's connection point and stretches to the bounds of the viewport.
   *
   * @param origin The point on the origin element where the overlay is connected.
   * @param position The position preference
   */
  _setBoundingBoxStyles(origin, position) {
    const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);
    if (!this._isInitialRender && !this._growAfterOpen) {
      boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);
      boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);
    }
    const styles = {};
    if (this._hasExactPosition()) {
      styles.top = styles.left = "0";
      styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = "";
      styles.width = styles.height = "100%";
    } else {
      const maxHeight = this._overlayRef.getConfig().maxHeight;
      const maxWidth = this._overlayRef.getConfig().maxWidth;
      styles.height = coerceCssPixelValue(boundingBoxRect.height);
      styles.top = coerceCssPixelValue(boundingBoxRect.top);
      styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);
      styles.width = coerceCssPixelValue(boundingBoxRect.width);
      styles.left = coerceCssPixelValue(boundingBoxRect.left);
      styles.right = coerceCssPixelValue(boundingBoxRect.right);
      if (position.overlayX === "center") {
        styles.alignItems = "center";
      } else {
        styles.alignItems = position.overlayX === "end" ? "flex-end" : "flex-start";
      }
      if (position.overlayY === "center") {
        styles.justifyContent = "center";
      } else {
        styles.justifyContent = position.overlayY === "bottom" ? "flex-end" : "flex-start";
      }
      if (maxHeight) {
        styles.maxHeight = coerceCssPixelValue(maxHeight);
      }
      if (maxWidth) {
        styles.maxWidth = coerceCssPixelValue(maxWidth);
      }
    }
    this._lastBoundingBoxSize = boundingBoxRect;
    extendStyles(this._boundingBox.style, styles);
  }
  /** Resets the styles for the bounding box so that a new positioning can be computed. */
  _resetBoundingBoxStyles() {
    extendStyles(this._boundingBox.style, {
      top: "0",
      left: "0",
      right: "0",
      bottom: "0",
      height: "",
      width: "",
      alignItems: "",
      justifyContent: ""
    });
  }
  /** Resets the styles for the overlay pane so that a new positioning can be computed. */
  _resetOverlayElementStyles() {
    extendStyles(this._pane.style, {
      top: "",
      left: "",
      bottom: "",
      right: "",
      position: "",
      transform: ""
    });
  }
  /** Sets positioning styles to the overlay element. */
  _setOverlayElementStyles(originPoint, position) {
    const styles = {};
    const hasExactPosition = this._hasExactPosition();
    const hasFlexibleDimensions = this._hasFlexibleDimensions;
    const config = this._overlayRef.getConfig();
    if (hasExactPosition) {
      const scrollPosition = this._viewportRuler.getViewportScrollPosition();
      extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));
      extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));
    } else {
      styles.position = "static";
    }
    let transformString = "";
    let offsetX = this._getOffset(position, "x");
    let offsetY = this._getOffset(position, "y");
    if (offsetX) {
      transformString += `translateX(${offsetX}px) `;
    }
    if (offsetY) {
      transformString += `translateY(${offsetY}px)`;
    }
    styles.transform = transformString.trim();
    if (config.maxHeight) {
      if (hasExactPosition) {
        styles.maxHeight = coerceCssPixelValue(config.maxHeight);
      } else if (hasFlexibleDimensions) {
        styles.maxHeight = "";
      }
    }
    if (config.maxWidth) {
      if (hasExactPosition) {
        styles.maxWidth = coerceCssPixelValue(config.maxWidth);
      } else if (hasFlexibleDimensions) {
        styles.maxWidth = "";
      }
    }
    extendStyles(this._pane.style, styles);
  }
  /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */
  _getExactOverlayY(position, originPoint, scrollPosition) {
    let styles = {
      top: "",
      bottom: ""
    };
    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
    if (this._isPushed) {
      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
    }
    if (position.overlayY === "bottom") {
      const documentHeight = this._document.documentElement.clientHeight;
      styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;
    } else {
      styles.top = coerceCssPixelValue(overlayPoint.y);
    }
    return styles;
  }
  /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */
  _getExactOverlayX(position, originPoint, scrollPosition) {
    let styles = {
      left: "",
      right: ""
    };
    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
    if (this._isPushed) {
      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
    }
    let horizontalStyleProperty;
    if (this._isRtl()) {
      horizontalStyleProperty = position.overlayX === "end" ? "left" : "right";
    } else {
      horizontalStyleProperty = position.overlayX === "end" ? "right" : "left";
    }
    if (horizontalStyleProperty === "right") {
      const documentWidth = this._document.documentElement.clientWidth;
      styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;
    } else {
      styles.left = coerceCssPixelValue(overlayPoint.x);
    }
    return styles;
  }
  /**
   * Gets the view properties of the trigger and overlay, including whether they are clipped
   * or completely outside the view of any of the strategy's scrollables.
   */
  _getScrollVisibility() {
    const originBounds = this._getOriginRect();
    const overlayBounds = this._pane.getBoundingClientRect();
    const scrollContainerBounds = this._scrollables.map((scrollable) => {
      return scrollable.getElementRef().nativeElement.getBoundingClientRect();
    });
    return {
      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),
      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),
      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),
      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds)
    };
  }
  /** Subtracts the amount that an element is overflowing on an axis from its length. */
  _subtractOverflows(length, ...overflows) {
    return overflows.reduce((currentValue, currentOverflow) => {
      return currentValue - Math.max(currentOverflow, 0);
    }, length);
  }
  /** Narrows the given viewport rect by the current _viewportMargin. */
  _getNarrowedViewportRect() {
    const width = this._document.documentElement.clientWidth;
    const height = this._document.documentElement.clientHeight;
    const scrollPosition = this._viewportRuler.getViewportScrollPosition();
    return {
      top: scrollPosition.top + this._viewportMargin,
      left: scrollPosition.left + this._viewportMargin,
      right: scrollPosition.left + width - this._viewportMargin,
      bottom: scrollPosition.top + height - this._viewportMargin,
      width: width - 2 * this._viewportMargin,
      height: height - 2 * this._viewportMargin
    };
  }
  /** Whether the we're dealing with an RTL context */
  _isRtl() {
    return this._overlayRef.getDirection() === "rtl";
  }
  /** Determines whether the overlay uses exact or flexible positioning. */
  _hasExactPosition() {
    return !this._hasFlexibleDimensions || this._isPushed;
  }
  /** Retrieves the offset of a position along the x or y axis. */
  _getOffset(position, axis) {
    if (axis === "x") {
      return position.offsetX == null ? this._offsetX : position.offsetX;
    }
    return position.offsetY == null ? this._offsetY : position.offsetY;
  }
  /** Validates that the current position match the expected values. */
  _validatePositions() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!this._preferredPositions.length) {
        throw Error("FlexibleConnectedPositionStrategy: At least one position is required.");
      }
      this._preferredPositions.forEach((pair) => {
        validateHorizontalPosition("originX", pair.originX);
        validateVerticalPosition("originY", pair.originY);
        validateHorizontalPosition("overlayX", pair.overlayX);
        validateVerticalPosition("overlayY", pair.overlayY);
      });
    }
  }
  /** Adds a single CSS class or an array of classes on the overlay panel. */
  _addPanelClasses(cssClasses) {
    if (this._pane) {
      coerceArray(cssClasses).forEach((cssClass) => {
        if (cssClass !== "" && this._appliedPanelClasses.indexOf(cssClass) === -1) {
          this._appliedPanelClasses.push(cssClass);
          this._pane.classList.add(cssClass);
        }
      });
    }
  }
  /** Clears the classes that the position strategy has applied from the overlay panel. */
  _clearPanelClasses() {
    if (this._pane) {
      this._appliedPanelClasses.forEach((cssClass) => {
        this._pane.classList.remove(cssClass);
      });
      this._appliedPanelClasses = [];
    }
  }
  /** Returns the DOMRect of the current origin. */
  _getOriginRect() {
    const origin = this._origin;
    if (origin instanceof ElementRef) {
      return origin.nativeElement.getBoundingClientRect();
    }
    if (origin instanceof Element) {
      return origin.getBoundingClientRect();
    }
    const width = origin.width || 0;
    const height = origin.height || 0;
    return {
      top: origin.y,
      bottom: origin.y + height,
      left: origin.x,
      right: origin.x + width,
      height,
      width
    };
  }
};
function extendStyles(destination, source) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      destination[key] = source[key];
    }
  }
  return destination;
}
function getPixelValue(input) {
  if (typeof input !== "number" && input != null) {
    const [value, units] = input.split(cssUnitPattern);
    return !units || units === "px" ? parseFloat(value) : null;
  }
  return input || null;
}
function getRoundedBoundingClientRect(clientRect) {
  return {
    top: Math.floor(clientRect.top),
    right: Math.floor(clientRect.right),
    bottom: Math.floor(clientRect.bottom),
    left: Math.floor(clientRect.left),
    width: Math.floor(clientRect.width),
    height: Math.floor(clientRect.height)
  };
}
function compareScrollVisibility(a, b) {
  if (a === b) {
    return true;
  }
  return a.isOriginClipped === b.isOriginClipped && a.isOriginOutsideView === b.isOriginOutsideView && a.isOverlayClipped === b.isOverlayClipped && a.isOverlayOutsideView === b.isOverlayOutsideView;
}
var wrapperClass = "cdk-global-overlay-wrapper";
var GlobalPositionStrategy = class {
  /** The overlay to which this strategy is attached. */
  _overlayRef;
  _cssPosition = "static";
  _topOffset = "";
  _bottomOffset = "";
  _alignItems = "";
  _xPosition = "";
  _xOffset = "";
  _width = "";
  _height = "";
  _isDisposed = false;
  attach(overlayRef) {
    const config = overlayRef.getConfig();
    this._overlayRef = overlayRef;
    if (this._width && !config.width) {
      overlayRef.updateSize({
        width: this._width
      });
    }
    if (this._height && !config.height) {
      overlayRef.updateSize({
        height: this._height
      });
    }
    overlayRef.hostElement.classList.add(wrapperClass);
    this._isDisposed = false;
  }
  /**
   * Sets the top position of the overlay. Clears any previously set vertical position.
   * @param value New top offset.
   */
  top(value = "") {
    this._bottomOffset = "";
    this._topOffset = value;
    this._alignItems = "flex-start";
    return this;
  }
  /**
   * Sets the left position of the overlay. Clears any previously set horizontal position.
   * @param value New left offset.
   */
  left(value = "") {
    this._xOffset = value;
    this._xPosition = "left";
    return this;
  }
  /**
   * Sets the bottom position of the overlay. Clears any previously set vertical position.
   * @param value New bottom offset.
   */
  bottom(value = "") {
    this._topOffset = "";
    this._bottomOffset = value;
    this._alignItems = "flex-end";
    return this;
  }
  /**
   * Sets the right position of the overlay. Clears any previously set horizontal position.
   * @param value New right offset.
   */
  right(value = "") {
    this._xOffset = value;
    this._xPosition = "right";
    return this;
  }
  /**
   * Sets the overlay to the start of the viewport, depending on the overlay direction.
   * This will be to the left in LTR layouts and to the right in RTL.
   * @param offset Offset from the edge of the screen.
   */
  start(value = "") {
    this._xOffset = value;
    this._xPosition = "start";
    return this;
  }
  /**
   * Sets the overlay to the end of the viewport, depending on the overlay direction.
   * This will be to the right in LTR layouts and to the left in RTL.
   * @param offset Offset from the edge of the screen.
   */
  end(value = "") {
    this._xOffset = value;
    this._xPosition = "end";
    return this;
  }
  /**
   * Sets the overlay width and clears any previously set width.
   * @param value New width for the overlay
   * @deprecated Pass the `width` through the `OverlayConfig`.
   * @breaking-change 8.0.0
   */
  width(value = "") {
    if (this._overlayRef) {
      this._overlayRef.updateSize({
        width: value
      });
    } else {
      this._width = value;
    }
    return this;
  }
  /**
   * Sets the overlay height and clears any previously set height.
   * @param value New height for the overlay
   * @deprecated Pass the `height` through the `OverlayConfig`.
   * @breaking-change 8.0.0
   */
  height(value = "") {
    if (this._overlayRef) {
      this._overlayRef.updateSize({
        height: value
      });
    } else {
      this._height = value;
    }
    return this;
  }
  /**
   * Centers the overlay horizontally with an optional offset.
   * Clears any previously set horizontal position.
   *
   * @param offset Overlay offset from the horizontal center.
   */
  centerHorizontally(offset = "") {
    this.left(offset);
    this._xPosition = "center";
    return this;
  }
  /**
   * Centers the overlay vertically with an optional offset.
   * Clears any previously set vertical position.
   *
   * @param offset Overlay offset from the vertical center.
   */
  centerVertically(offset = "") {
    this.top(offset);
    this._alignItems = "center";
    return this;
  }
  /**
   * Apply the position to the element.
   * @docs-private
   */
  apply() {
    if (!this._overlayRef || !this._overlayRef.hasAttached()) {
      return;
    }
    const styles = this._overlayRef.overlayElement.style;
    const parentStyles = this._overlayRef.hostElement.style;
    const config = this._overlayRef.getConfig();
    const {
      width,
      height,
      maxWidth,
      maxHeight
    } = config;
    const shouldBeFlushHorizontally = (width === "100%" || width === "100vw") && (!maxWidth || maxWidth === "100%" || maxWidth === "100vw");
    const shouldBeFlushVertically = (height === "100%" || height === "100vh") && (!maxHeight || maxHeight === "100%" || maxHeight === "100vh");
    const xPosition = this._xPosition;
    const xOffset = this._xOffset;
    const isRtl = this._overlayRef.getConfig().direction === "rtl";
    let marginLeft = "";
    let marginRight = "";
    let justifyContent = "";
    if (shouldBeFlushHorizontally) {
      justifyContent = "flex-start";
    } else if (xPosition === "center") {
      justifyContent = "center";
      if (isRtl) {
        marginRight = xOffset;
      } else {
        marginLeft = xOffset;
      }
    } else if (isRtl) {
      if (xPosition === "left" || xPosition === "end") {
        justifyContent = "flex-end";
        marginLeft = xOffset;
      } else if (xPosition === "right" || xPosition === "start") {
        justifyContent = "flex-start";
        marginRight = xOffset;
      }
    } else if (xPosition === "left" || xPosition === "start") {
      justifyContent = "flex-start";
      marginLeft = xOffset;
    } else if (xPosition === "right" || xPosition === "end") {
      justifyContent = "flex-end";
      marginRight = xOffset;
    }
    styles.position = this._cssPosition;
    styles.marginLeft = shouldBeFlushHorizontally ? "0" : marginLeft;
    styles.marginTop = shouldBeFlushVertically ? "0" : this._topOffset;
    styles.marginBottom = this._bottomOffset;
    styles.marginRight = shouldBeFlushHorizontally ? "0" : marginRight;
    parentStyles.justifyContent = justifyContent;
    parentStyles.alignItems = shouldBeFlushVertically ? "flex-start" : this._alignItems;
  }
  /**
   * Cleans up the DOM changes from the position strategy.
   * @docs-private
   */
  dispose() {
    if (this._isDisposed || !this._overlayRef) {
      return;
    }
    const styles = this._overlayRef.overlayElement.style;
    const parent = this._overlayRef.hostElement;
    const parentStyles = parent.style;
    parent.classList.remove(wrapperClass);
    parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop = styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = "";
    this._overlayRef = null;
    this._isDisposed = true;
  }
};
var OverlayPositionBuilder = class _OverlayPositionBuilder {
  _viewportRuler = inject(ViewportRuler);
  _document = inject(DOCUMENT);
  _platform = inject(Platform);
  _overlayContainer = inject(OverlayContainer);
  constructor() {
  }
  /**
   * Creates a global position strategy.
   */
  global() {
    return new GlobalPositionStrategy();
  }
  /**
   * Creates a flexible position strategy.
   * @param origin Origin relative to which to position the overlay.
   */
  flexibleConnectedTo(origin) {
    return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
  }
  static ɵfac = function OverlayPositionBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OverlayPositionBuilder)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _OverlayPositionBuilder,
    factory: _OverlayPositionBuilder.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayPositionBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var Overlay = class _Overlay {
  scrollStrategies = inject(ScrollStrategyOptions);
  _overlayContainer = inject(OverlayContainer);
  _positionBuilder = inject(OverlayPositionBuilder);
  _keyboardDispatcher = inject(OverlayKeyboardDispatcher);
  _injector = inject(Injector);
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  _directionality = inject(Directionality);
  _location = inject(Location);
  _outsideClickDispatcher = inject(OverlayOutsideClickDispatcher);
  _animationsModuleType = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  _idGenerator = inject(_IdGenerator);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _appRef;
  _styleLoader = inject(_CdkPrivateStyleLoader);
  constructor() {
  }
  /**
   * Creates an overlay.
   * @param config Configuration applied to the overlay.
   * @returns Reference to the created overlay.
   */
  create(config) {
    this._styleLoader.load(_CdkOverlayStyleLoader);
    const host = this._createHostElement();
    const pane = this._createPaneElement(host);
    const portalOutlet = this._createPortalOutlet(pane);
    const overlayConfig = new OverlayConfig(config);
    overlayConfig.direction = overlayConfig.direction || this._directionality.value;
    return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher, this._animationsModuleType === "NoopAnimations", this._injector.get(EnvironmentInjector), this._renderer);
  }
  /**
   * Gets a position builder that can be used, via fluent API,
   * to construct and configure a position strategy.
   * @returns An overlay position builder.
   */
  position() {
    return this._positionBuilder;
  }
  /**
   * Creates the DOM element for an overlay and appends it to the overlay container.
   * @returns Newly-created pane element
   */
  _createPaneElement(host) {
    const pane = this._document.createElement("div");
    pane.id = this._idGenerator.getId("cdk-overlay-");
    pane.classList.add("cdk-overlay-pane");
    host.appendChild(pane);
    return pane;
  }
  /**
   * Creates the host element that wraps around an overlay
   * and can be used for advanced positioning.
   * @returns Newly-create host element.
   */
  _createHostElement() {
    const host = this._document.createElement("div");
    this._overlayContainer.getContainerElement().appendChild(host);
    return host;
  }
  /**
   * Create a DomPortalOutlet into which the overlay content can be loaded.
   * @param pane The DOM element to turn into a portal outlet.
   * @returns A portal outlet for the given DOM element.
   */
  _createPortalOutlet(pane) {
    if (!this._appRef) {
      this._appRef = this._injector.get(ApplicationRef);
    }
    return new DomPortalOutlet(pane, null, this._appRef, this._injector, this._document);
  }
  static ɵfac = function Overlay_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Overlay)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _Overlay,
    factory: _Overlay.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Overlay, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var defaultPositionList = [{
  originX: "start",
  originY: "bottom",
  overlayX: "start",
  overlayY: "top"
}, {
  originX: "start",
  originY: "top",
  overlayX: "start",
  overlayY: "bottom"
}, {
  originX: "end",
  originY: "top",
  overlayX: "end",
  overlayY: "bottom"
}, {
  originX: "end",
  originY: "bottom",
  overlayX: "end",
  overlayY: "top"
}];
var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken("cdk-connected-overlay-scroll-strategy", {
  providedIn: "root",
  factory: () => {
    const overlay = inject(Overlay);
    return () => overlay.scrollStrategies.reposition();
  }
});
var CdkOverlayOrigin = class _CdkOverlayOrigin {
  elementRef = inject(ElementRef);
  constructor() {
  }
  static ɵfac = function CdkOverlayOrigin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkOverlayOrigin)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkOverlayOrigin,
    selectors: [["", "cdk-overlay-origin", ""], ["", "overlay-origin", ""], ["", "cdkOverlayOrigin", ""]],
    exportAs: ["cdkOverlayOrigin"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkOverlayOrigin, [{
    type: Directive,
    args: [{
      selector: "[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]",
      exportAs: "cdkOverlayOrigin"
    }]
  }], () => [], null);
})();
var CdkConnectedOverlay = class _CdkConnectedOverlay {
  _overlay = inject(Overlay);
  _dir = inject(Directionality, {
    optional: true
  });
  _overlayRef;
  _templatePortal;
  _backdropSubscription = Subscription.EMPTY;
  _attachSubscription = Subscription.EMPTY;
  _detachSubscription = Subscription.EMPTY;
  _positionSubscription = Subscription.EMPTY;
  _offsetX;
  _offsetY;
  _position;
  _scrollStrategyFactory = inject(CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY);
  _disposeOnNavigation = false;
  _ngZone = inject(NgZone);
  /** Origin for the connected overlay. */
  origin;
  /** Registered connected position pairs. */
  positions;
  /**
   * This input overrides the positions input if specified. It lets users pass
   * in arbitrary positioning strategies.
   */
  positionStrategy;
  /** The offset in pixels for the overlay connection point on the x-axis */
  get offsetX() {
    return this._offsetX;
  }
  set offsetX(offsetX) {
    this._offsetX = offsetX;
    if (this._position) {
      this._updatePositionStrategy(this._position);
    }
  }
  /** The offset in pixels for the overlay connection point on the y-axis */
  get offsetY() {
    return this._offsetY;
  }
  set offsetY(offsetY) {
    this._offsetY = offsetY;
    if (this._position) {
      this._updatePositionStrategy(this._position);
    }
  }
  /** The width of the overlay panel. */
  width;
  /** The height of the overlay panel. */
  height;
  /** The min width of the overlay panel. */
  minWidth;
  /** The min height of the overlay panel. */
  minHeight;
  /** The custom class to be set on the backdrop element. */
  backdropClass;
  /** The custom class to add to the overlay pane element. */
  panelClass;
  /** Margin between the overlay and the viewport edges. */
  viewportMargin = 0;
  /** Strategy to be used when handling scroll events while the overlay is open. */
  scrollStrategy;
  /** Whether the overlay is open. */
  open = false;
  /** Whether the overlay can be closed by user interaction. */
  disableClose = false;
  /** CSS selector which to set the transform origin. */
  transformOriginSelector;
  /** Whether or not the overlay should attach a backdrop. */
  hasBackdrop = false;
  /** Whether or not the overlay should be locked when scrolling. */
  lockPosition = false;
  /** Whether the overlay's width and height can be constrained to fit within the viewport. */
  flexibleDimensions = false;
  /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */
  growAfterOpen = false;
  /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */
  push = false;
  /** Whether the overlay should be disposed of when the user goes backwards/forwards in history. */
  get disposeOnNavigation() {
    return this._disposeOnNavigation;
  }
  set disposeOnNavigation(value) {
    this._disposeOnNavigation = value;
  }
  /** Event emitted when the backdrop is clicked. */
  backdropClick = new EventEmitter();
  /** Event emitted when the position has changed. */
  positionChange = new EventEmitter();
  /** Event emitted when the overlay has been attached. */
  attach = new EventEmitter();
  /** Event emitted when the overlay has been detached. */
  detach = new EventEmitter();
  /** Emits when there are keyboard events that are targeted at the overlay. */
  overlayKeydown = new EventEmitter();
  /** Emits when there are mouse outside click events that are targeted at the overlay. */
  overlayOutsideClick = new EventEmitter();
  // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.
  constructor() {
    const templateRef = inject(TemplateRef);
    const viewContainerRef = inject(ViewContainerRef);
    this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);
    this.scrollStrategy = this._scrollStrategyFactory();
  }
  /** The associated overlay reference. */
  get overlayRef() {
    return this._overlayRef;
  }
  /** The element's layout direction. */
  get dir() {
    return this._dir ? this._dir.value : "ltr";
  }
  ngOnDestroy() {
    this._attachSubscription.unsubscribe();
    this._detachSubscription.unsubscribe();
    this._backdropSubscription.unsubscribe();
    this._positionSubscription.unsubscribe();
    if (this._overlayRef) {
      this._overlayRef.dispose();
    }
  }
  ngOnChanges(changes) {
    if (this._position) {
      this._updatePositionStrategy(this._position);
      this._overlayRef.updateSize({
        width: this.width,
        minWidth: this.minWidth,
        height: this.height,
        minHeight: this.minHeight
      });
      if (changes["origin"] && this.open) {
        this._position.apply();
      }
    }
    if (changes["open"]) {
      this.open ? this._attachOverlay() : this._detachOverlay();
    }
  }
  /** Creates an overlay */
  _createOverlay() {
    if (!this.positions || !this.positions.length) {
      this.positions = defaultPositionList;
    }
    const overlayRef = this._overlayRef = this._overlay.create(this._buildConfig());
    this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());
    this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());
    overlayRef.keydownEvents().subscribe((event) => {
      this.overlayKeydown.next(event);
      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {
        event.preventDefault();
        this._detachOverlay();
      }
    });
    this._overlayRef.outsidePointerEvents().subscribe((event) => {
      const origin = this._getOriginElement();
      const target = _getEventTarget(event);
      if (!origin || origin !== target && !origin.contains(target)) {
        this.overlayOutsideClick.next(event);
      }
    });
  }
  /** Builds the overlay config based on the directive's inputs */
  _buildConfig() {
    const positionStrategy = this._position = this.positionStrategy || this._createPositionStrategy();
    const overlayConfig = new OverlayConfig({
      direction: this._dir || "ltr",
      positionStrategy,
      scrollStrategy: this.scrollStrategy,
      hasBackdrop: this.hasBackdrop,
      disposeOnNavigation: this.disposeOnNavigation
    });
    if (this.width || this.width === 0) {
      overlayConfig.width = this.width;
    }
    if (this.height || this.height === 0) {
      overlayConfig.height = this.height;
    }
    if (this.minWidth || this.minWidth === 0) {
      overlayConfig.minWidth = this.minWidth;
    }
    if (this.minHeight || this.minHeight === 0) {
      overlayConfig.minHeight = this.minHeight;
    }
    if (this.backdropClass) {
      overlayConfig.backdropClass = this.backdropClass;
    }
    if (this.panelClass) {
      overlayConfig.panelClass = this.panelClass;
    }
    return overlayConfig;
  }
  /** Updates the state of a position strategy, based on the values of the directive inputs. */
  _updatePositionStrategy(positionStrategy) {
    const positions = this.positions.map((currentPosition) => ({
      originX: currentPosition.originX,
      originY: currentPosition.originY,
      overlayX: currentPosition.overlayX,
      overlayY: currentPosition.overlayY,
      offsetX: currentPosition.offsetX || this.offsetX,
      offsetY: currentPosition.offsetY || this.offsetY,
      panelClass: currentPosition.panelClass || void 0
    }));
    return positionStrategy.setOrigin(this._getOrigin()).withPositions(positions).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector);
  }
  /** Returns the position strategy of the overlay to be set on the overlay config */
  _createPositionStrategy() {
    const strategy = this._overlay.position().flexibleConnectedTo(this._getOrigin());
    this._updatePositionStrategy(strategy);
    return strategy;
  }
  _getOrigin() {
    if (this.origin instanceof CdkOverlayOrigin) {
      return this.origin.elementRef;
    } else {
      return this.origin;
    }
  }
  _getOriginElement() {
    if (this.origin instanceof CdkOverlayOrigin) {
      return this.origin.elementRef.nativeElement;
    }
    if (this.origin instanceof ElementRef) {
      return this.origin.nativeElement;
    }
    if (typeof Element !== "undefined" && this.origin instanceof Element) {
      return this.origin;
    }
    return null;
  }
  /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */
  _attachOverlay() {
    if (!this._overlayRef) {
      this._createOverlay();
    } else {
      this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;
    }
    if (!this._overlayRef.hasAttached()) {
      this._overlayRef.attach(this._templatePortal);
    }
    if (this.hasBackdrop) {
      this._backdropSubscription = this._overlayRef.backdropClick().subscribe((event) => {
        this.backdropClick.emit(event);
      });
    } else {
      this._backdropSubscription.unsubscribe();
    }
    this._positionSubscription.unsubscribe();
    if (this.positionChange.observers.length > 0) {
      this._positionSubscription = this._position.positionChanges.pipe(takeWhile(() => this.positionChange.observers.length > 0)).subscribe((position) => {
        this._ngZone.run(() => this.positionChange.emit(position));
        if (this.positionChange.observers.length === 0) {
          this._positionSubscription.unsubscribe();
        }
      });
    }
  }
  /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */
  _detachOverlay() {
    if (this._overlayRef) {
      this._overlayRef.detach();
    }
    this._backdropSubscription.unsubscribe();
    this._positionSubscription.unsubscribe();
  }
  static ɵfac = function CdkConnectedOverlay_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkConnectedOverlay)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkConnectedOverlay,
    selectors: [["", "cdk-connected-overlay", ""], ["", "connected-overlay", ""], ["", "cdkConnectedOverlay", ""]],
    inputs: {
      origin: [0, "cdkConnectedOverlayOrigin", "origin"],
      positions: [0, "cdkConnectedOverlayPositions", "positions"],
      positionStrategy: [0, "cdkConnectedOverlayPositionStrategy", "positionStrategy"],
      offsetX: [0, "cdkConnectedOverlayOffsetX", "offsetX"],
      offsetY: [0, "cdkConnectedOverlayOffsetY", "offsetY"],
      width: [0, "cdkConnectedOverlayWidth", "width"],
      height: [0, "cdkConnectedOverlayHeight", "height"],
      minWidth: [0, "cdkConnectedOverlayMinWidth", "minWidth"],
      minHeight: [0, "cdkConnectedOverlayMinHeight", "minHeight"],
      backdropClass: [0, "cdkConnectedOverlayBackdropClass", "backdropClass"],
      panelClass: [0, "cdkConnectedOverlayPanelClass", "panelClass"],
      viewportMargin: [0, "cdkConnectedOverlayViewportMargin", "viewportMargin"],
      scrollStrategy: [0, "cdkConnectedOverlayScrollStrategy", "scrollStrategy"],
      open: [0, "cdkConnectedOverlayOpen", "open"],
      disableClose: [0, "cdkConnectedOverlayDisableClose", "disableClose"],
      transformOriginSelector: [0, "cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"],
      hasBackdrop: [2, "cdkConnectedOverlayHasBackdrop", "hasBackdrop", booleanAttribute],
      lockPosition: [2, "cdkConnectedOverlayLockPosition", "lockPosition", booleanAttribute],
      flexibleDimensions: [2, "cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions", booleanAttribute],
      growAfterOpen: [2, "cdkConnectedOverlayGrowAfterOpen", "growAfterOpen", booleanAttribute],
      push: [2, "cdkConnectedOverlayPush", "push", booleanAttribute],
      disposeOnNavigation: [2, "cdkConnectedOverlayDisposeOnNavigation", "disposeOnNavigation", booleanAttribute]
    },
    outputs: {
      backdropClick: "backdropClick",
      positionChange: "positionChange",
      attach: "attach",
      detach: "detach",
      overlayKeydown: "overlayKeydown",
      overlayOutsideClick: "overlayOutsideClick"
    },
    exportAs: ["cdkConnectedOverlay"],
    features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkConnectedOverlay, [{
    type: Directive,
    args: [{
      selector: "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]",
      exportAs: "cdkConnectedOverlay"
    }]
  }], () => [], {
    origin: [{
      type: Input,
      args: ["cdkConnectedOverlayOrigin"]
    }],
    positions: [{
      type: Input,
      args: ["cdkConnectedOverlayPositions"]
    }],
    positionStrategy: [{
      type: Input,
      args: ["cdkConnectedOverlayPositionStrategy"]
    }],
    offsetX: [{
      type: Input,
      args: ["cdkConnectedOverlayOffsetX"]
    }],
    offsetY: [{
      type: Input,
      args: ["cdkConnectedOverlayOffsetY"]
    }],
    width: [{
      type: Input,
      args: ["cdkConnectedOverlayWidth"]
    }],
    height: [{
      type: Input,
      args: ["cdkConnectedOverlayHeight"]
    }],
    minWidth: [{
      type: Input,
      args: ["cdkConnectedOverlayMinWidth"]
    }],
    minHeight: [{
      type: Input,
      args: ["cdkConnectedOverlayMinHeight"]
    }],
    backdropClass: [{
      type: Input,
      args: ["cdkConnectedOverlayBackdropClass"]
    }],
    panelClass: [{
      type: Input,
      args: ["cdkConnectedOverlayPanelClass"]
    }],
    viewportMargin: [{
      type: Input,
      args: ["cdkConnectedOverlayViewportMargin"]
    }],
    scrollStrategy: [{
      type: Input,
      args: ["cdkConnectedOverlayScrollStrategy"]
    }],
    open: [{
      type: Input,
      args: ["cdkConnectedOverlayOpen"]
    }],
    disableClose: [{
      type: Input,
      args: ["cdkConnectedOverlayDisableClose"]
    }],
    transformOriginSelector: [{
      type: Input,
      args: ["cdkConnectedOverlayTransformOriginOn"]
    }],
    hasBackdrop: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayHasBackdrop",
        transform: booleanAttribute
      }]
    }],
    lockPosition: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayLockPosition",
        transform: booleanAttribute
      }]
    }],
    flexibleDimensions: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayFlexibleDimensions",
        transform: booleanAttribute
      }]
    }],
    growAfterOpen: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayGrowAfterOpen",
        transform: booleanAttribute
      }]
    }],
    push: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayPush",
        transform: booleanAttribute
      }]
    }],
    disposeOnNavigation: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayDisposeOnNavigation",
        transform: booleanAttribute
      }]
    }],
    backdropClick: [{
      type: Output
    }],
    positionChange: [{
      type: Output
    }],
    attach: [{
      type: Output
    }],
    detach: [{
      type: Output
    }],
    overlayKeydown: [{
      type: Output
    }],
    overlayOutsideClick: [{
      type: Output
    }]
  });
})();
function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
  return () => overlay.scrollStrategies.reposition();
}
var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
  provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,
  deps: [Overlay],
  useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY
};
var OverlayModule = class _OverlayModule {
  static ɵfac = function OverlayModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OverlayModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _OverlayModule,
    imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],
    exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER],
    imports: [BidiModule, PortalModule, ScrollingModule, ScrollingModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],
      exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],
      providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER]
    }]
  }], null, null);
})();
var FullscreenOverlayContainer = class _FullscreenOverlayContainer extends OverlayContainer {
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _fullScreenEventName;
  _cleanupFullScreenListener;
  constructor() {
    super();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this._cleanupFullScreenListener?.();
  }
  _createContainer() {
    const eventName = this._getEventName();
    super._createContainer();
    this._adjustParentForFullscreenChange();
    if (eventName) {
      this._cleanupFullScreenListener?.();
      this._cleanupFullScreenListener = this._renderer.listen("document", eventName, () => {
        this._adjustParentForFullscreenChange();
      });
    }
  }
  _adjustParentForFullscreenChange() {
    if (this._containerElement) {
      const fullscreenElement = this.getFullscreenElement();
      const parent = fullscreenElement || this._document.body;
      parent.appendChild(this._containerElement);
    }
  }
  _getEventName() {
    if (!this._fullScreenEventName) {
      const _document = this._document;
      if (_document.fullscreenEnabled) {
        this._fullScreenEventName = "fullscreenchange";
      } else if (_document.webkitFullscreenEnabled) {
        this._fullScreenEventName = "webkitfullscreenchange";
      } else if (_document.mozFullScreenEnabled) {
        this._fullScreenEventName = "mozfullscreenchange";
      } else if (_document.msFullscreenEnabled) {
        this._fullScreenEventName = "MSFullscreenChange";
      }
    }
    return this._fullScreenEventName;
  }
  /**
   * When the page is put into fullscreen mode, a specific element is specified.
   * Only that element and its children are visible when in fullscreen mode.
   */
  getFullscreenElement() {
    const _document = this._document;
    return _document.fullscreenElement || _document.webkitFullscreenElement || _document.mozFullScreenElement || _document.msFullscreenElement || null;
  }
  static ɵfac = function FullscreenOverlayContainer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FullscreenOverlayContainer)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FullscreenOverlayContainer,
    factory: _FullscreenOverlayContainer.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FullscreenOverlayContainer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/drag-drop.mjs
function deepCloneNode(node) {
  const clone = node.cloneNode(true);
  const descendantsWithId = clone.querySelectorAll("[id]");
  const nodeName = node.nodeName.toLowerCase();
  clone.removeAttribute("id");
  for (let i = 0; i < descendantsWithId.length; i++) {
    descendantsWithId[i].removeAttribute("id");
  }
  if (nodeName === "canvas") {
    transferCanvasData(node, clone);
  } else if (nodeName === "input" || nodeName === "select" || nodeName === "textarea") {
    transferInputData(node, clone);
  }
  transferData("canvas", node, clone, transferCanvasData);
  transferData("input, textarea, select", node, clone, transferInputData);
  return clone;
}
function transferData(selector, node, clone, callback) {
  const descendantElements = node.querySelectorAll(selector);
  if (descendantElements.length) {
    const cloneElements = clone.querySelectorAll(selector);
    for (let i = 0; i < descendantElements.length; i++) {
      callback(descendantElements[i], cloneElements[i]);
    }
  }
}
var cloneUniqueId = 0;
function transferInputData(source, clone) {
  if (clone.type !== "file") {
    clone.value = source.value;
  }
  if (clone.type === "radio" && clone.name) {
    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;
  }
}
function transferCanvasData(source, clone) {
  const context = clone.getContext("2d");
  if (context) {
    try {
      context.drawImage(source, 0, 0);
    } catch {
    }
  }
}
function getMutableClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y
  };
}
function isInsideClientRect(clientRect, x, y) {
  const {
    top,
    bottom,
    left,
    right
  } = clientRect;
  return y >= top && y <= bottom && x >= left && x <= right;
}
function adjustDomRect(domRect, top, left) {
  domRect.top += top;
  domRect.bottom = domRect.top + domRect.height;
  domRect.left += left;
  domRect.right = domRect.left + domRect.width;
}
function isPointerNearDomRect(rect, threshold, pointerX, pointerY) {
  const {
    top,
    right,
    bottom,
    left,
    width,
    height
  } = rect;
  const xThreshold = width * threshold;
  const yThreshold = height * threshold;
  return pointerY > top - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;
}
var ParentPositionTracker = class {
  _document;
  /** Cached positions of the scrollable parent elements. */
  positions = /* @__PURE__ */ new Map();
  constructor(_document) {
    this._document = _document;
  }
  /** Clears the cached positions. */
  clear() {
    this.positions.clear();
  }
  /** Caches the positions. Should be called at the beginning of a drag sequence. */
  cache(elements) {
    this.clear();
    this.positions.set(this._document, {
      scrollPosition: this.getViewportScrollPosition()
    });
    elements.forEach((element) => {
      this.positions.set(element, {
        scrollPosition: {
          top: element.scrollTop,
          left: element.scrollLeft
        },
        clientRect: getMutableClientRect(element)
      });
    });
  }
  /** Handles scrolling while a drag is taking place. */
  handleScroll(event) {
    const target = _getEventTarget(event);
    const cachedPosition = this.positions.get(target);
    if (!cachedPosition) {
      return null;
    }
    const scrollPosition = cachedPosition.scrollPosition;
    let newTop;
    let newLeft;
    if (target === this._document) {
      const viewportScrollPosition = this.getViewportScrollPosition();
      newTop = viewportScrollPosition.top;
      newLeft = viewportScrollPosition.left;
    } else {
      newTop = target.scrollTop;
      newLeft = target.scrollLeft;
    }
    const topDifference = scrollPosition.top - newTop;
    const leftDifference = scrollPosition.left - newLeft;
    this.positions.forEach((position, node) => {
      if (position.clientRect && target !== node && target.contains(node)) {
        adjustDomRect(position.clientRect, topDifference, leftDifference);
      }
    });
    scrollPosition.top = newTop;
    scrollPosition.left = newLeft;
    return {
      top: topDifference,
      left: leftDifference
    };
  }
  /**
   * Gets the scroll position of the viewport. Note that we use the scrollX and scrollY directly,
   * instead of going through the `ViewportRuler`, because the first value the ruler looks at is
   * the top/left offset of the `document.documentElement` which works for most cases, but breaks
   * if the element is offset by something like the `BlockScrollStrategy`.
   */
  getViewportScrollPosition() {
    return {
      top: window.scrollY,
      left: window.scrollX
    };
  }
};
function getRootNode(viewRef, _document) {
  const rootNodes = viewRef.rootNodes;
  if (rootNodes.length === 1 && rootNodes[0].nodeType === _document.ELEMENT_NODE) {
    return rootNodes[0];
  }
  const wrapper = _document.createElement("div");
  rootNodes.forEach((node) => wrapper.appendChild(node));
  return wrapper;
}
function extendStyles2(dest, source, importantProperties2) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      const value = source[key];
      if (value) {
        dest.setProperty(key, value, importantProperties2?.has(key) ? "important" : "");
      } else {
        dest.removeProperty(key);
      }
    }
  }
  return dest;
}
function toggleNativeDragInteractions(element, enable) {
  const userSelect = enable ? "" : "none";
  extendStyles2(element.style, {
    "touch-action": enable ? "" : "none",
    "-webkit-user-drag": enable ? "" : "none",
    "-webkit-tap-highlight-color": enable ? "" : "transparent",
    "user-select": userSelect,
    "-ms-user-select": userSelect,
    "-webkit-user-select": userSelect,
    "-moz-user-select": userSelect
  });
}
function toggleVisibility(element, enable, importantProperties2) {
  extendStyles2(element.style, {
    position: enable ? "" : "fixed",
    top: enable ? "" : "0",
    opacity: enable ? "" : "0",
    left: enable ? "" : "-999em"
  }, importantProperties2);
}
function combineTransforms(transform, initialTransform) {
  return initialTransform && initialTransform != "none" ? transform + " " + initialTransform : transform;
}
function matchElementSize(target, sourceRect) {
  target.style.width = `${sourceRect.width}px`;
  target.style.height = `${sourceRect.height}px`;
  target.style.transform = getTransform(sourceRect.left, sourceRect.top);
}
function getTransform(x, y) {
  return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
}
function parseCssTimeUnitsToMs(value) {
  const multiplier = value.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
  return parseFloat(value) * multiplier;
}
function getTransformTransitionDurationInMs(element) {
  const computedStyle = getComputedStyle(element);
  const transitionedProperties = parseCssPropertyValue(computedStyle, "transition-property");
  const property = transitionedProperties.find((prop) => prop === "transform" || prop === "all");
  if (!property) {
    return 0;
  }
  const propertyIndex = transitionedProperties.indexOf(property);
  const rawDurations = parseCssPropertyValue(computedStyle, "transition-duration");
  const rawDelays = parseCssPropertyValue(computedStyle, "transition-delay");
  return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) + parseCssTimeUnitsToMs(rawDelays[propertyIndex]);
}
function parseCssPropertyValue(computedStyle, name) {
  const value = computedStyle.getPropertyValue(name);
  return value.split(",").map((part) => part.trim());
}
var importantProperties = /* @__PURE__ */ new Set([
  // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
  "position"
]);
var PreviewRef = class {
  _document;
  _rootElement;
  _direction;
  _initialDomRect;
  _previewTemplate;
  _previewClass;
  _pickupPositionOnPage;
  _initialTransform;
  _zIndex;
  _renderer;
  /** Reference to the view of the preview element. */
  _previewEmbeddedView;
  /** Reference to the preview element. */
  _preview;
  get element() {
    return this._preview;
  }
  constructor(_document, _rootElement, _direction, _initialDomRect, _previewTemplate, _previewClass, _pickupPositionOnPage, _initialTransform, _zIndex, _renderer) {
    this._document = _document;
    this._rootElement = _rootElement;
    this._direction = _direction;
    this._initialDomRect = _initialDomRect;
    this._previewTemplate = _previewTemplate;
    this._previewClass = _previewClass;
    this._pickupPositionOnPage = _pickupPositionOnPage;
    this._initialTransform = _initialTransform;
    this._zIndex = _zIndex;
    this._renderer = _renderer;
  }
  attach(parent) {
    this._preview = this._createPreview();
    parent.appendChild(this._preview);
    if (supportsPopover(this._preview)) {
      this._preview["showPopover"]();
    }
  }
  destroy() {
    this._preview.remove();
    this._previewEmbeddedView?.destroy();
    this._preview = this._previewEmbeddedView = null;
  }
  setTransform(value) {
    this._preview.style.transform = value;
  }
  getBoundingClientRect() {
    return this._preview.getBoundingClientRect();
  }
  addClass(className) {
    this._preview.classList.add(className);
  }
  getTransitionDuration() {
    return getTransformTransitionDurationInMs(this._preview);
  }
  addEventListener(name, handler) {
    return this._renderer.listen(this._preview, name, handler);
  }
  _createPreview() {
    const previewConfig = this._previewTemplate;
    const previewClass = this._previewClass;
    const previewTemplate = previewConfig ? previewConfig.template : null;
    let preview;
    if (previewTemplate && previewConfig) {
      const rootRect = previewConfig.matchSize ? this._initialDomRect : null;
      const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);
      viewRef.detectChanges();
      preview = getRootNode(viewRef, this._document);
      this._previewEmbeddedView = viewRef;
      if (previewConfig.matchSize) {
        matchElementSize(preview, rootRect);
      } else {
        preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);
      }
    } else {
      preview = deepCloneNode(this._rootElement);
      matchElementSize(preview, this._initialDomRect);
      if (this._initialTransform) {
        preview.style.transform = this._initialTransform;
      }
    }
    extendStyles2(preview.style, {
      // It's important that we disable the pointer events on the preview, because
      // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.
      "pointer-events": "none",
      // If the preview has a margin, it can throw off our positioning so we reset it. The reset
      // value for `margin-right` needs to be `auto` when opened as a popover, because our
      // positioning is always top/left based, but native popover seems to position itself
      // to the top/right if `<html>` or `<body>` have `dir="rtl"` (see #29604). Setting it
      // to `auto` pushed it to the top/left corner in RTL and is a noop in LTR.
      "margin": supportsPopover(preview) ? "0 auto 0 0" : "0",
      "position": "fixed",
      "top": "0",
      "left": "0",
      "z-index": this._zIndex + ""
    }, importantProperties);
    toggleNativeDragInteractions(preview, false);
    preview.classList.add("cdk-drag-preview");
    preview.setAttribute("popover", "manual");
    preview.setAttribute("dir", this._direction);
    if (previewClass) {
      if (Array.isArray(previewClass)) {
        previewClass.forEach((className) => preview.classList.add(className));
      } else {
        preview.classList.add(previewClass);
      }
    }
    return preview;
  }
};
function supportsPopover(element) {
  return "showPopover" in element;
}
var passiveEventListenerOptions = normalizePassiveListenerOptions({
  passive: true
});
var activeEventListenerOptions = normalizePassiveListenerOptions({
  passive: false
});
var activeCapturingEventOptions$1 = normalizePassiveListenerOptions({
  passive: false,
  capture: true
});
var MOUSE_EVENT_IGNORE_TIME = 800;
var dragImportantProperties = /* @__PURE__ */ new Set([
  // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
  "position"
]);
var DragRef = class {
  _config;
  _document;
  _ngZone;
  _viewportRuler;
  _dragDropRegistry;
  _renderer;
  /** Element displayed next to the user's pointer while the element is dragged. */
  _preview;
  /** Container into which to insert the preview. */
  _previewContainer;
  /** Reference to the view of the placeholder element. */
  _placeholderRef;
  /** Element that is rendered instead of the draggable item while it is being sorted. */
  _placeholder;
  /** Coordinates within the element at which the user picked up the element. */
  _pickupPositionInElement;
  /** Coordinates on the page at which the user picked up the element. */
  _pickupPositionOnPage;
  /**
   * Anchor node used to save the place in the DOM where the element was
   * picked up so that it can be restored at the end of the drag sequence.
   */
  _anchor;
  /**
   * CSS `transform` applied to the element when it isn't being dragged. We need a
   * passive transform in order for the dragged element to retain its new position
   * after the user has stopped dragging and because we need to know the relative
   * position in case they start dragging again. This corresponds to `element.style.transform`.
   */
  _passiveTransform = {
    x: 0,
    y: 0
  };
  /** CSS `transform` that is applied to the element while it's being dragged. */
  _activeTransform = {
    x: 0,
    y: 0
  };
  /** Inline `transform` value that the element had before the first dragging sequence. */
  _initialTransform;
  /**
   * Whether the dragging sequence has been started. Doesn't
   * necessarily mean that the element has been moved.
   */
  _hasStartedDragging = signal(false);
  /** Whether the element has moved since the user started dragging it. */
  _hasMoved;
  /** Drop container in which the DragRef resided when dragging began. */
  _initialContainer;
  /** Index at which the item started in its initial container. */
  _initialIndex;
  /** Cached positions of scrollable parent elements. */
  _parentPositions;
  /** Emits when the item is being moved. */
  _moveEvents = new Subject();
  /** Keeps track of the direction in which the user is dragging along each axis. */
  _pointerDirectionDelta;
  /** Pointer position at which the last change in the delta occurred. */
  _pointerPositionAtLastDirectionChange;
  /** Position of the pointer at the last pointer event. */
  _lastKnownPointerPosition;
  /**
   * Root DOM node of the drag instance. This is the element that will
   * be moved around as the user is dragging.
   */
  _rootElement;
  /**
   * Nearest ancestor SVG, relative to which coordinates are calculated if dragging SVGElement
   */
  _ownerSVGElement;
  /**
   * Inline style value of `-webkit-tap-highlight-color` at the time the
   * dragging was started. Used to restore the value once we're done dragging.
   */
  _rootElementTapHighlight;
  /** Subscription to pointer movement events. */
  _pointerMoveSubscription = Subscription.EMPTY;
  /** Subscription to the event that is dispatched when the user lifts their pointer. */
  _pointerUpSubscription = Subscription.EMPTY;
  /** Subscription to the viewport being scrolled. */
  _scrollSubscription = Subscription.EMPTY;
  /** Subscription to the viewport being resized. */
  _resizeSubscription = Subscription.EMPTY;
  /**
   * Time at which the last touch event occurred. Used to avoid firing the same
   * events multiple times on touch devices where the browser will fire a fake
   * mouse event for each touch event, after a certain time.
   */
  _lastTouchEventTime;
  /** Time at which the last dragging sequence was started. */
  _dragStartTime;
  /** Cached reference to the boundary element. */
  _boundaryElement = null;
  /** Whether the native dragging interactions have been enabled on the root element. */
  _nativeInteractionsEnabled = true;
  /** Client rect of the root element when the dragging sequence has started. */
  _initialDomRect;
  /** Cached dimensions of the preview element. Should be read via `_getPreviewRect`. */
  _previewRect;
  /** Cached dimensions of the boundary element. */
  _boundaryRect;
  /** Element that will be used as a template to create the draggable item's preview. */
  _previewTemplate;
  /** Template for placeholder element rendered to show where a draggable would be dropped. */
  _placeholderTemplate;
  /** Elements that can be used to drag the draggable item. */
  _handles = [];
  /** Registered handles that are currently disabled. */
  _disabledHandles = /* @__PURE__ */ new Set();
  /** Droppable container that the draggable is a part of. */
  _dropContainer;
  /** Layout direction of the item. */
  _direction = "ltr";
  /** Ref that the current drag item is nested in. */
  _parentDragRef;
  /**
   * Cached shadow root that the element is placed in. `null` means that the element isn't in
   * the shadow DOM and `undefined` means that it hasn't been resolved yet. Should be read via
   * `_getShadowRoot`, not directly.
   */
  _cachedShadowRoot;
  /** Axis along which dragging is locked. */
  lockAxis;
  /**
   * Amount of milliseconds to wait after the user has put their
   * pointer down before starting to drag the element.
   */
  dragStartDelay = 0;
  /** Class to be added to the preview element. */
  previewClass;
  /**
   * If the parent of the dragged element has a `scale` transform, it can throw off the
   * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
   */
  scale = 1;
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);
  }
  set disabled(value) {
    if (value !== this._disabled) {
      this._disabled = value;
      this._toggleNativeDragInteractions();
      this._handles.forEach((handle) => toggleNativeDragInteractions(handle, value));
    }
  }
  _disabled = false;
  /** Emits as the drag sequence is being prepared. */
  beforeStarted = new Subject();
  /** Emits when the user starts dragging the item. */
  started = new Subject();
  /** Emits when the user has released a drag item, before any animations have started. */
  released = new Subject();
  /** Emits when the user stops dragging an item in the container. */
  ended = new Subject();
  /** Emits when the user has moved the item into a new container. */
  entered = new Subject();
  /** Emits when the user removes the item its container by dragging it into another container. */
  exited = new Subject();
  /** Emits when the user drops the item inside a container. */
  dropped = new Subject();
  /**
   * Emits as the user is dragging the item. Use with caution,
   * because this event will fire for every pixel that the user has dragged.
   */
  moved = this._moveEvents;
  /** Arbitrary data that can be attached to the drag item. */
  data;
  /**
   * Function that can be used to customize the logic of how the position of the drag item
   * is limited while it's being dragged. Gets called with a point containing the current position
   * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
   * Should return a point describing where the item should be rendered.
   */
  constrainPosition;
  constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry, _renderer) {
    this._config = _config;
    this._document = _document;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._dragDropRegistry = _dragDropRegistry;
    this._renderer = _renderer;
    this.withRootElement(element).withParent(_config.parentDragRef || null);
    this._parentPositions = new ParentPositionTracker(_document);
    _dragDropRegistry.registerDragItem(this);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._placeholder;
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._rootElement;
  }
  /**
   * Gets the currently-visible element that represents the drag item.
   * While dragging this is the placeholder, otherwise it's the root element.
   */
  getVisibleElement() {
    return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();
  }
  /** Registers the handles that can be used to drag the element. */
  withHandles(handles) {
    this._handles = handles.map((handle) => coerceElement(handle));
    this._handles.forEach((handle) => toggleNativeDragInteractions(handle, this.disabled));
    this._toggleNativeDragInteractions();
    const disabledHandles = /* @__PURE__ */ new Set();
    this._disabledHandles.forEach((handle) => {
      if (this._handles.indexOf(handle) > -1) {
        disabledHandles.add(handle);
      }
    });
    this._disabledHandles = disabledHandles;
    return this;
  }
  /**
   * Registers the template that should be used for the drag preview.
   * @param template Template that from which to stamp out the preview.
   */
  withPreviewTemplate(template) {
    this._previewTemplate = template;
    return this;
  }
  /**
   * Registers the template that should be used for the drag placeholder.
   * @param template Template that from which to stamp out the placeholder.
   */
  withPlaceholderTemplate(template) {
    this._placeholderTemplate = template;
    return this;
  }
  /**
   * Sets an alternate drag root element. The root element is the element that will be moved as
   * the user is dragging. Passing an alternate root element is useful when trying to enable
   * dragging on an element that you might not have access to.
   */
  withRootElement(rootElement) {
    const element = coerceElement(rootElement);
    if (element !== this._rootElement) {
      if (this._rootElement) {
        this._removeRootElementListeners(this._rootElement);
      }
      this._ngZone.runOutsideAngular(() => {
        element.addEventListener("mousedown", this._pointerDown, activeEventListenerOptions);
        element.addEventListener("touchstart", this._pointerDown, passiveEventListenerOptions);
        element.addEventListener("dragstart", this._nativeDragStart, activeEventListenerOptions);
      });
      this._initialTransform = void 0;
      this._rootElement = element;
    }
    if (typeof SVGElement !== "undefined" && this._rootElement instanceof SVGElement) {
      this._ownerSVGElement = this._rootElement.ownerSVGElement;
    }
    return this;
  }
  /**
   * Element to which the draggable's position will be constrained.
   */
  withBoundaryElement(boundaryElement) {
    this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;
    this._resizeSubscription.unsubscribe();
    if (boundaryElement) {
      this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize());
    }
    return this;
  }
  /** Sets the parent ref that the ref is nested in.  */
  withParent(parent) {
    this._parentDragRef = parent;
    return this;
  }
  /** Removes the dragging functionality from the DOM element. */
  dispose() {
    this._removeRootElementListeners(this._rootElement);
    if (this.isDragging()) {
      this._rootElement?.remove();
    }
    this._anchor?.remove();
    this._destroyPreview();
    this._destroyPlaceholder();
    this._dragDropRegistry.removeDragItem(this);
    this._removeListeners();
    this.beforeStarted.complete();
    this.started.complete();
    this.released.complete();
    this.ended.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this._moveEvents.complete();
    this._handles = [];
    this._disabledHandles.clear();
    this._dropContainer = void 0;
    this._resizeSubscription.unsubscribe();
    this._parentPositions.clear();
    this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._anchor = this._parentDragRef = null;
  }
  /** Checks whether the element is currently being dragged. */
  isDragging() {
    return this._hasStartedDragging() && this._dragDropRegistry.isDragging(this);
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._rootElement.style.transform = this._initialTransform || "";
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform = {
      x: 0,
      y: 0
    };
  }
  /**
   * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.
   * @param handle Handle element that should be disabled.
   */
  disableHandle(handle) {
    if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {
      this._disabledHandles.add(handle);
      toggleNativeDragInteractions(handle, true);
    }
  }
  /**
   * Enables a handle, if it has been disabled.
   * @param handle Handle element to be enabled.
   */
  enableHandle(handle) {
    if (this._disabledHandles.has(handle)) {
      this._disabledHandles.delete(handle);
      toggleNativeDragInteractions(handle, this.disabled);
    }
  }
  /** Sets the layout direction of the draggable item. */
  withDirection(direction) {
    this._direction = direction;
    return this;
  }
  /** Sets the container that the item is part of. */
  _withDropContainer(container) {
    this._dropContainer = container;
  }
  /**
   * Gets the current position in pixels the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    const position = this.isDragging() ? this._activeTransform : this._passiveTransform;
    return {
      x: position.x,
      y: position.y
    };
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform.x = value.x;
    this._passiveTransform.y = value.y;
    if (!this._dropContainer) {
      this._applyRootElementTransform(value.x, value.y);
    }
    return this;
  }
  /**
   * Sets the container into which to insert the preview element.
   * @param value Container into which to insert the preview.
   */
  withPreviewContainer(value) {
    this._previewContainer = value;
    return this;
  }
  /** Updates the item's sort order based on the last-known pointer position. */
  _sortFromLastPointerPosition() {
    const position = this._lastKnownPointerPosition;
    if (position && this._dropContainer) {
      this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);
    }
  }
  /** Unsubscribes from the global subscriptions. */
  _removeListeners() {
    this._pointerMoveSubscription.unsubscribe();
    this._pointerUpSubscription.unsubscribe();
    this._scrollSubscription.unsubscribe();
    this._getShadowRoot()?.removeEventListener("selectstart", shadowDomSelectStart, activeCapturingEventOptions$1);
  }
  /** Destroys the preview element and its ViewRef. */
  _destroyPreview() {
    this._preview?.destroy();
    this._preview = null;
  }
  /** Destroys the placeholder element and its ViewRef. */
  _destroyPlaceholder() {
    this._placeholder?.remove();
    this._placeholderRef?.destroy();
    this._placeholder = this._placeholderRef = null;
  }
  /** Handler for the `mousedown`/`touchstart` events. */
  _pointerDown = (event) => {
    this.beforeStarted.next();
    if (this._handles.length) {
      const targetHandle = this._getTargetHandle(event);
      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
        this._initializeDragSequence(targetHandle, event);
      }
    } else if (!this.disabled) {
      this._initializeDragSequence(this._rootElement, event);
    }
  };
  /** Handler that is invoked when the user moves their pointer after they've initiated a drag. */
  _pointerMove = (event) => {
    const pointerPosition = this._getPointerPositionOnPage(event);
    if (!this._hasStartedDragging()) {
      const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);
      const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);
      const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;
      if (isOverThreshold) {
        const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);
        const container = this._dropContainer;
        if (!isDelayElapsed) {
          this._endDragSequence(event);
          return;
        }
        if (!container || !container.isDragging() && !container.isReceiving()) {
          if (event.cancelable) {
            event.preventDefault();
          }
          this._hasStartedDragging.set(true);
          this._ngZone.run(() => this._startDragSequence(event));
        }
      }
      return;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);
    this._hasMoved = true;
    this._lastKnownPointerPosition = pointerPosition;
    this._updatePointerDirectionDelta(constrainedPointerPosition);
    if (this._dropContainer) {
      this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);
    } else {
      const offset = this.constrainPosition ? this._initialDomRect : this._pickupPositionOnPage;
      const activeTransform = this._activeTransform;
      activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;
      activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;
      this._applyRootElementTransform(activeTransform.x, activeTransform.y);
    }
    if (this._moveEvents.observers.length) {
      this._ngZone.run(() => {
        this._moveEvents.next({
          source: this,
          pointerPosition: constrainedPointerPosition,
          event,
          distance: this._getDragDistance(constrainedPointerPosition),
          delta: this._pointerDirectionDelta
        });
      });
    }
  };
  /** Handler that is invoked when the user lifts their pointer up, after initiating a drag. */
  _pointerUp = (event) => {
    this._endDragSequence(event);
  };
  /**
   * Clears subscriptions and stops the dragging sequence.
   * @param event Browser event object that ended the sequence.
   */
  _endDragSequence(event) {
    if (!this._dragDropRegistry.isDragging(this)) {
      return;
    }
    this._removeListeners();
    this._dragDropRegistry.stopDragging(this);
    this._toggleNativeDragInteractions();
    if (this._handles) {
      this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;
    }
    if (!this._hasStartedDragging()) {
      return;
    }
    this.released.next({
      source: this,
      event
    });
    if (this._dropContainer) {
      this._dropContainer._stopScrolling();
      this._animatePreviewToPlaceholder().then(() => {
        this._cleanupDragArtifacts(event);
        this._cleanupCachedDimensions();
        this._dragDropRegistry.stopDragging(this);
      });
    } else {
      this._passiveTransform.x = this._activeTransform.x;
      const pointerPosition = this._getPointerPositionOnPage(event);
      this._passiveTransform.y = this._activeTransform.y;
      this._ngZone.run(() => {
        this.ended.next({
          source: this,
          distance: this._getDragDistance(pointerPosition),
          dropPoint: pointerPosition,
          event
        });
      });
      this._cleanupCachedDimensions();
      this._dragDropRegistry.stopDragging(this);
    }
  }
  /** Starts the dragging sequence. */
  _startDragSequence(event) {
    if (isTouchEvent(event)) {
      this._lastTouchEventTime = Date.now();
    }
    this._toggleNativeDragInteractions();
    const shadowRoot = this._getShadowRoot();
    const dropContainer = this._dropContainer;
    if (shadowRoot) {
      this._ngZone.runOutsideAngular(() => {
        shadowRoot.addEventListener("selectstart", shadowDomSelectStart, activeCapturingEventOptions$1);
      });
    }
    if (dropContainer) {
      const element = this._rootElement;
      const parent = element.parentNode;
      const placeholder = this._placeholder = this._createPlaceholderElement();
      const anchor = this._anchor = this._anchor || this._document.createComment(typeof ngDevMode === "undefined" || ngDevMode ? "cdk-drag-anchor" : "");
      parent.insertBefore(anchor, element);
      this._initialTransform = element.style.transform || "";
      this._preview = new PreviewRef(this._document, this._rootElement, this._direction, this._initialDomRect, this._previewTemplate || null, this.previewClass || null, this._pickupPositionOnPage, this._initialTransform, this._config.zIndex || 1e3, this._renderer);
      this._preview.attach(this._getPreviewInsertionPoint(parent, shadowRoot));
      toggleVisibility(element, false, dragImportantProperties);
      this._document.body.appendChild(parent.replaceChild(placeholder, element));
      this.started.next({
        source: this,
        event
      });
      dropContainer.start();
      this._initialContainer = dropContainer;
      this._initialIndex = dropContainer.getItemIndex(this);
    } else {
      this.started.next({
        source: this,
        event
      });
      this._initialContainer = this._initialIndex = void 0;
    }
    this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);
  }
  /**
   * Sets up the different variables and subscriptions
   * that will be necessary for the dragging sequence.
   * @param referenceElement Element that started the drag sequence.
   * @param event Browser event object that started the sequence.
   */
  _initializeDragSequence(referenceElement, event) {
    if (this._parentDragRef) {
      event.stopPropagation();
    }
    const isDragging = this.isDragging();
    const isTouchSequence = isTouchEvent(event);
    const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;
    const rootElement = this._rootElement;
    const target = _getEventTarget(event);
    const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime && this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();
    const isFakeEvent = isTouchSequence ? isFakeTouchstartFromScreenReader(event) : isFakeMousedownFromScreenReader(event);
    if (target && target.draggable && event.type === "mousedown") {
      event.preventDefault();
    }
    if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {
      return;
    }
    if (this._handles.length) {
      const rootStyles = rootElement.style;
      this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || "";
      rootStyles.webkitTapHighlightColor = "transparent";
    }
    this._hasMoved = false;
    this._hasStartedDragging.set(this._hasMoved);
    this._removeListeners();
    this._initialDomRect = this._rootElement.getBoundingClientRect();
    this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);
    this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);
    this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((scrollEvent) => this._updateOnScroll(scrollEvent));
    if (this._boundaryElement) {
      this._boundaryRect = getMutableClientRect(this._boundaryElement);
    }
    const previewTemplate = this._previewTemplate;
    this._pickupPositionInElement = previewTemplate && previewTemplate.template && !previewTemplate.matchSize ? {
      x: 0,
      y: 0
    } : this._getPointerPositionInElement(this._initialDomRect, referenceElement, event);
    const pointerPosition = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(event);
    this._pointerDirectionDelta = {
      x: 0,
      y: 0
    };
    this._pointerPositionAtLastDirectionChange = {
      x: pointerPosition.x,
      y: pointerPosition.y
    };
    this._dragStartTime = Date.now();
    this._dragDropRegistry.startDragging(this, event);
  }
  /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */
  _cleanupDragArtifacts(event) {
    toggleVisibility(this._rootElement, true, dragImportantProperties);
    this._anchor.parentNode.replaceChild(this._rootElement, this._anchor);
    this._destroyPreview();
    this._destroyPlaceholder();
    this._initialDomRect = this._boundaryRect = this._previewRect = this._initialTransform = void 0;
    this._ngZone.run(() => {
      const container = this._dropContainer;
      const currentIndex = container.getItemIndex(this);
      const pointerPosition = this._getPointerPositionOnPage(event);
      const distance = this._getDragDistance(pointerPosition);
      const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);
      this.ended.next({
        source: this,
        distance,
        dropPoint: pointerPosition,
        event
      });
      this.dropped.next({
        item: this,
        currentIndex,
        previousIndex: this._initialIndex,
        container,
        previousContainer: this._initialContainer,
        isPointerOverContainer,
        distance,
        dropPoint: pointerPosition,
        event
      });
      container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);
      this._dropContainer = this._initialContainer;
    });
  }
  /**
   * Updates the item's position in its drop container, or moves it
   * into a new one, depending on its current drag position.
   */
  _updateActiveDropContainer({
    x,
    y
  }, {
    x: rawX,
    y: rawY
  }) {
    let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);
    if (!newContainer && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(x, y)) {
      newContainer = this._initialContainer;
    }
    if (newContainer && newContainer !== this._dropContainer) {
      this._ngZone.run(() => {
        this.exited.next({
          item: this,
          container: this._dropContainer
        });
        this._dropContainer.exit(this);
        this._dropContainer = newContainer;
        this._dropContainer.enter(this, x, y, newContainer === this._initialContainer && // If we're re-entering the initial container and sorting is disabled,
        // put item the into its starting index to begin with.
        newContainer.sortingDisabled ? this._initialIndex : void 0);
        this.entered.next({
          item: this,
          container: newContainer,
          currentIndex: newContainer.getItemIndex(this)
        });
      });
    }
    if (this.isDragging()) {
      this._dropContainer._startScrollingIfNecessary(rawX, rawY);
      this._dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);
      if (this.constrainPosition) {
        this._applyPreviewTransform(x, y);
      } else {
        this._applyPreviewTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);
      }
    }
  }
  /**
   * Animates the preview element from its current position to the location of the drop placeholder.
   * @returns Promise that resolves when the animation completes.
   */
  _animatePreviewToPlaceholder() {
    if (!this._hasMoved) {
      return Promise.resolve();
    }
    const placeholderRect = this._placeholder.getBoundingClientRect();
    this._preview.addClass("cdk-drag-animating");
    this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);
    const duration = this._preview.getTransitionDuration();
    if (duration === 0) {
      return Promise.resolve();
    }
    return this._ngZone.runOutsideAngular(() => {
      return new Promise((resolve) => {
        const handler = (event) => {
          if (!event || this._preview && _getEventTarget(event) === this._preview.element && event.propertyName === "transform") {
            cleanupListener();
            resolve();
            clearTimeout(timeout);
          }
        };
        const timeout = setTimeout(handler, duration * 1.5);
        const cleanupListener = this._preview.addEventListener("transitionend", handler);
      });
    });
  }
  /** Creates an element that will be shown instead of the current element while dragging. */
  _createPlaceholderElement() {
    const placeholderConfig = this._placeholderTemplate;
    const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;
    let placeholder;
    if (placeholderTemplate) {
      this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);
      this._placeholderRef.detectChanges();
      placeholder = getRootNode(this._placeholderRef, this._document);
    } else {
      placeholder = deepCloneNode(this._rootElement);
    }
    placeholder.style.pointerEvents = "none";
    placeholder.classList.add("cdk-drag-placeholder");
    return placeholder;
  }
  /**
   * Figures out the coordinates at which an element was picked up.
   * @param referenceElement Element that initiated the dragging.
   * @param event Event that initiated the dragging.
   */
  _getPointerPositionInElement(elementRect, referenceElement, event) {
    const handleElement = referenceElement === this._rootElement ? null : referenceElement;
    const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;
    const point = isTouchEvent(event) ? event.targetTouches[0] : event;
    const scrollPosition = this._getViewportScrollPosition();
    const x = point.pageX - referenceRect.left - scrollPosition.left;
    const y = point.pageY - referenceRect.top - scrollPosition.top;
    return {
      x: referenceRect.left - elementRect.left + x,
      y: referenceRect.top - elementRect.top + y
    };
  }
  /** Determines the point of the page that was touched by the user. */
  _getPointerPositionOnPage(event) {
    const scrollPosition = this._getViewportScrollPosition();
    const point = isTouchEvent(event) ? (
      // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.
      // Also note that on real devices we're guaranteed for either `touches` or `changedTouches`
      // to have a value, but Firefox in device emulation mode has a bug where both can be empty
      // for `touchstart` and `touchend` so we fall back to a dummy object in order to avoid
      // throwing an error. The value returned here will be incorrect, but since this only
      // breaks inside a developer tool and the value is only used for secondary information,
      // we can get away with it. See https://bugzilla.mozilla.org/show_bug.cgi?id=1615824.
      event.touches[0] || event.changedTouches[0] || {
        pageX: 0,
        pageY: 0
      }
    ) : event;
    const x = point.pageX - scrollPosition.left;
    const y = point.pageY - scrollPosition.top;
    if (this._ownerSVGElement) {
      const svgMatrix = this._ownerSVGElement.getScreenCTM();
      if (svgMatrix) {
        const svgPoint = this._ownerSVGElement.createSVGPoint();
        svgPoint.x = x;
        svgPoint.y = y;
        return svgPoint.matrixTransform(svgMatrix.inverse());
      }
    }
    return {
      x,
      y
    };
  }
  /** Gets the pointer position on the page, accounting for any position constraints. */
  _getConstrainedPointerPosition(point) {
    const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;
    let {
      x,
      y
    } = this.constrainPosition ? this.constrainPosition(point, this, this._initialDomRect, this._pickupPositionInElement) : point;
    if (this.lockAxis === "x" || dropContainerLock === "x") {
      y = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0);
    } else if (this.lockAxis === "y" || dropContainerLock === "y") {
      x = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0);
    }
    if (this._boundaryRect) {
      const {
        x: pickupX,
        y: pickupY
      } = !this.constrainPosition ? this._pickupPositionInElement : {
        x: 0,
        y: 0
      };
      const boundaryRect = this._boundaryRect;
      const {
        width: previewWidth,
        height: previewHeight
      } = this._getPreviewRect();
      const minY = boundaryRect.top + pickupY;
      const maxY = boundaryRect.bottom - (previewHeight - pickupY);
      const minX = boundaryRect.left + pickupX;
      const maxX = boundaryRect.right - (previewWidth - pickupX);
      x = clamp$1(x, minX, maxX);
      y = clamp$1(y, minY, maxY);
    }
    return {
      x,
      y
    };
  }
  /** Updates the current drag delta, based on the user's current pointer position on the page. */
  _updatePointerDirectionDelta(pointerPositionOnPage) {
    const {
      x,
      y
    } = pointerPositionOnPage;
    const delta = this._pointerDirectionDelta;
    const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;
    const changeX = Math.abs(x - positionSinceLastChange.x);
    const changeY = Math.abs(y - positionSinceLastChange.y);
    if (changeX > this._config.pointerDirectionChangeThreshold) {
      delta.x = x > positionSinceLastChange.x ? 1 : -1;
      positionSinceLastChange.x = x;
    }
    if (changeY > this._config.pointerDirectionChangeThreshold) {
      delta.y = y > positionSinceLastChange.y ? 1 : -1;
      positionSinceLastChange.y = y;
    }
    return delta;
  }
  /** Toggles the native drag interactions, based on how many handles are registered. */
  _toggleNativeDragInteractions() {
    if (!this._rootElement || !this._handles) {
      return;
    }
    const shouldEnable = this._handles.length > 0 || !this.isDragging();
    if (shouldEnable !== this._nativeInteractionsEnabled) {
      this._nativeInteractionsEnabled = shouldEnable;
      toggleNativeDragInteractions(this._rootElement, shouldEnable);
    }
  }
  /** Removes the manually-added event listeners from the root element. */
  _removeRootElementListeners(element) {
    element.removeEventListener("mousedown", this._pointerDown, activeEventListenerOptions);
    element.removeEventListener("touchstart", this._pointerDown, passiveEventListenerOptions);
    element.removeEventListener("dragstart", this._nativeDragStart, activeEventListenerOptions);
  }
  /**
   * Applies a `transform` to the root element, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyRootElementTransform(x, y) {
    const scale = 1 / this.scale;
    const transform = getTransform(x * scale, y * scale);
    const styles = this._rootElement.style;
    if (this._initialTransform == null) {
      this._initialTransform = styles.transform && styles.transform != "none" ? styles.transform : "";
    }
    styles.transform = combineTransforms(transform, this._initialTransform);
  }
  /**
   * Applies a `transform` to the preview, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyPreviewTransform(x, y) {
    const initialTransform = this._previewTemplate?.template ? void 0 : this._initialTransform;
    const transform = getTransform(x, y);
    this._preview.setTransform(combineTransforms(transform, initialTransform));
  }
  /**
   * Gets the distance that the user has dragged during the current drag sequence.
   * @param currentPosition Current position of the user's pointer.
   */
  _getDragDistance(currentPosition) {
    const pickupPosition = this._pickupPositionOnPage;
    if (pickupPosition) {
      return {
        x: currentPosition.x - pickupPosition.x,
        y: currentPosition.y - pickupPosition.y
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */
  _cleanupCachedDimensions() {
    this._boundaryRect = this._previewRect = void 0;
    this._parentPositions.clear();
  }
  /**
   * Checks whether the element is still inside its boundary after the viewport has been resized.
   * If not, the position is adjusted so that the element fits again.
   */
  _containInsideBoundaryOnResize() {
    let {
      x,
      y
    } = this._passiveTransform;
    if (x === 0 && y === 0 || this.isDragging() || !this._boundaryElement) {
      return;
    }
    const elementRect = this._rootElement.getBoundingClientRect();
    const boundaryRect = this._boundaryElement.getBoundingClientRect();
    if (boundaryRect.width === 0 && boundaryRect.height === 0 || elementRect.width === 0 && elementRect.height === 0) {
      return;
    }
    const leftOverflow = boundaryRect.left - elementRect.left;
    const rightOverflow = elementRect.right - boundaryRect.right;
    const topOverflow = boundaryRect.top - elementRect.top;
    const bottomOverflow = elementRect.bottom - boundaryRect.bottom;
    if (boundaryRect.width > elementRect.width) {
      if (leftOverflow > 0) {
        x += leftOverflow;
      }
      if (rightOverflow > 0) {
        x -= rightOverflow;
      }
    } else {
      x = 0;
    }
    if (boundaryRect.height > elementRect.height) {
      if (topOverflow > 0) {
        y += topOverflow;
      }
      if (bottomOverflow > 0) {
        y -= bottomOverflow;
      }
    } else {
      y = 0;
    }
    if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {
      this.setFreeDragPosition({
        y,
        x
      });
    }
  }
  /** Gets the drag start delay, based on the event type. */
  _getDragStartDelay(event) {
    const value = this.dragStartDelay;
    if (typeof value === "number") {
      return value;
    } else if (isTouchEvent(event)) {
      return value.touch;
    }
    return value ? value.mouse : 0;
  }
  /** Updates the internal state of the draggable element when scrolling has occurred. */
  _updateOnScroll(event) {
    const scrollDifference = this._parentPositions.handleScroll(event);
    if (scrollDifference) {
      const target = _getEventTarget(event);
      if (this._boundaryRect && target !== this._boundaryElement && target.contains(this._boundaryElement)) {
        adjustDomRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);
      }
      this._pickupPositionOnPage.x += scrollDifference.left;
      this._pickupPositionOnPage.y += scrollDifference.top;
      if (!this._dropContainer) {
        this._activeTransform.x -= scrollDifference.left;
        this._activeTransform.y -= scrollDifference.top;
        this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);
      }
    }
  }
  /** Gets the scroll position of the viewport. */
  _getViewportScrollPosition() {
    return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition();
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (this._cachedShadowRoot === void 0) {
      this._cachedShadowRoot = _getShadowRoot(this._rootElement);
    }
    return this._cachedShadowRoot;
  }
  /** Gets the element into which the drag preview should be inserted. */
  _getPreviewInsertionPoint(initialParent, shadowRoot) {
    const previewContainer = this._previewContainer || "global";
    if (previewContainer === "parent") {
      return initialParent;
    }
    if (previewContainer === "global") {
      const documentRef = this._document;
      return shadowRoot || documentRef.fullscreenElement || documentRef.webkitFullscreenElement || documentRef.mozFullScreenElement || documentRef.msFullscreenElement || documentRef.body;
    }
    return coerceElement(previewContainer);
  }
  /** Lazily resolves and returns the dimensions of the preview. */
  _getPreviewRect() {
    if (!this._previewRect || !this._previewRect.width && !this._previewRect.height) {
      this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialDomRect;
    }
    return this._previewRect;
  }
  /** Handles a native `dragstart` event. */
  _nativeDragStart = (event) => {
    if (this._handles.length) {
      const targetHandle = this._getTargetHandle(event);
      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
        event.preventDefault();
      }
    } else if (!this.disabled) {
      event.preventDefault();
    }
  };
  /** Gets a handle that is the target of an event. */
  _getTargetHandle(event) {
    return this._handles.find((handle) => {
      return event.target && (event.target === handle || handle.contains(event.target));
    });
  }
};
function clamp$1(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function isTouchEvent(event) {
  return event.type[0] === "t";
}
function shadowDomSelectStart(event) {
  event.preventDefault();
}
function moveItemInArray(array, fromIndex, toIndex) {
  const from2 = clamp(fromIndex, array.length - 1);
  const to = clamp(toIndex, array.length - 1);
  if (from2 === to) {
    return;
  }
  const target = array[from2];
  const delta = to < from2 ? -1 : 1;
  for (let i = from2; i !== to; i += delta) {
    array[i] = array[i + delta];
  }
  array[to] = target;
}
function clamp(value, max) {
  return Math.max(0, Math.min(max, value));
}
var SingleAxisSortStrategy = class {
  _dragDropRegistry;
  /** Root element container of the drop list. */
  _element;
  /** Function used to determine if an item can be sorted into a specific index. */
  _sortPredicate;
  /** Cache of the dimensions of all the items inside the container. */
  _itemPositions = [];
  /**
   * Draggable items that are currently active inside the container. Includes the items
   * that were there at the start of the sequence, as well as any items that have been dragged
   * in, but haven't been dropped yet.
   */
  _activeDraggables;
  /** Direction in which the list is oriented. */
  orientation = "vertical";
  /** Layout direction of the drop list. */
  direction;
  constructor(_dragDropRegistry) {
    this._dragDropRegistry = _dragDropRegistry;
  }
  /**
   * Keeps track of the item that was last swapped with the dragged item, as well as what direction
   * the pointer was moving in when the swap occurred and whether the user's pointer continued to
   * overlap with the swapped item after the swapping occurred.
   */
  _previousSwap = {
    drag: null,
    delta: 0,
    overlaps: false
  };
  /**
   * To be called when the drag sequence starts.
   * @param items Items that are currently in the list.
   */
  start(items) {
    this.withItems(items);
  }
  /**
   * To be called when an item is being sorted.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  sort(item, pointerX, pointerY, pointerDelta) {
    const siblings = this._itemPositions;
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);
    if (newIndex === -1 && siblings.length > 0) {
      return null;
    }
    const isHorizontal = this.orientation === "horizontal";
    const currentIndex = siblings.findIndex((currentItem) => currentItem.drag === item);
    const siblingAtNewPosition = siblings[newIndex];
    const currentPosition = siblings[currentIndex].clientRect;
    const newPosition = siblingAtNewPosition.clientRect;
    const delta = currentIndex > newIndex ? 1 : -1;
    const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);
    const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);
    const oldOrder = siblings.slice();
    moveItemInArray(siblings, currentIndex, newIndex);
    siblings.forEach((sibling, index) => {
      if (oldOrder[index] === sibling) {
        return;
      }
      const isDraggedItem = sibling.drag === item;
      const offset = isDraggedItem ? itemOffset : siblingOffset;
      const elementToOffset = isDraggedItem ? item.getPlaceholderElement() : sibling.drag.getRootElement();
      sibling.offset += offset;
      const transformAmount = Math.round(sibling.offset * (1 / sibling.drag.scale));
      if (isHorizontal) {
        elementToOffset.style.transform = combineTransforms(`translate3d(${transformAmount}px, 0, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, 0, offset);
      } else {
        elementToOffset.style.transform = combineTransforms(`translate3d(0, ${transformAmount}px, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, offset, 0);
      }
    });
    this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);
    this._previousSwap.drag = siblingAtNewPosition.drag;
    this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;
    return {
      previousIndex: currentIndex,
      currentIndex: newIndex
    };
  }
  /**
   * Called when an item is being moved into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    const newIndex = index == null || index < 0 ? (
      // We use the coordinates of where the item entered the drop
      // zone to figure out at which index it should be inserted.
      this._getItemIndexFromPointerPosition(item, pointerX, pointerY)
    ) : index;
    const activeDraggables = this._activeDraggables;
    const currentIndex = activeDraggables.indexOf(item);
    const placeholder = item.getPlaceholderElement();
    let newPositionReference = activeDraggables[newIndex];
    if (newPositionReference === item) {
      newPositionReference = activeDraggables[newIndex + 1];
    }
    if (!newPositionReference && (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) && this._shouldEnterAsFirstChild(pointerX, pointerY)) {
      newPositionReference = activeDraggables[0];
    }
    if (currentIndex > -1) {
      activeDraggables.splice(currentIndex, 1);
    }
    if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {
      const element = newPositionReference.getRootElement();
      element.parentElement.insertBefore(placeholder, element);
      activeDraggables.splice(newIndex, 0, item);
    } else {
      this._element.appendChild(placeholder);
      activeDraggables.push(item);
    }
    placeholder.style.transform = "";
    this._cacheItemPositions();
  }
  /** Sets the items that are currently part of the list. */
  withItems(items) {
    this._activeDraggables = items.slice();
    this._cacheItemPositions();
  }
  /** Assigns a sort predicate to the strategy. */
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  /** Resets the strategy to its initial state before dragging was started. */
  reset() {
    this._activeDraggables?.forEach((item) => {
      const rootElement = item.getRootElement();
      if (rootElement) {
        const initialTransform = this._itemPositions.find((p) => p.drag === item)?.initialTransform;
        rootElement.style.transform = initialTransform || "";
      }
    });
    this._itemPositions = [];
    this._activeDraggables = [];
    this._previousSwap.drag = null;
    this._previousSwap.delta = 0;
    this._previousSwap.overlaps = false;
  }
  /**
   * Gets a snapshot of items currently in the list.
   * Can include items that we dragged in from another list.
   */
  getActiveItemsSnapshot() {
    return this._activeDraggables;
  }
  /** Gets the index of a specific item. */
  getItemIndex(item) {
    const items = this.orientation === "horizontal" && this.direction === "rtl" ? this._itemPositions.slice().reverse() : this._itemPositions;
    return items.findIndex((currentItem) => currentItem.drag === item);
  }
  /** Used to notify the strategy that the scroll position has changed. */
  updateOnScroll(topDifference, leftDifference) {
    this._itemPositions.forEach(({
      clientRect
    }) => {
      adjustDomRect(clientRect, topDifference, leftDifference);
    });
    this._itemPositions.forEach(({
      drag
    }) => {
      if (this._dragDropRegistry.isDragging(drag)) {
        drag._sortFromLastPointerPosition();
      }
    });
  }
  withElementContainer(container) {
    this._element = container;
  }
  /** Refreshes the position cache of the items and sibling containers. */
  _cacheItemPositions() {
    const isHorizontal = this.orientation === "horizontal";
    this._itemPositions = this._activeDraggables.map((drag) => {
      const elementToMeasure = drag.getVisibleElement();
      return {
        drag,
        offset: 0,
        initialTransform: elementToMeasure.style.transform || "",
        clientRect: getMutableClientRect(elementToMeasure)
      };
    }).sort((a, b) => {
      return isHorizontal ? a.clientRect.left - b.clientRect.left : a.clientRect.top - b.clientRect.top;
    });
  }
  /**
   * Gets the offset in pixels by which the item that is being dragged should be moved.
   * @param currentPosition Current position of the item.
   * @param newPosition Position of the item where the current item should be moved.
   * @param delta Direction in which the user is moving.
   */
  _getItemOffsetPx(currentPosition, newPosition, delta) {
    const isHorizontal = this.orientation === "horizontal";
    let itemOffset = isHorizontal ? newPosition.left - currentPosition.left : newPosition.top - currentPosition.top;
    if (delta === -1) {
      itemOffset += isHorizontal ? newPosition.width - currentPosition.width : newPosition.height - currentPosition.height;
    }
    return itemOffset;
  }
  /**
   * Gets the offset in pixels by which the items that aren't being dragged should be moved.
   * @param currentIndex Index of the item currently being dragged.
   * @param siblings All of the items in the list.
   * @param delta Direction in which the user is moving.
   */
  _getSiblingOffsetPx(currentIndex, siblings, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const currentPosition = siblings[currentIndex].clientRect;
    const immediateSibling = siblings[currentIndex + delta * -1];
    let siblingOffset = currentPosition[isHorizontal ? "width" : "height"] * delta;
    if (immediateSibling) {
      const start = isHorizontal ? "left" : "top";
      const end = isHorizontal ? "right" : "bottom";
      if (delta === -1) {
        siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];
      } else {
        siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];
      }
    }
    return siblingOffset;
  }
  /**
   * Checks if pointer is entering in the first position
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   */
  _shouldEnterAsFirstChild(pointerX, pointerY) {
    if (!this._activeDraggables.length) {
      return false;
    }
    const itemPositions = this._itemPositions;
    const isHorizontal = this.orientation === "horizontal";
    const reversed = itemPositions[0].drag !== this._activeDraggables[0];
    if (reversed) {
      const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;
      return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;
    } else {
      const firstItemRect = itemPositions[0].clientRect;
      return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;
    }
  }
  /**
   * Gets the index of an item in the drop container, based on the position of the user's pointer.
   * @param item Item that is being sorted.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   * @param delta Direction in which the user is moving their pointer.
   */
  _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const index = this._itemPositions.findIndex(({
      drag,
      clientRect
    }) => {
      if (drag === item) {
        return false;
      }
      if (delta) {
        const direction = isHorizontal ? delta.x : delta.y;
        if (drag === this._previousSwap.drag && this._previousSwap.overlaps && direction === this._previousSwap.delta) {
          return false;
        }
      }
      return isHorizontal ? (
        // Round these down since most browsers report client rects with
        // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.
        pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right)
      ) : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);
    });
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
};
var MixedSortStrategy = class {
  _document;
  _dragDropRegistry;
  /** Root element container of the drop list. */
  _element;
  /** Function used to determine if an item can be sorted into a specific index. */
  _sortPredicate;
  /** Lazily-resolved root node containing the list. Use `_getRootNode` to read this. */
  _rootNode;
  /**
   * Draggable items that are currently active inside the container. Includes the items
   * that were there at the start of the sequence, as well as any items that have been dragged
   * in, but haven't been dropped yet.
   */
  _activeItems;
  /**
   * Keeps track of the item that was last swapped with the dragged item, as well as what direction
   * the pointer was moving in when the swap occurred and whether the user's pointer continued to
   * overlap with the swapped item after the swapping occurred.
   */
  _previousSwap = {
    drag: null,
    deltaX: 0,
    deltaY: 0,
    overlaps: false
  };
  /**
   * Keeps track of the relationship between a node and its next sibling. This information
   * is used to restore the DOM to the order it was in before dragging started.
   */
  _relatedNodes = [];
  constructor(_document, _dragDropRegistry) {
    this._document = _document;
    this._dragDropRegistry = _dragDropRegistry;
  }
  /**
   * To be called when the drag sequence starts.
   * @param items Items that are currently in the list.
   */
  start(items) {
    const childNodes = this._element.childNodes;
    this._relatedNodes = [];
    for (let i = 0; i < childNodes.length; i++) {
      const node = childNodes[i];
      this._relatedNodes.push([node, node.nextSibling]);
    }
    this.withItems(items);
  }
  /**
   * To be called when an item is being sorted.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  sort(item, pointerX, pointerY, pointerDelta) {
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);
    const previousSwap = this._previousSwap;
    if (newIndex === -1 || this._activeItems[newIndex] === item) {
      return null;
    }
    const toSwapWith = this._activeItems[newIndex];
    if (previousSwap.drag === toSwapWith && previousSwap.overlaps && previousSwap.deltaX === pointerDelta.x && previousSwap.deltaY === pointerDelta.y) {
      return null;
    }
    const previousIndex = this.getItemIndex(item);
    const current = item.getPlaceholderElement();
    const overlapElement = toSwapWith.getRootElement();
    if (newIndex > previousIndex) {
      overlapElement.after(current);
    } else {
      overlapElement.before(current);
    }
    moveItemInArray(this._activeItems, previousIndex, newIndex);
    const newOverlapElement = this._getRootNode().elementFromPoint(pointerX, pointerY);
    previousSwap.deltaX = pointerDelta.x;
    previousSwap.deltaY = pointerDelta.y;
    previousSwap.drag = toSwapWith;
    previousSwap.overlaps = overlapElement === newOverlapElement || overlapElement.contains(newOverlapElement);
    return {
      previousIndex,
      currentIndex: newIndex
    };
  }
  /**
   * Called when an item is being moved into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    let enterIndex = index == null || index < 0 ? this._getItemIndexFromPointerPosition(item, pointerX, pointerY) : index;
    if (enterIndex === -1) {
      enterIndex = this._getClosestItemIndexToPointer(item, pointerX, pointerY);
    }
    const targetItem = this._activeItems[enterIndex];
    const currentIndex = this._activeItems.indexOf(item);
    if (currentIndex > -1) {
      this._activeItems.splice(currentIndex, 1);
    }
    if (targetItem && !this._dragDropRegistry.isDragging(targetItem)) {
      this._activeItems.splice(enterIndex, 0, item);
      targetItem.getRootElement().before(item.getPlaceholderElement());
    } else {
      this._activeItems.push(item);
      this._element.appendChild(item.getPlaceholderElement());
    }
  }
  /** Sets the items that are currently part of the list. */
  withItems(items) {
    this._activeItems = items.slice();
  }
  /** Assigns a sort predicate to the strategy. */
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  /** Resets the strategy to its initial state before dragging was started. */
  reset() {
    const root = this._element;
    const previousSwap = this._previousSwap;
    for (let i = this._relatedNodes.length - 1; i > -1; i--) {
      const [node, nextSibling] = this._relatedNodes[i];
      if (node.parentNode === root && node.nextSibling !== nextSibling) {
        if (nextSibling === null) {
          root.appendChild(node);
        } else if (nextSibling.parentNode === root) {
          root.insertBefore(node, nextSibling);
        }
      }
    }
    this._relatedNodes = [];
    this._activeItems = [];
    previousSwap.drag = null;
    previousSwap.deltaX = previousSwap.deltaY = 0;
    previousSwap.overlaps = false;
  }
  /**
   * Gets a snapshot of items currently in the list.
   * Can include items that we dragged in from another list.
   */
  getActiveItemsSnapshot() {
    return this._activeItems;
  }
  /** Gets the index of a specific item. */
  getItemIndex(item) {
    return this._activeItems.indexOf(item);
  }
  /** Used to notify the strategy that the scroll position has changed. */
  updateOnScroll() {
    this._activeItems.forEach((item) => {
      if (this._dragDropRegistry.isDragging(item)) {
        item._sortFromLastPointerPosition();
      }
    });
  }
  withElementContainer(container) {
    if (container !== this._element) {
      this._element = container;
      this._rootNode = void 0;
    }
  }
  /**
   * Gets the index of an item in the drop container, based on the position of the user's pointer.
   * @param item Item that is being sorted.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   * @param delta Direction in which the user is moving their pointer.
   */
  _getItemIndexFromPointerPosition(item, pointerX, pointerY) {
    const elementAtPoint = this._getRootNode().elementFromPoint(Math.floor(pointerX), Math.floor(pointerY));
    const index = elementAtPoint ? this._activeItems.findIndex((item2) => {
      const root = item2.getRootElement();
      return elementAtPoint === root || root.contains(elementAtPoint);
    }) : -1;
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
  /** Lazily resolves the list's root node. */
  _getRootNode() {
    if (!this._rootNode) {
      this._rootNode = _getShadowRoot(this._element) || this._document;
    }
    return this._rootNode;
  }
  /**
   * Finds the index of the item that's closest to the item being dragged.
   * @param item Item being dragged.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   */
  _getClosestItemIndexToPointer(item, pointerX, pointerY) {
    if (this._activeItems.length === 0) {
      return -1;
    }
    if (this._activeItems.length === 1) {
      return 0;
    }
    let minDistance = Infinity;
    let minIndex = -1;
    for (let i = 0; i < this._activeItems.length; i++) {
      const current = this._activeItems[i];
      if (current !== item) {
        const {
          x,
          y
        } = current.getRootElement().getBoundingClientRect();
        const distance = Math.hypot(pointerX - x, pointerY - y);
        if (distance < minDistance) {
          minDistance = distance;
          minIndex = i;
        }
      }
    }
    return minIndex;
  }
};
var DROP_PROXIMITY_THRESHOLD = 0.05;
var SCROLL_PROXIMITY_THRESHOLD = 0.05;
var AutoScrollVerticalDirection;
(function(AutoScrollVerticalDirection2) {
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["NONE"] = 0] = "NONE";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["UP"] = 1] = "UP";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["DOWN"] = 2] = "DOWN";
})(AutoScrollVerticalDirection || (AutoScrollVerticalDirection = {}));
var AutoScrollHorizontalDirection;
(function(AutoScrollHorizontalDirection2) {
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["NONE"] = 0] = "NONE";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["LEFT"] = 1] = "LEFT";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["RIGHT"] = 2] = "RIGHT";
})(AutoScrollHorizontalDirection || (AutoScrollHorizontalDirection = {}));
var DropListRef = class {
  _dragDropRegistry;
  _ngZone;
  _viewportRuler;
  /** Element that the drop list is attached to. */
  element;
  /** Whether starting a dragging sequence from this container is disabled. */
  disabled = false;
  /** Whether sorting items within the list is disabled. */
  sortingDisabled = false;
  /** Locks the position of the draggable elements inside the container along the specified axis. */
  lockAxis;
  /**
   * Whether auto-scrolling the view when the user
   * moves their pointer close to the edges is disabled.
   */
  autoScrollDisabled = false;
  /** Number of pixels to scroll for each frame when auto-scrolling an element. */
  autoScrollStep = 2;
  /**
   * Function that is used to determine whether an item
   * is allowed to be moved into a drop container.
   */
  enterPredicate = () => true;
  /** Function that is used to determine whether an item can be sorted into a particular index. */
  sortPredicate = () => true;
  /** Emits right before dragging has started. */
  beforeStarted = new Subject();
  /**
   * Emits when the user has moved a new drag item into this container.
   */
  entered = new Subject();
  /**
   * Emits when the user removes an item from the container
   * by dragging it into another container.
   */
  exited = new Subject();
  /** Emits when the user drops an item inside the container. */
  dropped = new Subject();
  /** Emits as the user is swapping items while actively dragging. */
  sorted = new Subject();
  /** Emits when a dragging sequence is started in a list connected to the current one. */
  receivingStarted = new Subject();
  /** Emits when a dragging sequence is stopped from a list connected to the current one. */
  receivingStopped = new Subject();
  /** Arbitrary data that can be attached to the drop list. */
  data;
  /** Element that is the direct parent of the drag items. */
  _container;
  /** Whether an item in the list is being dragged. */
  _isDragging = false;
  /** Keeps track of the positions of any parent scrollable elements. */
  _parentPositions;
  /** Strategy being used to sort items within the list. */
  _sortStrategy;
  /** Cached `DOMRect` of the drop list. */
  _domRect;
  /** Draggable items in the container. */
  _draggables = [];
  /** Drop lists that are connected to the current one. */
  _siblings = [];
  /** Connected siblings that currently have a dragged item. */
  _activeSiblings = /* @__PURE__ */ new Set();
  /** Subscription to the window being scrolled. */
  _viewportScrollSubscription = Subscription.EMPTY;
  /** Vertical direction in which the list is currently scrolling. */
  _verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  /** Horizontal direction in which the list is currently scrolling. */
  _horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  /** Node that is being auto-scrolled. */
  _scrollNode;
  /** Used to signal to the current auto-scroll sequence when to stop. */
  _stopScrollTimers = new Subject();
  /** Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly. */
  _cachedShadowRoot = null;
  /** Reference to the document. */
  _document;
  /** Elements that can be scrolled while the user is dragging. */
  _scrollableElements = [];
  /** Initial value for the element's `scroll-snap-type` style. */
  _initialScrollSnap;
  /** Direction of the list's layout. */
  _direction = "ltr";
  constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {
    this._dragDropRegistry = _dragDropRegistry;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    const coercedElement = this.element = coerceElement(element);
    this._document = _document;
    this.withOrientation("vertical").withElementContainer(coercedElement);
    _dragDropRegistry.registerDropContainer(this);
    this._parentPositions = new ParentPositionTracker(_document);
  }
  /** Removes the drop list functionality from the DOM element. */
  dispose() {
    this._stopScrolling();
    this._stopScrollTimers.complete();
    this._viewportScrollSubscription.unsubscribe();
    this.beforeStarted.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this.sorted.complete();
    this.receivingStarted.complete();
    this.receivingStopped.complete();
    this._activeSiblings.clear();
    this._scrollNode = null;
    this._parentPositions.clear();
    this._dragDropRegistry.removeDropContainer(this);
  }
  /** Whether an item from this list is currently being dragged. */
  isDragging() {
    return this._isDragging;
  }
  /** Starts dragging an item. */
  start() {
    this._draggingStarted();
    this._notifyReceivingSiblings();
  }
  /**
   * Attempts to move an item into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    this._draggingStarted();
    if (index == null && this.sortingDisabled) {
      index = this._draggables.indexOf(item);
    }
    this._sortStrategy.enter(item, pointerX, pointerY, index);
    this._cacheParentPositions();
    this._notifyReceivingSiblings();
    this.entered.next({
      item,
      container: this,
      currentIndex: this.getItemIndex(item)
    });
  }
  /**
   * Removes an item from the container after it was dragged into another container by the user.
   * @param item Item that was dragged out.
   */
  exit(item) {
    this._reset();
    this.exited.next({
      item,
      container: this
    });
  }
  /**
   * Drops an item into this container.
   * @param item Item being dropped into the container.
   * @param currentIndex Index at which the item should be inserted.
   * @param previousIndex Index of the item when dragging started.
   * @param previousContainer Container from which the item got dragged in.
   * @param isPointerOverContainer Whether the user's pointer was over the
   *    container when the item was dropped.
   * @param distance Distance the user has dragged since the start of the dragging sequence.
   * @param event Event that triggered the dropping sequence.
   *
   * @breaking-change 15.0.0 `previousIndex` and `event` parameters to become required.
   */
  drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {
    this._reset();
    this.dropped.next({
      item,
      currentIndex,
      previousIndex,
      container: this,
      previousContainer,
      isPointerOverContainer,
      distance,
      dropPoint,
      event
    });
  }
  /**
   * Sets the draggable items that are a part of this list.
   * @param items Items that are a part of this list.
   */
  withItems(items) {
    const previousItems = this._draggables;
    this._draggables = items;
    items.forEach((item) => item._withDropContainer(this));
    if (this.isDragging()) {
      const draggedItems = previousItems.filter((item) => item.isDragging());
      if (draggedItems.every((item) => items.indexOf(item) === -1)) {
        this._reset();
      } else {
        this._sortStrategy.withItems(this._draggables);
      }
    }
    return this;
  }
  /** Sets the layout direction of the drop list. */
  withDirection(direction) {
    this._direction = direction;
    if (this._sortStrategy instanceof SingleAxisSortStrategy) {
      this._sortStrategy.direction = direction;
    }
    return this;
  }
  /**
   * Sets the containers that are connected to this one. When two or more containers are
   * connected, the user will be allowed to transfer items between them.
   * @param connectedTo Other containers that the current containers should be connected to.
   */
  connectedTo(connectedTo) {
    this._siblings = connectedTo.slice();
    return this;
  }
  /**
   * Sets the orientation of the container.
   * @param orientation New orientation for the container.
   */
  withOrientation(orientation) {
    if (orientation === "mixed") {
      this._sortStrategy = new MixedSortStrategy(this._document, this._dragDropRegistry);
    } else {
      const strategy = new SingleAxisSortStrategy(this._dragDropRegistry);
      strategy.direction = this._direction;
      strategy.orientation = orientation;
      this._sortStrategy = strategy;
    }
    this._sortStrategy.withElementContainer(this._container);
    this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));
    return this;
  }
  /**
   * Sets which parent elements are can be scrolled while the user is dragging.
   * @param elements Elements that can be scrolled.
   */
  withScrollableParents(elements) {
    const element = this._container;
    this._scrollableElements = elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();
    return this;
  }
  /**
   * Configures the drop list so that a different element is used as the container for the
   * dragged items. This is useful for the cases when one might not have control over the
   * full DOM that sets up the dragging.
   * Note that the alternate container needs to be a descendant of the drop list.
   * @param container New element container to be assigned.
   */
  withElementContainer(container) {
    if (container === this._container) {
      return this;
    }
    const element = coerceElement(this.element);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && container !== element && !element.contains(container)) {
      throw new Error("Invalid DOM structure for drop list. Alternate container element must be a descendant of the drop list.");
    }
    const oldContainerIndex = this._scrollableElements.indexOf(this._container);
    const newContainerIndex = this._scrollableElements.indexOf(container);
    if (oldContainerIndex > -1) {
      this._scrollableElements.splice(oldContainerIndex, 1);
    }
    if (newContainerIndex > -1) {
      this._scrollableElements.splice(newContainerIndex, 1);
    }
    if (this._sortStrategy) {
      this._sortStrategy.withElementContainer(container);
    }
    this._cachedShadowRoot = null;
    this._scrollableElements.unshift(container);
    this._container = container;
    return this;
  }
  /** Gets the scrollable parents that are registered with this drop container. */
  getScrollableParents() {
    return this._scrollableElements;
  }
  /**
   * Figures out the index of an item in the container.
   * @param item Item whose index should be determined.
   */
  getItemIndex(item) {
    return this._isDragging ? this._sortStrategy.getItemIndex(item) : this._draggables.indexOf(item);
  }
  /**
   * Whether the list is able to receive the item that
   * is currently being dragged inside a connected drop list.
   */
  isReceiving() {
    return this._activeSiblings.size > 0;
  }
  /**
   * Sorts an item inside the container based on its position.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  _sortItem(item, pointerX, pointerY, pointerDelta) {
    if (this.sortingDisabled || !this._domRect || !isPointerNearDomRect(this._domRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
      return;
    }
    const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);
    if (result) {
      this.sorted.next({
        previousIndex: result.previousIndex,
        currentIndex: result.currentIndex,
        container: this,
        item
      });
    }
  }
  /**
   * Checks whether the user's pointer is close to the edges of either the
   * viewport or the drop list and starts the auto-scroll sequence.
   * @param pointerX User's pointer position along the x axis.
   * @param pointerY User's pointer position along the y axis.
   */
  _startScrollingIfNecessary(pointerX, pointerY) {
    if (this.autoScrollDisabled) {
      return;
    }
    let scrollNode;
    let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
    let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
    this._parentPositions.positions.forEach((position, element) => {
      if (element === this._document || !position.clientRect || scrollNode) {
        return;
      }
      if (isPointerNearDomRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
        [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, this._direction, pointerX, pointerY);
        if (verticalScrollDirection || horizontalScrollDirection) {
          scrollNode = element;
        }
      }
    });
    if (!verticalScrollDirection && !horizontalScrollDirection) {
      const {
        width,
        height
      } = this._viewportRuler.getViewportSize();
      const domRect = {
        width,
        height,
        top: 0,
        right: width,
        bottom: height,
        left: 0
      };
      verticalScrollDirection = getVerticalScrollDirection(domRect, pointerY);
      horizontalScrollDirection = getHorizontalScrollDirection(domRect, pointerX);
      scrollNode = window;
    }
    if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection || horizontalScrollDirection !== this._horizontalScrollDirection || scrollNode !== this._scrollNode)) {
      this._verticalScrollDirection = verticalScrollDirection;
      this._horizontalScrollDirection = horizontalScrollDirection;
      this._scrollNode = scrollNode;
      if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {
        this._ngZone.runOutsideAngular(this._startScrollInterval);
      } else {
        this._stopScrolling();
      }
    }
  }
  /** Stops any currently-running auto-scroll sequences. */
  _stopScrolling() {
    this._stopScrollTimers.next();
  }
  /** Starts the dragging sequence within the list. */
  _draggingStarted() {
    const styles = this._container.style;
    this.beforeStarted.next();
    this._isDragging = true;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && // Prevent the check from running on apps not using an alternate container. Ideally we
    // would always run it, but introducing it at this stage would be a breaking change.
    this._container !== coerceElement(this.element)) {
      for (const drag of this._draggables) {
        if (!drag.isDragging() && drag.getVisibleElement().parentNode !== this._container) {
          throw new Error("Invalid DOM structure for drop list. All items must be placed directly inside of the element container.");
        }
      }
    }
    this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || "";
    styles.scrollSnapType = styles.msScrollSnapType = "none";
    this._sortStrategy.start(this._draggables);
    this._cacheParentPositions();
    this._viewportScrollSubscription.unsubscribe();
    this._listenToScrollEvents();
  }
  /** Caches the positions of the configured scrollable parents. */
  _cacheParentPositions() {
    this._parentPositions.cache(this._scrollableElements);
    this._domRect = this._parentPositions.positions.get(this._container).clientRect;
  }
  /** Resets the container to its initial state. */
  _reset() {
    this._isDragging = false;
    const styles = this._container.style;
    styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;
    this._siblings.forEach((sibling) => sibling._stopReceiving(this));
    this._sortStrategy.reset();
    this._stopScrolling();
    this._viewportScrollSubscription.unsubscribe();
    this._parentPositions.clear();
  }
  /** Starts the interval that'll auto-scroll the element. */
  _startScrollInterval = () => {
    this._stopScrolling();
    interval(0, animationFrameScheduler).pipe(takeUntil(this._stopScrollTimers)).subscribe(() => {
      const node = this._scrollNode;
      const scrollStep = this.autoScrollStep;
      if (this._verticalScrollDirection === AutoScrollVerticalDirection.UP) {
        node.scrollBy(0, -scrollStep);
      } else if (this._verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {
        node.scrollBy(0, scrollStep);
      }
      if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {
        node.scrollBy(-scrollStep, 0);
      } else if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {
        node.scrollBy(scrollStep, 0);
      }
    });
  };
  /**
   * Checks whether the user's pointer is positioned over the container.
   * @param x Pointer position along the X axis.
   * @param y Pointer position along the Y axis.
   */
  _isOverContainer(x, y) {
    return this._domRect != null && isInsideClientRect(this._domRect, x, y);
  }
  /**
   * Figures out whether an item should be moved into a sibling
   * drop container, based on its current position.
   * @param item Drag item that is being moved.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _getSiblingContainerFromPosition(item, x, y) {
    return this._siblings.find((sibling) => sibling._canReceive(item, x, y));
  }
  /**
   * Checks whether the drop list can receive the passed-in item.
   * @param item Item that is being dragged into the list.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _canReceive(item, x, y) {
    if (!this._domRect || !isInsideClientRect(this._domRect, x, y) || !this.enterPredicate(item, this)) {
      return false;
    }
    const elementFromPoint = this._getShadowRoot().elementFromPoint(x, y);
    if (!elementFromPoint) {
      return false;
    }
    return elementFromPoint === this._container || this._container.contains(elementFromPoint);
  }
  /**
   * Called by one of the connected drop lists when a dragging sequence has started.
   * @param sibling Sibling in which dragging has started.
   */
  _startReceiving(sibling, items) {
    const activeSiblings = this._activeSiblings;
    if (!activeSiblings.has(sibling) && items.every((item) => {
      return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;
    })) {
      activeSiblings.add(sibling);
      this._cacheParentPositions();
      this._listenToScrollEvents();
      this.receivingStarted.next({
        initiator: sibling,
        receiver: this,
        items
      });
    }
  }
  /**
   * Called by a connected drop list when dragging has stopped.
   * @param sibling Sibling whose dragging has stopped.
   */
  _stopReceiving(sibling) {
    this._activeSiblings.delete(sibling);
    this._viewportScrollSubscription.unsubscribe();
    this.receivingStopped.next({
      initiator: sibling,
      receiver: this
    });
  }
  /**
   * Starts listening to scroll events on the viewport.
   * Used for updating the internal state of the list.
   */
  _listenToScrollEvents() {
    this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((event) => {
      if (this.isDragging()) {
        const scrollDifference = this._parentPositions.handleScroll(event);
        if (scrollDifference) {
          this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);
        }
      } else if (this.isReceiving()) {
        this._cacheParentPositions();
      }
    });
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (!this._cachedShadowRoot) {
      const shadowRoot = _getShadowRoot(this._container);
      this._cachedShadowRoot = shadowRoot || this._document;
    }
    return this._cachedShadowRoot;
  }
  /** Notifies any siblings that may potentially receive the item. */
  _notifyReceivingSiblings() {
    const draggedItems = this._sortStrategy.getActiveItemsSnapshot().filter((item) => item.isDragging());
    this._siblings.forEach((sibling) => sibling._startReceiving(this, draggedItems));
  }
};
function getVerticalScrollDirection(clientRect, pointerY) {
  const {
    top,
    bottom,
    height
  } = clientRect;
  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {
    return AutoScrollVerticalDirection.UP;
  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {
    return AutoScrollVerticalDirection.DOWN;
  }
  return AutoScrollVerticalDirection.NONE;
}
function getHorizontalScrollDirection(clientRect, pointerX) {
  const {
    left,
    right,
    width
  } = clientRect;
  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {
    return AutoScrollHorizontalDirection.LEFT;
  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {
    return AutoScrollHorizontalDirection.RIGHT;
  }
  return AutoScrollHorizontalDirection.NONE;
}
function getElementScrollDirections(element, clientRect, direction, pointerX, pointerY) {
  const computedVertical = getVerticalScrollDirection(clientRect, pointerY);
  const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);
  let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  if (computedVertical) {
    const scrollTop = element.scrollTop;
    if (computedVertical === AutoScrollVerticalDirection.UP) {
      if (scrollTop > 0) {
        verticalScrollDirection = AutoScrollVerticalDirection.UP;
      }
    } else if (element.scrollHeight - scrollTop > element.clientHeight) {
      verticalScrollDirection = AutoScrollVerticalDirection.DOWN;
    }
  }
  if (computedHorizontal) {
    const scrollLeft = element.scrollLeft;
    if (direction === "rtl") {
      if (computedHorizontal === AutoScrollHorizontalDirection.RIGHT) {
        if (scrollLeft < 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
        }
      } else if (element.scrollWidth + scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
      }
    } else {
      if (computedHorizontal === AutoScrollHorizontalDirection.LEFT) {
        if (scrollLeft > 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
        }
      } else if (element.scrollWidth - scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
      }
    }
  }
  return [verticalScrollDirection, horizontalScrollDirection];
}
var activeCapturingEventOptions = normalizePassiveListenerOptions({
  passive: false,
  capture: true
});
var _ResetsLoader = class __ResetsLoader {
  static ɵfac = function _ResetsLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __ResetsLoader)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: __ResetsLoader,
    selectors: [["ng-component"]],
    hostAttrs: ["cdk-drag-resets-container", ""],
    decls: 0,
    vars: 0,
    template: function _ResetsLoader_Template(rf, ctx) {
    },
    styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_ResetsLoader, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation.None,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "cdk-drag-resets-container": ""
      },
      styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}"]
    }]
  }], null, null);
})();
var DragDropRegistry = class _DragDropRegistry {
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  _styleLoader = inject(_CdkPrivateStyleLoader);
  /** Registered drop container instances. */
  _dropInstances = /* @__PURE__ */ new Set();
  /** Registered drag item instances. */
  _dragInstances = /* @__PURE__ */ new Set();
  /** Drag item instances that are currently being dragged. */
  _activeDragInstances = signal([]);
  /** Keeps track of the event listeners that we've bound to the `document`. */
  _globalListeners = /* @__PURE__ */ new Map();
  /**
   * Predicate function to check if an item is being dragged.  Moved out into a property,
   * because it'll be called a lot and we don't want to create a new function every time.
   */
  _draggingPredicate = (item) => item.isDragging();
  /**
   * Map tracking DOM nodes and their corresponding drag directives. Note that this is different
   * from looking through the `_dragInstances` and getting their root node, because the root node
   * isn't necessarily the node that the directive is set on.
   */
  _domNodesToDirectives = null;
  /**
   * Emits the `touchmove` or `mousemove` events that are dispatched
   * while the user is dragging a drag item instance.
   */
  pointerMove = new Subject();
  /**
   * Emits the `touchend` or `mouseup` events that are dispatched
   * while the user is dragging a drag item instance.
   */
  pointerUp = new Subject();
  /**
   * Emits when the viewport has been scrolled while the user is dragging an item.
   * @deprecated To be turned into a private member. Use the `scrolled` method instead.
   * @breaking-change 13.0.0
   */
  scroll = new Subject();
  constructor() {
  }
  /** Adds a drop container to the registry. */
  registerDropContainer(drop) {
    if (!this._dropInstances.has(drop)) {
      this._dropInstances.add(drop);
    }
  }
  /** Adds a drag item instance to the registry. */
  registerDragItem(drag) {
    this._dragInstances.add(drag);
    if (this._dragInstances.size === 1) {
      this._ngZone.runOutsideAngular(() => {
        this._document.addEventListener("touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
      });
    }
  }
  /** Removes a drop container from the registry. */
  removeDropContainer(drop) {
    this._dropInstances.delete(drop);
  }
  /** Removes a drag item instance from the registry. */
  removeDragItem(drag) {
    this._dragInstances.delete(drag);
    this.stopDragging(drag);
    if (this._dragInstances.size === 0) {
      this._document.removeEventListener("touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
    }
  }
  /**
   * Starts the dragging sequence for a drag instance.
   * @param drag Drag instance which is being dragged.
   * @param event Event that initiated the dragging.
   */
  startDragging(drag, event) {
    if (this._activeDragInstances().indexOf(drag) > -1) {
      return;
    }
    this._styleLoader.load(_ResetsLoader);
    this._activeDragInstances.update((instances) => [...instances, drag]);
    if (this._activeDragInstances().length === 1) {
      const isTouchEvent2 = event.type.startsWith("touch");
      const endEventHandler = {
        handler: (e) => this.pointerUp.next(e),
        options: true
      };
      if (isTouchEvent2) {
        this._globalListeners.set("touchend", endEventHandler);
        this._globalListeners.set("touchcancel", endEventHandler);
      } else {
        this._globalListeners.set("mouseup", endEventHandler);
      }
      this._globalListeners.set("scroll", {
        handler: (e) => this.scroll.next(e),
        // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't
        // the document. See https://github.com/angular/components/issues/17144.
        options: true
      }).set("selectstart", {
        handler: this._preventDefaultWhileDragging,
        options: activeCapturingEventOptions
      });
      if (!isTouchEvent2) {
        this._globalListeners.set("mousemove", {
          handler: (e) => this.pointerMove.next(e),
          options: activeCapturingEventOptions
        });
      }
      this._ngZone.runOutsideAngular(() => {
        this._globalListeners.forEach((config, name) => {
          this._document.addEventListener(name, config.handler, config.options);
        });
      });
    }
  }
  /** Stops dragging a drag item instance. */
  stopDragging(drag) {
    this._activeDragInstances.update((instances) => {
      const index = instances.indexOf(drag);
      if (index > -1) {
        instances.splice(index, 1);
        return [...instances];
      }
      return instances;
    });
    if (this._activeDragInstances().length === 0) {
      this._clearGlobalListeners();
    }
  }
  /** Gets whether a drag item instance is currently being dragged. */
  isDragging(drag) {
    return this._activeDragInstances().indexOf(drag) > -1;
  }
  /**
   * Gets a stream that will emit when any element on the page is scrolled while an item is being
   * dragged.
   * @param shadowRoot Optional shadow root that the current dragging sequence started from.
   *   Top-level listeners won't pick up events coming from the shadow DOM so this parameter can
   *   be used to include an additional top-level listener at the shadow root level.
   */
  scrolled(shadowRoot) {
    const streams = [this.scroll];
    if (shadowRoot && shadowRoot !== this._document) {
      streams.push(new Observable((observer) => {
        return this._ngZone.runOutsideAngular(() => {
          const eventOptions = true;
          const callback = (event) => {
            if (this._activeDragInstances().length) {
              observer.next(event);
            }
          };
          shadowRoot.addEventListener("scroll", callback, eventOptions);
          return () => {
            shadowRoot.removeEventListener("scroll", callback, eventOptions);
          };
        });
      }));
    }
    return merge(...streams);
  }
  /**
   * Tracks the DOM node which has a draggable directive.
   * @param node Node to track.
   * @param dragRef Drag directive set on the node.
   */
  registerDirectiveNode(node, dragRef) {
    this._domNodesToDirectives ??= /* @__PURE__ */ new WeakMap();
    this._domNodesToDirectives.set(node, dragRef);
  }
  /**
   * Stops tracking a draggable directive node.
   * @param node Node to stop tracking.
   */
  removeDirectiveNode(node) {
    this._domNodesToDirectives?.delete(node);
  }
  /**
   * Gets the drag directive corresponding to a specific DOM node, if any.
   * @param node Node for which to do the lookup.
   */
  getDragDirectiveForNode(node) {
    return this._domNodesToDirectives?.get(node) || null;
  }
  ngOnDestroy() {
    this._dragInstances.forEach((instance) => this.removeDragItem(instance));
    this._dropInstances.forEach((instance) => this.removeDropContainer(instance));
    this._domNodesToDirectives = null;
    this._clearGlobalListeners();
    this.pointerMove.complete();
    this.pointerUp.complete();
  }
  /**
   * Event listener that will prevent the default browser action while the user is dragging.
   * @param event Event whose default action should be prevented.
   */
  _preventDefaultWhileDragging = (event) => {
    if (this._activeDragInstances().length > 0) {
      event.preventDefault();
    }
  };
  /** Event listener for `touchmove` that is bound even if no dragging is happening. */
  _persistentTouchmoveListener = (event) => {
    if (this._activeDragInstances().length > 0) {
      if (this._activeDragInstances().some(this._draggingPredicate)) {
        event.preventDefault();
      }
      this.pointerMove.next(event);
    }
  };
  /** Clears out the global event listeners from the `document`. */
  _clearGlobalListeners() {
    this._globalListeners.forEach((config, name) => {
      this._document.removeEventListener(name, config.handler, config.options);
    });
    this._globalListeners.clear();
  }
  static ɵfac = function DragDropRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDropRegistry)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragDropRegistry,
    factory: _DragDropRegistry.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var DEFAULT_CONFIG = {
  dragStartThreshold: 5,
  pointerDirectionChangeThreshold: 5
};
var DragDrop = class _DragDrop {
  _document = inject(DOCUMENT);
  _ngZone = inject(NgZone);
  _viewportRuler = inject(ViewportRuler);
  _dragDropRegistry = inject(DragDropRegistry);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  constructor() {
  }
  /**
   * Turns an element into a draggable item.
   * @param element Element to which to attach the dragging functionality.
   * @param config Object used to configure the dragging behavior.
   */
  createDrag(element, config = DEFAULT_CONFIG) {
    return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry, this._renderer);
  }
  /**
   * Turns an element into a drop list.
   * @param element Element to which to attach the drop list functionality.
   */
  createDropList(element) {
    return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);
  }
  static ɵfac = function DragDrop_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDrop)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragDrop,
    factory: _DragDrop.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDrop, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CDK_DRAG_PARENT = new InjectionToken("CDK_DRAG_PARENT");
function assertElementNode(node, name) {
  if (node.nodeType !== 1) {
    throw Error(`${name} must be attached to an element node. Currently attached to "${node.nodeName}".`);
  }
}
var CDK_DRAG_HANDLE = new InjectionToken("CdkDragHandle");
var CdkDragHandle = class _CdkDragHandle {
  element = inject(ElementRef);
  _parentDrag = inject(CDK_DRAG_PARENT, {
    optional: true,
    skipSelf: true
  });
  _dragDropRegistry = inject(DragDropRegistry);
  /** Emits when the state of the handle has changed. */
  _stateChanges = new Subject();
  /** Whether starting to drag through this handle is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._stateChanges.next(this);
  }
  _disabled = false;
  constructor() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(this.element.nativeElement, "cdkDragHandle");
    }
    this._parentDrag?._addHandle(this);
  }
  ngAfterViewInit() {
    if (!this._parentDrag) {
      let parent = this.element.nativeElement.parentElement;
      while (parent) {
        const ref = this._dragDropRegistry.getDragDirectiveForNode(parent);
        if (ref) {
          this._parentDrag = ref;
          ref._addHandle(this);
          break;
        }
        parent = parent.parentElement;
      }
    }
  }
  ngOnDestroy() {
    this._parentDrag?._removeHandle(this);
    this._stateChanges.complete();
  }
  static ɵfac = function CdkDragHandle_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragHandle)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDragHandle,
    selectors: [["", "cdkDragHandle", ""]],
    hostAttrs: [1, "cdk-drag-handle"],
    inputs: {
      disabled: [2, "cdkDragHandleDisabled", "disabled", booleanAttribute]
    },
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_HANDLE,
      useExisting: _CdkDragHandle
    }]), ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragHandle, [{
    type: Directive,
    args: [{
      selector: "[cdkDragHandle]",
      host: {
        "class": "cdk-drag-handle"
      },
      providers: [{
        provide: CDK_DRAG_HANDLE,
        useExisting: CdkDragHandle
      }]
    }]
  }], () => [], {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragHandleDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_CONFIG = new InjectionToken("CDK_DRAG_CONFIG");
var CDK_DROP_LIST = new InjectionToken("CdkDropList");
var CdkDrag = class _CdkDrag {
  element = inject(ElementRef);
  dropContainer = inject(CDK_DROP_LIST, {
    optional: true,
    skipSelf: true
  });
  _ngZone = inject(NgZone);
  _viewContainerRef = inject(ViewContainerRef);
  _dir = inject(Directionality, {
    optional: true
  });
  _changeDetectorRef = inject(ChangeDetectorRef);
  _selfHandle = inject(CDK_DRAG_HANDLE, {
    optional: true,
    self: true
  });
  _parentDrag = inject(CDK_DRAG_PARENT, {
    optional: true,
    skipSelf: true
  });
  _dragDropRegistry = inject(DragDropRegistry);
  _destroyed = new Subject();
  _handles = new BehaviorSubject([]);
  _previewTemplate;
  _placeholderTemplate;
  /** Reference to the underlying drag instance. */
  _dragRef;
  /** Arbitrary data to attach to this drag instance. */
  data;
  /** Locks the position of the dragged element along the specified axis. */
  lockAxis;
  /**
   * Selector that will be used to determine the root draggable element, starting from
   * the `cdkDrag` element and going up the DOM. Passing an alternate root element is useful
   * when trying to enable dragging on an element that you might not have access to.
   */
  rootElementSelector;
  /**
   * Node or selector that will be used to determine the element to which the draggable's
   * position will be constrained. If a string is passed in, it'll be used as a selector that
   * will be matched starting from the element's parent and going up the DOM until a match
   * has been found.
   */
  boundaryElement;
  /**
   * Amount of milliseconds to wait after the user has put their
   * pointer down before starting to drag the element.
   */
  dragStartDelay;
  /**
   * Sets the position of a `CdkDrag` that is outside of a drop container.
   * Can be used to restore the element's position for a returning user.
   */
  freeDragPosition;
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || !!(this.dropContainer && this.dropContainer.disabled);
  }
  set disabled(value) {
    this._disabled = value;
    this._dragRef.disabled = this._disabled;
  }
  _disabled;
  /**
   * Function that can be used to customize the logic of how the position of the drag item
   * is limited while it's being dragged. Gets called with a point containing the current position
   * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
   * Should return a point describing where the item should be rendered.
   */
  constrainPosition;
  /** Class to be added to the preview element. */
  previewClass;
  /**
   * Configures the place into which the preview of the item will be inserted. Can be configured
   * globally through `CDK_DROP_LIST`. Possible values:
   * - `global` - Preview will be inserted at the bottom of the `<body>`. The advantage is that
   * you don't have to worry about `overflow: hidden` or `z-index`, but the item won't retain
   * its inherited styles.
   * - `parent` - Preview will be inserted into the parent of the drag item. The advantage is that
   * inherited styles will be preserved, but it may be clipped by `overflow: hidden` or not be
   * visible due to `z-index`. Furthermore, the preview is going to have an effect over selectors
   * like `:nth-child` and some flexbox configurations.
   * - `ElementRef<HTMLElement> | HTMLElement` - Preview will be inserted into a specific element.
   * Same advantages and disadvantages as `parent`.
   */
  previewContainer;
  /**
   * If the parent of the dragged element has a `scale` transform, it can throw off the
   * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
   */
  scale = 1;
  /** Emits when the user starts dragging the item. */
  started = new EventEmitter();
  /** Emits when the user has released a drag item, before any animations have started. */
  released = new EventEmitter();
  /** Emits when the user stops dragging an item in the container. */
  ended = new EventEmitter();
  /** Emits when the user has moved the item into a new container. */
  entered = new EventEmitter();
  /** Emits when the user removes the item its container by dragging it into another container. */
  exited = new EventEmitter();
  /** Emits when the user drops the item inside a container. */
  dropped = new EventEmitter();
  /**
   * Emits as the user is dragging the item. Use with caution,
   * because this event will fire for every pixel that the user has dragged.
   */
  moved = new Observable((observer) => {
    const subscription = this._dragRef.moved.pipe(map((movedEvent) => ({
      source: this,
      pointerPosition: movedEvent.pointerPosition,
      event: movedEvent.event,
      delta: movedEvent.delta,
      distance: movedEvent.distance
    }))).subscribe(observer);
    return () => {
      subscription.unsubscribe();
    };
  });
  _injector = inject(Injector);
  constructor() {
    const dropContainer = this.dropContainer;
    const config = inject(CDK_DRAG_CONFIG, {
      optional: true
    });
    const dragDrop = inject(DragDrop);
    this._dragRef = dragDrop.createDrag(this.element, {
      dragStartThreshold: config && config.dragStartThreshold != null ? config.dragStartThreshold : 5,
      pointerDirectionChangeThreshold: config && config.pointerDirectionChangeThreshold != null ? config.pointerDirectionChangeThreshold : 5,
      zIndex: config?.zIndex
    });
    this._dragRef.data = this;
    this._dragDropRegistry.registerDirectiveNode(this.element.nativeElement, this);
    if (config) {
      this._assignDefaults(config);
    }
    if (dropContainer) {
      this._dragRef._withDropContainer(dropContainer._dropListRef);
      dropContainer.addItem(this);
      dropContainer._dropListRef.beforeStarted.pipe(takeUntil(this._destroyed)).subscribe(() => {
        this._dragRef.scale = this.scale;
      });
    }
    this._syncInputs(this._dragRef);
    this._handleEvents(this._dragRef);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._dragRef.getPlaceholderElement();
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._dragRef.getRootElement();
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._dragRef.reset();
  }
  /**
   * Gets the pixel coordinates of the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    return this._dragRef.getFreeDragPosition();
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._dragRef.setFreeDragPosition(value);
  }
  ngAfterViewInit() {
    afterNextRender(() => {
      this._updateRootElement();
      this._setupHandlesListener();
      this._dragRef.scale = this.scale;
      if (this.freeDragPosition) {
        this._dragRef.setFreeDragPosition(this.freeDragPosition);
      }
    }, {
      injector: this._injector
    });
  }
  ngOnChanges(changes) {
    const rootSelectorChange = changes["rootElementSelector"];
    const positionChange = changes["freeDragPosition"];
    if (rootSelectorChange && !rootSelectorChange.firstChange) {
      this._updateRootElement();
    }
    this._dragRef.scale = this.scale;
    if (positionChange && !positionChange.firstChange && this.freeDragPosition) {
      this._dragRef.setFreeDragPosition(this.freeDragPosition);
    }
  }
  ngOnDestroy() {
    if (this.dropContainer) {
      this.dropContainer.removeItem(this);
    }
    this._dragDropRegistry.removeDirectiveNode(this.element.nativeElement);
    this._ngZone.runOutsideAngular(() => {
      this._handles.complete();
      this._destroyed.next();
      this._destroyed.complete();
      this._dragRef.dispose();
    });
  }
  _addHandle(handle) {
    const handles = this._handles.getValue();
    handles.push(handle);
    this._handles.next(handles);
  }
  _removeHandle(handle) {
    const handles = this._handles.getValue();
    const index = handles.indexOf(handle);
    if (index > -1) {
      handles.splice(index, 1);
      this._handles.next(handles);
    }
  }
  _setPreviewTemplate(preview) {
    this._previewTemplate = preview;
  }
  _resetPreviewTemplate(preview) {
    if (preview === this._previewTemplate) {
      this._previewTemplate = null;
    }
  }
  _setPlaceholderTemplate(placeholder) {
    this._placeholderTemplate = placeholder;
  }
  _resetPlaceholderTemplate(placeholder) {
    if (placeholder === this._placeholderTemplate) {
      this._placeholderTemplate = null;
    }
  }
  /** Syncs the root element with the `DragRef`. */
  _updateRootElement() {
    const element = this.element.nativeElement;
    let rootElement = element;
    if (this.rootElementSelector) {
      rootElement = element.closest !== void 0 ? element.closest(this.rootElementSelector) : (
        // Comment tag doesn't have closest method, so use parent's one.
        element.parentElement?.closest(this.rootElementSelector)
      );
    }
    if (rootElement && (typeof ngDevMode === "undefined" || ngDevMode)) {
      assertElementNode(rootElement, "cdkDrag");
    }
    this._dragRef.withRootElement(rootElement || element);
  }
  /** Gets the boundary element, based on the `boundaryElement` value. */
  _getBoundaryElement() {
    const boundary = this.boundaryElement;
    if (!boundary) {
      return null;
    }
    if (typeof boundary === "string") {
      return this.element.nativeElement.closest(boundary);
    }
    return coerceElement(boundary);
  }
  /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */
  _syncInputs(ref) {
    ref.beforeStarted.subscribe(() => {
      if (!ref.isDragging()) {
        const dir = this._dir;
        const dragStartDelay = this.dragStartDelay;
        const placeholder = this._placeholderTemplate ? {
          template: this._placeholderTemplate.templateRef,
          context: this._placeholderTemplate.data,
          viewContainer: this._viewContainerRef
        } : null;
        const preview = this._previewTemplate ? {
          template: this._previewTemplate.templateRef,
          context: this._previewTemplate.data,
          matchSize: this._previewTemplate.matchSize,
          viewContainer: this._viewContainerRef
        } : null;
        ref.disabled = this.disabled;
        ref.lockAxis = this.lockAxis;
        ref.scale = this.scale;
        ref.dragStartDelay = typeof dragStartDelay === "object" && dragStartDelay ? dragStartDelay : coerceNumberProperty(dragStartDelay);
        ref.constrainPosition = this.constrainPosition;
        ref.previewClass = this.previewClass;
        ref.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(placeholder).withPreviewTemplate(preview).withPreviewContainer(this.previewContainer || "global");
        if (dir) {
          ref.withDirection(dir.value);
        }
      }
    });
    ref.beforeStarted.pipe(take(1)).subscribe(() => {
      if (this._parentDrag) {
        ref.withParent(this._parentDrag._dragRef);
        return;
      }
      let parent = this.element.nativeElement.parentElement;
      while (parent) {
        const parentDrag = this._dragDropRegistry.getDragDirectiveForNode(parent);
        if (parentDrag) {
          ref.withParent(parentDrag._dragRef);
          break;
        }
        parent = parent.parentElement;
      }
    });
  }
  /** Handles the events from the underlying `DragRef`. */
  _handleEvents(ref) {
    ref.started.subscribe((startEvent) => {
      this.started.emit({
        source: this,
        event: startEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.released.subscribe((releaseEvent) => {
      this.released.emit({
        source: this,
        event: releaseEvent.event
      });
    });
    ref.ended.subscribe((endEvent) => {
      this.ended.emit({
        source: this,
        distance: endEvent.distance,
        dropPoint: endEvent.dropPoint,
        event: endEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe((enterEvent) => {
      this.entered.emit({
        container: enterEvent.container.data,
        item: this,
        currentIndex: enterEvent.currentIndex
      });
    });
    ref.exited.subscribe((exitEvent) => {
      this.exited.emit({
        container: exitEvent.container.data,
        item: this
      });
    });
    ref.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        item: this,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
    });
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      dragStartDelay,
      constrainPosition,
      previewClass,
      boundaryElement,
      draggingDisabled,
      rootElementSelector,
      previewContainer
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.dragStartDelay = dragStartDelay || 0;
    if (lockAxis) {
      this.lockAxis = lockAxis;
    }
    if (constrainPosition) {
      this.constrainPosition = constrainPosition;
    }
    if (previewClass) {
      this.previewClass = previewClass;
    }
    if (boundaryElement) {
      this.boundaryElement = boundaryElement;
    }
    if (rootElementSelector) {
      this.rootElementSelector = rootElementSelector;
    }
    if (previewContainer) {
      this.previewContainer = previewContainer;
    }
  }
  /** Sets up the listener that syncs the handles with the drag ref. */
  _setupHandlesListener() {
    this._handles.pipe(
      // Sync the new handles with the DragRef.
      tap((handles) => {
        const handleElements = handles.map((handle) => handle.element);
        if (this._selfHandle && this.rootElementSelector) {
          handleElements.push(this.element);
        }
        this._dragRef.withHandles(handleElements);
      }),
      // Listen if the state of any of the handles changes.
      switchMap((handles) => {
        return merge(...handles.map((item) => item._stateChanges.pipe(startWith(item))));
      }),
      takeUntil(this._destroyed)
    ).subscribe((handleInstance) => {
      const dragRef = this._dragRef;
      const handle = handleInstance.element.nativeElement;
      handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);
    });
  }
  static ɵfac = function CdkDrag_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDrag)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDrag,
    selectors: [["", "cdkDrag", ""]],
    hostAttrs: [1, "cdk-drag"],
    hostVars: 4,
    hostBindings: function CdkDrag_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("cdk-drag-disabled", ctx.disabled)("cdk-drag-dragging", ctx._dragRef.isDragging());
      }
    },
    inputs: {
      data: [0, "cdkDragData", "data"],
      lockAxis: [0, "cdkDragLockAxis", "lockAxis"],
      rootElementSelector: [0, "cdkDragRootElement", "rootElementSelector"],
      boundaryElement: [0, "cdkDragBoundary", "boundaryElement"],
      dragStartDelay: [0, "cdkDragStartDelay", "dragStartDelay"],
      freeDragPosition: [0, "cdkDragFreeDragPosition", "freeDragPosition"],
      disabled: [2, "cdkDragDisabled", "disabled", booleanAttribute],
      constrainPosition: [0, "cdkDragConstrainPosition", "constrainPosition"],
      previewClass: [0, "cdkDragPreviewClass", "previewClass"],
      previewContainer: [0, "cdkDragPreviewContainer", "previewContainer"],
      scale: [2, "cdkDragScale", "scale", numberAttribute]
    },
    outputs: {
      started: "cdkDragStarted",
      released: "cdkDragReleased",
      ended: "cdkDragEnded",
      entered: "cdkDragEntered",
      exited: "cdkDragExited",
      dropped: "cdkDragDropped",
      moved: "cdkDragMoved"
    },
    exportAs: ["cdkDrag"],
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_PARENT,
      useExisting: _CdkDrag
    }]), ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDrag, [{
    type: Directive,
    args: [{
      selector: "[cdkDrag]",
      exportAs: "cdkDrag",
      host: {
        "class": "cdk-drag",
        "[class.cdk-drag-disabled]": "disabled",
        "[class.cdk-drag-dragging]": "_dragRef.isDragging()"
      },
      providers: [{
        provide: CDK_DRAG_PARENT,
        useExisting: CdkDrag
      }]
    }]
  }], () => [], {
    data: [{
      type: Input,
      args: ["cdkDragData"]
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDragLockAxis"]
    }],
    rootElementSelector: [{
      type: Input,
      args: ["cdkDragRootElement"]
    }],
    boundaryElement: [{
      type: Input,
      args: ["cdkDragBoundary"]
    }],
    dragStartDelay: [{
      type: Input,
      args: ["cdkDragStartDelay"]
    }],
    freeDragPosition: [{
      type: Input,
      args: ["cdkDragFreeDragPosition"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragDisabled",
        transform: booleanAttribute
      }]
    }],
    constrainPosition: [{
      type: Input,
      args: ["cdkDragConstrainPosition"]
    }],
    previewClass: [{
      type: Input,
      args: ["cdkDragPreviewClass"]
    }],
    previewContainer: [{
      type: Input,
      args: ["cdkDragPreviewContainer"]
    }],
    scale: [{
      type: Input,
      args: [{
        alias: "cdkDragScale",
        transform: numberAttribute
      }]
    }],
    started: [{
      type: Output,
      args: ["cdkDragStarted"]
    }],
    released: [{
      type: Output,
      args: ["cdkDragReleased"]
    }],
    ended: [{
      type: Output,
      args: ["cdkDragEnded"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDragEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDragExited"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDragDropped"]
    }],
    moved: [{
      type: Output,
      args: ["cdkDragMoved"]
    }]
  });
})();
var CDK_DROP_LIST_GROUP = new InjectionToken("CdkDropListGroup");
var CdkDropListGroup = class _CdkDropListGroup {
  /** Drop lists registered inside the group. */
  _items = /* @__PURE__ */ new Set();
  /** Whether starting a dragging sequence from inside this group is disabled. */
  disabled = false;
  ngOnDestroy() {
    this._items.clear();
  }
  static ɵfac = function CdkDropListGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDropListGroup)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDropListGroup,
    selectors: [["", "cdkDropListGroup", ""]],
    inputs: {
      disabled: [2, "cdkDropListGroupDisabled", "disabled", booleanAttribute]
    },
    exportAs: ["cdkDropListGroup"],
    features: [ɵɵProvidersFeature([{
      provide: CDK_DROP_LIST_GROUP,
      useExisting: _CdkDropListGroup
    }]), ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropListGroup, [{
    type: Directive,
    args: [{
      selector: "[cdkDropListGroup]",
      exportAs: "cdkDropListGroup",
      providers: [{
        provide: CDK_DROP_LIST_GROUP,
        useExisting: CdkDropListGroup
      }]
    }]
  }], null, {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListGroupDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CdkDropList = class _CdkDropList {
  element = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _scrollDispatcher = inject(ScrollDispatcher);
  _dir = inject(Directionality, {
    optional: true
  });
  _group = inject(CDK_DROP_LIST_GROUP, {
    optional: true,
    skipSelf: true
  });
  /** Emits when the list has been destroyed. */
  _destroyed = new Subject();
  /** Whether the element's scrollable parents have been resolved. */
  _scrollableParentsResolved;
  /** Keeps track of the drop lists that are currently on the page. */
  static _dropLists = [];
  /** Reference to the underlying drop list instance. */
  _dropListRef;
  /**
   * Other draggable containers that this container is connected to and into which the
   * container's items can be transferred. Can either be references to other drop containers,
   * or their unique IDs.
   */
  connectedTo = [];
  /** Arbitrary data to attach to this container. */
  data;
  /** Direction in which the list is oriented. */
  orientation;
  /**
   * Unique ID for the drop zone. Can be used as a reference
   * in the `connectedTo` of another `CdkDropList`.
   */
  id = inject(_IdGenerator).getId("cdk-drop-list-");
  /** Locks the position of the draggable elements inside the container along the specified axis. */
  lockAxis;
  /** Whether starting a dragging sequence from this container is disabled. */
  get disabled() {
    return this._disabled || !!this._group && this._group.disabled;
  }
  set disabled(value) {
    this._dropListRef.disabled = this._disabled = value;
  }
  _disabled;
  /** Whether sorting within this drop list is disabled. */
  sortingDisabled;
  /**
   * Function that is used to determine whether an item
   * is allowed to be moved into a drop container.
   */
  enterPredicate = () => true;
  /** Functions that is used to determine whether an item can be sorted into a particular index. */
  sortPredicate = () => true;
  /** Whether to auto-scroll the view when the user moves their pointer close to the edges. */
  autoScrollDisabled;
  /** Number of pixels to scroll for each frame when auto-scrolling an element. */
  autoScrollStep;
  /**
   * Selector that will be used to resolve an alternate element container for the drop list.
   * Passing an alternate container is useful for the cases where one might not have control
   * over the parent node of the draggable items within the list (e.g. due to content projection).
   * This allows for usages like:
   *
   * ```
   * <div cdkDropList cdkDropListElementContainer=".inner">
   *   <div class="inner">
   *     <div cdkDrag></div>
   *   </div>
   * </div>
   * ```
   */
  elementContainerSelector;
  /** Emits when the user drops an item inside the container. */
  dropped = new EventEmitter();
  /**
   * Emits when the user has moved a new drag item into this container.
   */
  entered = new EventEmitter();
  /**
   * Emits when the user removes an item from the container
   * by dragging it into another container.
   */
  exited = new EventEmitter();
  /** Emits as the user is swapping items while actively dragging. */
  sorted = new EventEmitter();
  /**
   * Keeps track of the items that are registered with this container. Historically we used to
   * do this with a `ContentChildren` query, however queries don't handle transplanted views very
   * well which means that we can't handle cases like dragging the headers of a `mat-table`
   * correctly. What we do instead is to have the items register themselves with the container
   * and then we sort them based on their position in the DOM.
   */
  _unsortedItems = /* @__PURE__ */ new Set();
  constructor() {
    const dragDrop = inject(DragDrop);
    const config = inject(CDK_DRAG_CONFIG, {
      optional: true
    });
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(this.element.nativeElement, "cdkDropList");
    }
    this._dropListRef = dragDrop.createDropList(this.element);
    this._dropListRef.data = this;
    if (config) {
      this._assignDefaults(config);
    }
    this._dropListRef.enterPredicate = (drag, drop) => {
      return this.enterPredicate(drag.data, drop.data);
    };
    this._dropListRef.sortPredicate = (index, drag, drop) => {
      return this.sortPredicate(index, drag.data, drop.data);
    };
    this._setupInputSyncSubscription(this._dropListRef);
    this._handleEvents(this._dropListRef);
    _CdkDropList._dropLists.push(this);
    if (this._group) {
      this._group._items.add(this);
    }
  }
  /** Registers an items with the drop list. */
  addItem(item) {
    this._unsortedItems.add(item);
    if (this._dropListRef.isDragging()) {
      this._syncItemsWithRef();
    }
  }
  /** Removes an item from the drop list. */
  removeItem(item) {
    this._unsortedItems.delete(item);
    if (this._dropListRef.isDragging()) {
      this._syncItemsWithRef();
    }
  }
  /** Gets the registered items in the list, sorted by their position in the DOM. */
  getSortedItems() {
    return Array.from(this._unsortedItems).sort((a, b) => {
      const documentPosition = a._dragRef.getVisibleElement().compareDocumentPosition(b._dragRef.getVisibleElement());
      return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
    });
  }
  ngOnDestroy() {
    const index = _CdkDropList._dropLists.indexOf(this);
    if (index > -1) {
      _CdkDropList._dropLists.splice(index, 1);
    }
    if (this._group) {
      this._group._items.delete(this);
    }
    this._unsortedItems.clear();
    this._dropListRef.dispose();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */
  _setupInputSyncSubscription(ref) {
    if (this._dir) {
      this._dir.change.pipe(startWith(this._dir.value), takeUntil(this._destroyed)).subscribe((value) => ref.withDirection(value));
    }
    ref.beforeStarted.subscribe(() => {
      const siblings = coerceArray(this.connectedTo).map((drop) => {
        if (typeof drop === "string") {
          const correspondingDropList = _CdkDropList._dropLists.find((list) => list.id === drop);
          if (!correspondingDropList && (typeof ngDevMode === "undefined" || ngDevMode)) {
            console.warn(`CdkDropList could not find connected drop list with id "${drop}"`);
          }
          return correspondingDropList;
        }
        return drop;
      });
      if (this._group) {
        this._group._items.forEach((drop) => {
          if (siblings.indexOf(drop) === -1) {
            siblings.push(drop);
          }
        });
      }
      if (!this._scrollableParentsResolved) {
        const scrollableParents = this._scrollDispatcher.getAncestorScrollContainers(this.element).map((scrollable) => scrollable.getElementRef().nativeElement);
        this._dropListRef.withScrollableParents(scrollableParents);
        this._scrollableParentsResolved = true;
      }
      if (this.elementContainerSelector) {
        const container = this.element.nativeElement.querySelector(this.elementContainerSelector);
        if (!container && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw new Error(`CdkDropList could not find an element container matching the selector "${this.elementContainerSelector}"`);
        }
        ref.withElementContainer(container);
      }
      ref.disabled = this.disabled;
      ref.lockAxis = this.lockAxis;
      ref.sortingDisabled = this.sortingDisabled;
      ref.autoScrollDisabled = this.autoScrollDisabled;
      ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);
      ref.connectedTo(siblings.filter((drop) => drop && drop !== this).map((list) => list._dropListRef)).withOrientation(this.orientation);
    });
  }
  /** Handles events from the underlying DropListRef. */
  _handleEvents(ref) {
    ref.beforeStarted.subscribe(() => {
      this._syncItemsWithRef();
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe((event) => {
      this.entered.emit({
        container: this,
        item: event.item.data,
        currentIndex: event.currentIndex
      });
    });
    ref.exited.subscribe((event) => {
      this.exited.emit({
        container: this,
        item: event.item.data
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.sorted.subscribe((event) => {
      this.sorted.emit({
        previousIndex: event.previousIndex,
        currentIndex: event.currentIndex,
        container: this,
        item: event.item.data
      });
    });
    ref.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        item: dropEvent.item.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    merge(ref.receivingStarted, ref.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck());
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      draggingDisabled,
      sortingDisabled,
      listAutoScrollDisabled,
      listOrientation
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;
    this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;
    this.orientation = listOrientation || "vertical";
    if (lockAxis) {
      this.lockAxis = lockAxis;
    }
  }
  /** Syncs up the registered drag items with underlying drop list ref. */
  _syncItemsWithRef() {
    this._dropListRef.withItems(this.getSortedItems().map((item) => item._dragRef));
  }
  static ɵfac = function CdkDropList_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDropList)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDropList,
    selectors: [["", "cdkDropList", ""], ["cdk-drop-list"]],
    hostAttrs: [1, "cdk-drop-list"],
    hostVars: 7,
    hostBindings: function CdkDropList_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.id);
        ɵɵclassProp("cdk-drop-list-disabled", ctx.disabled)("cdk-drop-list-dragging", ctx._dropListRef.isDragging())("cdk-drop-list-receiving", ctx._dropListRef.isReceiving());
      }
    },
    inputs: {
      connectedTo: [0, "cdkDropListConnectedTo", "connectedTo"],
      data: [0, "cdkDropListData", "data"],
      orientation: [0, "cdkDropListOrientation", "orientation"],
      id: "id",
      lockAxis: [0, "cdkDropListLockAxis", "lockAxis"],
      disabled: [2, "cdkDropListDisabled", "disabled", booleanAttribute],
      sortingDisabled: [2, "cdkDropListSortingDisabled", "sortingDisabled", booleanAttribute],
      enterPredicate: [0, "cdkDropListEnterPredicate", "enterPredicate"],
      sortPredicate: [0, "cdkDropListSortPredicate", "sortPredicate"],
      autoScrollDisabled: [2, "cdkDropListAutoScrollDisabled", "autoScrollDisabled", booleanAttribute],
      autoScrollStep: [0, "cdkDropListAutoScrollStep", "autoScrollStep"],
      elementContainerSelector: [0, "cdkDropListElementContainer", "elementContainerSelector"]
    },
    outputs: {
      dropped: "cdkDropListDropped",
      entered: "cdkDropListEntered",
      exited: "cdkDropListExited",
      sorted: "cdkDropListSorted"
    },
    exportAs: ["cdkDropList"],
    features: [ɵɵProvidersFeature([
      // Prevent child drop lists from picking up the same group as their parent.
      {
        provide: CDK_DROP_LIST_GROUP,
        useValue: void 0
      },
      {
        provide: CDK_DROP_LIST,
        useExisting: _CdkDropList
      }
    ]), ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropList, [{
    type: Directive,
    args: [{
      selector: "[cdkDropList], cdk-drop-list",
      exportAs: "cdkDropList",
      providers: [
        // Prevent child drop lists from picking up the same group as their parent.
        {
          provide: CDK_DROP_LIST_GROUP,
          useValue: void 0
        },
        {
          provide: CDK_DROP_LIST,
          useExisting: CdkDropList
        }
      ],
      host: {
        "class": "cdk-drop-list",
        "[attr.id]": "id",
        "[class.cdk-drop-list-disabled]": "disabled",
        "[class.cdk-drop-list-dragging]": "_dropListRef.isDragging()",
        "[class.cdk-drop-list-receiving]": "_dropListRef.isReceiving()"
      }
    }]
  }], () => [], {
    connectedTo: [{
      type: Input,
      args: ["cdkDropListConnectedTo"]
    }],
    data: [{
      type: Input,
      args: ["cdkDropListData"]
    }],
    orientation: [{
      type: Input,
      args: ["cdkDropListOrientation"]
    }],
    id: [{
      type: Input
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDropListLockAxis"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListDisabled",
        transform: booleanAttribute
      }]
    }],
    sortingDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListSortingDisabled",
        transform: booleanAttribute
      }]
    }],
    enterPredicate: [{
      type: Input,
      args: ["cdkDropListEnterPredicate"]
    }],
    sortPredicate: [{
      type: Input,
      args: ["cdkDropListSortPredicate"]
    }],
    autoScrollDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListAutoScrollDisabled",
        transform: booleanAttribute
      }]
    }],
    autoScrollStep: [{
      type: Input,
      args: ["cdkDropListAutoScrollStep"]
    }],
    elementContainerSelector: [{
      type: Input,
      args: ["cdkDropListElementContainer"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDropListDropped"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDropListEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDropListExited"]
    }],
    sorted: [{
      type: Output,
      args: ["cdkDropListSorted"]
    }]
  });
})();
var CDK_DRAG_PREVIEW = new InjectionToken("CdkDragPreview");
var CdkDragPreview = class _CdkDragPreview {
  templateRef = inject(TemplateRef);
  _drag = inject(CDK_DRAG_PARENT, {
    optional: true
  });
  /** Context data to be added to the preview template instance. */
  data;
  /** Whether the preview should preserve the same size as the item that is being dragged. */
  matchSize = false;
  constructor() {
    this._drag?._setPreviewTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPreviewTemplate(this);
  }
  static ɵfac = function CdkDragPreview_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragPreview)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDragPreview,
    selectors: [["ng-template", "cdkDragPreview", ""]],
    inputs: {
      data: "data",
      matchSize: [2, "matchSize", "matchSize", booleanAttribute]
    },
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_PREVIEW,
      useExisting: _CdkDragPreview
    }]), ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPreview, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPreview]",
      providers: [{
        provide: CDK_DRAG_PREVIEW,
        useExisting: CdkDragPreview
      }]
    }]
  }], () => [], {
    data: [{
      type: Input
    }],
    matchSize: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_PLACEHOLDER = new InjectionToken("CdkDragPlaceholder");
var CdkDragPlaceholder = class _CdkDragPlaceholder {
  templateRef = inject(TemplateRef);
  _drag = inject(CDK_DRAG_PARENT, {
    optional: true
  });
  /** Context data to be added to the placeholder template instance. */
  data;
  constructor() {
    this._drag?._setPlaceholderTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPlaceholderTemplate(this);
  }
  static ɵfac = function CdkDragPlaceholder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragPlaceholder)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDragPlaceholder,
    selectors: [["ng-template", "cdkDragPlaceholder", ""]],
    inputs: {
      data: "data"
    },
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_PLACEHOLDER,
      useExisting: _CdkDragPlaceholder
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPlaceholder, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPlaceholder]",
      providers: [{
        provide: CDK_DRAG_PLACEHOLDER,
        useExisting: CdkDragPlaceholder
      }]
    }]
  }], () => [], {
    data: [{
      type: Input
    }]
  });
})();
var DRAG_DROP_DIRECTIVES = [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder];
var DragDropModule = class _DragDropModule {
  static ɵfac = function DragDropModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDropModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DragDropModule,
    imports: [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder],
    exports: [CdkScrollableModule, CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [DragDrop],
    imports: [CdkScrollableModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropModule, [{
    type: NgModule,
    args: [{
      imports: DRAG_DROP_DIRECTIVES,
      exports: [CdkScrollableModule, ...DRAG_DROP_DIRECTIVES],
      providers: [DragDrop]
    }]
  }], null, null);
})();

// node_modules/@po-ui/ng-components/fesm2022/po-ui-ng-components.mjs
var PoDividerSize;
(function(PoDividerSize2) {
  PoDividerSize2["small"] = "small";
  PoDividerSize2["medium"] = "medium";
  PoDividerSize2["large"] = "large";
})(PoDividerSize || (PoDividerSize = {}));
var PoDividerBaseComponent = class _PoDividerBaseComponent {
  coordinateX1;
  coordinateX2;
  _borderWidth = PoDividerSize.small;
  /** Valor do rótulo a ser exibido. */
  label;
  /**
   * @optional
   *
   * @description
   *
   * Define a espessura da linha.
   *
   * Valores válidos:
   * - small
   * - medium
   * - large
   *
   * @default `small`
   */
  set borderWidth(value) {
    this._borderWidth = PoDividerSize[value] ? PoDividerSize[value] : PoDividerSize.small;
    this.getCoordinates();
  }
  get borderWidth() {
    return this._borderWidth;
  }
  ngOnInit() {
    this.getCoordinates();
  }
  getCoordinates() {
    if (this.borderWidth === PoDividerSize.small) {
      this.coordinateX1 = "0.1%";
      this.coordinateX2 = "99.9%";
    } else if (this.borderWidth === PoDividerSize.medium) {
      this.coordinateX1 = "0.2%";
      this.coordinateX2 = "99.8%";
    } else {
      this.coordinateX1 = "0.3%";
      this.coordinateX2 = "99.7%";
    }
  }
  static ɵfac = function PoDividerBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDividerBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoDividerBaseComponent,
    inputs: {
      label: [0, "p-label", "label"],
      borderWidth: [0, "p-border-width", "borderWidth"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDividerBaseComponent, [{
    type: Directive
  }], null, {
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    borderWidth: [{
      type: Input,
      args: ["p-border-width"]
    }]
  });
})();
function PoDividerComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
var PoDividerComponent = class _PoDividerComponent extends PoDividerBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoDividerComponent_BaseFactory;
    return function PoDividerComponent_Factory(__ngFactoryType__) {
      return (ɵPoDividerComponent_BaseFactory || (ɵPoDividerComponent_BaseFactory = ɵɵgetInheritedFactory(_PoDividerComponent)))(__ngFactoryType__ || _PoDividerComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDividerComponent,
    selectors: [["po-divider"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 4,
    consts: [[1, "po-divider"], ["class", "po-divider-label", 4, "ngIf"], ["xmlns", "http://www.w3.org/2000/svg"], ["y1", "50%", "y2", "50%"], [1, "po-divider-label"]],
    template: function PoDividerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoDividerComponent_div_1_Template, 2, 1, "div", 1);
        ɵɵnamespaceSVG();
        ɵɵelementStart(2, "svg", 2);
        ɵɵelement(3, "line", 3);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵattribute("p-size", ctx.borderWidth);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.label);
        ɵɵadvance(2);
        ɵɵattribute("x1", ctx.coordinateX1)("x2", ctx.coordinateX2);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDividerComponent, [{
    type: Component,
    args: [{
      selector: "po-divider",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div class="po-divider" [attr.p-size]="borderWidth">\n  <div *ngIf="label" class="po-divider-label">{{ label }}</div>\n  <svg xmlns="http://www.w3.org/2000/svg">\n    <line [attr.x1]="coordinateX1" y1="50%" [attr.x2]="coordinateX2" y2="50%" />\n  </svg>\n</div>\n'
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDividerComponent, {
    className: "PoDividerComponent",
    filePath: "lib/components/po-divider/po-divider.component.ts",
    lineNumber: 31
  });
})();
var PoDividerModule = class _PoDividerModule {
  static ɵfac = function PoDividerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDividerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoDividerModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDividerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PoDividerComponent],
      exports: [PoDividerComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDividerModule, {
    declarations: [PoDividerComponent],
    imports: [CommonModule],
    exports: [PoDividerComponent]
  });
})();
var ICONS_DICTIONARY = new InjectionToken("ICONS_TOKEN");
var PoIconDictionary = {
  NAME_LIB: "PoIcon",
  ICON_A11Y_ELDERLY: "po-icon po-icon-a11y-elderly",
  ICON_A11Y_PREGNANT: "po-icon po-icon-a11y-pregnant",
  ICON_A11Y_WHEELCHAIR: "po-icon po-icon-a11y-wheelchair",
  ICON_AGRO_BUSINESS: "po-icon po-icon-agro-business",
  ICON_ALIGN_CENTER: "po-icon po-icon-align-center",
  ICON_ALIGN_JUSTIFY: "po-icon po-icon-align-justify",
  ICON_ALIGN_LEFT: "po-icon po-icon-align-left",
  ICON_ALIGN_RIGHT: "po-icon po-icon-align-right",
  ICON_ANCHOR: "po-icon po-icon-anchor",
  ICON_ARCHIVE: "po-icon po-icon-archive",
  ICON_ARROW_DOWN: "po-icon po-icon-arrow-down",
  ICON_ARROW_LEFT: "po-icon po-icon-arrow-left",
  ICON_ARROW_RIGHT: "po-icon po-icon-arrow-right",
  ICON_ARROW_UP: "po-icon po-icon-arrow-up",
  ICON_ATTACH: "po-icon po-icon-attach",
  ICON_AUTOMATIC_BARRIER: "po-icon po-icon-automatic-barrier",
  ICON_BALANCE: "po-icon po-icon-balance",
  ICON_BALANCE_WEIGHT: "po-icon po-icon-balance-weight",
  ICON_BAR_CODE: "po-icon po-icon-bar-code",
  ICON_BASKET: "po-icon po-icon-basket",
  ICON_BLUETOOTH: "po-icon po-icon-bluetooth",
  ICON_BOOK: "po-icon po-icon-book",
  ICON_CALCULATOR: "po-icon po-icon-calculator",
  ICON_CALENDAR: "po-icon po-icon-calendar",
  ICON_CALENDAR_OK: "po-icon po-icon-calendar-ok",
  ICON_CALENDAR_SETTINGS: "po-icon po-icon-calendar-settings",
  ICON_CAMERA: "po-icon po-icon-camera",
  ICON_CART: "po-icon po-icon-cart",
  ICON_CHANGE: "po-icon po-icon-change",
  ICON_CHART_AREA: "po-icon po-icon-chart-area",
  ICON_CHART_COLUMNS: "po-icon po-icon-chart-columns",
  ICON_CHAT: "po-icon po-icon-chat",
  ICON_CLEAR_CONTENT: "po-icon po-icon-clear-content",
  ICON_CLIPBOARD: "po-icon po-icon-clipboard",
  ICON_CLOCK: "po-icon po-icon-clock",
  ICON_CLOSE: "po-icon po-icon-close",
  ICON_COMPANY: "po-icon po-icon-company",
  ICON_CONSTRUCTION: "po-icon po-icon-construction",
  ICON_COPY: "po-icon po-icon-copy",
  ICON_COTTON: "po-icon po-icon-cotton",
  ICON_CREDIT_PAYMENT: "po-icon po-icon-credit-payment",
  ICON_CUT: "po-icon po-icon-cut",
  ICON_DATABASE: "po-icon po-icon-database",
  ICON_DEBIT_PAYMENT: "po-icon po-icon-debit-payment",
  ICON_DELETE: "po-icon po-icon-delete",
  ICON_DEVICE_DESKTOP: "po-icon po-icon-device-desktop",
  ICON_DEVICE_NOTEBOOK: "po-icon po-icon-device-notebook",
  ICON_DEVICE_SMARTPHONE: "po-icon po-icon-device-smartphone",
  ICON_DEVICE_TABLET: "po-icon po-icon-device-tablet",
  ICON_DOC_XLS: "po-icon po-icon-doc-xls",
  ICON_DOCUMENT: "po-icon po-icon-document",
  ICON_DOCUMENT_DOUBLE: "po-icon po-icon-document-double",
  ICON_DOCUMENT_FILLED: "po-icon po-icon-document-filled",
  ICON_DOWNLOAD: "po-icon po-icon-download",
  ICON_EDIT: "po-icon po-icon-edit",
  ICON_EXAM: "po-icon po-icon-exam",
  ICON_EXCLAMATION: "po-icon po-icon-exclamation",
  ICON_EXIT: "po-icon po-icon-exit",
  ICON_EXPORT: "po-icon po-icon-export",
  ICON_EYE: "po-icon po-icon-eye",
  ICON_EYE_OFF: "po-icon po-icon-eye-off",
  ICON_FILTER: "po-icon po-icon-filter",
  ICON_FINANCE: "po-icon po-icon-finance",
  ICON_FINANCE_BITCOIN: "po-icon po-icon-finance-bitcoin",
  ICON_FINANCE_SECURE: "po-icon po-icon-finance-secure",
  ICON_FIRST_PAGE: "po-icon po-icon-first-page",
  ICON_FOLDER: "po-icon po-icon-folder",
  ICON_FOOD: "po-icon po-icon-food",
  ICON_FOOD_MENU: "po-icon po-icon-food-menu",
  ICON_GAS: "po-icon po-icon-gas",
  ICON_GIFT: "po-icon po-icon-gift",
  ICON_GRID: "po-icon po-icon-grid",
  ICON_HANDSHAKE: "po-icon po-icon-handshake",
  ICON_HDD: "po-icon po-icon-hdd",
  ICON_HELP: "po-icon po-icon-help",
  ICON_HISTORY: "po-icon po-icon-history",
  ICON_HOME: "po-icon po-icon-home",
  ICON_IMAGE_ALIGN_INLINE: "po-icon po-icon-image-align-inline",
  ICON_IMAGE_ALIGN_LEFT: "po-icon po-icon-image-align-left",
  ICON_IMAGE_ALIGN_RIGHT: "po-icon po-icon-image-align-right",
  ICON_INFO: "po-icon po-icon-info",
  ICON_INJECTOR: "po-icon po-icon-injector",
  ICON_KEYBOARD: "po-icon po-icon-keyboard",
  ICON_LAST_PAGE: "po-icon po-icon-last-page",
  ICON_LAYERS: "po-icon po-icon-layers",
  ICON_LIGHT: "po-icon po-icon-light",
  ICON_LIKE: "po-icon po-icon-like",
  ICON_LINK: "po-icon po-icon-link",
  ICON_LIST: "po-icon po-icon-list",
  ICON_LOCK: "po-icon po-icon-lock",
  ICON_LOCK_OFF: "po-icon po-icon-lock-off",
  ICON_MAIL: "po-icon po-icon-mail",
  ICON_MANUFACTURE: "po-icon po-icon-manufacture",
  ICON_MAP: "po-icon po-icon-map",
  ICON_MENU: "po-icon po-icon-menu",
  ICON_MENU_CLOSE: "po-icon po-icon-menu-close",
  ICON_MENU_OPEN: "po-icon po-icon-menu-open",
  ICON_MESSAGE: "po-icon po-icon-message",
  ICON_MICROPHONE: "po-icon po-icon-microphone",
  ICON_MINUS: "po-icon po-icon-minus",
  ICON_MINUS_CIRCLE: "po-icon po-icon-minus-circle",
  ICON_MONEY: "po-icon po-icon-money",
  ICON_MORE: "po-icon po-icon-more",
  ICON_MORE_VERT: "po-icon po-icon-more-vert",
  ICON_NEWS: "po-icon po-icon-news",
  ICON_NO_SIGNAL: "po-icon po-icon-no-signal",
  ICON_NOTIFICATION: "po-icon po-icon-notification",
  ICON_OIL: "po-icon po-icon-oil",
  ICON_OIL_ANALYSIS: "po-icon po-icon-oil-analysis",
  ICON_OK: "po-icon po-icon-ok",
  ICON_PALLET_FULL: "po-icon po-icon-pallet-full",
  ICON_PALLET_PARTIAL: "po-icon po-icon-pallet-partial",
  ICON_PARAMETERS: "po-icon po-icon-parameters",
  ICON_PASTE: "po-icon po-icon-paste",
  ICON_PAYMENT: "po-icon po-icon-payment",
  ICON_PDF: "po-icon po-icon-pdf",
  ICON_PICKER: "po-icon po-icon-picker",
  ICON_PICTURE: "po-icon po-icon-picture",
  ICON_PIN: "po-icon po-icon-pin",
  ICON_PIX_LOGO: "po-icon po-icon-pix-logo",
  ICON_PLUS: "po-icon po-icon-plus",
  ICON_PLUS_CIRCLE: "po-icon po-icon-plus-circle",
  ICON_PRINT: "po-icon po-icon-print",
  ICON_PUSHCART: "po-icon po-icon-pushcart",
  ICON_QR_CODE: "po-icon po-icon-qr-code",
  ICON_REFRESH: "po-icon po-icon-refresh",
  ICON_SALE: "po-icon po-icon-sale",
  ICON_SCREEN_FULL: "po-icon po-icon-screen-full",
  ICON_SCREEN_MINIMIZE: "po-icon po-icon-screen-minimize",
  ICON_SEARCH: "po-icon po-icon-search",
  ICON_SECURITY_GUARD: "po-icon po-icon-security-guard",
  ICON_SERVER: "po-icon po-icon-server",
  ICON_SETTINGS: "po-icon po-icon-settings",
  ICON_SHARE: "po-icon po-icon-share",
  ICON_SIGNAL: "po-icon po-icon-signal",
  ICON_SMS: "po-icon po-icon-sms",
  ICON_SOCIAL_GITHUB: "po-icon po-icon-social-github",
  ICON_SOCIAL_INSTAGRAM: "po-icon po-icon-social-instagram",
  ICON_SOCIAL_TWITTER: "po-icon po-icon-social-twitter",
  ICON_SOCIAL_WHATSAPP: "po-icon po-icon-social-whatsapp",
  ICON_SORT: "po-icon po-icon-sort",
  ICON_SORT_ASC: "po-icon po-icon-sort-asc",
  ICON_SORT_ASCENDING: "po-icon po-icon-sort-ascending",
  ICON_SORT_DESC: "po-icon po-icon-sort-desc",
  ICON_SORT_DESCENDING: "po-icon po-icon-sort-descending",
  ICON_STAR: "po-icon po-icon-star",
  ICON_STAR_FILLED: "po-icon po-icon-star-filled",
  ICON_STAR_HALF: "po-icon po-icon-star-half",
  ICON_STEERING_WHEEL: "po-icon po-icon-steering-wheel",
  ICON_STOCK: "po-icon po-icon-stock",
  ICON_TABLE: "po-icon po-icon-table",
  ICON_TARGET: "po-icon po-icon-target",
  ICON_TELEPHONE: "po-icon po-icon-telephone",
  ICON_TEXT_BOLD: "po-icon po-icon-text-bold",
  ICON_TEXT_ITALIC: "po-icon po-icon-text-italic",
  ICON_TEXT_UNDERLINE: "po-icon po-icon-text-underline",
  ICON_TOUCH: "po-icon po-icon-touch",
  ICON_TRAVEL: "po-icon po-icon-travel",
  ICON_TRUCK: "po-icon po-icon-truck",
  ICON_UPLOAD: "po-icon po-icon-upload",
  ICON_UPLOAD_CLOUD: "po-icon po-icon-upload-cloud",
  ICON_USER: "po-icon po-icon-user",
  ICON_USER_ADD: "po-icon po-icon-user-add",
  ICON_USER_DELETE: "po-icon po-icon-user-delete",
  ICON_USERS: "po-icon po-icon-users",
  ICON_VIDEO_CALL: "po-icon po-icon-video-call",
  ICON_WAITER: "po-icon po-icon-waiter",
  ICON_WALLET: "po-icon po-icon-wallet",
  ICON_WAREHOUSE: "po-icon po-icon-warehouse",
  ICON_WARNING: "po-icon po-icon-warning",
  ICON_WEIGHT: "po-icon po-icon-weight",
  ICON_WORLD: "po-icon po-icon-world",
  ICON_XML: "po-icon po-icon-xml",
  ICON_ZOOM_IN: "po-icon po-icon-zoom-in",
  ICON_ZOOM_OUT: "po-icon po-icon-zoom-out"
};
var AnimaliaIconDictionary = {
  NAME_LIB: "AnimaliaIcon",
  ICON_ALIGN_CENTER: "an an-text-align-center",
  ICON_ALIGN_JUSTIFY: "an an-text-align-justify",
  ICON_ALIGN_LEFT: "an an-text-align-left",
  ICON_ALIGN_RIGHT: "an an-text-align-right",
  ICON_ARROW_DOWN: "an an-caret-down",
  ICON_ARROW_LEFT: "an an-caret-left",
  ICON_ARROW_RIGHT: "an an-caret-right",
  ICON_ARROW_UP: "an an-caret-up",
  ICON_CALENDAR: "an an-calendar-blank",
  ICON_CLEAR_CONTENT: "an an-x-circle",
  ICON_CLOCK: "an an-clock",
  ICON_CLOSE: "an an-x",
  ICON_DELETE: "an an-trash",
  ICON_DRAG: "an an-dots-six-vertical",
  ICON_EDIT: "an an-pencil-simple",
  ICON_EXCLAMATION: "an an-warning-circle",
  ICON_EXIT: "an an-sign-out",
  ICON_EYE: "an an-eye",
  ICON_EYE_OFF: "an an-eye-closed",
  ICON_FILTER: "an an-funnel",
  ICON_HELP: "an an-question",
  ICON_INFO: "an an-info",
  ICON_LAST_PAGE: "an an-caret-double-right",
  ICON_LINK: "an an-link",
  ICON_LIST: "an an-list-dashes",
  ICON_LOCK: "an an-lock",
  ICON_MAIL: "an an-envelope-simple",
  ICON_MENU: "an an-list",
  ICON_MENU_CLOSE: "an an-caret-circle-left",
  ICON_MENU_OPEN: "an an-caret-circle-right",
  ICON_MINUS: "an an-minus",
  ICON_MORE: "an an-dots-three",
  ICON_MORE_VERT: "an an-dots-three-vertical",
  ICON_NOTIFICATION: "an an-bell",
  ICON_OK: "an an-check",
  ICON_PARAMETERS: "an an-sliders-horizontal",
  ICON_PICTURE: "an an-image",
  ICON_PUSH_PIN: "an an-push-pin",
  ICON_PUSH_PIN_SLASH: "an an-push-pin-slash",
  ICON_REFRESH: "an an-arrow-clockwise",
  ICON_SEARCH: "an an-magnifying-glass",
  ICON_SETTINGS: "an an-gear-six",
  ICON_SORT: "an an-caret-up-down ",
  ICON_SORT_ASC: "an an-caret-up",
  ICON_SORT_DESC: "an an-caret-down",
  ICON_STAR: "an an-star",
  ICON_TELEPHONE: "an an-phone",
  ICON_TEXT_BOLD: "an an-text-b",
  ICON_TEXT_ITALIC: "an an-text-italic",
  ICON_TEXT_UNDERLINE: "an an-text-underline",
  ICON_UPLOAD_CLOUD: "an an-cloud-arrow-up",
  ICON_USER: "an an-user",
  ICON_WARNING: "an an-exclamation-mark",
  ICON_WORLD: "an an-globe-simple"
};
var _c0$1O = ["*"];
function PoIconComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoIconComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "i", 2);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap(ctx_r0.class);
  }
}
var PoIconComponent = class _PoIconComponent {
  class;
  _icon;
  _iconToken;
  constructor(value) {
    this._iconToken = value ?? AnimaliaIconDictionary;
  }
  /**
   * Define o ícone a ser exibido.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](https://po-ui.io/icons). conforme exemplo abaixo:
   * ```
   * <po-button p-icon="an an-user" p-label="PO button"></po-button>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-button p-icon="fa fa-podcast" p-label="PO button"></po-button>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-button [p-icon]="template" p-label="button template ionic"></po-button>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   */
  set icon(value) {
    if (typeof value === "string") {
      this.processIcon(value);
    } else if (value instanceof TemplateRef) {
      this._icon = value;
    }
  }
  get icon() {
    return this._icon;
  }
  addClasses(value, iconToken = false) {
    this.class = iconToken ? value : value.startsWith("po-icon-") ? this.class = `po-icon ${value}` : this.class = `po-fonts-icon ${value}`;
  }
  getIcon(iconName) {
    return this._iconToken.hasOwnProperty(iconName) ? this._iconToken[iconName].startsWith("po-icon ") ? this._iconToken[iconName] : "po-fonts-icon " + this._iconToken[iconName] : "";
  }
  processIcon(icon) {
    const iconToken = this.processIconTokens(icon);
    if (iconToken !== "") {
      this.addClasses(iconToken, true);
    } else {
      this.addClasses(icon);
    }
  }
  processIconTokens(value) {
    const iconTokens = this.splitIconNames(value);
    let icon = "";
    if (Array.isArray(iconTokens)) {
      iconTokens.map((iconName) => {
        icon += this.getIcon(iconName) !== "" ? " " + this.getIcon(iconName) : icon !== "" ? " " + iconName : iconName;
      });
    } else {
      icon = this.getIcon(iconTokens);
    }
    return icon.trim();
  }
  splitIconNames(iconName) {
    return iconName.includes(" ") ? iconName.split(" ") : iconName;
  }
  static ɵfac = function PoIconComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoIconComponent)(ɵɵdirectiveInject(ICONS_DICTIONARY, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoIconComponent,
    selectors: [["po-icon"]],
    inputs: {
      icon: [0, "p-icon", "icon"]
    },
    standalone: false,
    ngContentSelectors: _c0$1O,
    decls: 3,
    vars: 3,
    consts: [["fontTemplate", ""], [4, "ngIf", "ngIfThen", "ngIfElse"], ["aria-hidden", "true"]],
    template: function PoIconComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, PoIconComponent_ng_container_0_Template, 1, 0, "ng-container", 1)(1, PoIconComponent_ng_template_1_Template, 2, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const fontTemplate_r2 = ɵɵreference(2);
        ɵɵproperty("ngIf", ctx.class)("ngIfThen", fontTemplate_r2)("ngIfElse", ctx.icon);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoIconComponent, [{
    type: Component,
    args: [{
      selector: "po-icon",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<ng-container *ngIf="class; then fontTemplate; else icon"></ng-container>\n\n<ng-template #fontTemplate>\n  <i [class]="class" aria-hidden="true">\n    <ng-content></ng-content>\n  </i>\n</ng-template>\n'
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ICONS_DICTIONARY]
    }]
  }], {
    icon: [{
      type: Input,
      args: ["p-icon"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoIconComponent, {
    className: "PoIconComponent",
    filePath: "lib/components/po-icon/po-icon.component.ts",
    lineNumber: 18
  });
})();
var PoIconModule = class _PoIconModule {
  static ɵfac = function PoIconModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoIconModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoIconModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoIconModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PoIconComponent],
      exports: [PoIconComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoIconModule, {
    declarations: [PoIconComponent],
    imports: [CommonModule],
    exports: [PoIconComponent]
  });
})();
var PoTagOrientation;
(function(PoTagOrientation2) {
  PoTagOrientation2["Horizontal"] = "horizontal";
  PoTagOrientation2["Vertical"] = "vertical";
})(PoTagOrientation || (PoTagOrientation = {}));
var PoTagType;
(function(PoTagType2) {
  PoTagType2["Danger"] = "danger";
  PoTagType2["Info"] = "info";
  PoTagType2["Success"] = "success";
  PoTagType2["Warning"] = "warning";
  PoTagType2["Neutral"] = "neutral";
})(PoTagType || (PoTagType = {}));
var PoTagIcon;
(function(PoTagIcon2) {
  PoTagIcon2["Danger"] = "ICON_CLOSE";
  PoTagIcon2["Info"] = "ICON_INFO";
  PoTagIcon2["Success"] = "ICON_OK";
  PoTagIcon2["Warning"] = "ICON_WARNING";
})(PoTagIcon || (PoTagIcon = {}));
var PoColorPaletteEnum;
(function(PoColorPaletteEnum2) {
  PoColorPaletteEnum2["Color01"] = "color-01";
  PoColorPaletteEnum2["Color02"] = "color-02";
  PoColorPaletteEnum2["Color03"] = "color-03";
  PoColorPaletteEnum2["Color04"] = "color-04";
  PoColorPaletteEnum2["Color05"] = "color-05";
  PoColorPaletteEnum2["Color06"] = "color-06";
  PoColorPaletteEnum2["Color07"] = "color-07";
  PoColorPaletteEnum2["Color08"] = "color-08";
  PoColorPaletteEnum2["Color09"] = "color-09";
  PoColorPaletteEnum2["Color10"] = "color-10";
  PoColorPaletteEnum2["Color11"] = "color-11";
  PoColorPaletteEnum2["Color12"] = "color-12";
})(PoColorPaletteEnum || (PoColorPaletteEnum = {}));
var poLanguageDefault = [{
  description: "English",
  language: "en"
}, {
  description: "Español",
  language: "es"
}, {
  description: "Português",
  language: "pt"
}, {
  description: "Pусский",
  language: "ru"
}];
var poLocales = poLanguageDefault.map((language) => language.language);
var poLocaleDefault = "pt";
var poLocaleDecimalSeparatorList = [{
  separator: ".",
  language: "en"
}, {
  separator: ",",
  language: "es"
}, {
  separator: ",",
  language: "pt"
}, {
  separator: ",",
  language: "ru"
}];
var poLocaleThousandSeparatorList = [{
  separator: ",",
  language: "en"
}, {
  separator: ".",
  language: "es"
}, {
  separator: ".",
  language: "pt"
}, {
  separator: " ",
  language: "ru"
}];
var poLocaleDateSeparatorList = [{
  separator: "/",
  locale: "en"
}, {
  separator: "/",
  locale: "es"
}, {
  separator: "/",
  locale: "pt"
}, {
  separator: ".",
  locale: "ru"
}];
function formatBytes(bytes, decimals = 2) {
  if (!bytes) {
    return void 0;
  }
  const multiplier = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  const result = Math.floor(Math.log(bytes) / Math.log(multiplier));
  decimals = decimals < 0 ? 0 : decimals;
  return `${parseFloat((bytes / Math.pow(multiplier, result)).toFixed(decimals))} ${sizes[result]}`;
}
function getBrowserLanguage() {
  const language = navigator.language || navigator["userLanguage"];
  const shortLanguage = getShortLanguage(language);
  return poLocales.includes(shortLanguage) ? language : poLocaleDefault;
}
function getShortBrowserLanguage() {
  return getShortLanguage(getBrowserLanguage());
}
function getShortLanguage(language) {
  return (language || poLocaleDefault).toLowerCase().substring(0, 2);
}
function isLanguage(value) {
  const languageRegex = new RegExp("^[a-z]{2}(-[a-z]{2})?$", "i");
  return languageRegex.test(value);
}
function reloadCurrentPage() {
  const currentUrl = window.location.origin + window.location.pathname;
  if (isValidUrl(currentUrl)) {
    window.location.assign(currentUrl);
  }
}
function isValidUrl(url, location = window.location) {
  return url === location.origin + location.pathname;
}
function convertToBoolean(val) {
  if (typeof val === "string") {
    val = val.toLowerCase().trim();
    return val === "true" || val === "on" || val === "";
  }
  if (typeof val === "number") {
    return val === 1;
  }
  return !!val;
}
function convertToInt(value, valueDefault) {
  const validNumber = parseInt(value, 10);
  const validDefaultValue = parseInt(valueDefault, 10);
  const defaultValue = validDefaultValue || validDefaultValue === 0 ? validDefaultValue : void 0;
  return validNumber || validNumber === 0 ? validNumber : defaultValue;
}
function isTypeof(object, type) {
  return typeof object === type;
}
function callFunction(fn, context, param) {
  if (isTypeof(fn, "function")) {
    fn.call(context, param);
  } else {
    context[fn](param);
  }
}
function convertIsoToDate(value, start, end) {
  if (value) {
    const day = parseInt(value.substring(8, 10), 10);
    const month = parseInt(value.substring(5, 7), 10);
    const year = parseInt(value.substring(0, 4), 10);
    if (start) {
      const date = new Date(year, month - 1, day, 0, 0, 0);
      setYearFrom0To100(date, year);
      return date;
    } else if (end) {
      const date = new Date(year, month - 1, day, 23, 59, 59);
      setYearFrom0To100(date, year);
      return date;
    } else {
      return new Date(year, month - 1, day);
    }
  }
}
function convertDateToISODate(date) {
  if (date) {
    const getMonth = date.getMonth() + 1;
    const day = date.getDate() < 10 ? "0" + date.getDate() : date.getDate();
    const month = getMonth < 10 ? "0" + getMonth : getMonth;
    const year = formatYear(date.getFullYear());
    return year + "-" + month + "-" + day;
  } else {
    return null;
  }
}
function convertDateToISOExtended(date, time) {
  if (date) {
    const getMonth = date.getMonth() + 1;
    const day = date.getDate() < 10 ? "0" + date.getDate() : date.getDate();
    const month = getMonth < 10 ? "0" + getMonth : getMonth;
    const year = formatYear(date.getFullYear());
    const dateString = date.toString();
    if (time !== null) {
      return year + "-" + month + "-" + day + time;
    } else {
      return year + "-" + month + "-" + day + "T" + dateString.substring(16, 24) + dateString.substring(28, 31) + ":" + dateString.substring(31, 33);
    }
  } else {
    return null;
  }
}
function formatYear(year) {
  if (year >= 1e3) {
    return year.toString();
  }
  if (year > 99 && year < 1e3) {
    return `0${year}`;
  }
  if (year > 9 && year < 100) {
    return `00${year}`;
  }
  if (year >= 0 && year < 10) {
    return `000${year}`;
  }
}
function isIEOrEdge() {
  const userAgent = window.navigator.userAgent;
  return /msie\s|trident\/|edge\//i.test(userAgent);
}
function isIE() {
  const userAgent = window.navigator.userAgent;
  return /msie\s|trident/i.test(userAgent);
}
function isFirefox() {
  const userAgent = window.navigator.userAgent;
  return userAgent.toLowerCase().indexOf("firefox") > -1;
}
function isSafari() {
  const userAgent = window.navigator.userAgent;
  return /^(?!.*chrome).*safari.*$/.test(userAgent.toLocaleLowerCase());
}
function isMobile() {
  const userAgent = window.navigator.userAgent;
  return userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone/i);
}
function isEquals(value, comparedValue) {
  return JSON.stringify(value) === JSON.stringify(comparedValue);
}
function isKeyCodeEnter(event) {
  return event.keyCode === 13 || event.which === 13;
}
function isKeyCodeSpace(event) {
  return event.keyCode === 32 || event.which === 32;
}
function setYearFrom0To100(date, year) {
  if (year >= 0 && year < 100) {
    date.setFullYear(year);
  }
}
function sortOptionsByProperty(options, property) {
  options.sort((optionA, optionB) => {
    optionA = optionA[property].toString().toLowerCase();
    optionB = optionB[property].toString().toLowerCase();
    if (optionA < optionB) {
      return -1;
    }
    if (optionA > optionB) {
      return 1;
    }
    return 0;
  });
}
function sortFields(fields = [], defaultOrdering = -1) {
  const resultClassification = {
    fieldAComesFirst: -1,
    fieldAComesAfter: 1,
    keepPositions: 0
  };
  const isOrderValid = (order) => isTypeof(order, "number") && order > 0;
  const applyDefaultOrdering = (order) => isOrderValid(order) ? order : defaultOrdering;
  return fields.sort((fieldA, fieldB) => {
    const orderA = applyDefaultOrdering(fieldA.order);
    const orderB = applyDefaultOrdering(fieldB.order);
    if (orderA === orderB) {
      return resultClassification.keepPositions;
    }
    if (orderA === defaultOrdering) {
      return resultClassification.fieldAComesAfter;
    }
    if (orderB === defaultOrdering) {
      return resultClassification.fieldAComesFirst;
    }
    return orderA - orderB;
  });
}
function removeDuplicatedOptions(list) {
  for (let i = 0; i < list.length; i++) {
    if (i === 0) {
      continue;
    }
    if (list.findIndex((op) => op.value === list[i].value) !== i) {
      list.splice(i, 1);
      i--;
    }
  }
}
function removeDuplicatedOptionsWithFieldValue(list, newValue) {
  for (let i = 0; i < list.length; i++) {
    if (i === 0) {
      continue;
    }
    if (list.findIndex((op) => op[newValue] === list[i][newValue]) !== i) {
      list.splice(i, 1);
      i--;
    }
  }
}
function removeUndefinedAndNullOptions(list) {
  for (let i = 0; i < list.length; i++) {
    if (list[i].value === void 0 || list[i].value === null) {
      list.splice(i, 1);
      i--;
    }
  }
}
function removeUndefinedAndNullOptionsWithFieldValue(list, newValue) {
  for (let i = 0; i < list.length; i++) {
    if (list[i][newValue] === void 0 || list[i][newValue] === null) {
      list.splice(i, 1);
      i--;
    }
  }
}
function validValue(value) {
  return value !== null && value !== void 0 && value !== "" || value === false;
}
function isExternalLink(url) {
  return url ? url.startsWith("http") : false;
}
function openExternalLink(url) {
  window.open(url, "_blank");
}
function getFormattedLink(link) {
  let formattedLink = "";
  if (link) {
    formattedLink = link.replace(/^(\.)+/g, "");
  }
  if (!formattedLink.startsWith("/")) {
    formattedLink = "/".concat(formattedLink);
  }
  return formattedLink;
}
function sortValues(leftSide, rightSide, ascending = true) {
  const left = isTypeof(leftSide, "string") ? leftSide.toLowerCase() : leftSide;
  const right = isTypeof(rightSide, "string") ? rightSide.toLowerCase() : rightSide;
  const leftIsInvalid = left === null || left === void 0 || Number.isNaN(left);
  const rightIsInvalid = right === null || right === void 0 || Number.isNaN(right);
  if (ascending) {
    if (left < right || leftIsInvalid) {
      return -1;
    } else if (left > right || rightIsInvalid) {
      return 1;
    }
  } else if (ascending === false) {
    if (left < right || leftIsInvalid) {
      return 1;
    } else if (left > right || rightIsInvalid) {
      return -1;
    }
  }
  return 0;
}
function validateDateRange(date, dateStart, dateEnd) {
  if (dateStart && dateEnd) {
    return date >= dateStart && date <= dateEnd;
  } else if (dateStart && !dateEnd) {
    return date >= dateStart;
  } else if (!dateStart && dateEnd) {
    return date <= dateEnd;
  } else {
    return true;
  }
}
function uuid() {
  function hex4() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  return hex4() + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + hex4() + hex4();
}
function capitalizeFirstLetter(text) {
  return `${text.charAt(0).toUpperCase()}${text.slice(1)}`;
}
function convertImageToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = (error) => reject(error);
  });
}
function isValidImageBase64(value) {
  try {
    return !!value.match(/^data:image\/([a-zA-Z]*);base64,([^\"]*)$/);
  } catch (err) {
    return false;
  }
}
function convertNumberToDecimal(number, decimalsPlace) {
  const isValidValue = (number || number === 0) && !isNaN(number);
  const floatValue = isValidValue ? parseFloat(number) : void 0;
  try {
    return parseFloat(floatValue.toFixed(decimalsPlace));
  } catch {
    return floatValue;
  }
}
function validateObjectType(value) {
  return isTypeof(value, "object") && !Array.isArray(value) ? value : void 0;
}
function getFocusableElements(parentElement) {
  const focusableElements = 'button:not([disabled]), [href], input, select, textarea, [tabindex]:not([tabindex="-1"]';
  return parentElement.querySelectorAll(focusableElements);
}
function replaceFormatSeparator(format, separator) {
  let newFormat = format;
  if (separator !== "/") {
    newFormat = newFormat.replace(/\//g, separator);
  }
  return newFormat;
}
function sortArrayOfObjects(items, key, isAscendingOrder) {
  if (items) {
    return items.sort((a, b) => {
      const valueA = a[key];
      const valueB = b[key];
      if (typeof valueA === "number" && typeof valueB === "number") {
        return isAscendingOrder ? valueA - valueB : valueB - valueA;
      } else {
        const compareResult = valueA.toString().localeCompare(valueB.toString());
        return isAscendingOrder ? compareResult : -compareResult;
      }
    });
  }
}
var poDefaultLanguage = "PO_DEFAULT_LANGUAGE";
var poLocaleKey = "PO_USER_LOCALE";
var PoLanguageService = class _PoLanguageService {
  constructor() {
  }
  set languageDefault(language) {
    if (language && isLanguage(language)) {
      localStorage.setItem(poDefaultLanguage, language);
    }
  }
  get languageDefault() {
    return localStorage.getItem(poDefaultLanguage);
  }
  /**
   * @description
   *
   * Método responsável por retornar o idioma ativo.
   *
   * A busca do idioma será feita na seguinte ordem:
   *
   *   1 - o idioma que foi armazenado no *localStorage*, através do método `setLanguage()` utilizado pelo i18n.
   *
   *   2 - o valor inserido nas configurações do módulo do i18n através do parâmetro `config`, sendo o idioma inserido
   * na propriedade `language` da interface `PoI18nConfigDefault`.
   *
   *   3 - o idioma do navegador utilizado.
   *
   * > Caso o idioma do navegador não seja suportado pelo PO (`pt`, `en`, `es` ou `ru`), será retornado valor `pt`.
   *
   * **Retorno:** `string` com a sigla do idioma ativo.
   */
  getLanguage() {
    const language = localStorage.getItem(poLocaleKey) || this.languageDefault || getBrowserLanguage();
    return language && language.toLowerCase();
  }
  /**
   * @description
   *
   * Método responsável por retornar o idioma *default* da aplicação definido nas configurações do módulo do i18n através
   * do parâmetro `config`.
   *
   * **Retorno:** `string` com a sigla do idioma *default*.
   */
  getLanguageDefault() {
    return this.languageDefault;
  }
  /**
   * @description
   *
   * Método responsável por retornar a abreviação do idioma ativo na aplicação.
   *
   * @default `pt`
   *
   * **Retorno:** `string` com a sigla abreviada do idioma ativo.
   */
  getShortLanguage() {
    const language = this.getLanguage();
    const shortLanguage = getShortLanguage(language);
    return poLocales.includes(shortLanguage) ? shortLanguage : poLocaleDefault;
  }
  /**
   * @description
   *
   * Método para salvar o idioma da aplicação no *storage*, utilizado pelo serviço do i18n.
   *
   * > Ao definir um idioma por este método, todos os módulos da aplicação utilizarão o idioma definido.
   *
   * @param language sigla do idioma.
   *
   * Esta sigla deve ser composta por duas letras representando o idioma,
   * podendo ser adicionado outras duas letras representando o país, por exemplo: `pt`, `pt-BR`, `pt-br`, `en` ou `en-US`.
   *
   * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
   */
  setLanguage(language) {
    if (!isLanguage(language)) {
      return;
    }
    localStorage.setItem(poLocaleKey, language.toLowerCase());
  }
  /**
   * @description
   *
   * Método que define o idioma configurado a partir do parâmetro `config` utilizado pelo módulo do i18n.
   *
   * > Ao definir um idioma por este serviço, apenas o módulo do i18n referente a esta configuração utilizará o idioma definido.
   *
   * @param language sigla do idioma.
   *
   * Esta sigla deve ser composta por duas letras representando o idioma,
   * podendo ser adicionado outras duas letras representando o país, por exemplo: `pt`, `pt-BR`, `pt-br`, `en` ou `en-US`.
   *
   * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
   */
  setLanguageDefault(language) {
    this.languageDefault = language;
  }
  /**
   * @description
   *
   * Método que retorna o separador
   *
   * @param language sigla do idioma.
   *
   * Esta sigla deve ser composta por duas letras representando o idioma
   *
   * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
   */
  getNumberSeparators(language) {
    language = language || this.getShortLanguage();
    const decimal = poLocaleDecimalSeparatorList.find((separator) => separator.language === language) ?? {};
    const thousand = poLocaleThousandSeparatorList.find((separator) => separator.language === language) ?? {};
    const decimalSeparator = decimal.separator ?? ",";
    const thousandSeparator = thousand.separator ?? ".";
    return {
      decimalSeparator,
      thousandSeparator
    };
  }
  /**
   * @description
   *
   * Método que retorna o separador de datas
   *
   * @param language sigla do idioma.
   *
   * Esta sigla deve ser composta por duas letras representando o idioma
   *
   * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
   */
  getDateSeparator(language) {
    language = language || this.getShortLanguage();
    const separatorChar = poLocaleDateSeparatorList.find((separator) => separator.locale === language) ?? {};
    return separatorChar.separator ?? "/";
  }
  static ɵfac = function PoLanguageService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLanguageService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoLanguageService,
    factory: _PoLanguageService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLanguageService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var poTagColors = Object.values(PoColorPaletteEnum);
var poTagOrientationDefault = PoTagOrientation.Vertical;
var PoTagLiteralsDefault = {
  en: {
    remove: "Clear"
  },
  es: {
    remove: "Eliminar"
  },
  pt: {
    remove: "Remover"
  },
  ru: {
    remove: "удалять"
  }
};
var PoTagBaseComponent = class _PoTagBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Define uma legenda que será exibida acima ou ao lado da *tag*, de acordo com a `p-orientation`.
   */
  label;
  /**
   * @optional
   *
   * @description
   *
   * Habilita a opção de remover a tag
   *
   * @default `false`
   */
  removable = false;
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o `po-tag` e não permite que o usuário interaja com o mesmo.
   * > A propriedade `p-disabled` somente terá efeito caso a propriedade `p-removable` esteja definida como `true`.
   *
   * @default `false`
   */
  disabled = false;
  /** Texto da tag. */
  value;
  /**
   * @optional
   *
   * @description
   *
   * Ação que será executada ao clicar sobre o `po-tag` e que receberá como parâmetro um objeto contendo o seu valor e tipo.
   *
   * O evento de click só funciona se a tag não for removível.
   */
  click = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que sera executada quando clicar sobre o ícone de remover no `po-tag`
   */
  remove = new EventEmitter();
  poTagOrientation = PoTagOrientation;
  customColor;
  customTextColor;
  _color;
  _textColor;
  _icon;
  _orientation = poTagOrientationDefault;
  _type;
  _literals;
  language;
  /**
   * @optional
   *
   * @description
   *
   * Determina a cor da tag. As maneiras de customizar as cores são:
   * - Hexadeximal, por exemplo `#c64840`;
   * - RGB, como `rgb(0, 0, 165)`;
   * - O nome da cor, por exemplo `blue`;
   * - Usando uma das cores do tema do PO:
   * Valores válidos:
   *  - <span class="dot po-color-01"></span> `color-01`
   *  - <span class="dot po-color-02"></span> `color-02`
   *  - <span class="dot po-color-03"></span> `color-03`
   *  - <span class="dot po-color-04"></span> `color-04`
   *  - <span class="dot po-color-05"></span> `color-05`
   *  - <span class="dot po-color-06"></span> `color-06`
   *  - <span class="dot po-color-07"></span> `color-07`
   *  - <span class="dot po-color-08"></span> `color-08`
   *  - <span class="dot po-color-09"></span> `color-09`
   *  - <span class="dot po-color-10"></span> `color-10`
   *  - <span class="dot po-color-11"></span> `color-11`
   *  - <span class="dot po-color-12"></span> `color-12`
   *
   * - Para uma melhor acessibilidade no uso do componente é recomendável utilizar cores com um melhor contraste em relação ao background.
   *
   * > **Atenção:** A propriedade `p-type` sobrepõe esta definição.
   */
  set color(value) {
    this._color = poTagColors.includes(value) ? value : void 0;
    if (this._color === void 0) {
      CSS.supports("color", value) ? this.customColor = value : this.customColor = void 0;
    }
  }
  get color() {
    return this._color;
  }
  /**
   * @optional
   *
   * @description
   *
   * Determina a cor do texto da tag. As maneiras de customizar as cores são:
   * - Hexadeximal, por exemplo `#c64840`;
   * - RGB, como `rgb(0, 0, 165)`;
   * - O nome da cor, por exemplo `blue`;
   * - Usando uma das cores do tema do PO:
   * Valores válidos:
   *  - <span class="dot po-color-01"></span> `color-01`
   *  - <span class="dot po-color-02"></span> `color-02`
   *  - <span class="dot po-color-03"></span> `color-03`
   *  - <span class="dot po-color-04"></span> `color-04`
   *  - <span class="dot po-color-05"></span> `color-05`
   *  - <span class="dot po-color-06"></span> `color-06`
   *  - <span class="dot po-color-07"></span> `color-07`
   *  - <span class="dot po-color-08"></span> `color-08`
   *  - <span class="dot po-color-09"></span> `color-09`
   *  - <span class="dot po-color-10"></span> `color-10`
   *  - <span class="dot po-color-11"></span> `color-11`
   *  - <span class="dot po-color-12"></span> `color-12`
   *
   * - Para uma melhor acessibilidade no uso do componente é recomendável utilizar cores com um melhor contraste em relação ao background.
   *
   * > **Atenção:** A propriedade `p-type` sobrepõe esta definição.
   */
  set textColor(value) {
    this._textColor = poTagColors.includes(value) ? value : void 0;
    if (this._textColor === void 0) {
      CSS.supports("color", value) ? this.customTextColor = value : this.customTextColor = void 0;
    }
  }
  get textColor() {
    return this._textColor;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define ou ativa um ícone que será exibido ao lado do valor da *tag*.
   *
   * Quando `p-type` estiver definida, basta informar um valor igual a `true` para que o ícone seja exibido conforme descrições abaixo:
   * - <span class="an an-check"></span> - `success`
   * - <span class="an an-warning-circle"></span> - `warning`
   * - <span class="an an-x"></span> - `danger`
   * - <span class="an an-info"></span> - `info`
   *
   * Também É possível usar qualquer um dos ícones da [Biblioteca de ícones](https://po-ui.io/icons). conforme exemplo abaixo:
   * ```
   * <po-tag p-icon="an an-user" p-value="PO Tag"></po-tag>
   * ```
   * como também utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-tag p-icon="fa fa-podcast" p-value="PO Tag"></po-button>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-tag [p-icon]="template" p-value="Tag template ionic"></po-button>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   *
   * @default `false`
   */
  set icon(value) {
    if (this.type) {
      this._icon = convertToBoolean(value);
    } else {
      this._icon = value;
    }
  }
  get icon() {
    return this._icon;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o *layout* de exibição.
   *
   * @default `vertical`
   */
  set orientation(value) {
    this._orientation = Object.values(PoTagOrientation).includes(value) ? value : poTagOrientationDefault;
  }
  get orientation() {
    return this._orientation;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o tipo da *tag*.
   *
   * Valores válidos:
   *  - `success`: cor verde utilizada para simbolizar sucesso ou êxito.
   *  - `warning`: cor amarela que representa aviso ou advertência.
   *  - `danger`: cor vermelha para erro ou aviso crítico.
   *  - `info`: cor azul claro que caracteriza conteúdo informativo.
   *  - `neutral`: cor cinza claro para uso geral.
   *
   * > Quando esta propriedade for definida, irá sobrepor a definição de `p-color` e `p-icon` somente será exibido caso seja `true`.
   *
   * @default `info`
   */
  set type(value) {
    if (!this.removable) {
      this._type = Object.values(PoTagType).includes(value) ? value : void 0;
    }
  }
  get type() {
    return this._type;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-tag`.
   *
   *
   * Para utilizar, basta passar a literal customizada:
   *
   * ```
   *  const customLiterals: PoTagLiterals = {
   *    remove: 'Remover itens'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente:
   *
   * ```
   * <po-tag
   *   [p-literals]="customLiterals">
   * </po-tag>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, PoTagLiteralsDefault[poLocaleDefault]), PoTagLiteralsDefault[this.language]), value);
    } else {
      this._literals = PoTagLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || PoTagLiteralsDefault[this.language];
  }
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoTagBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTagBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTagBaseComponent,
    inputs: {
      label: [0, "p-label", "label"],
      removable: [2, "p-removable", "removable", convertToBoolean],
      disabled: [2, "p-disabled", "disabled", convertToBoolean],
      value: [0, "p-value", "value"],
      color: [0, "p-color", "color"],
      textColor: [0, "p-text-color", "textColor"],
      icon: [0, "p-icon", "icon"],
      orientation: [0, "p-orientation", "orientation"],
      type: [0, "p-type", "type"],
      literals: [0, "p-literals", "literals"]
    },
    outputs: {
      click: "p-click",
      remove: "p-close"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTagBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    removable: [{
      type: Input,
      args: [{
        alias: "p-removable",
        transform: convertToBoolean
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "p-disabled",
        transform: convertToBoolean
      }]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }],
    remove: [{
      type: Output,
      args: ["p-close"]
    }],
    color: [{
      type: Input,
      args: ["p-color"]
    }],
    textColor: [{
      type: Input,
      args: ["p-text-color"]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }],
    orientation: [{
      type: Input,
      args: ["p-orientation"]
    }],
    type: [{
      type: Input,
      args: ["p-type"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }]
  });
})();
var PO_CONTROL_POSITIONS = ["right", "right-top", "right-bottom", "top", "top-left", "top-right", "left", "left-top", "left-bottom", "bottom", "bottom-left", "bottom-right"];
var PO_TOOLTIP_POSITION_DEFAULT = "bottom";
var PoTooltipBaseDirective = class _PoTooltipBaseDirective {
  /**
   * @optional
   *
   * @description
   *
   * Define que o po-tooltip será incluido no body e não dentro do elemento ao qual o tooltip foi especificado.
   * Opção necessária para o caso de uso de tooltip em um elemento SVG.
   *
   * @default `false`
   */
  appendInBody = false;
  _tooltipPosition = "bottom";
  tooltipContent;
  _displayTooltip = false;
  _tooltip = "";
  /**
   * @description
   *
   * Habilita e atribui um texto ao po-tooltip.
   *
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   */
  set tooltip(tooltip) {
    this._tooltip = tooltip;
  }
  get tooltip() {
    return this._tooltip;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a posição que o po-tooltip abrirá em relação ao componente alvo. Sugere-se que seja
   * usada a orientação "bottom" (abaixo), porém o mesmo é flexível e será rotacionado
   * automaticamente para se adequar a tela, caso necessário.
   *
   * Posições válidas:
   * - `right`: Posiciona o po-tooltip no lado direito do componente alvo.
   * - `right-bottom`: Posiciona o po-tooltip no lado direito inferior do componente alvo.
   * - `right-top`: Posiciona o po-tooltip no lado direito superior do componente alvo.
   * - `bottom`: Posiciona o po-tooltip abaixo do componente alvo.
   * - `bottom-left`: Posiciona o po-tooltip abaixo e à esquerda do componente alvo.
   * - `bottom-right`: Posiciona o po-tooltip abaixo e à direita do componente alvo.
   * - `left`: Posiciona o po-tooltip no lado esquerdo do componente alvo.
   * - `left-top`: Posiciona o po-tooltip no lado esquerdo superior do componente alvo.
   * - `left-bottom`: Posiciona o po-tooltip no lado esquerdo inferior do componente alvo.
   * - `top`: Posiciona o po-tooltip acima do componente alvo.
   * - `top-right`: Posiciona o po-tooltip acima e à direita do componente alvo.
   * - `top-left`: Posiciona o po-tooltip acima e à esquerda do componente alvo.
   *
   * @default bottom
   */
  set tooltipPosition(position) {
    this._tooltipPosition = PO_CONTROL_POSITIONS.includes(position) ? position : PO_TOOLTIP_POSITION_DEFAULT;
  }
  get tooltipPosition() {
    return this._tooltipPosition;
  }
  set displayTooltip(value) {
    this._displayTooltip = value;
    this._displayTooltip ? this.addTooltipAction() : this.removeTooltipAction();
  }
  get displayTooltip() {
    return this._displayTooltip;
  }
  static ɵfac = function PoTooltipBaseDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTooltipBaseDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTooltipBaseDirective,
    inputs: {
      appendInBody: [2, "p-append-in-body", "appendInBody", convertToBoolean],
      tooltip: [0, "p-tooltip", "tooltip"],
      tooltipPosition: [0, "p-tooltip-position", "tooltipPosition"],
      displayTooltip: [2, "p-display-tooltip", "displayTooltip", convertToBoolean]
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTooltipBaseDirective, [{
    type: Directive
  }], null, {
    appendInBody: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    tooltip: [{
      type: Input,
      args: ["p-tooltip"]
    }],
    tooltipPosition: [{
      type: Input,
      args: ["p-tooltip-position"]
    }],
    displayTooltip: [{
      type: Input,
      args: [{
        alias: "p-display-tooltip",
        transform: convertToBoolean
      }]
    }]
  });
})();
var poControlPositionSidesDefault = ["bottom", "bottom-left", "bottom-right", "left", "left-top", "left-bottom", "top", "top-right", "top-left", "right", "right-bottom", "right-top"];
var PoControlPositionService = class _PoControlPositionService {
  arrowDirection;
  customPositions;
  differenceDiagonalToWidthArrow = 3;
  element;
  elementOffset;
  isCornerAligned;
  isSetElementWidth = false;
  // offset da seta em relação ao canto do componente
  offsetArrow = 12;
  targetElement;
  /**
   * @description Ajusta a posição do elemento, caso não couber em tela irá para próxima posição.
   *
   * @param value posição para exibição do elemento
   */
  adjustPosition(value) {
    const position = value || "bottom";
    this.elementPosition(position);
    this.customPositions && this.customPositions.length ? this.adjustCustomPosition(position) : this.adjustDefaultPosition(position);
  }
  /**
   * @description Retorna a direção da seta, conforme a posição do elemento.
   */
  getArrowDirection() {
    return this.arrowDirection;
  }
  /**
   * @description Método responsável por definir as propriedades utilizadas para exibir o elemento na posição correta.
   *
   * @param element elemento que será exibido
   * @param elementOffset offSet do elemento
   * @param targetElement elemento de onde deve partir a exibição
   * @param customPositions posições que sobrescreve as posições padrões
   * @param isSetElementWidth indica se deve definir o tamanho do elemento a ser exibido, caso for verdadeiro será igual do targetElement
   * @param isCornerAligned indica se o elemento filho será alinhado nos cantos do elemneto pai.
   */
  setElements(element, elementOffset, targetElement, customPositions, isSetElementWidth = false, isCornerAligned = false) {
    this.element = element instanceof ElementRef ? element.nativeElement : element;
    this.targetElement = targetElement instanceof ElementRef ? targetElement.nativeElement : targetElement;
    this.elementOffset = elementOffset;
    this.customPositions = customPositions;
    this.isSetElementWidth = isSetElementWidth;
    this.isCornerAligned = isCornerAligned;
  }
  adjustCustomPosition(position) {
    const positionLength = this.customPositions.length;
    let sidesCount = 0;
    while (sidesCount++ < positionLength) {
      if (this.overflowAllSides(position)) {
        position = this.nextPosition(position, this.customPositions);
        this.elementPosition(position);
      }
    }
  }
  adjustDefaultPosition(position) {
    const mainPositions = this.getMainPositions();
    const mainPositionLength = mainPositions.length;
    let mainSidesCount = 0;
    while (mainSidesCount++ < mainPositionLength) {
      const mainPosition = this.getMainPosition(position);
      this.elementPosition(position);
      if (this.overflowMain(mainPosition)) {
        position = this.nextPosition(mainPosition, mainPositions);
        continue;
      } else if (this.overflowAllSides(position)) {
        this.verifySubPositions(position);
        return;
      }
      return;
    }
  }
  elementPosition(position) {
    this.isCornerAligned ? this.setAlignedElementPosition(position) : this.setElementPosition(position);
  }
  getMainPosition(position) {
    return position.indexOf("-") > -1 ? position.substring(0, position.indexOf("-")) : position;
  }
  getMainPositions() {
    const defaultMainPositions = ["top", "right", "bottom", "left"];
    return this.customPositions && this.customPositions.length ? this.getMainPositionsByCustomPositions(this.customPositions) : defaultMainPositions;
  }
  getMainPositionsByCustomPositions(customPositions) {
    const mainPositions = [];
    const customPositionsLength = customPositions.length;
    for (let i = 0; i < customPositionsLength; i++) {
      const position = customPositions[i];
      const mainPosition = this.getMainPosition(position);
      if (!mainPositions.includes(mainPosition)) {
        mainPositions.push(mainPosition);
      }
    }
    return mainPositions;
  }
  getOverflows() {
    const sizesAndPositions = this.getSizesAndPositions();
    return {
      right: sizesAndPositions.element.right > sizesAndPositions.window.innerWidth,
      top: sizesAndPositions.element.top <= 0,
      left: sizesAndPositions.element.left <= 0,
      bottom: sizesAndPositions.element.bottom > sizesAndPositions.window.innerHeight
    };
  }
  getSizesAndPositions() {
    return {
      window: {
        scrollY: window.scrollY,
        scrollX: window.scrollX,
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight
      },
      element: this.element.getBoundingClientRect(),
      target: this.targetElement ? this.targetElement.getBoundingClientRect() : {
        top: 0,
        bottom: 0,
        right: 0,
        left: 0
      }
    };
  }
  nextPosition(position, positions = []) {
    const index = positions.indexOf(position);
    const nextIndex = index + 1;
    if (index > -1 && nextIndex < positions.length) {
      return positions[nextIndex];
    } else {
      return positions[0];
    }
  }
  overflowAllSides(position) {
    const overflows = this.getOverflows();
    switch (position) {
      case "top":
        return overflows.top || overflows.right || overflows.left;
      case "top-right":
        return overflows.top || overflows.right || overflows.left;
      case "top-left":
        return overflows.top || overflows.left || overflows.right;
      case "right":
        return overflows.right || overflows.top || overflows.bottom;
      case "right-top":
        return overflows.right || overflows.top;
      case "right-bottom":
        return overflows.right || overflows.bottom;
      case "bottom":
        return overflows.bottom || overflows.right || overflows.left;
      case "bottom-right":
        return overflows.bottom || overflows.right || overflows.left;
      case "bottom-left":
        return overflows.bottom || overflows.left || overflows.right;
      case "left":
        return overflows.left || overflows.top || overflows.bottom;
      case "left-top":
        return overflows.left || overflows.top;
      case "left-bottom":
        return overflows.left || overflows.bottom;
    }
  }
  overflowMain(position) {
    const overflows = this.getOverflows();
    switch (position) {
      case "top":
        return overflows.top;
      case "right":
        return overflows.right;
      case "bottom":
        return overflows.bottom;
      case "left":
        return overflows.left;
    }
  }
  setAlignedArrowDirection(elementPosition) {
    switch (elementPosition) {
      case "top-left":
        return "bottom-left";
      case "top-right":
        return "bottom-right";
      case "bottom-right":
        return "top-right";
      case "bottom-left":
        return "top-left";
    }
  }
  setAlignedBottomPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.bottom + this.elementOffset + "px";
    this.element.style.left = sizesAndPositions.target.left - displacement + "px";
  }
  setAlignedElementPosition(position) {
    this.setElementWidth();
    const sizesAndPositions = this.getSizesAndPositions();
    switch (position) {
      case "bottom-left":
        this.setAlignedBottomPositions(0, sizesAndPositions);
        break;
      case "bottom-right":
        this.setAlignedBottomPositions(sizesAndPositions.element.width - sizesAndPositions.target.width, sizesAndPositions);
        break;
      case "top-left":
        this.setAlignedTopPositions(0, sizesAndPositions);
        break;
      case "top-right":
        this.setAlignedTopPositions(sizesAndPositions.element.width - sizesAndPositions.target.width, sizesAndPositions);
        break;
    }
    this.arrowDirection = this.setAlignedArrowDirection(position);
  }
  setAlignedTopPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.top - sizesAndPositions.element.height - this.elementOffset + "px";
    this.element.style.left = sizesAndPositions.target.left - displacement + "px";
  }
  setArrowDirection(elementPosition) {
    switch (elementPosition) {
      case "top":
        return "bottom";
      case "top-left":
        return "bottom-right";
      case "top-right":
        return "bottom-left";
      case "right":
        return "left";
      case "right-top":
        return "left-bottom";
      case "right-bottom":
        return "left-top";
      case "bottom":
        return "top";
      case "bottom-right":
        return "top-left";
      case "bottom-left":
        return "top-right";
      case "left":
        return "right";
      case "left-bottom":
        return "right-top";
      case "left-top":
        return "right-bottom";
    }
  }
  setBottomPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.bottom + this.elementOffset + "px";
    this.element.style.left = sizesAndPositions.target.left + sizesAndPositions.target.width / 2 - displacement + "px";
  }
  setElementPosition(position) {
    this.setElementWidth();
    const sizesAndPositions = this.getSizesAndPositions();
    switch (position) {
      case "top":
        this.setTopPositions(sizesAndPositions.element.width / 2, sizesAndPositions);
        break;
      case "top-left":
        this.setTopPositions(sizesAndPositions.element.width - this.offsetArrow - this.differenceDiagonalToWidthArrow, sizesAndPositions);
        break;
      case "top-right":
        this.setTopPositions(this.offsetArrow + this.differenceDiagonalToWidthArrow, sizesAndPositions);
        break;
      case "right":
        this.setRightPositions(sizesAndPositions.element.height / 2, sizesAndPositions);
        break;
      case "right-top":
        this.setRightPositions(sizesAndPositions.element.height - this.offsetArrow - this.differenceDiagonalToWidthArrow, sizesAndPositions);
        break;
      case "right-bottom":
        this.setRightPositions(this.offsetArrow, sizesAndPositions);
        break;
      case "bottom":
        this.setBottomPositions(sizesAndPositions.element.width / 2, sizesAndPositions);
        break;
      case "bottom-right":
        this.setBottomPositions(this.offsetArrow + this.differenceDiagonalToWidthArrow, sizesAndPositions);
        break;
      case "bottom-left":
        this.setBottomPositions(sizesAndPositions.element.width - this.offsetArrow - this.differenceDiagonalToWidthArrow, sizesAndPositions);
        break;
      case "left":
        this.setLeftPositions(sizesAndPositions.element.height / 2, sizesAndPositions);
        break;
      case "left-bottom":
        this.setLeftPositions(this.offsetArrow, sizesAndPositions);
        break;
      case "left-top":
        this.setLeftPositions(sizesAndPositions.element.height - this.offsetArrow, sizesAndPositions);
        break;
    }
    this.arrowDirection = this.setArrowDirection(position);
  }
  setElementWidth() {
    if (this.isSetElementWidth && this.targetElement) {
      this.element.style.width = `${this.targetElement.clientWidth}px`;
    }
  }
  setLeftPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.top - displacement + sizesAndPositions.target.height / 2 + "px";
    this.element.style.left = sizesAndPositions.target.left - sizesAndPositions.element.width - this.elementOffset + "px";
  }
  setRightPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.top - displacement + sizesAndPositions.target.height / 2 + "px";
    this.element.style.left = sizesAndPositions.target.right + this.elementOffset + "px";
  }
  setTopPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.top - sizesAndPositions.element.height - this.elementOffset + "px";
    this.element.style.left = sizesAndPositions.target.left + sizesAndPositions.target.width / 2 - displacement + "px";
  }
  verifySubPositions(position) {
    if (position.indexOf("-") > -1) {
      position = position.substring(0, position.indexOf("-"));
      this.elementPosition(position);
    }
    let align = 0;
    while (align++ < 3) {
      if (this.overflowAllSides(position)) {
        position = this.nextPosition(position, poControlPositionSidesDefault);
        this.elementPosition(position);
      } else {
        return null;
      }
    }
  }
  static ɵfac = function PoControlPositionService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoControlPositionService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoControlPositionService,
    factory: _PoControlPositionService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoControlPositionService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var PoTooltipControlPositionService = class _PoTooltipControlPositionService extends PoControlPositionService {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoTooltipControlPositionService_BaseFactory;
    return function PoTooltipControlPositionService_Factory(__ngFactoryType__) {
      return (ɵPoTooltipControlPositionService_BaseFactory || (ɵPoTooltipControlPositionService_BaseFactory = ɵɵgetInheritedFactory(_PoTooltipControlPositionService)))(__ngFactoryType__ || _PoTooltipControlPositionService);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({
    token: _PoTooltipControlPositionService,
    factory: _PoTooltipControlPositionService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTooltipControlPositionService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var nativeElements = ["input", "button"];
var PoTooltipDirective = class _PoTooltipDirective extends PoTooltipBaseDirective {
  elementRef;
  renderer;
  poControlPosition;
  arrowDirection;
  divArrow;
  divContent;
  isHidden;
  lastTooltipText;
  textContent;
  tooltipOffset = 8;
  eventListenerFunction;
  constructor(elementRef, renderer, poControlPosition) {
    super();
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.poControlPosition = poControlPosition;
  }
  ngOnDestroy() {
    this.hideTooltip();
  }
  ngOnInit() {
    this.initScrollEventListenerFunction();
  }
  onMouseEnter() {
    if (!this.displayTooltip) {
      this.addTooltipAction();
    }
  }
  onMouseLeave() {
    if (!this.displayTooltip) {
      this.removeTooltipAction();
    }
  }
  onMouseClick() {
    if (!this.displayTooltip) {
      this.removeTooltipAction();
    }
  }
  onFocusOut() {
    if (!this.displayTooltip) {
      this.removeTooltipAction();
    }
  }
  onFocusIn() {
    if (!this.displayTooltip) {
      this.addTooltipAction();
    }
  }
  onKeyDown(event) {
    if (!this.displayTooltip && (event.code === "Escape" || event.keyCode === 27)) {
      this.removeTooltipAction();
    }
  }
  // Controla a visibilidade do tooltip, criado para auxiliar a propriedade `p-additional-help-tooltip`.
  toggleTooltipVisibility(show) {
    if (!this.displayTooltip) {
      show ? this.addTooltipAction() : this.removeTooltipAction();
    }
  }
  addTooltipAction() {
    setTimeout(() => {
      if (this.tooltip) {
        this.tooltipContent ? this.showTooltip() : this.createTooltip();
        this.removeArrow(this.arrowDirection);
        this.poControlPosition.adjustPosition(this.tooltipPosition);
        this.arrowDirection = this.poControlPosition.getArrowDirection();
        this.addArrow(this.arrowDirection);
        this.lastTooltipText = this.tooltip;
      }
    });
  }
  removeTooltipAction() {
    setTimeout(() => {
      if (this.appendInBody && this.tooltipContent) {
        this.renderer.removeChild(document.body, this.tooltipContent);
        this.tooltipContent = void 0;
      } else {
        this.hideTooltip();
      }
    });
  }
  addArrow(arrowDirection) {
    this.renderer.addClass(this.divArrow, `po-arrow-${arrowDirection}`);
  }
  addScrollEventListener() {
    window.addEventListener("scroll", this.eventListenerFunction, true);
  }
  // Monta a estrutura do tooltip
  createTooltip() {
    this.tooltipContent = this.renderer.createElement("div");
    this.renderer.addClass(this.tooltipContent, "po-tooltip");
    this.renderer.setStyle(this.tooltipContent, "transition", "visibility .3s, opacity .3s linear");
    this.renderer.setStyle(this.tooltipContent, "opacity", 0.9);
    this.insertAriaLabelTooltip();
    this.divArrow = this.renderer.createElement("div");
    this.renderer.addClass(this.divArrow, "po-tooltip-arrow");
    this.divContent = this.renderer.createElement("div");
    this.renderer.addClass(this.divContent, "po-tooltip-content");
    this.textContent = this.renderer.createText(this.tooltip);
    this.renderer.appendChild(this.divContent, this.textContent);
    this.renderer.appendChild(this.tooltipContent, this.divArrow);
    this.renderer.appendChild(this.tooltipContent, this.divContent);
    const parentTarget = this.appendInBody ? document.body : this.elementRef.nativeElement;
    this.renderer.appendChild(parentTarget, this.tooltipContent);
    this.poControlPosition.setElements(this.tooltipContent, this.tooltipOffset, this.elementRef);
    this.addScrollEventListener();
  }
  initScrollEventListenerFunction() {
    this.eventListenerFunction = () => {
      if (!this.isHidden) {
        setTimeout(() => {
          this.poControlPosition.adjustPosition(this.tooltipPosition);
        });
      }
    };
  }
  hideTooltip() {
    if (this.tooltipContent) {
      this.renderer.setStyle(this.tooltipContent, "opacity", 0);
      this.renderer.setStyle(this.tooltipContent, "visibility", "hidden");
      this.isHidden = true;
      this.removeScrollEventListener();
    }
  }
  removeArrow(arrowDirection) {
    if (this.elementRef.nativeElement.querySelector(`.po-arrow-${arrowDirection}`)) {
      this.renderer.removeClass(this.divArrow, `po-arrow-${arrowDirection}`);
    }
  }
  removeScrollEventListener() {
    window.removeEventListener("scroll", this.eventListenerFunction, true);
  }
  showTooltip() {
    this.renderer.setStyle(this.tooltipContent, "opacity", 0.9);
    this.renderer.setStyle(this.tooltipContent, "visibility", "visible");
    this.updateTextContent();
    this.isHidden = false;
    this.addScrollEventListener();
  }
  updateTextContent() {
    const checkRepeatedText = this.tooltip.split("\n");
    if (this.lastTooltipText !== this.tooltip && checkRepeatedText[0] !== this.lastTooltipText) {
      this.renderer.removeChild(this.divContent, this.textContent);
      this.textContent = this.renderer.createText(this.tooltip);
      this.renderer.appendChild(this.divContent, this.textContent);
    }
  }
  insertAriaLabelTooltip() {
    const nativeTextContent = this.elementRef.nativeElement.textContent;
    let targetElement = "";
    nativeElements.forEach((el) => {
      if (this.elementRef.nativeElement.getElementsByTagName(el)[0] !== void 0) {
        targetElement = el;
      }
    });
    if (this.elementRef.nativeElement.getElementsByTagName(targetElement)[0] && this.tooltip) {
      this.renderer.setAttribute(this.elementRef.nativeElement.getElementsByTagName(targetElement)[0], "aria-label", nativeTextContent + " " + this.tooltip);
    }
  }
  static ɵfac = function PoTooltipDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTooltipDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoTooltipControlPositionService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTooltipDirective,
    selectors: [["", "p-tooltip", ""]],
    hostBindings: function PoTooltipDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("mouseenter", function PoTooltipDirective_mouseenter_HostBindingHandler() {
          return ctx.onMouseEnter();
        })("mouseleave", function PoTooltipDirective_mouseleave_HostBindingHandler() {
          return ctx.onMouseLeave();
        })("click", function PoTooltipDirective_click_HostBindingHandler() {
          return ctx.onMouseClick();
        })("focusout", function PoTooltipDirective_focusout_HostBindingHandler() {
          return ctx.onFocusOut();
        })("focusin", function PoTooltipDirective_focusin_HostBindingHandler() {
          return ctx.onFocusIn();
        })("keydown", function PoTooltipDirective_keydown_HostBindingHandler($event) {
          return ctx.onKeyDown($event);
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoTooltipControlPositionService]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[p-tooltip]",
      providers: [PoTooltipControlPositionService],
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: PoTooltipControlPositionService
  }], {
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }],
    onMouseClick: [{
      type: HostListener,
      args: ["click"]
    }],
    onFocusOut: [{
      type: HostListener,
      args: ["focusout"]
    }],
    onFocusIn: [{
      type: HostListener,
      args: ["focusin"]
    }],
    onKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var _c0$1N = ["tagContainer"];
var _c1$K = ["tagClose"];
var _c2$l = ["poTag"];
var _c3$h = (a0) => ({
  "color": a0
});
function PoTagComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13)(1, "span", 14);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.tagOrientation ? ctx_r1.label + ":" : ctx_r1.label);
  }
}
function PoTagComponent_po_icon_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 15);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-icon", !ctx_r1.type ? ctx_r1.icon : ctx_r1.iconFromType)("ngStyle", !ctx_r1.type && ctx_r1.customTextColor ? ɵɵpureFunction1(2, _c3$h, ctx_r1.customTextColor) : "");
  }
}
function PoTagComponent_po_icon_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-icon", 16, 3);
    ɵɵlistener("click", function PoTagComponent_po_icon_12_Template_po_icon_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClose());
    })("keydown.enter", function PoTagComponent_po_icon_12_Template_po_icon_keydown_enter_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClose("enter"));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-clickable", !ctx_r1.disabled);
    ɵɵproperty("p-tooltip", ctx_r1.literals.remove)("tabindex", !ctx_r1.disabled ? 0 : -1);
    ɵɵattribute("aria-label", ctx_r1.setAriaLabel())("role", !ctx_r1.disabled ? "button" : "");
  }
}
var poTagTypeDefault = "po-tag-" + PoTagType.Info;
var PoTagComponent = class _PoTagComponent extends PoTagBaseComponent {
  el;
  tagContainer;
  tagClose;
  poTag;
  isClickable;
  constructor(el, languageService) {
    super(languageService);
    this.el = el;
  }
  ngOnInit() {
    this.isClickable = this.click.observers.length > 0;
  }
  get iconFromType() {
    switch (this.type) {
      case PoTagType.Danger:
        return PoTagIcon.Danger;
      case PoTagType.Info:
        return PoTagIcon.Info;
      case PoTagType.Success:
        return PoTagIcon.Success;
      case PoTagType.Warning:
        return PoTagIcon.Warning;
    }
  }
  get tagColor() {
    if (this.type && !this.removable) {
      return `po-tag-${this.type}`;
    }
    if (this.color && !this.removable) {
      return `po-${this.color}`;
    }
    if (!this.customColor && !this.removable) {
      return poTagTypeDefault;
    }
  }
  get tagOrientation() {
    return this.orientation === this.poTagOrientation.Horizontal;
  }
  onClick(event = "click") {
    if (!this.removable && !this.disabled) {
      const submittedTagItem = {
        value: this.value,
        type: this.type,
        event
      };
      this.click.emit(submittedTagItem);
      if (this.poTag && this.poTag.nativeElement) {
        this.poTag.nativeElement.focus();
      }
    }
  }
  onClose(event = "click") {
    if (!this.disabled) {
      this.onRemove();
      this.remove.emit(event);
    }
  }
  onKeyPressed(event) {
    event.preventDefault();
    event.stopPropagation();
    this.onClick("enter");
  }
  styleTag() {
    if (!this.tagColor && !this.removable) {
      return {
        "background-color": this.customColor,
        "color": "white"
      };
    } else {
      return {};
    }
  }
  getWidthTag() {
    return this.tagContainer.nativeElement.offsetWidth > 155;
  }
  setAriaLabel() {
    return this.label ? this.label + " " + this.literals.remove : this.value + " " + this.literals.remove;
  }
  onRemove() {
    if (!this.disabled) {
      this.el.nativeElement.remove();
    }
  }
  static ɵfac = function PoTagComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTagComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTagComponent,
    selectors: [["po-tag"]],
    viewQuery: function PoTagComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1N, 7);
        ɵɵviewQuery(_c1$K, 7);
        ɵɵviewQuery(_c2$l, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagClose = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poTag = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 13,
    vars: 22,
    consts: [["poTagWrapper", ""], ["poTag", ""], ["tagContainer", ""], ["tagClose", ""], [1, "po-tag-container"], ["class", "po-tag-title po-text-nowrap", 4, "ngIf"], [1, "po-tag-sub-container"], [1, "po-tag-wrapper", 3, "keydown.enter", "keydown.space", "keyup.space", "click", "tabindex"], [1, "po-tag", 3, "ngClass", "ngStyle"], ["class", "po-tag-icon", 3, "p-icon", "ngStyle", 4, "ngIf"], ["p-tooltip-position", "top", 1, "po-tag-value", 3, "p-tooltip"], [3, "ngStyle"], ["p-icon", "ICON_CLOSE", "p-tooltip-position", "top", "class", "po-tag-remove", 3, "p-tooltip", "po-clickable", "tabindex", "click", "keydown.enter", 4, "ngIf"], [1, "po-tag-title", "po-text-nowrap"], [1, "po-tag-label"], [1, "po-tag-icon", 3, "p-icon", "ngStyle"], ["p-icon", "ICON_CLOSE", "p-tooltip-position", "top", 1, "po-tag-remove", 3, "click", "keydown.enter", "p-tooltip", "tabindex"]],
    template: function PoTagComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 4);
        ɵɵtemplate(1, PoTagComponent_div_1_Template, 3, 1, "div", 5);
        ɵɵelementStart(2, "div", 6)(3, "div", 7, 0);
        ɵɵlistener("keydown.enter", function PoTagComponent_Template_div_keydown_enter_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyPressed($event));
        })("keydown.space", function PoTagComponent_Template_div_keydown_space_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView($event.preventDefault());
        })("keyup.space", function PoTagComponent_Template_div_keyup_space_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyPressed($event));
        })("click", function PoTagComponent_Template_div_click_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onClick());
        });
        ɵɵelementStart(5, "div", 8, 1);
        ɵɵtemplate(7, PoTagComponent_po_icon_7_Template, 1, 4, "po-icon", 9);
        ɵɵelementStart(8, "div", 10, 2)(10, "span", 11);
        ɵɵtext(11);
        ɵɵelementEnd()();
        ɵɵtemplate(12, PoTagComponent_po_icon_12_Template, 2, 6, "po-icon", 12);
        ɵɵelementEnd()()()();
      }
      if (rf & 2) {
        ɵɵclassProp("po-tag-container-horizontal", ctx.tagOrientation);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.label);
        ɵɵadvance(2);
        ɵɵclassProp("po-clickable", ctx.isClickable && !ctx.disabled && !ctx.removable);
        ɵɵproperty("tabindex", ctx.isClickable && !ctx.removable ? 0 : -1);
        ɵɵattribute("role", ctx.isClickable && !ctx.disabled && !ctx.removable ? "button" : "");
        ɵɵadvance(2);
        ɵɵclassProp("po-clickable", ctx.isClickable && !ctx.disabled && !ctx.removable)("po-tag-removable", ctx.removable)("po-tag-disabled", ctx.disabled && ctx.removable);
        ɵɵproperty("ngClass", ctx.tagColor)("ngStyle", ctx.styleTag());
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.icon && !ctx.removable);
        ɵɵadvance();
        ɵɵproperty("p-tooltip", ctx.getWidthTag() ? ctx.value : "");
        ɵɵadvance(2);
        ɵɵproperty("ngStyle", !ctx.type && ctx.customTextColor && !ctx.removable ? ɵɵpureFunction1(20, _c3$h, ctx.customTextColor) : "");
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.value);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.removable);
      }
    },
    dependencies: [NgClass, NgIf, NgStyle, PoIconComponent, PoTooltipDirective],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTagComponent, [{
    type: Component,
    args: [{
      selector: "po-tag",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<div class="po-tag-container" [class.po-tag-container-horizontal]="tagOrientation">
  <div *ngIf="label" class="po-tag-title po-text-nowrap">
    <span class="po-tag-label">{{ tagOrientation ? label + ':' : label }}</span>
  </div>

  <div class="po-tag-sub-container">
    <div
      #poTagWrapper
      class="po-tag-wrapper"
      [class.po-clickable]="isClickable && !disabled && !removable"
      [attr.role]="isClickable && !disabled && !removable ? 'button' : ''"
      (keydown.enter)="onKeyPressed($event)"
      (keydown.space)="$event.preventDefault()"
      (keyup.space)="onKeyPressed($event)"
      (click)="onClick()"
      [tabindex]="isClickable && !removable ? 0 : -1"
    >
      <div
        #poTag
        class="po-tag"
        [class.po-clickable]="isClickable && !disabled && !removable"
        [class.po-tag-removable]="removable"
        [class.po-tag-disabled]="disabled && removable"
        [ngClass]="tagColor"
        [ngStyle]="styleTag()"
      >
        <po-icon
          *ngIf="icon && !removable"
          class="po-tag-icon"
          [p-icon]="!type ? icon : iconFromType"
          [ngStyle]="!type && customTextColor ? { 'color': customTextColor } : ''"
        >
        </po-icon>

        <div #tagContainer class="po-tag-value" [p-tooltip]="getWidthTag() ? value : ''" p-tooltip-position="top">
          <span [ngStyle]="!type && customTextColor && !removable ? { 'color': customTextColor } : ''">{{
            value
          }}</span>
        </div>

        <po-icon
          #tagClose
          *ngIf="removable"
          p-icon="ICON_CLOSE"
          p-tooltip-position="top"
          [p-tooltip]="literals.remove"
          [attr.aria-label]="setAriaLabel()"
          class="po-tag-remove"
          [class.po-clickable]="!disabled"
          [tabindex]="!disabled ? 0 : -1"
          [attr.role]="!disabled ? 'button' : ''"
          (click)="onClose()"
          (keydown.enter)="onClose('enter')"
        >
        </po-icon>
      </div>
    </div>
  </div>
</div>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: PoLanguageService
  }], {
    tagContainer: [{
      type: ViewChild,
      args: ["tagContainer", {
        static: true
      }]
    }],
    tagClose: [{
      type: ViewChild,
      args: ["tagClose", {
        static: true
      }]
    }],
    poTag: [{
      type: ViewChild,
      args: ["poTag", {
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTagComponent, {
    className: "PoTagComponent",
    filePath: "lib/components/po-tag/po-tag.component.ts",
    lineNumber: 37
  });
})();
var PoTooltipModule = class _PoTooltipModule {
  static ɵfac = function PoTooltipModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTooltipModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoTooltipModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTooltipModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PoTooltipDirective],
      exports: [PoTooltipDirective]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTooltipModule, {
    declarations: [PoTooltipDirective],
    imports: [CommonModule],
    exports: [PoTooltipDirective]
  });
})();
var PoTagModule = class _PoTagModule {
  static ɵfac = function PoTagModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTagModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoTagModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoIconModule, PoTooltipModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTagModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoIconModule, PoTooltipModule],
      declarations: [PoTagComponent],
      exports: [PoTagComponent],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTagModule, {
    declarations: [PoTagComponent],
    imports: [CommonModule, PoIconModule, PoTooltipModule],
    exports: [PoTagComponent]
  });
})();
var _c0$1M = ["*"];
function PoAccordionItemBodyComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵprojection(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵproperty("@toggleBody", void 0);
  }
}
var PoAccordionItemBodyComponent = class _PoAccordionItemBodyComponent {
  expanded = false;
  static ɵfac = function PoAccordionItemBodyComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoAccordionItemBodyComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoAccordionItemBodyComponent,
    selectors: [["po-accordion-item-body"]],
    inputs: {
      expanded: [0, "p-expanded", "expanded"]
    },
    standalone: false,
    ngContentSelectors: _c0$1M,
    decls: 1,
    vars: 1,
    consts: [["class", "po-accordion-item-body", 4, "ngIf"], [1, "po-accordion-item-body"], [1, "po-accordion-item-body-content"]],
    template: function PoAccordionItemBodyComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, PoAccordionItemBodyComponent_div_0_Template, 3, 1, "div", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.expanded);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2,
    data: {
      animation: [trigger("toggleBody", [transition("* => void", [style({
        height: "*"
      }), animate(200, style({
        height: 0
      }))]), transition("void => *", [style({
        height: "0"
      }), animate(200, style({
        height: "*"
      }))])])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionItemBodyComponent, [{
    type: Component,
    args: [{
      selector: "po-accordion-item-body",
      animations: [trigger("toggleBody", [transition("* => void", [style({
        height: "*"
      }), animate(200, style({
        height: 0
      }))]), transition("void => *", [style({
        height: "0"
      }), animate(200, style({
        height: "*"
      }))])])],
      standalone: false,
      template: '<div class="po-accordion-item-body" *ngIf="expanded" @toggleBody>\n  <div class="po-accordion-item-body-content">\n    <ng-content></ng-content>\n  </div>\n</div>\n'
    }]
  }], null, {
    expanded: [{
      type: Input,
      args: ["p-expanded"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAccordionItemBodyComponent, {
    className: "PoAccordionItemBodyComponent",
    filePath: "lib/components/po-accordion/po-accordion-item-body/po-accordion-item-body.component.ts",
    lineNumber: 15
  });
})();
var PoLanguageModule = class _PoLanguageModule {
  static ɵfac = function PoLanguageModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLanguageModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoLanguageModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoLanguageService]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLanguageModule, [{
    type: NgModule,
    args: [{
      providers: [PoLanguageService]
    }]
  }], null, null);
})();
var _c0$1L = ["accordionElement"];
var _c1$J = ["accordionHeaderElement"];
function PoAccordionItemHeaderComponent_po_tag_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-tag", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-value", ctx_r1.labelTag)("p-type", ctx_r1.typeTag);
  }
}
var PoAccordionItemHeaderComponent = class _PoAccordionItemHeaderComponent {
  language = poLocaleDefault;
  accordionElement;
  accordionHeaderElement;
  expanded = false;
  label;
  labelTag;
  typeTag;
  disabledItem;
  toggle = new EventEmitter();
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  onClick() {
    this.expanded = !this.expanded;
    this.toggle.emit(this.expanded);
  }
  getTooltip() {
    const widthContainer = this.accordionElement.nativeElement.offsetWidth - 56;
    const widthHeaderElement = this.accordionHeaderElement.nativeElement.offsetWidth;
    if (widthHeaderElement >= widthContainer) {
      return this.label;
    }
    return null;
  }
  static ɵfac = function PoAccordionItemHeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoAccordionItemHeaderComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoAccordionItemHeaderComponent,
    selectors: [["po-accordion-item-header"]],
    viewQuery: function PoAccordionItemHeaderComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1L, 7, ElementRef);
        ɵɵviewQuery(_c1$J, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accordionElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accordionHeaderElement = _t.first);
      }
    },
    inputs: {
      expanded: [0, "p-expanded", "expanded"],
      label: [0, "p-label", "label"],
      labelTag: [0, "p-label-tag", "labelTag"],
      typeTag: [0, "p-type-tag", "typeTag"],
      disabledItem: [0, "p-disabled", "disabledItem"]
    },
    outputs: {
      toggle: "p-toggle"
    },
    standalone: false,
    decls: 9,
    vars: 6,
    consts: [["accordionElement", ""], ["accordionHeaderElement", ""], [1, "po-accordion-item-header"], ["type", "button", 1, "po-accordion-item-header-button", "po-clickable", 3, "click", "disabled"], [1, "po-accordion-item-header-button-content", 3, "p-tooltip"], [1, "po-text-ellipsis", "po-accordion-item-header-title"], ["class", "po-accordion-item-header-tag", 3, "p-value", "p-type", 4, "ngIf"], ["p-icon", "ICON_ARROW_DOWN", 1, "po-icon", "po-accordion-item-header-icon"], [1, "po-accordion-item-header-tag", 3, "p-value", "p-type"]],
    template: function PoAccordionItemHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 2)(1, "button", 3, 0);
        ɵɵlistener("click", function PoAccordionItemHeaderComponent_Template_button_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onClick());
        });
        ɵɵelementStart(3, "div", 4)(4, "div", 5, 1);
        ɵɵtext(6);
        ɵɵelementEnd();
        ɵɵtemplate(7, PoAccordionItemHeaderComponent_po_tag_7_Template, 1, 2, "po-tag", 6);
        ɵɵelementEnd();
        ɵɵelement(8, "po-icon", 7);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("disabled", ctx.disabledItem);
        ɵɵattribute("aria-label", ctx.label)("aria-expanded", ctx.expanded || false);
        ɵɵadvance(2);
        ɵɵproperty("p-tooltip", ctx.getTooltip());
        ɵɵadvance(3);
        ɵɵtextInterpolate(ctx.label);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.labelTag);
      }
    },
    dependencies: [NgIf, PoTagComponent, PoIconComponent, PoTooltipDirective],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionItemHeaderComponent, [{
    type: Component,
    args: [{
      selector: "po-accordion-item-header",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div class="po-accordion-item-header">\n  <button\n    #accordionElement\n    [disabled]="disabledItem"\n    [attr.aria-label]="label"\n    [attr.aria-expanded]="expanded || false"\n    class="po-accordion-item-header-button po-clickable"\n    type="button"\n    (click)="onClick()"\n  >\n    <div class="po-accordion-item-header-button-content" [p-tooltip]="getTooltip()">\n      <div #accordionHeaderElement class="po-text-ellipsis po-accordion-item-header-title">{{ label }}</div>\n      <po-tag *ngIf="labelTag" class="po-accordion-item-header-tag" [p-value]="labelTag" [p-type]="typeTag"> </po-tag>\n    </div>\n    <po-icon p-icon="ICON_ARROW_DOWN" class="po-icon po-accordion-item-header-icon"></po-icon>\n  </button>\n</div>\n'
    }]
  }], () => [{
    type: PoLanguageService
  }], {
    accordionElement: [{
      type: ViewChild,
      args: ["accordionElement", {
        read: ElementRef,
        static: true
      }]
    }],
    accordionHeaderElement: [{
      type: ViewChild,
      args: ["accordionHeaderElement", {
        read: ElementRef,
        static: true
      }]
    }],
    expanded: [{
      type: Input,
      args: ["p-expanded"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    labelTag: [{
      type: Input,
      args: ["p-label-tag"]
    }],
    typeTag: [{
      type: Input,
      args: ["p-type-tag"]
    }],
    disabledItem: [{
      type: Input,
      args: ["p-disabled"]
    }],
    toggle: [{
      type: Output,
      args: ["p-toggle"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAccordionItemHeaderComponent, {
    className: "PoAccordionItemHeaderComponent",
    filePath: "lib/components/po-accordion/po-accordion-item-header/po-accordion-item-header.component.ts",
    lineNumber: 11
  });
})();
var PoAccordionService = class _PoAccordionService {
  subjectChild = new Subject();
  // Recebe o accordionItem
  receiveFromChildAccordionClicked() {
    return this.subjectChild.asObservable();
  }
  // Envia accordionItem colapsado/expadido do accordion
  sendToParentAccordionItemClicked(accordionItem) {
    this.subjectChild.next(accordionItem);
  }
  static ɵfac = function PoAccordionService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoAccordionService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoAccordionService,
    factory: _PoAccordionService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _c0$1K = ["*"];
function PoAccordionItemComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var PoAccordionItemComponent = class _PoAccordionItemComponent {
  accordionService;
  _type;
  /** Título do item. */
  label;
  /**
   * @optional
   *
   * @description
   *
   * Label da Tag.
   *
   */
  labelTag;
  /**
   * @optional
   *
   * @description
   *
   * Desabilita item.
   *
   * @default `false`
   */
  disabledItem = false;
  /**
   * @optional
   *
   * @description
   *
   * Define o tipo da *tag* caso ela esteja sendo exibida.
   *
   * Valores válidos:
   *  - `success`: cor verde utilizada para simbolizar sucesso ou êxito.
   *  - `warning`: cor amarela que representa aviso ou advertência.
   *  - `danger`: cor vermelha para erro ou aviso crítico.
   *  - `info`: cor cinza escuro que caracteriza conteúdo informativo.
   *
   *
   * @default `info`
   */
  set typeTag(value) {
    this._type = Object.values(PoTagType).includes(value) ? value : void 0;
  }
  get typeTag() {
    return this._type;
  }
  /** Evento disparado ao expandir o item, seja manualmente ou programaticamente. */
  expandEvent = new EventEmitter();
  /** Evento disparado ao retrair o item, seja manualmente ou programaticamente. */
  collapseEvent = new EventEmitter();
  templateRef;
  expanded;
  expandSubscription;
  collapseSubscription;
  constructor(accordionService) {
    this.accordionService = accordionService;
    this.expandSubscription = this.accordionService.receiveFromChildAccordionClicked().pipe(filter((poAccordionItem) => poAccordionItem === this && poAccordionItem.expanded)).subscribe(() => {
      this.expandEvent.emit();
    });
    this.collapseSubscription = this.accordionService.receiveFromChildAccordionClicked().pipe(filter((poAccordionItem) => poAccordionItem === this && !poAccordionItem.expanded)).subscribe(() => {
      this.collapseEvent.emit();
    });
  }
  ngOnDestroy() {
    this.expandSubscription.unsubscribe();
    this.collapseSubscription.unsubscribe();
  }
  /**
   * Método para colapsar o `po-accordion-item`.
   */
  collapse() {
    if (!this.disabledItem) {
      this.expanded = false;
      this.accordionService.sendToParentAccordionItemClicked(this);
    }
  }
  /**
   * Método para expandir o `po-accordion-item`.
   */
  expand() {
    if (!this.disabledItem) {
      this.expanded = true;
      this.accordionService.sendToParentAccordionItemClicked(this);
    }
  }
  static ɵfac = function PoAccordionItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoAccordionItemComponent)(ɵɵdirectiveInject(PoAccordionService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoAccordionItemComponent,
    selectors: [["po-accordion-item"]],
    viewQuery: function PoAccordionItemComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(TemplateRef, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
      }
    },
    inputs: {
      label: [0, "p-label", "label"],
      labelTag: [0, "p-label-tag", "labelTag"],
      disabledItem: [2, "p-disabled", "disabledItem", convertToBoolean],
      typeTag: [0, "p-type-tag", "typeTag"]
    },
    outputs: {
      expandEvent: "p-expand",
      collapseEvent: "p-collapse"
    },
    standalone: false,
    features: [ɵɵInputTransformsFeature],
    ngContentSelectors: _c0$1K,
    decls: 1,
    vars: 0,
    template: function PoAccordionItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, PoAccordionItemComponent_ng_template_0_Template, 1, 0, "ng-template");
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionItemComponent, [{
    type: Component,
    args: [{
      selector: "po-accordion-item",
      standalone: false,
      template: "<ng-template>\n  <ng-content></ng-content>\n</ng-template>\n"
    }]
  }], () => [{
    type: PoAccordionService
  }], {
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    labelTag: [{
      type: Input,
      args: ["p-label-tag"]
    }],
    disabledItem: [{
      type: Input,
      args: [{
        alias: "p-disabled",
        transform: convertToBoolean
      }]
    }],
    typeTag: [{
      type: Input,
      args: ["p-type-tag"]
    }],
    expandEvent: [{
      type: Output,
      args: ["p-expand"]
    }],
    collapseEvent: [{
      type: Output,
      args: ["p-collapse"]
    }],
    templateRef: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAccordionItemComponent, {
    className: "PoAccordionItemComponent",
    filePath: "lib/components/po-accordion/po-accordion-item/po-accordion-item.component.ts",
    lineNumber: 44
  });
})();
var _c0$1J = ["accordionHeaderButtonManagerElement"];
var _c1$I = ["accordionHeaderManagerElement"];
var PoAccordionManagerComponent = class _PoAccordionManagerComponent {
  labelValue = "";
  changeDetector = inject(ChangeDetectorRef);
  accordionElement;
  accordionHeaderElement;
  expandedAllItems = false;
  literals;
  clickManager = new EventEmitter();
  ngOnChanges(changes) {
    this.labelValue = changes.expandedAllItems.currentValue ? this.literals.closeAllItems : this.literals.expandAllItems;
    this.changeDetector.detectChanges();
  }
  onClick() {
    this.clickManager.emit();
  }
  getTooltip() {
    const widthContainer = this.accordionElement.nativeElement.offsetWidth - 69;
    const widthHeaderElement = this.accordionHeaderElement.nativeElement.offsetWidth;
    if (widthHeaderElement >= widthContainer) {
      return this.labelValue;
    }
    return null;
  }
  static ɵfac = function PoAccordionManagerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoAccordionManagerComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoAccordionManagerComponent,
    selectors: [["po-accordion-manager"]],
    viewQuery: function PoAccordionManagerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1J, 7, ElementRef);
        ɵɵviewQuery(_c1$I, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accordionElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accordionHeaderElement = _t.first);
      }
    },
    inputs: {
      expandedAllItems: [0, "p-expanded-all-items", "expandedAllItems"],
      literals: [0, "p-literals", "literals"]
    },
    outputs: {
      clickManager: "p-click"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature],
    decls: 7,
    vars: 4,
    consts: [["accordionHeaderButtonManagerElement", ""], ["accordionHeaderManagerElement", ""], [1, "po-accordion-manager-header"], ["type", "button", 1, "po-accordion-manager-button", "po-clickable", 3, "click", "p-tooltip"], [1, "po-text-ellipsis", "po-accordion-manager-button-content"], ["p-icon", "ICON_LAST_PAGE", 1, "po-icon", "po-accordion-manager-icon", 3, "ngClass"]],
    template: function PoAccordionManagerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 2)(1, "button", 3, 0);
        ɵɵlistener("click", function PoAccordionManagerComponent_Template_button_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onClick());
        });
        ɵɵelementStart(3, "div", 4, 1);
        ɵɵtext(5);
        ɵɵelementEnd();
        ɵɵelement(6, "po-icon", 5);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("p-tooltip", ctx.getTooltip());
        ɵɵattribute("aria-expanded", ctx.expandedAllItems);
        ɵɵadvance(4);
        ɵɵtextInterpolate1(" ", ctx.expandedAllItems ? ctx.literals.closeAllItems : ctx.literals.expandAllItems, " ");
        ɵɵadvance();
        ɵɵproperty("ngClass", ctx.expandedAllItems ? "icon-down" : "icon-up");
      }
    },
    dependencies: [NgClass, PoIconComponent, PoTooltipDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionManagerComponent, [{
    type: Component,
    args: [{
      selector: "po-accordion-manager",
      standalone: false,
      template: `<div class="po-accordion-manager-header">
  <button
    #accordionHeaderButtonManagerElement
    class="po-accordion-manager-button po-clickable"
    type="button"
    (click)="onClick()"
    [attr.aria-expanded]="expandedAllItems"
    [p-tooltip]="getTooltip()"
  >
    <div #accordionHeaderManagerElement class="po-text-ellipsis po-accordion-manager-button-content">
      {{ expandedAllItems ? literals.closeAllItems : literals.expandAllItems }}
    </div>
    <po-icon
      p-icon="ICON_LAST_PAGE"
      [ngClass]="expandedAllItems ? 'icon-down' : 'icon-up'"
      class="po-icon po-accordion-manager-icon"
    >
    </po-icon>
  </button>
</div>
`
    }]
  }], null, {
    accordionElement: [{
      type: ViewChild,
      args: ["accordionHeaderButtonManagerElement", {
        read: ElementRef,
        static: true
      }]
    }],
    accordionHeaderElement: [{
      type: ViewChild,
      args: ["accordionHeaderManagerElement", {
        read: ElementRef,
        static: true
      }]
    }],
    expandedAllItems: [{
      type: Input,
      args: ["p-expanded-all-items"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    clickManager: [{
      type: Output,
      args: ["p-click"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAccordionManagerComponent, {
    className: "PoAccordionManagerComponent",
    filePath: "lib/components/po-accordion/po-accordion-manager/po-accordion-manager.component.ts",
    lineNumber: 20
  });
})();
var poAccordionLiteralsDefault = {
  en: {
    closeAllItems: "Close all items",
    expandAllItems: "Open all items"
  },
  es: {
    closeAllItems: "Cerrar todos los elementos",
    expandAllItems: "Abrir todos los elementos"
  },
  pt: {
    closeAllItems: "Fechar todos os itens",
    expandAllItems: "Abrir todos os itens"
  },
  ru: {
    closeAllItems: "Закрыть все элементы",
    expandAllItems: "Открыть все элементы"
  }
};
var PoAccordionBaseComponent = class _PoAccordionBaseComponent {
  language = poLocaleDefault;
  _literals;
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-accordion`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoAccordionLiterals = {
   *    closeAllItems: 'Fechar todos os itens',
   *    expandAllItems: 'Expandir todos os itens'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoAccordionLiterals = {
   *    expandAllItems: 'Expandir todos os itens'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-accordion
   *   [p-literals]="customLiterals">
   * </po-accordion>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poAccordionLiteralsDefault[poLocaleDefault]), poAccordionLiteralsDefault[this.language]), value);
    } else {
      this._literals = poAccordionLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poAccordionLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Exibe o Gerenciador de Accordion.
   *
   * @default `false`
   */
  showManagerAccordion = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite expandir mais de um `<po-accordion-item></po-accordion-item>` ao mesmo tempo.
   * Sempre habilitada caso a propriedade `p-show-manager-accordion` esteja como `true`.
   *
   * @default `false`
   */
  allowExpandItems = false;
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao expandir o gerenciador de accordion, seja manualmente ou programaticamente.
   *
   */
  expandAllEvent = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao retrair o gerenciador de accordion, seja manualmente ou programaticamente.
   *
   */
  collapseAllEvent = new EventEmitter();
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoAccordionBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoAccordionBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoAccordionBaseComponent,
    inputs: {
      literals: [0, "p-literals", "literals"],
      showManagerAccordion: [2, "p-show-manager-accordion", "showManagerAccordion", convertToBoolean],
      allowExpandItems: [2, "p-allow-expand-all-items", "allowExpandItems", convertToBoolean]
    },
    outputs: {
      expandAllEvent: "p-expand-all",
      collapseAllEvent: "p-collapse-all"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    showManagerAccordion: [{
      type: Input,
      args: [{
        alias: "p-show-manager-accordion",
        transform: convertToBoolean
      }]
    }],
    allowExpandItems: [{
      type: Input,
      args: [{
        alias: "p-allow-expand-all-items",
        transform: convertToBoolean
      }]
    }],
    expandAllEvent: [{
      type: Output,
      args: ["p-expand-all"]
    }],
    collapseAllEvent: [{
      type: Output,
      args: ["p-collapse-all"]
    }]
  });
})();
function PoAccordionComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3)(1, "po-accordion-manager", 4);
    ɵɵlistener("p-click", function PoAccordionComponent_div_1_Template_po_accordion_manager_p_click_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changeVisibleAllItems(ctx_r1.expandedAllItems));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-expanded-all-items", ctx_r1.expandedAllItems)("p-literals", ctx_r1.literals);
  }
}
function PoAccordionComponent_li_3_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoAccordionComponent_li_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 5)(1, "po-accordion-item-header", 6);
    ɵɵlistener("p-toggle", function PoAccordionComponent_li_3_Template_po_accordion_item_header_p_toggle_1_listener($event) {
      const poAccordionItem_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.headerToggle($event, poAccordionItem_r4));
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "po-accordion-item-body", 7);
    ɵɵtemplate(3, PoAccordionComponent_li_3_ng_container_3_Template, 1, 0, "ng-container", 8);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const poAccordionItem_r4 = ctx.$implicit;
    ɵɵclassProp("po-accordion-item-active", poAccordionItem_r4.expanded);
    ɵɵadvance();
    ɵɵproperty("p-disabled", poAccordionItem_r4.disabledItem)("p-expanded", poAccordionItem_r4.expanded)("p-label", poAccordionItem_r4.label)("p-label-tag", poAccordionItem_r4.labelTag)("p-type-tag", poAccordionItem_r4.typeTag);
    ɵɵadvance();
    ɵɵproperty("p-expanded", poAccordionItem_r4.expanded);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", poAccordionItem_r4.templateRef);
  }
}
var PoAccordionComponent = class _PoAccordionComponent extends PoAccordionBaseComponent {
  accordionService;
  accordionsHeader;
  poAccordionItems;
  expandedAllItems = false;
  accordionServiceSubscription;
  expandedActiveAccordionItem;
  constructor(accordionService, languageService) {
    super(languageService);
    this.accordionService = accordionService;
    this.receiveFromChildAccordionSubscription();
  }
  ngOnDestroy() {
    this.accordionServiceSubscription.unsubscribe();
  }
  changeVisibleAllItems(event) {
    this.expandedAllItems = !event;
    this.poAccordionItems.forEach((item) => {
      if (!item.disabledItem) {
        item.expanded = this.expandedAllItems;
        this.toggle(item, false);
      }
    });
    if (this.expandedAllItems) {
      this.expandAllEvent.emit();
    } else {
      this.collapseAllEvent.emit();
    }
  }
  /**
   * Método para colapsar todos os itens.
   * Só pode ser utilizado quando a propriedade `p-show-manager-accordion` estiver como `true`.
   */
  collapseAllItems() {
    if (this.showManagerAccordion) {
      this.changeVisibleAllItems(true);
    }
  }
  /**
   * Método para expandir todos os itens.
   * Só pode ser utilizado quando a propriedade `p-show-manager-accordion` estiver como `true`.
   */
  expandAllItems() {
    if (this.showManagerAccordion) {
      this.changeVisibleAllItems(false);
    }
  }
  headerToggle(event, poAccordionItem) {
    poAccordionItem.expanded = event;
    this.accordionService.sendToParentAccordionItemClicked(poAccordionItem);
  }
  checkVisibleAllItems(event) {
    if (this.showManagerAccordion) {
      const accordionList = this.poAccordionItems.toArray();
      const accordionsValids = accordionList.filter((item) => !item.disabledItem);
      const allItemsExpanded = accordionsValids.every((item) => item.expanded === true);
      if (allItemsExpanded) {
        this.expandedAllItems = event;
      } else {
        this.expandedAllItems = false;
      }
    }
  }
  receiveFromChildAccordionSubscription() {
    this.accordionServiceSubscription = this.accordionService.receiveFromChildAccordionClicked().subscribe((poAccordionItem) => this.toggle(poAccordionItem));
  }
  toggle(poAccordionItem, checkAllItems = true) {
    const isCurrentAccordionCollapsed = !poAccordionItem.expanded;
    if (checkAllItems) {
      this.checkVisibleAllItems(poAccordionItem.expanded);
    }
    if (isCurrentAccordionCollapsed) {
      this.expandedActiveAccordionItem = null;
      return;
    }
    if (!this.showManagerAccordion && !this.allowExpandItems && this.expandedActiveAccordionItem) {
      this.expandedActiveAccordionItem.collapse();
    }
    this.expandedActiveAccordionItem = poAccordionItem;
  }
  static ɵfac = function PoAccordionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoAccordionComponent)(ɵɵdirectiveInject(PoAccordionService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoAccordionComponent,
    selectors: [["po-accordion"]],
    contentQueries: function PoAccordionComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PoAccordionItemComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poAccordionItems = _t);
      }
    },
    viewQuery: function PoAccordionComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoAccordionItemHeaderComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accordionsHeader = _t);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoAccordionService]), ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 2,
    consts: [[1, "po-accordion"], ["class", "po-accordion-manager", 4, "ngIf"], ["class", "po-accordion-item", 3, "po-accordion-item-active", 4, "ngFor", "ngForOf"], [1, "po-accordion-manager"], [3, "p-click", "p-expanded-all-items", "p-literals"], [1, "po-accordion-item"], [3, "p-toggle", "p-disabled", "p-expanded", "p-label", "p-label-tag", "p-type-tag"], [3, "p-expanded"], [4, "ngTemplateOutlet"]],
    template: function PoAccordionComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoAccordionComponent_div_1_Template, 2, 2, "div", 1);
        ɵɵelementStart(2, "ul");
        ɵɵtemplate(3, PoAccordionComponent_li_3_Template, 4, 9, "li", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showManagerAccordion && ctx.poAccordionItems.length > 1);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ctx.poAccordionItems);
      }
    },
    dependencies: [NgForOf, NgIf, NgTemplateOutlet, PoAccordionItemBodyComponent, PoAccordionItemHeaderComponent, PoAccordionManagerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionComponent, [{
    type: Component,
    args: [{
      selector: "po-accordion",
      providers: [PoAccordionService],
      standalone: false,
      template: '<div class="po-accordion">\n  <div *ngIf="showManagerAccordion && poAccordionItems.length > 1" class="po-accordion-manager">\n    <po-accordion-manager\n      [p-expanded-all-items]="expandedAllItems"\n      [p-literals]="literals"\n      (p-click)="changeVisibleAllItems(expandedAllItems)"\n    ></po-accordion-manager>\n  </div>\n  <ul>\n    <li\n      *ngFor="let poAccordionItem of poAccordionItems"\n      class="po-accordion-item"\n      [class.po-accordion-item-active]="poAccordionItem.expanded"\n    >\n      <po-accordion-item-header\n        [p-disabled]="poAccordionItem.disabledItem"\n        [p-expanded]="poAccordionItem.expanded"\n        [p-label]="poAccordionItem.label"\n        [p-label-tag]="poAccordionItem.labelTag"\n        [p-type-tag]="poAccordionItem.typeTag"\n        (p-toggle)="headerToggle($event, poAccordionItem)"\n      >\n      </po-accordion-item-header>\n\n      <po-accordion-item-body [p-expanded]="poAccordionItem.expanded">\n        <ng-container *ngTemplateOutlet="poAccordionItem.templateRef"></ng-container>\n      </po-accordion-item-body>\n    </li>\n  </ul>\n</div>\n'
    }]
  }], () => [{
    type: PoAccordionService
  }, {
    type: PoLanguageService
  }], {
    accordionsHeader: [{
      type: ViewChildren,
      args: [PoAccordionItemHeaderComponent]
    }],
    poAccordionItems: [{
      type: ContentChildren,
      args: [PoAccordionItemComponent]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAccordionComponent, {
    className: "PoAccordionComponent",
    filePath: "lib/components/po-accordion/po-accordion.component.ts",
    lineNumber: 39
  });
})();
var PoAccordionModule = class _PoAccordionModule {
  static ɵfac = function PoAccordionModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoAccordionModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoAccordionModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoTagModule, PoIconModule, PoDividerModule, PoTooltipModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoTagModule, PoIconModule, PoDividerModule, PoTooltipModule],
      declarations: [PoAccordionComponent, PoAccordionItemBodyComponent, PoAccordionItemComponent, PoAccordionItemHeaderComponent, PoAccordionManagerComponent],
      exports: [PoAccordionComponent, PoAccordionItemComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoAccordionModule, {
    declarations: [PoAccordionComponent, PoAccordionItemBodyComponent, PoAccordionItemComponent, PoAccordionItemHeaderComponent, PoAccordionManagerComponent],
    imports: [CommonModule, PoTagModule, PoIconModule, PoDividerModule, PoTooltipModule],
    exports: [PoAccordionComponent, PoAccordionItemComponent]
  });
})();
var PO_AVATAR_SIZES = ["xs", "sm", "md", "lg", "xl"];
var PO_AVATAR_SIZE_DEFAULT = "md";
var PoAvatarBaseComponent = class _PoAvatarBaseComponent {
  /**
   * Fonte da imagem que pode ser um caminho local (`./assets/images/logo-black-small.png`)
   * ou um servidor externo (`https://po-ui.io/assets/images/logo-black-small.png`).
   */
  src;
  /**
   * @optional
   *
   * @description
   *
   * Indica como o navegador deve carregar a imagem.
   *
   * Valores válidos:
   *  - `eager` (a imagem é carregada imediatamente, independente de estar visível ou não)
   *  - `lazy` (a imagem só é carregada quando estiver próxima de ser renderizada)
   *
   * @default `eager`
   */
  loading = "eager";
  /** Evento disparado ao clicar na imagem do *avatar*. */
  click = new EventEmitter();
  _size = "md";
  /**
   * @optional
   *
   * @description
   *
   * Tamanho de exibição do componente.
   *
   * Valores válidos:
   *  - `xs` (24x24)
   *  - `sm` (32x32)
   *  - `md` (64x64)
   *  - `lg` (96x96)
   *  - `xl` (144x144)
   *
   * @default `md`
   */
  set size(value) {
    this._size = PO_AVATAR_SIZES.includes(value) ? value : PO_AVATAR_SIZE_DEFAULT;
  }
  get size() {
    return this._size;
  }
  get hasClickEvent() {
    return !!this.click.observers.length;
  }
  static ɵfac = function PoAvatarBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoAvatarBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoAvatarBaseComponent,
    inputs: {
      src: [0, "p-src", "src"],
      loading: [0, "p-loading", "loading"],
      size: [0, "p-size", "size"]
    },
    outputs: {
      click: "p-click"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAvatarBaseComponent, [{
    type: Directive
  }], null, {
    src: [{
      type: Input,
      args: ["p-src"]
    }],
    loading: [{
      type: Input,
      args: ["p-loading"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }]
  });
})();
function PoAvatarComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoAvatarComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "img", 4);
    ɵɵlistener("error", function PoAvatarComponent_ng_template_2_Template_img_error_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onError());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("src", ctx_r2.src, ɵɵsanitizeUrl);
    ɵɵattribute("loading", ctx_r2.loading);
  }
}
function PoAvatarComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 5);
  }
}
var PoAvatarComponent = class _PoAvatarComponent extends PoAvatarBaseComponent {
  ngOnInit() {
    if (!this.src) {
      this.src = void 0;
    }
  }
  onError() {
    this.src = void 0;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoAvatarComponent_BaseFactory;
    return function PoAvatarComponent_Factory(__ngFactoryType__) {
      return (ɵPoAvatarComponent_BaseFactory || (ɵPoAvatarComponent_BaseFactory = ɵɵgetInheritedFactory(_PoAvatarComponent)))(__ngFactoryType__ || _PoAvatarComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoAvatarComponent,
    selectors: [["po-avatar"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 8,
    consts: [["sourceImage", ""], ["defaultIcon", ""], [3, "click"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["alt", "", 1, "po-avatar-image", 3, "error", "src"], ["p-icon", "ICON_USER", 1, "po-avatar-default-icon"]],
    template: function PoAvatarComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 2);
        ɵɵlistener("click", function PoAvatarComponent_Template_div_click_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.click.emit());
        });
        ɵɵtemplate(1, PoAvatarComponent_ng_container_1_Template, 1, 0, "ng-container", 3);
        ɵɵelementEnd();
        ɵɵtemplate(2, PoAvatarComponent_ng_template_2_Template, 1, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor)(4, PoAvatarComponent_ng_template_4_Template, 1, 0, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const sourceImage_r4 = ɵɵreference(3);
        const defaultIcon_r5 = ɵɵreference(5);
        ɵɵclassMapInterpolate1("po-avatar po-avatar-", ctx.size, "");
        ɵɵclassProp("po-clickable", ctx.hasClickEvent);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.src)("ngIfThen", sourceImage_r4)("ngIfElse", defaultIcon_r5);
      }
    },
    dependencies: [NgIf, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAvatarComponent, [{
    type: Component,
    args: [{
      selector: "po-avatar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div class="po-avatar po-avatar-{{ size }}" [class.po-clickable]="hasClickEvent" (click)="click.emit()">\n  <ng-container *ngIf="src; then sourceImage; else defaultIcon"></ng-container>\n</div>\n\n<ng-template #sourceImage>\n  <img class="po-avatar-image" [src]="src" alt="" [attr.loading]="loading" (error)="onError()" />\n</ng-template>\n\n<ng-template #defaultIcon>\n  <po-icon p-icon="ICON_USER" class="po-avatar-default-icon"></po-icon>\n</ng-template>\n'
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAvatarComponent, {
    className: "PoAvatarComponent",
    filePath: "lib/components/po-avatar/po-avatar.component.ts",
    lineNumber: 33
  });
})();
var PoAvatarModule = class _PoAvatarModule {
  static ɵfac = function PoAvatarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoAvatarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoAvatarModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAvatarModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoIconModule],
      declarations: [PoAvatarComponent],
      exports: [PoAvatarComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoAvatarModule, {
    declarations: [PoAvatarComponent],
    imports: [CommonModule, PoIconModule],
    exports: [PoAvatarComponent]
  });
})();
var poBadgeColors = Object.values(PoColorPaletteEnum);
var PO_BADGE_COLOR_DEFAULT = "color-07";
var PoBadgeBaseComponent = class _PoBadgeBaseComponent {
  badgeValue;
  customColor;
  _color = PO_BADGE_COLOR_DEFAULT;
  _value;
  _status;
  _ariaLabel;
  /**
   * @description
   *
   * Define um `aria-label` para o `po-badge`
   */
  set ariaLabel(value) {
    if (value === void 0) {
      this._ariaLabel = "";
    }
    this._ariaLabel = value;
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  /**
   * @optional
   *
   * @description
   *
   * Determina a cor do `po-badge`. As maneiras de customizar as cores são:
   * - Hexadeximal, por exemplo `#c64840`;
   * - RGB, como `rgb(0, 0, 165)`;
   * - O nome da cor, por exemplo `blue`;
   * - Usando uma das cores do tema do PO:
   * Valores válidos:
   *  - <span class="dot po-color-01"></span> `color-01`
   *  - <span class="dot po-color-02"></span> `color-02`
   *  - <span class="dot po-color-03"></span> `color-03`
   *  - <span class="dot po-color-04"></span> `color-04`
   *  - <span class="dot po-color-05"></span> `color-05`
   *  - <span class="dot po-color-06"></span> `color-06`
   *  - <span class="dot po-color-07"></span> `color-07`
   *  - <span class="dot po-color-08"></span> `color-08`
   *  - <span class="dot po-color-09"></span> `color-09`
   *  - <span class="dot po-color-10"></span> `color-10`
   *  - <span class="dot po-color-11"></span> `color-11`
   *  - <span class="dot po-color-12"></span> `color-12`
   *
   * @default `color-07`
   */
  set color(value) {
    if (value !== void 0 && value.includes("color")) {
      this._color = poBadgeColors.includes(value) ? value : PO_BADGE_COLOR_DEFAULT;
    } else {
      CSS.supports("background-color", value) ? this.customColor = value : this.customColor = void 0;
    }
  }
  get color() {
    return this._color;
  }
  /**
   * @optional
   *
   * @description
   * Ícone exibido no `po-badge`.
   *
   * Para exibir icone do status atual declare a propriedade `p-icon`. conforme exemplo abaixo:
   * ```
   * <po-badge [p-icon]="true"></po-badge>
   * ```
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](https://po-ui.io/icons). conforme exemplo abaixo:
   * ```
   * <po-badge p-icon="an an-user"></po-badge>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-badge p-icon="fa fa-podcast"></po-badge>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-badge [p-icon]="template"></po-badge>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   */
  icon;
  /**
   * @description
   *
   * Define o estado do `po-badge`
   *
   * Valores válidos:
   * - `positive`: Define a cor do `po-badge` com a cor de feedback positivo.;
   * - `negative`: Define a cor do `po-badge` com a cor de feedback negative.;
   * - `warning`: Define a cor do `po-badge` com a cor de feedback warning.;
   * - `disabled`: Define a cor do `po-badge` com a cor de feedback disabled;
   *
   */
  set status(value) {
    this._status = ["positive", "negative", "warning", "disabled"].includes(value) ? value : void 0;
  }
  get status() {
    return this._status;
  }
  /**
   * @description
   *
   * Define o tamanho do `po-badge`
   *
   * Valores válidos:
   * - `small`: o `po-badge` fica do tamanho padrão, com 8px de altura.;
   * - `medium`: o `po-badge` fica do tamanho padrão, com 16px de altura.;
   * - `large`: o `po-badge` fica do tamanho padrão, com 24px de altura.;
   *
   * @default `medium`
   */
  size = "medium";
  /**
   * @description
   *
   * Exibe uma borda para o `po-badge`
   *
   * > Pode personalizar cor da bordar com a propriedade `p-color-border`
   */
  showBorder = false;
  /**
   * @description
   *
   * Número exibido no componente, caso o mesmo seja maior que 9 o valor exibido será 9+.
   */
  set value(value) {
    this._value = value <= 0 ? 0 : convertToInt(value);
  }
  get value() {
    return this._value;
  }
  static ɵfac = function PoBadgeBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoBadgeBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoBadgeBaseComponent,
    hostVars: 1,
    hostBindings: function PoBadgeBaseComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("p-status", ctx.status);
      }
    },
    inputs: {
      ariaLabel: [0, "p-aria-label", "ariaLabel"],
      color: [0, "p-color", "color"],
      icon: [0, "p-icon", "icon"],
      status: [0, "p-status", "status"],
      size: [0, "p-size", "size"],
      showBorder: [2, "p-show-border", "showBorder", convertToBoolean],
      value: [0, "p-value", "value"]
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBadgeBaseComponent, [{
    type: Directive
  }], null, {
    ariaLabel: [{
      type: Input,
      args: ["p-aria-label"]
    }],
    color: [{
      type: Input,
      args: ["p-color"]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }],
    status: [{
      type: HostBinding,
      args: ["attr.p-status"]
    }, {
      type: Input,
      args: ["p-status"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }],
    showBorder: [{
      type: Input,
      args: [{
        alias: "p-show-border",
        transform: convertToBoolean
      }]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }]
  });
})();
var PoBadgeLiteralsDefault = {
  en: {
    notification: "new notification",
    notifications: "new notifications"
  },
  es: {
    notification: "nueva notificación",
    notifications: "nuevas notificaciones"
  },
  pt: {
    notification: "nova notificação",
    notifications: "nova notificaçoes"
  },
  ru: {
    notification: "новое уведомление",
    notifications: "новые уведомления"
  }
};
var _c0$1I = (a0) => ({
  "background-color": a0
});
var _c1$H = () => ({});
function PoBadgeComponent_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-icon", ctx_r0.badgeIcon);
  }
}
function PoBadgeComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.badgeValue);
  }
}
var PO_BADGE_MAX_NOTIFICATIONS = 9;
var PoBadgeComponent = class _PoBadgeComponent extends PoBadgeBaseComponent {
  isNotification = false;
  notificationLabel = "";
  literals;
  badgeIcon = "";
  isValidValue = false;
  poLanguageService = inject(PoLanguageService);
  ngOnInit() {
    this.literals = PoBadgeLiteralsDefault[this.poLanguageService.getShortLanguage()];
    this.initialize();
  }
  ngOnChanges(changes) {
    if (changes["status"] || changes["icon"]) {
      this.setStatus();
    }
    if (changes["value"]) {
      this.setBadgeValue();
      this.setBadgeNotification(changes["value"].currentValue);
      this.setLiterals();
    }
  }
  initialize() {
    this.setStatus();
    this.setLiterals();
    this.setBadgeValue();
    this.setBadgeNotification(this.value);
  }
  getChangeStyle() {
    if (this.color === "color-07" && !this.customColor || this.status) {
      return "po-badge-default";
    } else if (this.color) {
      return `po-${this.color}`;
    }
  }
  setLiterals() {
    if (this.value) {
      this.notificationLabel = this.value > 1 ? `${this.ariaLabel ?? ""} ${this.value} ${this.literals?.notifications}` : `${this.ariaLabel ?? ""} ${this.value} ${this.literals?.notification}`;
    } else {
      this.notificationLabel = `${this.ariaLabel ?? ""} ${this.literals?.notification}`;
    }
  }
  setStatus() {
    this.isNotification = false;
    this.badgeValue = null;
    this.switchIconStatus();
  }
  switchIconStatus() {
    if (typeof this.icon === "boolean" && this.icon) {
      this.badgeIcon = "";
      if (["positive", "negative", "warning", "disabled"].includes(this.status)) {
        switch (this.status) {
          case "positive":
            this.badgeIcon = "ICON_OK";
            break;
          case "negative":
            this.badgeIcon = "ICON_MINUS";
            break;
          case "warning":
            this.badgeIcon = "ICON_WARNING";
            break;
        }
      }
    } else {
      this.badgeIcon = this.icon;
    }
  }
  setBadgeNotification(value) {
    if (value > 1 && !this.status) {
      this.isNotification = true;
      return true;
    } else {
      this.isNotification = false;
      this.badgeValue = null;
      return false;
    }
  }
  setBadgeValue() {
    if (this.value) {
      this.checkBadgeValue(this.value);
    }
  }
  checkBadgeValue(value) {
    this.isValidValue = Number.isInteger(value) && value >= 1;
    this.badgeValue = this.isValidValue ? this.formatBadgeValue(value) : "";
  }
  formatBadgeValue(value) {
    return value > PO_BADGE_MAX_NOTIFICATIONS ? "9+" : value.toString();
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoBadgeComponent_BaseFactory;
    return function PoBadgeComponent_Factory(__ngFactoryType__) {
      return (ɵPoBadgeComponent_BaseFactory || (ɵPoBadgeComponent_BaseFactory = ɵɵgetInheritedFactory(_PoBadgeComponent)))(__ngFactoryType__ || _PoBadgeComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoBadgeComponent,
    selectors: [["po-badge"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 3,
    vars: 16,
    consts: [[3, "ariaLabel", "ngStyle"], [3, "p-icon", 4, "ngIf"], ["class", "po-badge-value", "aria-hidden", "true", 4, "ngIf"], [3, "p-icon"], ["aria-hidden", "true", 1, "po-badge-value"]],
    template: function PoBadgeComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoBadgeComponent_po_icon_1_Template, 1, 1, "po-icon", 1)(2, PoBadgeComponent_span_2_Template, 2, 1, "span", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMapInterpolate2("", ctx.getChangeStyle(), " po-badge po-badge-", ctx.size ? ctx.size : "medium", "");
        ɵɵclassProp("po-badge-notification", ctx.isNotification && !ctx.status)("po-badge-border", ctx.showBorder);
        ɵɵproperty("ariaLabel", ctx.notificationLabel)("ngStyle", ctx.customColor && !ctx.status ? ɵɵpureFunction1(13, _c0$1I, ctx.customColor) : ɵɵpureFunction0(15, _c1$H));
        ɵɵattribute("data-status", ctx.status);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.isNotification && ctx.size !== "small" && ctx.badgeIcon && ctx.status !== "disabled");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.value > 1);
      }
    },
    dependencies: [NgIf, NgStyle, PoIconComponent],
    styles: ["[_nghost-%COMP%]{display:inline-block;vertical-align:middle}"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBadgeComponent, [{
    type: Component,
    args: [{
      selector: "po-badge",
      standalone: false,
      template: `<div
  class="{{ getChangeStyle() }} po-badge po-badge-{{ size ? size : 'medium' }}"
  [class.po-badge-notification]="isNotification && !status"
  [class.po-badge-border]="showBorder"
  [attr.data-status]="status"
  [ariaLabel]="notificationLabel"
  [ngStyle]="customColor && !status ? { 'background-color': customColor } : {}"
>
  <po-icon
    *ngIf="!isNotification && size !== 'small' && badgeIcon && status !== 'disabled'"
    [p-icon]="badgeIcon"
  ></po-icon>
  <span *ngIf="value > 1" class="po-badge-value" aria-hidden="true">{{ badgeValue }}</span>
</div>
`,
      styles: [":host{display:inline-block;vertical-align:middle}\n"]
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoBadgeComponent, {
    className: "PoBadgeComponent",
    filePath: "lib/components/po-badge/po-badge.component.ts",
    lineNumber: 37
  });
})();
var PoBadgeModule = class _PoBadgeModule {
  static ɵfac = function PoBadgeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoBadgeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoBadgeModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBadgeModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoIconModule],
      declarations: [PoBadgeComponent],
      exports: [PoBadgeComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoBadgeModule, {
    declarations: [PoBadgeComponent],
    imports: [CommonModule, PoIconModule],
    exports: [PoBadgeComponent]
  });
})();
var PoBreadcrumbBaseComponent = class _PoBreadcrumbBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Permite definir uma URL no componente `po-breadcrumb` para favoritar ou desfavoritar.
   * > Para utilizar esta propriedade, o último `PoBreadcrumbItem` da lista de items da propriedade `p-items` deve ter um link informado.
   *
   * > A API deve estar preparada para retornar um objeto no formato `{ isFavorite: boolean }`.
   *
   * Ao iniciar, o `po-breadcrumb` faz um GET na URL definida na propriedade `p-favorite-service` e deve retornar a propriedade
   * `{ isFavorite: boolean }` do último `PoBreadcrumbItem` definido na lista de itens da propriedade `p-items`.
   *
   * Ao clicar em favoritar ou desfavoritar o `po-breadcrumb` faz um POST com o link e a propriedade `{ isFavorite: boolean }`
   * definidos no último item da propriedade `p-items`.
   *
   * > Caso algum parâmetro seja definido na propriedade `p-params-service`, o mesmo será enviado para a API e retornará
   * após fazer um GET ou POST.
   *
   * Exemplo de URL contendo o serviço de favoritar ou desfavoritar:
   *
   * ```
   * https://po-ui.io/sample/api/favorite
   * ```
   *
   * Ao fazer o GET o `po-breadcrumb` concatena o link com a URL de serviço. Exemplo:
   *
   * ```
   * GET http://<domain>/api/favorite?url=/example
   * ```
   *
   * ```
   * GET http://po.com.br/sample/api/favorite?url=/example
   * ```
   *
   * ```
   * POST
   * payload: { isFavorite: true, url: '/example' }
   * ```
   *
   * Caso possua parâmetros definidos na propriedade `p-params-service`:
   *
   * ```
   * POST
   * payload: { isFavorite: true, url: "/example", params: "{ id: 14, user: 'dev.po' }" }
   * ```
   *
   * Exemplos de retorno:
   *
   * ```
   * { isFavorite: true, url: "/example" }
   * ```
   *
   * ```
   * { isFavorite: false, url: "/example" }
   * ```
   *
   * ```
   * { isFavorite: false, url: "/example", params: "{ id: 14, user: 'dev.po' }" }
   * ```
   */
  favoriteService;
  /**
   * @optional
   *
   * @description
   *
   * Objeto que possibilita o envio de parâmetros adicionais à requisição.
   */
  paramsService;
  itemsView = [];
  itemsViewPopup = [];
  clickoutListener;
  resizeListener;
  _items = [];
  /**
   * @description
   *
   * Lista de itens do _breadcrumb_.
   *
   * **Exemplo:**
   * ```
   * { label: 'Po Portal', link: 'portal' }
   * ```
   */
  set items(items) {
    this._items = items;
    this.itemsView = [].concat(items);
    if (this.itemsView.length >= 4) {
      this.transformToArrayPopup(items);
    }
  }
  get items() {
    return this._items;
  }
  transformToArrayPopup(items) {
    const itemsCopy = items.map((obj) => __spreadValues({}, obj));
    itemsCopy.shift();
    itemsCopy.splice(-2, 1);
    itemsCopy.pop();
    this.itemsViewPopup = this.transformArrayToActionPopUp(itemsCopy);
  }
  transformArrayToActionPopUp(items) {
    return items.map((obj) => {
      if (obj.hasOwnProperty("link")) {
        obj["url"] = obj.link;
        delete obj.link;
        if (obj.hasOwnProperty("action")) {
          delete obj.action;
        }
      }
      return obj;
    });
  }
  static ɵfac = function PoBreadcrumbBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoBreadcrumbBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoBreadcrumbBaseComponent,
    inputs: {
      favoriteService: [0, "p-favorite-service", "favoriteService"],
      paramsService: [0, "p-params-service", "paramsService"],
      items: [0, "p-items", "items"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBreadcrumbBaseComponent, [{
    type: Directive
  }], null, {
    favoriteService: [{
      type: Input,
      args: ["p-favorite-service"]
    }],
    paramsService: [{
      type: Input,
      args: ["p-params-service"]
    }],
    items: [{
      type: Input,
      args: ["p-items"]
    }]
  });
})();
var PoLinkBaseComponent = class _PoLinkBaseComponent {
  /** Valor do rótulo a ser exibido. */
  label;
  /** Indica se o link deverá ser aberto em uma nova aba. Sempre que utilizar essa propriedade, é importante informar isso ao usuário através da label. */
  openNewTab = false;
  /** Url que será aberta ao clicar no link. */
  url;
  get type() {
    if (!this.url && this.action.observed) {
      return "action";
    }
    return isExternalLink(this.url) ? "externalLink" : "internalLink";
  }
  /** Ação que será executada quando o usuário clicar sobre o `po-link`.
   * > Ao utilizar junto da propriedade `p-url` a ação será ignorada.
   */
  action = new EventEmitter();
  static ɵfac = function PoLinkBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLinkBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoLinkBaseComponent,
    inputs: {
      label: [0, "p-label", "label"],
      openNewTab: [2, "p-open-new-tab", "openNewTab", convertToBoolean],
      url: [0, "p-url", "url"]
    },
    outputs: {
      action: "p-action"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLinkBaseComponent, [{
    type: Directive
  }], null, {
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    openNewTab: [{
      type: Input,
      args: [{
        alias: "p-open-new-tab",
        transform: convertToBoolean
      }]
    }],
    url: [{
      type: Input,
      args: ["p-url"]
    }],
    action: [{
      type: Output,
      args: ["p-action"]
    }]
  });
})();
function PoLinkComponent_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 5);
    ɵɵlistener("click", function PoLinkComponent_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClick());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function PoLinkComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("href", ctx_r1.url, ɵɵsanitizeUrl)("target", ctx_r1.openNewTab ? "_blank" : "_self");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function PoLinkComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("routerLink", ctx_r1.url);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function PoLinkComponent_a_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("href", ctx_r1.url, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
var PoLinkComponent = class _PoLinkComponent extends PoLinkBaseComponent {
  onClick() {
    if (this.url) {
      return;
    } else {
      this.action.emit(null);
    }
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoLinkComponent_BaseFactory;
    return function PoLinkComponent_Factory(__ngFactoryType__) {
      return (ɵPoLinkComponent_BaseFactory || (ɵPoLinkComponent_BaseFactory = ɵɵgetInheritedFactory(_PoLinkComponent)))(__ngFactoryType__ || _PoLinkComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoLinkComponent,
    selectors: [["po-link"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 5,
    vars: 4,
    consts: [[3, "ngSwitch"], ["class", "po-link", "type", "button", 3, "click", 4, "ngSwitchCase"], ["class", "po-link", 3, "href", "target", 4, "ngSwitchCase"], ["class", "po-link", 3, "routerLink", 4, "ngSwitchCase"], ["class", "po-link", 3, "href", 4, "ngSwitchDefault"], ["type", "button", 1, "po-link", 3, "click"], [1, "po-link", 3, "href", "target"], [1, "po-link", 3, "routerLink"], [1, "po-link", 3, "href"]],
    template: function PoLinkComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0, 0);
        ɵɵtemplate(1, PoLinkComponent_button_1_Template, 2, 1, "button", 1)(2, PoLinkComponent_a_2_Template, 2, 3, "a", 2)(3, PoLinkComponent_a_3_Template, 2, 2, "a", 3)(4, PoLinkComponent_a_4_Template, 2, 2, "a", 4);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngSwitch", ctx.type);
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", "action");
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", "externalLink");
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", "internalLink");
      }
    },
    dependencies: [NgSwitch, NgSwitchCase, NgSwitchDefault, RouterLink],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLinkComponent, [{
    type: Component,
    args: [{
      selector: "po-link",
      standalone: false,
      template: `<ng-container [ngSwitch]="type">
  <button *ngSwitchCase="'action'" class="po-link" type="button" (click)="onClick()">{{ label }}</button>

  <a *ngSwitchCase="'externalLink'" class="po-link" [href]="url" [target]="openNewTab ? '_blank' : '_self'">{{
    label
  }}</a>

  <a *ngSwitchCase="'internalLink'" class="po-link" [routerLink]="url">{{ label }}</a>

  <a *ngSwitchDefault class="po-link" [href]="url">{{ label }}</a>
</ng-container>
`
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLinkComponent, {
    className: "PoLinkComponent",
    filePath: "lib/components/po-link/po-link.component.ts",
    lineNumber: 30
  });
})();
var poPopupDefaultPosition = "bottom-left";
var PoPopupBaseComponent = class _PoPopupBaseComponent {
  arrowDirection = "top-right";
  showPopup = false;
  oldTarget;
  param;
  clickoutListener;
  resizeListener;
  _actions;
  _customPositions;
  _hideArrow = false;
  _isCornerAlign = false;
  _position = poPopupDefaultPosition;
  _target;
  /** Lista de ações que serão exibidas no componente. */
  set actions(value) {
    this._actions = Array.isArray(value) ? value : [];
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Oculta a seta do componente *popup*.
   *
   * @default `false`
   */
  set hideArrow(value) {
    this._hideArrow = convertToBoolean(value);
  }
  get hideArrow() {
    return this._hideArrow;
  }
  // Define se o `po-popup` será alinhado pelos cantos do elemento target.
  set isCornerAlign(value) {
    this._isCornerAlign = convertToBoolean(value);
  }
  get isCornerAlign() {
    return this._isCornerAlign;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a posição inicial que o `po-popup` abrirá em relação ao componente alvo. Sugere-se que seja
   * usada a orientação `bottom-left` (abaixo e a esquerda), porém o mesmo é flexível e será rotacionado
   * automaticamente para se adequar a tela, caso necessário.
   *
   * > Caso seja definido um `p-custom-positions` o componente irá abrir na posição definida na propriedade `p-position`
   * e caso não caiba na posição inicial ele irá rotacionar seguindo a ordem de posições definidas no `p-custom-positions`.
   *
   * Posições válidas:
   * - `right`: Posiciona o po-popup no lado direito do componente alvo.
   * - `right-bottom`: Posiciona o po-popup no lado direito inferior do componente alvo.
   * - `right-top`: Posiciona o po-popup no lado direito superior do componente alvo.
   * - `bottom`: Posiciona o po-popup abaixo do componente alvo.
   * - `bottom-left`: Posiciona o po-popup abaixo e à esquerda do componente alvo.
   * - `bottom-right`: Posiciona o po-popup abaixo e à direita do componente alvo.
   * - `left`: Posiciona o po-popup no lado esquerdo do componente alvo.
   * - `left-top`: Posiciona o po-popup no lado esquerdo superior do componente alvo.
   * - `left-bottom`: Posiciona o po-popup no lado esquerdo inferior do componente alvo.
   * - `top`: Posiciona o po-popup acima do componente alvo.
   * - `top-right`: Posiciona o po-popup acima e à direita do componente alvo.
   * - `top-left`: Posiciona o po-popup acima e à esquerda do componente alvo.
   *
   * @default `bottom-left`
   */
  set position(value) {
    this._position = PO_CONTROL_POSITIONS.includes(value) ? value : poPopupDefaultPosition;
  }
  get position() {
    return this._position;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define as posições e a sequência que o `po-popup` poderá rotacionar. A sequência será definida pela ordem passada
   * no *array*. Caso não seja definido, o `po-popup` irá rotacionar em todas as posições válidas.
   *
   * > O componente sempre irá abrir na posição definida no `p-position` e caso não caiba na posição definida o mesmo
   * irá rotacionar seguindo a ordem definida pelo `p-custom-position`.
   *
   * Posições válidas:
   * - `right`: Posiciona o po-popup no lado direito do componente alvo.
   * - `right-bottom`: Posiciona o po-popup no lado direito inferior do componente alvo.
   * - `right-top`: Posiciona o po-popup no lado direito superior do componente alvo.
   * - `bottom`: Posiciona o po-popup abaixo do componente alvo.
   * - `bottom-left`: Posiciona o po-popup abaixo e à esquerda do componente alvo.
   * - `bottom-right`: Posiciona o po-popup abaixo e à direita do componente alvo.
   * - `left`: Posiciona o po-popup no lado esquerdo do componente alvo.
   * - `left-top`: Posiciona o po-popup no lado esquerdo superior do componente alvo.
   * - `left-bottom`: Posiciona o po-popup no lado esquerdo inferior do componente alvo.
   * - `top`: Posiciona o po-popup acima do componente alvo.
   * - `top-right`: Posiciona o po-popup acima e à direita do componente alvo.
   * - `top-left`: Posiciona o po-popup acima e à esquerda do componente alvo.
   */
  set customPositions(value) {
    this._customPositions = Array.isArray(value) ? value : [];
  }
  get customPositions() {
    return this._customPositions;
  }
  /**
   * @description
   *
   * Para utilizar o `po-popup` deve-se colocar uma variável local no componente que disparará o evento
   * de abertura no mesmo e com isso, invocará a função `toggle`, por exemplo:
   *
   * ```
   * <span #icon class="an an-credit-card" (click)="popup.toggle()">
   *   Credit Actions
   * </span>
   *
   * <po-popup #popup
   *   [p-actions]="actions"
   *   [p-target]="icon">
   * </po-popup>
   * ```
   *
   * Caso o elemento alvo for um componente, será preciso obter o `ElementRef` do mesmo e passá-lo à propriedade, por exemplo:
   *
   * ```
   * // component.html
   *
   * <po-button #poButton
   *   p-label="Open Popover"
   *   (p-click)="popup.toggle()">
   * </po-button>
   *
   * <po-popup #popup
   *   [p-actions]="actions"
   *   [p-target]="poButtonRef">
   * </po-popup>
   *
   * // component.ts
   *
   * @ViewChild('poButton', { read: ElementRef }) poButtonRef: ElementRef;
   * ```
   */
  set target(value) {
    this._target = value instanceof ElementRef ? value.nativeElement : value;
  }
  get target() {
    return this._target;
  }
  closeEvent = new EventEmitter();
  static ɵfac = function PoPopupBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPopupBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoPopupBaseComponent,
    inputs: {
      actions: [0, "p-actions", "actions"],
      hideArrow: [0, "p-hide-arrow", "hideArrow"],
      isCornerAlign: [0, "p-is-corner-align", "isCornerAlign"],
      position: [0, "p-position", "position"],
      customPositions: [0, "p-custom-positions", "customPositions"],
      target: [0, "p-target", "target"]
    },
    outputs: {
      closeEvent: "p-close"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopupBaseComponent, [{
    type: Directive
  }], null, {
    actions: [{
      type: Input,
      args: ["p-actions"]
    }],
    hideArrow: [{
      type: Input,
      args: ["p-hide-arrow"]
    }],
    isCornerAlign: [{
      type: Input,
      args: ["p-is-corner-align"]
    }],
    position: [{
      type: Input,
      args: ["p-position"]
    }],
    customPositions: [{
      type: Input,
      args: ["p-custom-positions"]
    }],
    target: [{
      type: Input,
      args: ["p-target"]
    }],
    closeEvent: [{
      type: Output,
      args: ["p-close"]
    }]
  });
})();
var PoItemListType;
(function(PoItemListType2) {
  PoItemListType2["action"] = "action";
  PoItemListType2["check"] = "check";
  PoItemListType2["option"] = "option";
  PoItemListType2["danger"] = "danger";
})(PoItemListType || (PoItemListType = {}));
var PoItemListFilterMode;
(function(PoItemListFilterMode2) {
  PoItemListFilterMode2[PoItemListFilterMode2["startsWith"] = 0] = "startsWith";
  PoItemListFilterMode2[PoItemListFilterMode2["contains"] = 1] = "contains";
  PoItemListFilterMode2[PoItemListFilterMode2["endsWith"] = 2] = "endsWith";
})(PoItemListFilterMode || (PoItemListFilterMode = {}));
var poListBoxLiteralsDefault = {
  en: {
    noItems: "No items found"
  },
  es: {
    noItems: "No se encontraron artículos"
  },
  pt: {
    noItems: "Nenhum item encontrado"
  },
  ru: {
    noItems: "ничего не найдено"
  }
};
var PoListBoxBaseComponent = class _PoListBoxBaseComponent {
  _items = [];
  _type;
  _literals;
  language = poLocaleDefault;
  visible = false;
  set type(value) {
    this._type = PoItemListType[value] ?? "action";
  }
  get type() {
    return this._type;
  }
  set items(items) {
    this._items = Array.isArray(items) ? items : [];
  }
  get items() {
    return this._items;
  }
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poListBoxLiteralsDefault[poLocaleDefault]), poListBoxLiteralsDefault[this.language]), value);
    } else {
      this._literals = poListBoxLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poListBoxLiteralsDefault[this.language];
  }
  get isItemListGroup() {
    return this.items.length && this.items[0].hasOwnProperty("options");
  }
  isTabs = false;
  // parâmetro que pode ser passado para o popup ao clicar em um item
  param;
  selectItem = new EventEmitter();
  closeEvent = new EventEmitter();
  // MULTISELECT PROPERTIES
  //output para evento do checkbox
  change = new EventEmitter();
  //output para evento do checkbox
  selectCombo = new EventEmitter();
  //output para evento do checkbox de selecionar todos
  changeAll = new EventEmitter();
  UpdateInfiniteScroll = new EventEmitter();
  //valor do checkbox de selecionar todos
  checkboxAllValue;
  // Propriedade que recebe a lista de opções selecionadas.
  selectedOptions = [];
  // Propriedade que recebe um item selecionado.
  selectedOption;
  fieldValue = "value";
  fieldLabel = "label";
  // Evento disparado a cada tecla digitada na pesquisa.
  changeSearch = new EventEmitter();
  // Propriedade que recebe as literais definidas no componente `po-multiselect`.
  literalSearch;
  // Propriedade que recebe o valor de comparação de pesquisa
  fieldValueSearch = "value";
  // Propriedade que indica se o campo de pesquisa deverá ser escondido.
  hideSearch = false;
  // Propriedade que indica se o campo "Selecionar todos" deverá ser escondido.
  hideSelectAll = false;
  //Propriedades relacionados ao template customizado do multiselect
  multiselectTemplate;
  template;
  placeholderSearch;
  searchValue;
  isServerSearching = false;
  infiniteLoading = false;
  infiniteScroll = false;
  cache = false;
  infiniteScrollDistance = 100;
  filterMode = PoItemListFilterMode.contains;
  isFiltering = false;
  shouldMarkLetters = true;
  compareCache = false;
  comboService;
  containerWidth;
  // Evento disparado quando uma tab é ativada
  activatedTab = new EventEmitter();
  // Evento disparado no click de uma aba do tabs
  clickTab = new EventEmitter();
  changeStateTabs = new EventEmitter();
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoListBoxBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoListBoxBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoListBoxBaseComponent,
    inputs: {
      visible: [2, "p-visible", "visible", convertToBoolean],
      type: [0, "p-type", "type"],
      items: [0, "p-items", "items"],
      literals: [0, "p-literals", "literals"],
      isTabs: [2, "p-is-tabs", "isTabs", convertToBoolean],
      param: [0, "p-param", "param"],
      checkboxAllValue: [0, "p-checkboxAllValue", "checkboxAllValue"],
      selectedOptions: [0, "p-selected-options", "selectedOptions"],
      selectedOption: [0, "p-selected-option", "selectedOption"],
      fieldValue: [0, "p-field-value", "fieldValue"],
      fieldLabel: [0, "p-field-label", "fieldLabel"],
      literalSearch: [0, "p-literal-search", "literalSearch"],
      fieldValueSearch: [0, "p-field-value-search", "fieldValueSearch"],
      hideSearch: [0, "p-hide-search", "hideSearch"],
      hideSelectAll: [0, "p-hide-select-all", "hideSelectAll"],
      multiselectTemplate: [0, "p-multiselect-template", "multiselectTemplate"],
      template: [0, "p-template", "template"],
      placeholderSearch: [0, "p-placeholder-search", "placeholderSearch"],
      searchValue: [0, "p-search-value", "searchValue"],
      isServerSearching: [2, "p-is-searching", "isServerSearching", convertToBoolean],
      infiniteLoading: [2, "p-infinite-loading", "infiniteLoading", convertToBoolean],
      infiniteScroll: [2, "p-infinite-scroll", "infiniteScroll", convertToBoolean],
      cache: [2, "p-cache", "cache", convertToBoolean],
      infiniteScrollDistance: [0, "p-infinite-scroll-distance", "infiniteScrollDistance"],
      filterMode: [0, "p-filter-mode", "filterMode"],
      isFiltering: [0, "p-filtering", "isFiltering"],
      shouldMarkLetters: [0, "p-should-mark-letter", "shouldMarkLetters"],
      compareCache: [0, "p-compare-cache", "compareCache"],
      comboService: [0, "p-combo-service", "comboService"],
      containerWidth: [0, "p-container-width", "containerWidth"]
    },
    outputs: {
      selectItem: "p-select-item",
      closeEvent: "p-close",
      change: "p-change",
      selectCombo: "p-selectcombo-item",
      changeAll: "p-change-all",
      UpdateInfiniteScroll: "p-update-infinite-scroll",
      changeSearch: "p-change-search",
      activatedTab: "p-activated-tabs",
      clickTab: "p-click-tabs",
      changeStateTabs: "p-change-state-tabs"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListBoxBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    visible: [{
      type: Input,
      args: [{
        alias: "p-visible",
        transform: convertToBoolean
      }]
    }],
    type: [{
      type: Input,
      args: ["p-type"]
    }],
    items: [{
      type: Input,
      args: ["p-items"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    isTabs: [{
      type: Input,
      args: [{
        alias: "p-is-tabs",
        transform: convertToBoolean
      }]
    }],
    param: [{
      type: Input,
      args: ["p-param"]
    }],
    selectItem: [{
      type: Output,
      args: ["p-select-item"]
    }],
    closeEvent: [{
      type: Output,
      args: ["p-close"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    selectCombo: [{
      type: Output,
      args: ["p-selectcombo-item"]
    }],
    changeAll: [{
      type: Output,
      args: ["p-change-all"]
    }],
    UpdateInfiniteScroll: [{
      type: Output,
      args: ["p-update-infinite-scroll"]
    }],
    checkboxAllValue: [{
      type: Input,
      args: ["p-checkboxAllValue"]
    }],
    selectedOptions: [{
      type: Input,
      args: ["p-selected-options"]
    }],
    selectedOption: [{
      type: Input,
      args: ["p-selected-option"]
    }],
    fieldValue: [{
      type: Input,
      args: ["p-field-value"]
    }],
    fieldLabel: [{
      type: Input,
      args: ["p-field-label"]
    }],
    changeSearch: [{
      type: Output,
      args: ["p-change-search"]
    }],
    literalSearch: [{
      type: Input,
      args: ["p-literal-search"]
    }],
    fieldValueSearch: [{
      type: Input,
      args: ["p-field-value-search"]
    }],
    hideSearch: [{
      type: Input,
      args: ["p-hide-search"]
    }],
    hideSelectAll: [{
      type: Input,
      args: ["p-hide-select-all"]
    }],
    multiselectTemplate: [{
      type: Input,
      args: ["p-multiselect-template"]
    }],
    template: [{
      type: Input,
      args: ["p-template"]
    }],
    placeholderSearch: [{
      type: Input,
      args: ["p-placeholder-search"]
    }],
    searchValue: [{
      type: Input,
      args: ["p-search-value"]
    }],
    isServerSearching: [{
      type: Input,
      args: [{
        alias: "p-is-searching",
        transform: convertToBoolean
      }]
    }],
    infiniteLoading: [{
      type: Input,
      args: [{
        alias: "p-infinite-loading",
        transform: convertToBoolean
      }]
    }],
    infiniteScroll: [{
      type: Input,
      args: [{
        alias: "p-infinite-scroll",
        transform: convertToBoolean
      }]
    }],
    cache: [{
      type: Input,
      args: [{
        alias: "p-cache",
        transform: convertToBoolean
      }]
    }],
    infiniteScrollDistance: [{
      type: Input,
      args: ["p-infinite-scroll-distance"]
    }],
    filterMode: [{
      type: Input,
      args: ["p-filter-mode"]
    }],
    isFiltering: [{
      type: Input,
      args: ["p-filtering"]
    }],
    shouldMarkLetters: [{
      type: Input,
      args: ["p-should-mark-letter"]
    }],
    compareCache: [{
      type: Input,
      args: ["p-compare-cache"]
    }],
    comboService: [{
      type: Input,
      args: ["p-combo-service"]
    }],
    containerWidth: [{
      type: Input,
      args: ["p-container-width"]
    }],
    activatedTab: [{
      type: Output,
      args: ["p-activated-tabs"]
    }],
    clickTab: [{
      type: Output,
      args: ["p-click-tabs"]
    }],
    changeStateTabs: [{
      type: Output,
      args: ["p-change-state-tabs"]
    }]
  });
})();
var poLoadingOverlayLiteralsDefault = {
  en: {
    loading: "Loading"
  },
  es: {
    loading: "Cargando"
  },
  pt: {
    loading: "Carregando"
  },
  ru: {
    loading: "Загрузка"
  }
};
var PoLoadingOverlayBaseComponent = class _PoLoadingOverlayBaseComponent {
  languageService;
  _screenLock = false;
  _text;
  _size;
  /**
   * @optional
   *
   * @description
   *
   * Define se o *overlay* será aplicado a um *container* ou à página inteira.
   *
   * Para utilizar o componente como um *container*, o elemento pai deverá receber uma posição relativa, por exemplo:
   *
   * ```
   * <div style="position: relative">
   *
   *  <po-chart [p-series]="[{ value: 10, category: 'Example' }]">
   *  </po-chart>
   *
   *  <po-loading-overlay>
   *  </po-loading-overlay>
   * </div>
   * ```
   *
   * @default `false`
   */
  set screenLock(screenLock2) {
    this._screenLock = convertToBoolean(screenLock2);
  }
  get screenLock() {
    return this._screenLock;
  }
  /**
   * @optional
   *
   * @description
   *
   * Texto a ser exibido no componente.
   *
   * > O valor padrão será traduzido de acordo com o idioma configurado no [**PoI18n**](/documentation/po-i18n) ou navegador.
   *
   * @default `Carregando`
   */
  set text(value) {
    this._text = value || this.getTextDefault();
  }
  get text() {
    return this._text;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho do componente com base no tamanho do ícone de *loading*.
   *
   * Tamanhos disponíveis para o *loading*:
   * - `xs`: 16px
   * - `sm`: 24px
   * - `md`: 48px
   * - `lg`: 80px (valor padrão)
   *
   * @default `lg`
   */
  set size(value) {
    this._size = value === "" || !value ? "lg" : value;
  }
  get size() {
    return this._size;
  }
  constructor(languageService) {
    this.languageService = languageService;
    this.text = this.getTextDefault();
  }
  getTextDefault() {
    const language = this.languageService.getShortLanguage();
    return poLoadingOverlayLiteralsDefault[language].loading;
  }
  static ɵfac = function PoLoadingOverlayBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLoadingOverlayBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoLoadingOverlayBaseComponent,
    inputs: {
      screenLock: [0, "p-screen-lock", "screenLock"],
      text: [0, "p-text", "text"],
      size: [0, "p-size", "size"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingOverlayBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    screenLock: [{
      type: Input,
      args: ["p-screen-lock"]
    }],
    text: [{
      type: Input,
      args: ["p-text"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }]
  });
})();
var PoOverlayBaseComponent = class _PoOverlayBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Define se o *overlay* será aplicado a um *container* ou a página inteira.
   *
   * Para utilizar o componente como um *container*, o elemento pai deverá receber uma posição relativa, por exemplo:
   *
   * ```
   * <div style="position: relative">
   *
   *  <po-chart [p-series]="[{ value: 10, category: 'Example' }]">
   *  </po-chart>
   *
   *  <po-overlay>
   *  </po-overlay>
   * </div>
   * ```
   *
   * @default `false`
   */
  screenLock = false;
  static ɵfac = function PoOverlayBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoOverlayBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoOverlayBaseComponent,
    inputs: {
      screenLock: [2, "p-screen-lock", "screenLock", convertToBoolean]
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoOverlayBaseComponent, [{
    type: Directive
  }], null, {
    screenLock: [{
      type: Input,
      args: [{
        alias: "p-screen-lock",
        transform: convertToBoolean
      }]
    }]
  });
})();
var _c0$1H = ["*"];
var PoOverlayComponent = class _PoOverlayComponent extends PoOverlayBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoOverlayComponent_BaseFactory;
    return function PoOverlayComponent_Factory(__ngFactoryType__) {
      return (ɵPoOverlayComponent_BaseFactory || (ɵPoOverlayComponent_BaseFactory = ɵɵgetInheritedFactory(_PoOverlayComponent)))(__ngFactoryType__ || _PoOverlayComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoOverlayComponent,
    selectors: [["po-overlay"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0$1H,
    decls: 3,
    vars: 2,
    consts: [["role", "alert", "aria-busy", "true", 1, "po-overlay"], [1, "po-overlay-content"]],
    template: function PoOverlayComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0)(1, "div", 1);
        ɵɵprojection(2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵclassProp("po-overlay-fixed", ctx.screenLock);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoOverlayComponent, [{
    type: Component,
    args: [{
      selector: "po-overlay",
      standalone: false,
      template: '<div class="po-overlay" [class.po-overlay-fixed]="screenLock" role="alert" aria-busy="true">\n  <div class="po-overlay-content">\n    <ng-content></ng-content>\n  </div>\n</div>\n'
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoOverlayComponent, {
    className: "PoOverlayComponent",
    filePath: "lib/components/po-overlay/po-overlay.component.ts",
    lineNumber: 9
  });
})();
var PoLoadingIconSize;
(function(PoLoadingIconSize2) {
  PoLoadingIconSize2["xs"] = "xs";
  PoLoadingIconSize2["sm"] = "sm";
  PoLoadingIconSize2["md"] = "md";
  PoLoadingIconSize2["lg"] = "lg";
})(PoLoadingIconSize || (PoLoadingIconSize = {}));
var poLoadingLiteralsDefault = {
  en: {
    loading: "Loading"
  },
  es: {
    loading: "Cargando"
  },
  pt: {
    loading: "Carregando"
  },
  ru: {
    loading: "Загрузка"
  }
};
var PoLoadingBaseComponent = class _PoLoadingBaseComponent {
  languageService;
  _text;
  _size;
  /**
   * Texto a ser exibido no componente.
   */
  set text(value) {
    this._text = value || (value === "" ? "" : this.getTextDefault());
  }
  get text() {
    return this._text;
  }
  /**
   * Define o tamanho do ícone.
   *
   * @default `lg`
   *
   * Valores válidos:
   *  - `xs`: tamanho `extra small`
   *  - `sm`: tamanho `small`
   *  - `md`: tamanho `medium`
   *  - `lg`: tamanho `large`
   */
  set size(value) {
    this._size = PoLoadingIconSize[value] ? PoLoadingIconSize[value] : PoLoadingIconSize.lg;
  }
  get size() {
    return this._size;
  }
  constructor(languageService) {
    this.languageService = languageService;
    this.text = this.getTextDefault();
  }
  getTextDefault() {
    const language = this.languageService.getShortLanguage();
    return poLoadingLiteralsDefault[language].loading;
  }
  static ɵfac = function PoLoadingBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLoadingBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoLoadingBaseComponent,
    inputs: {
      text: [0, "p-text", "text"],
      size: [0, "p-size", "size"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    text: [{
      type: Input,
      args: ["p-text"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }]
  });
})();
var PoLoadingIconComponent = class _PoLoadingIconComponent {
  _neutralColor;
  _size = "md";
  id = uuid();
  /**
   * @optional
   *
   * @description
   *
   * Definição para cor neutra (cinza) para o ícone de carregamento.
   *
   * @default `false`
   */
  set neutralColor(value) {
    this._neutralColor = convertToBoolean(value);
  }
  get neutralColor() {
    return this._neutralColor;
  }
  /**
   * @optional
   *
   * @description
   *
   * Definição do tamanho do ícone.
   *
   * Valores válidos:
   *  - `xs`: tamanho `extra small`
   *  - `sm`: tamanho `small`
   *  - `md`: tamanho `medium`
   *  - `lg`: tamanho `large`
   *
   * @default `md`
   */
  set size(value) {
    this._size = PoLoadingIconSize[value] ? PoLoadingIconSize[value] : PoLoadingIconSize.md;
  }
  get size() {
    return this._size;
  }
  static ɵfac = function PoLoadingIconComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLoadingIconComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoLoadingIconComponent,
    selectors: [["po-loading-icon"]],
    inputs: {
      neutralColor: [0, "p-neutral-color", "neutralColor"],
      size: [0, "p-size", "size"]
    },
    standalone: false,
    decls: 14,
    vars: 8,
    consts: [["viewBox", "0 0 200 200", "fill", "none", "xmlns", "http://www.w3.org/2000/svg", 3, "ngClass"], [3, "id"], ["offset", "0", "stop-opacity", "0", "stop-color", "currentColor"], ["offset", "1", "stop-opacity", "0.5", "stop-color", "currentColor"], ["offset", "0", "stop-opacity", "1", "stop-color", "currentColor"], ["stroke-width", "24", "transform", "matrix(0.876218, 0, 0, 0.87855, 12.377892, 12.144993)"], ["d", "M 4 100 A 96 96 0 0 1 196 100"], ["d", "M 196 100 A 96 96 0 0 1 4 100"], ["stroke", "currentColor", "d", "M 4 100 A 96 96 0 0 1 4 98"], ["from", "0 0 0", "to", "360 0 0", "attributeName", "transform", "type", "rotate", "repeatCount", "indefinite", "dur", "1200ms"]],
    template: function PoLoadingIconComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div");
        ɵɵnamespaceSVG();
        ɵɵelementStart(1, "svg", 0)(2, "defs")(3, "linearGradient", 1);
        ɵɵelement(4, "stop", 2)(5, "stop", 3);
        ɵɵelementEnd();
        ɵɵelementStart(6, "linearGradient", 1);
        ɵɵelement(7, "stop", 4)(8, "stop", 3);
        ɵɵelementEnd()();
        ɵɵelementStart(9, "g", 5);
        ɵɵelement(10, "path", 6)(11, "path", 7)(12, "path", 8);
        ɵɵelementEnd();
        ɵɵelement(13, "animateTransform", 9);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵclassMapInterpolate1("po-loading-icon-container po-loading-svg-", ctx.size, "");
        ɵɵadvance();
        ɵɵproperty("ngClass", ctx.neutralColor ? "po-loading-icon-neutral" : "po-loading-icon");
        ɵɵadvance(2);
        ɵɵproperty("id", "first" + ctx.id);
        ɵɵadvance(3);
        ɵɵproperty("id", "second" + ctx.id);
        ɵɵadvance(4);
        ɵɵattribute("stroke", "url(#second" + ctx.id + ")");
        ɵɵadvance();
        ɵɵattribute("stroke", "url(#first" + ctx.id + ")");
      }
    },
    dependencies: [NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingIconComponent, [{
    type: Component,
    args: [{
      selector: "po-loading-icon",
      standalone: false,
      template: `<div class="po-loading-icon-container po-loading-svg-{{ size }}">
  <svg
    [ngClass]="neutralColor ? 'po-loading-icon-neutral' : 'po-loading-icon'"
    viewBox="0 0 200 200"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <defs>
      <linearGradient [id]="'first' + id">
        <stop offset="0" stop-opacity="0" stop-color="currentColor" />
        <stop offset="1" stop-opacity="0.5" stop-color="currentColor" />
      </linearGradient>
      <linearGradient [id]="'second' + id">
        <stop offset="0" stop-opacity="1" stop-color="currentColor" />
        <stop offset="1" stop-opacity="0.5" stop-color="currentColor" />
      </linearGradient>
    </defs>
    <g stroke-width="24" transform="matrix(0.876218, 0, 0, 0.87855, 12.377892, 12.144993)">
      <path [attr.stroke]="'url(#' + 'second' + id + ')'" d="M 4 100 A 96 96 0 0 1 196 100" />
      <path [attr.stroke]="'url(#' + 'first' + id + ')'" d="M 196 100 A 96 96 0 0 1 4 100" />
      <path stroke="currentColor" d="M 4 100 A 96 96 0 0 1 4 98" />
    </g>

    <animateTransform
      from="0 0 0"
      to="360 0 0"
      attributeName="transform"
      type="rotate"
      repeatCount="indefinite"
      dur="1200ms"
    />
  </svg>
</div>
`
    }]
  }], null, {
    neutralColor: [{
      type: Input,
      args: ["p-neutral-color"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLoadingIconComponent, {
    className: "PoLoadingIconComponent",
    filePath: "lib/components/po-loading/po-loading-icon/po-loading-icon.component.ts",
    lineNumber: 19
  });
})();
function PoLoadingComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 2);
    ɵɵtext(1);
    ɵɵelementStart(2, "div", 3);
    ɵɵtext(3, ".");
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 3);
    ɵɵtext(5, ".");
    ɵɵelementEnd();
    ɵɵelementStart(6, "div", 3);
    ɵɵtext(7, ".");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.text, " ");
  }
}
var PoLoadingComponent = class _PoLoadingComponent extends PoLoadingBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoLoadingComponent_BaseFactory;
    return function PoLoadingComponent_Factory(__ngFactoryType__) {
      return (ɵPoLoadingComponent_BaseFactory || (ɵPoLoadingComponent_BaseFactory = ɵɵgetInheritedFactory(_PoLoadingComponent)))(__ngFactoryType__ || _PoLoadingComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoLoadingComponent,
    selectors: [["po-loading"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 5,
    consts: [[3, "p-size"], ["class", "po-loading-label po-text-ellipsis", 4, "ngIf"], [1, "po-loading-label", "po-text-ellipsis"], ["aria-hidden", "true", 1, "po-loading-dot"]],
    template: function PoLoadingComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div");
        ɵɵelement(1, "po-loading-icon", 0);
        ɵɵtemplate(2, PoLoadingComponent_span_2_Template, 8, 1, "span", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMapInterpolate1("po-loading po-loading-", ctx.size, "");
        ɵɵadvance();
        ɵɵproperty("p-size", ctx.size);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.text);
      }
    },
    dependencies: [NgIf, PoLoadingIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingComponent, [{
    type: Component,
    args: [{
      selector: "po-loading",
      standalone: false,
      template: '<div class="po-loading po-loading-{{ size }}">\n  <po-loading-icon [p-size]="size"></po-loading-icon>\n\n  <span *ngIf="text" class="po-loading-label po-text-ellipsis"\n    >{{ text }}\n    <div class="po-loading-dot" aria-hidden="true">.</div>\n    <div class="po-loading-dot" aria-hidden="true">.</div>\n    <div class="po-loading-dot" aria-hidden="true">.</div>\n  </span>\n</div>\n'
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLoadingComponent, {
    className: "PoLoadingComponent",
    filePath: "lib/components/po-loading/po-loading.component.ts",
    lineNumber: 15
  });
})();
var PoLoadingOverlayComponent = class _PoLoadingOverlayComponent extends PoLoadingOverlayBaseComponent {
  changeDetector;
  constructor(changeDetector, languageService) {
    super(languageService);
    this.changeDetector = changeDetector;
  }
  static ɵfac = function PoLoadingOverlayComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLoadingOverlayComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoLoadingOverlayComponent,
    selectors: [["po-loading-overlay"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 3,
    consts: [[3, "p-screen-lock"], [3, "p-text", "p-size"]],
    template: function PoLoadingOverlayComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "po-overlay", 0);
        ɵɵelement(1, "po-loading", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-screen-lock", ctx.screenLock);
        ɵɵadvance();
        ɵɵproperty("p-text", ctx.text)("p-size", ctx.size);
      }
    },
    dependencies: [PoOverlayComponent, PoLoadingComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingOverlayComponent, [{
    type: Component,
    args: [{
      selector: "po-loading-overlay",
      standalone: false,
      template: '<po-overlay [p-screen-lock]="screenLock">\n  <po-loading [p-text]="text" [p-size]="size"></po-loading>\n</po-overlay>\n'
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: PoLanguageService
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLoadingOverlayComponent, {
    className: "PoLoadingOverlayComponent",
    filePath: "lib/components/po-loading/po-loading-overlay/po-loading-overlay.component.ts",
    lineNumber: 33
  });
})();
var PoItemListBaseComponent = class _PoItemListBaseComponent {
  _label;
  _value;
  _type;
  _visible = true;
  _disabled = false;
  _activeTabs = false;
  set type(value) {
    this._type = PoItemListType[value] ?? "action";
  }
  get type() {
    return this._type;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o estado como visível.
   *
   * @default `true`
   */
  set visible(value) {
    if (value === true || value === null || value === void 0) {
      this._visible = true;
    } else {
      this._visible = false;
    }
  }
  get visible() {
    return this._visible;
  }
  item;
  /** Texto de exibição do item. */
  label;
  /** Valor do item. */
  value;
  danger = false;
  /**
   * @optional
   *
   * @description
   *
   * Define o estado como desabilitado.
   *
   * @default `false`
   */
  set disabled(value) {
    if (value === false || value === null || value === void 0) {
      this._disabled = false;
    } else {
      this._disabled = true;
    }
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define se a ação está selecionada.
   *
   * @default `false`
   */
  selected = false;
  /**
   * @optional
   *
   * @description
   *
   * Atribui uma linha separadora acima do item.
   *
   * @default `false`
   */
  separator = false;
  /**
   * @optional
   *
   * @description
   *
   * Define um ícone que será exibido ao lado esquerdo do rótulo.
   */
  icon;
  /**
   * @optional
   *
   * @description
   *
   * Ação a ser realizada ao clicar no item do tipo `option`.
   */
  clickItem = new EventEmitter();
  // MULTISELECT PROPERTIES
  //emissao de evento do checkbox
  checkboxItem = new EventEmitter();
  comboItem = new EventEmitter();
  //valor do checkbox de selecionar todos
  checkboxValue;
  fieldValue = "value";
  fieldLabel = "label";
  template;
  templateContext;
  searchValue = "";
  filterMode = PoItemListFilterMode.contains;
  isFiltering = false;
  shouldMarkLetters = true;
  compareCache = false;
  comboService;
  // TABS PROPERTIES
  isTabs = false;
  tabHide = false;
  tabsItem = new EventEmitter();
  activatedTab = new EventEmitter();
  // Ativa o botão
  set activeTabs(value) {
    this._activeTabs = value;
    this.emitActiveTabs(this.item);
  }
  get activeTabs() {
    return this._activeTabs;
  }
  emitActiveTabs(tab) {
    if (tab?.active) {
      this.activatedTab.emit(tab);
    }
  }
  static ɵfac = function PoItemListBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoItemListBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoItemListBaseComponent,
    hostVars: 1,
    hostBindings: function PoItemListBaseComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("p-type", ctx.type);
      }
    },
    inputs: {
      type: [0, "p-type", "type"],
      visible: [0, "p-visible", "visible"],
      item: [0, "p-item", "item"],
      label: [0, "p-label", "label"],
      value: [0, "p-value", "value"],
      danger: [2, "p-danger", "danger", convertToBoolean],
      disabled: [0, "p-disabled", "disabled"],
      selected: [2, "p-selected", "selected", convertToBoolean],
      separator: [2, "p-separator", "separator", convertToBoolean],
      icon: [0, "p-icon", "icon"],
      checkboxValue: [0, "p-checkbox-value", "checkboxValue"],
      fieldValue: [0, "p-field-value", "fieldValue"],
      fieldLabel: [0, "p-field-label", "fieldLabel"],
      template: [0, "p-template", "template"],
      templateContext: [0, "p-template-context", "templateContext"],
      searchValue: [0, "p-search-value", "searchValue"],
      filterMode: [0, "p-filter-mode", "filterMode"],
      isFiltering: [0, "p-filtering", "isFiltering"],
      shouldMarkLetters: [0, "p-should-mark-letter", "shouldMarkLetters"],
      compareCache: [0, "p-compare-cache", "compareCache"],
      comboService: [0, "p-combo-service", "comboService"],
      isTabs: [0, "p-is-tabs", "isTabs"],
      tabHide: [0, "p-tab-hide", "tabHide"],
      activeTabs: [0, "p-active-tabs", "activeTabs"]
    },
    outputs: {
      clickItem: "p-click-item",
      checkboxItem: "p-selectcheckbox-item",
      comboItem: "p-selectcombo-item",
      tabsItem: "p-emit-item-tabs",
      activatedTab: "p-activated-tabs"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoItemListBaseComponent, [{
    type: Directive
  }], null, {
    type: [{
      type: HostBinding,
      args: ["attr.p-type"]
    }, {
      type: Input,
      args: ["p-type"]
    }],
    visible: [{
      type: Input,
      args: ["p-visible"]
    }],
    item: [{
      type: Input,
      args: ["p-item"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }],
    danger: [{
      type: Input,
      args: [{
        alias: "p-danger",
        transform: convertToBoolean
      }]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    selected: [{
      type: Input,
      args: [{
        alias: "p-selected",
        transform: convertToBoolean
      }]
    }],
    separator: [{
      type: Input,
      args: [{
        alias: "p-separator",
        transform: convertToBoolean
      }]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }],
    clickItem: [{
      type: Output,
      args: ["p-click-item"]
    }],
    checkboxItem: [{
      type: Output,
      args: ["p-selectcheckbox-item"]
    }],
    comboItem: [{
      type: Output,
      args: ["p-selectcombo-item"]
    }],
    checkboxValue: [{
      type: Input,
      args: ["p-checkbox-value"]
    }],
    fieldValue: [{
      type: Input,
      args: ["p-field-value"]
    }],
    fieldLabel: [{
      type: Input,
      args: ["p-field-label"]
    }],
    template: [{
      type: Input,
      args: ["p-template"]
    }],
    templateContext: [{
      type: Input,
      args: ["p-template-context"]
    }],
    searchValue: [{
      type: Input,
      args: ["p-search-value"]
    }],
    filterMode: [{
      type: Input,
      args: ["p-filter-mode"]
    }],
    isFiltering: [{
      type: Input,
      args: ["p-filtering"]
    }],
    shouldMarkLetters: [{
      type: Input,
      args: ["p-should-mark-letter"]
    }],
    compareCache: [{
      type: Input,
      args: ["p-compare-cache"]
    }],
    comboService: [{
      type: Input,
      args: ["p-combo-service"]
    }],
    isTabs: [{
      type: Input,
      args: ["p-is-tabs"]
    }],
    tabHide: [{
      type: Input,
      args: ["p-tab-hide"]
    }],
    tabsItem: [{
      type: Output,
      args: ["p-emit-item-tabs"]
    }],
    activatedTab: [{
      type: Output,
      args: ["p-activated-tabs"]
    }],
    activeTabs: [{
      type: Input,
      args: ["p-active-tabs"]
    }]
  });
})();
var PoKeyCodeEnum;
(function(PoKeyCodeEnum2) {
  PoKeyCodeEnum2[PoKeyCodeEnum2["arrowDown"] = 40] = "arrowDown";
  PoKeyCodeEnum2[PoKeyCodeEnum2["arrowUp"] = 38] = "arrowUp";
  PoKeyCodeEnum2[PoKeyCodeEnum2["backspace"] = 8] = "backspace";
  PoKeyCodeEnum2[PoKeyCodeEnum2["delete"] = 46] = "delete";
  PoKeyCodeEnum2[PoKeyCodeEnum2["enter"] = 13] = "enter";
  PoKeyCodeEnum2[PoKeyCodeEnum2["esc"] = 27] = "esc";
  PoKeyCodeEnum2[PoKeyCodeEnum2["keyK"] = 75] = "keyK";
  PoKeyCodeEnum2[PoKeyCodeEnum2["keyL"] = 76] = "keyL";
  PoKeyCodeEnum2[PoKeyCodeEnum2["space"] = 32] = "space";
  PoKeyCodeEnum2[PoKeyCodeEnum2["tab"] = 9] = "tab";
  PoKeyCodeEnum2[PoKeyCodeEnum2["left"] = 37] = "left";
  PoKeyCodeEnum2[PoKeyCodeEnum2["right"] = 39] = "right";
})(PoKeyCodeEnum || (PoKeyCodeEnum = {}));
var PoCheckboxSize;
(function(PoCheckboxSize2) {
  PoCheckboxSize2["medium"] = "medium";
  PoCheckboxSize2["large"] = "large";
})(PoCheckboxSize || (PoCheckboxSize = {}));
var PoCheckboxBaseComponent = class _PoCheckboxBaseComponent {
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Define que o tooltip (`p-additional-help-tooltip`) será incluído no body da página e não dentro do componente. Essa
   * opção pode ser necessária em cenários com containers que possuem scroll ou overflow escondido, garantindo o
   * posicionamento correto do tooltip próximo ao elemento.
   *
   * > Quando utilizado com `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  /**
   * @optional
   *
   * @description
   * Texto de apoio do campo */
  help;
  /** Define o nome do *checkbox*. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Texto de exibição do *checkbox*. */
  label;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  // Evento disparado ao sair do campo.
  blur = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado quando o valor do *checkbox* for alterado.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  //propriedade interna recebida do checkbox-group para verificar se o checkbox está ativo, inativo ou indeterminate
  checkboxValue;
  //propriedade interna recebida do checkbox-group para verificar se o checkbox é required
  checkBoxRequired;
  //propriedade interna recebida para desabilitar o tabindex do checkbox na utilização dentro de um list-box
  disabladTabindex = false;
  displayAdditionalHelp = false;
  id = uuid();
  propagateChange;
  onTouched;
  _disabled = false;
  /**
   * @optional
   *
   * @description
   *
   * Define o estado do *checkbox* como desabilitado.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
  }
  get disabled() {
    return this._disabled;
  }
  _size = PoCheckboxSize.medium;
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho do *checkbox*
   *
   * Valores válidos:
   * - `medium`: o `po-checkbox` fica do tamanho padrão, com 24px de altura.;
   * - `large`: o `po-checkbox` fica maior, com 32px de altura.;
   *
   * @default `medium`
   *
   */
  set size(value) {
    this._size = PoCheckboxSize[value] ? PoCheckboxSize[value] : PoCheckboxSize.medium;
  }
  get size() {
    return this._size;
  }
  changeValue() {
    if (this.propagateChange) {
      this.propagateChange(this.checkboxValue);
    }
    this.change.emit(this.checkboxValue);
  }
  checkOption(value) {
    if (!this.disabled) {
      value === "mixed" ? this.changeModelValue(true) : this.changeModelValue(!value);
      this.changeValue();
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(value) {
    if (value !== this.checkboxValue) {
      this.changeModelValue(value);
    }
  }
  static ɵfac = function PoCheckboxBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCheckboxBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoCheckboxBaseComponent,
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      help: [0, "p-help", "help"],
      name: "name",
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      label: [0, "p-label", "label"],
      checkboxValue: [0, "p-checkboxValue", "checkboxValue"],
      checkBoxRequired: [2, "p-required", "checkBoxRequired", convertToBoolean],
      disabladTabindex: [2, "p-disabled-tabindex", "disabladTabindex", convertToBoolean],
      disabled: [0, "p-disabled", "disabled"],
      size: [0, "p-size", "size"]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      blur: "p-blur",
      change: "p-change",
      keydown: "p-keydown"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxBaseComponent, [{
    type: Directive
  }], null, {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    blur: [{
      type: Output,
      args: ["p-blur"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    checkboxValue: [{
      type: Input,
      args: ["p-checkboxValue"]
    }],
    checkBoxRequired: [{
      type: Input,
      args: [{
        alias: "p-required",
        transform: convertToBoolean
      }]
    }],
    disabladTabindex: [{
      type: Input,
      args: [{
        alias: "p-disabled-tabindex",
        transform: convertToBoolean
      }]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }]
  });
})();
function PoLabelComponent_label_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-label-disabled", ctx_r0.disabled);
    ɵɵattribute("for", ctx_r0.field && ctx_r0.for ? ctx_r0.for : void 0)("p-field", ctx_r0.field);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function PoLabelComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.requirement);
  }
}
var PoLabelComponent = class _PoLabelComponent {
  _disabled = false;
  _field = false;
  /**
   * @optional
   *
   * @description
   *
   * Indica se o label está desativado.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = value === "" ? true : convertToBoolean(value);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica se o label será de um field.
   *
   * @default `false`
   */
  set field(value) {
    this._field = value === "" ? true : convertToBoolean(value);
  }
  get field() {
    return this._field;
  }
  /** Indica o campo vinculado ao label */
  for;
  /** Label do campo. */
  label;
  /** Indica o tipo do campo vinculado ao label */
  requirement;
  static ɵfac = function PoLabelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLabelComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoLabelComponent,
    selectors: [["po-label"]],
    inputs: {
      disabled: [0, "p-disabled", "disabled"],
      field: [0, "p-field", "field"],
      for: [0, "p-for", "for"],
      label: [0, "p-label", "label"],
      requirement: [0, "p-requirement", "requirement"]
    },
    standalone: false,
    decls: 2,
    vars: 2,
    consts: [["class", "po-label", 3, "po-label-disabled", 4, "ngIf"], ["class", "po-label-requirement", 4, "ngIf"], [1, "po-label"], [1, "po-label-requirement"]],
    template: function PoLabelComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoLabelComponent_label_0_Template, 2, 5, "label", 0)(1, PoLabelComponent_span_1_Template, 2, 1, "span", 1);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.label);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.field && ctx.requirement);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLabelComponent, [{
    type: Component,
    args: [{
      selector: "po-label",
      standalone: false,
      template: '<label\n  *ngIf="label"\n  class="po-label"\n  [attr.for]="field && for ? for : undefined"\n  [attr.p-field]="field"\n  [class.po-label-disabled]="disabled"\n  >{{ label }}</label\n>\n<span *ngIf="field && requirement" class="po-label-requirement">{{ requirement }}</span>\n'
    }]
  }], null, {
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    field: [{
      type: Input,
      args: ["p-field"]
    }],
    for: [{
      type: Input,
      args: ["p-for"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    requirement: [{
      type: Input,
      args: ["p-requirement"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLabelComponent, {
    className: "PoLabelComponent",
    filePath: "lib/components/po-label/po-label.component.ts",
    lineNumber: 15
  });
})();
var PoDirectivesModule = class _PoDirectivesModule {
  static ɵfac = function PoDirectivesModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDirectivesModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoDirectivesModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [PoTooltipModule, PoTooltipModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDirectivesModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [PoTooltipModule],
      exports: [PoTooltipModule],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDirectivesModule, {
    imports: [PoTooltipModule],
    exports: [PoTooltipModule]
  });
})();
function PoFieldContainerBottomComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵelement(1, "po-icon", 4);
    ɵɵelementStart(2, "span", 5);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵclassProp("po-field-error-limit", ctx_r0.errorLimit);
    ɵɵproperty("p-tooltip", ctx_r0.errorLimit ? ctx_r0.errorPattern : null)("p-append-in-body", ctx_r0.appendBox);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.errorPattern, " ");
  }
}
function PoFieldContainerBottomComponent_div_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.help, " ");
  }
}
function PoFieldContainerBottomComponent_div_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 9)(1, "po-icon", 10);
    ɵɵlistener("click", function PoFieldContainerBottomComponent_div_2_div_2_Template_po_icon_click_1_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.additionalHelp.emit());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassProp("po-clickable", !ctx_r0.additionalHelpTooltip);
    ɵɵproperty("p-append-in-body", ctx_r0.appendBox)("p-tooltip", ctx_r0.additionalHelpTooltip);
  }
}
function PoFieldContainerBottomComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, PoFieldContainerBottomComponent_div_2_span_1_Template, 2, 1, "span", 7)(2, PoFieldContainerBottomComponent_div_2_div_2_Template, 2, 4, "div", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.help);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showAdditionalHelpIcon);
  }
}
var PoFieldContainerBottomComponent = class _PoFieldContainerBottomComponent {
  poTooltip;
  /** Texto exibido no tooltip do ícone de ajuda adicional. */
  additionalHelpTooltip = "";
  /** Define se o tooltip será inserido no `body` em vez do componente. */
  appendBox = false;
  disabled = false;
  /**
   * Mensagem que será apresentada quando o pattern ou a máscara não for satisfeita.
   * Obs: Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja requerido.
   */
  errorPattern = "";
  /**
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   */
  errorLimit = false;
  help;
  /** Ativa a exibição da ajuda adicional. */
  showAdditionalHelp = false;
  /** Exibe o ícone de ajuda adicional. */
  showAdditionalHelpIcon = false;
  /** Evento disparado ao clicar no ícone de ajuda adicional. */
  additionalHelp = new EventEmitter();
  isInitialChange = true;
  ngOnChanges(changes) {
    if (changes.showAdditionalHelp) {
      if (!this.isInitialChange) {
        if (this.additionalHelpTooltip) {
          this.poTooltip.toggleTooltipVisibility(this.showAdditionalHelp);
        } else {
          this.additionalHelp.emit();
        }
      } else {
        this.isInitialChange = false;
      }
    }
  }
  static ɵfac = function PoFieldContainerBottomComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoFieldContainerBottomComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoFieldContainerBottomComponent,
    selectors: [["po-field-container-bottom"]],
    viewQuery: function PoFieldContainerBottomComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoTooltipDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poTooltip = _t.first);
      }
    },
    inputs: {
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      disabled: [0, "p-disabled", "disabled"],
      errorPattern: [0, "p-error-pattern", "errorPattern"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      help: [0, "p-help", "help"],
      showAdditionalHelp: [0, "p-show-additional-help", "showAdditionalHelp"],
      showAdditionalHelpIcon: [0, "p-show-additional-help-icon", "showAdditionalHelpIcon"]
    },
    outputs: {
      additionalHelp: "p-additional-help"
    },
    standalone: false,
    features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature],
    decls: 3,
    vars: 5,
    consts: [["role", "alert", "aria-live", "assertive", "tabindex", "-1", 1, "po-field-container-bottom"], ["class", "po-field-container-bottom-text-error", 4, "ngIf"], ["class", "po-field-container-bottom-help-text", 4, "ngIf"], [1, "po-field-container-bottom-text-error"], ["p-icon", "an an-warning-circle"], ["p-tooltip-position", "top", 1, "po-field-error-message", 3, "p-tooltip", "p-append-in-body"], [1, "po-field-container-bottom-help-text"], [4, "ngIf"], ["class", "po-icon-container", 4, "ngIf"], [1, "po-icon-container"], ["p-icon", "an an-fill an an-info", 1, "po-icon-additional-help", 3, "click", "p-append-in-body", "p-tooltip"]],
    template: function PoFieldContainerBottomComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoFieldContainerBottomComponent_div_1_Template, 4, 5, "div", 1)(2, PoFieldContainerBottomComponent_div_2_Template, 3, 2, "div", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("po-field-container-bottom-disabled", ctx.disabled);
        ɵɵattribute("aria-label", ctx.errorPattern && ctx.errorLimit ? ctx.errorPattern : null);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.errorPattern);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.errorPattern);
      }
    },
    dependencies: [NgIf, PoIconComponent, PoTooltipDirective],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldContainerBottomComponent, [{
    type: Component,
    args: [{
      selector: "po-field-container-bottom",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div\n  class="po-field-container-bottom"\n  [class.po-field-container-bottom-disabled]="disabled"\n  [attr.aria-label]="errorPattern && errorLimit ? errorPattern : null"\n  role="alert"\n  aria-live="assertive"\n  tabindex="-1"\n>\n  <div *ngIf="errorPattern" class="po-field-container-bottom-text-error">\n    <po-icon p-icon="an an-warning-circle"></po-icon>\n    <span\n      class="po-field-error-message"\n      [class.po-field-error-limit]="errorLimit"\n      [p-tooltip]="errorLimit ? errorPattern : null"\n      p-tooltip-position="top"\n      [p-append-in-body]="appendBox"\n    >\n      {{ errorPattern }}\n    </span>\n  </div>\n  <div *ngIf="!errorPattern" class="po-field-container-bottom-help-text">\n    <span *ngIf="help">\n      {{ help }}\n    </span>\n    <div *ngIf="showAdditionalHelpIcon" class="po-icon-container">\n      <po-icon\n        class="po-icon-additional-help"\n        [class.po-clickable]="!additionalHelpTooltip"\n        p-icon="an an-fill an an-info"\n        [p-append-in-body]="appendBox"\n        [p-tooltip]="additionalHelpTooltip"\n        (click)="additionalHelp.emit()"\n      ></po-icon>\n    </div>\n  </div>\n</div>\n'
    }]
  }], null, {
    poTooltip: [{
      type: ViewChild,
      args: [PoTooltipDirective]
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    errorPattern: [{
      type: Input,
      args: ["p-error-pattern"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    showAdditionalHelp: [{
      type: Input,
      args: ["p-show-additional-help"]
    }],
    showAdditionalHelpIcon: [{
      type: Input,
      args: ["p-show-additional-help-icon"]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoFieldContainerBottomComponent, {
    className: "PoFieldContainerBottomComponent",
    filePath: "lib/components/po-field/po-field-container/po-field-container-bottom/po-field-container-bottom.component.ts",
    lineNumber: 31
  });
})();
var poFieldContainerLiterals = {
  en: {
    optional: "Optional",
    required: "Required"
  },
  es: {
    optional: "Opcional",
    required: "Obligatorio"
  },
  pt: {
    optional: "Opcional",
    required: "Obrigatório"
  },
  ru: {
    optional: "Пожеланию",
    required: "Обязательный"
  }
};
var _c0$1G = ["*"];
function PoFieldContainerComponent_po_label_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-label", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r0.disabled)("p-for", ctx_r0.id)("p-label", ctx_r0.label)("p-requirement", ctx_r0.requirement);
  }
}
function PoFieldContainerComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.help);
  }
}
var PoFieldContainerComponent = class _PoFieldContainerComponent {
  /** Indica se o campo será desabilitado. */
  disabled;
  /** Identificador do campo */
  id;
  /** Label do campo. */
  label;
  /** Texto de apoio do campo. */
  help;
  literals;
  requirement;
  _optional = false;
  _required = false;
  /** Indica se o campo será opcional. */
  set optional(value) {
    this._optional = convertToBoolean(value);
  }
  get optional() {
    return this._optional;
  }
  /** Indica se o campo será obrigatório. */
  set required(value) {
    this._required = convertToBoolean(value);
  }
  get required() {
    return this._required;
  }
  /** Define se a indicação de campo obrigatório será exibida. */
  showRequired = false;
  constructor(languageService) {
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues({}, poFieldContainerLiterals[language]);
  }
  ngOnInit() {
    this.setRequirement();
  }
  ngOnChanges(changes) {
    if (changes.help || changes.label || changes.optional || changes.required || changes.showRequired) {
      this.setRequirement();
    }
  }
  setRequirement() {
    if (this.label || this.help) {
      if (!this.required && this.optional) {
        this.requirement = this.literals["optional"];
      } else if (this.required && this.showRequired) {
        this.requirement = this.literals["required"];
      } else {
        this.requirement = void 0;
      }
    }
  }
  static ɵfac = function PoFieldContainerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoFieldContainerComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoFieldContainerComponent,
    selectors: [["po-field-container"]],
    inputs: {
      disabled: [0, "p-disabled", "disabled"],
      id: [0, "p-id", "id"],
      label: [0, "p-label", "label"],
      help: [0, "p-help", "help"],
      optional: [0, "p-optional", "optional"],
      required: [0, "p-required", "required"],
      showRequired: [0, "p-show-required", "showRequired"]
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature],
    ngContentSelectors: _c0$1G,
    decls: 5,
    vars: 2,
    consts: [[1, "po-field-container"], [1, "po-field-container-title"], ["p-field", "true", 3, "p-disabled", "p-for", "p-label", "p-requirement", 4, "ngIf"], ["class", "po-field-help", 4, "ngIf"], ["p-field", "true", 3, "p-disabled", "p-for", "p-label", "p-requirement"], [1, "po-field-help"]],
    template: function PoFieldContainerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0)(1, "div", 1);
        ɵɵtemplate(2, PoFieldContainerComponent_po_label_2_Template, 1, 4, "po-label", 2);
        ɵɵelementEnd();
        ɵɵtemplate(3, PoFieldContainerComponent_div_3_Template, 2, 1, "div", 3);
        ɵɵprojection(4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.label || ctx.help);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.help);
      }
    },
    dependencies: [NgIf, PoLabelComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldContainerComponent, [{
    type: Component,
    args: [{
      selector: "po-field-container",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div class="po-field-container">\n  <div class="po-field-container-title">\n    <po-label\n      *ngIf="label || help"\n      [p-disabled]="disabled"\n      p-field="true"\n      [p-for]="id"\n      [p-label]="label"\n      [p-requirement]="requirement"\n    ></po-label>\n  </div>\n\n  <div class="po-field-help" *ngIf="help">{{ help }}</div>\n\n  <ng-content></ng-content>\n</div>\n'
    }]
  }], () => [{
    type: PoLanguageService
  }], {
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    id: [{
      type: Input,
      args: ["p-id"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    required: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoFieldContainerComponent, {
    className: "PoFieldContainerComponent",
    filePath: "lib/components/po-field/po-field-container/po-field-container.component.ts",
    lineNumber: 18
  });
})();
var _c0$1F = ["checkboxLabel"];
function PoCheckboxComponent_po_label_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-label", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r1.disabled)("p-for", ctx_r1.id)("p-label", ctx_r1.label);
  }
}
var PoCheckboxComponent = class _PoCheckboxComponent extends PoCheckboxBaseComponent {
  changeDetector;
  _iconToken;
  checkboxLabel;
  constructor(value, changeDetector) {
    super();
    this.changeDetector = changeDetector;
    this._iconToken = value ?? AnimaliaIconDictionary;
  }
  /**
   * Função que atribui foco ao *checkbox*.
   *
   * Para utilizá-la é necessário capturar a referência do componente no DOM através do `ViewChild`, como por exemplo:
   *
   * ```
   * ...
   * import { ViewChild } from '@angular/core';
   * import { PoCheckboxComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoCheckboxComponent, { static: true }) checkbox: PoCheckboxComponent;
   *
   * focusCheckbox() {
   *   this.checkbox.focus();
   * }
   * ```
   */
  focus() {
    if (this.checkboxLabel && !this.disabled) {
      this.checkboxLabel.nativeElement.focus();
    }
  }
  onBlur() {
    this.onTouched?.();
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
    this.blur.emit();
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  onKeyDown(event, value) {
    const isFieldFocused = document.activeElement === this.checkboxLabel.nativeElement;
    if (event.which === PoKeyCodeEnum.space || event.keyCode === PoKeyCodeEnum.space) {
      this.checkOption(value);
      event.preventDefault();
    }
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-checkbox
   *  #checkbox
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, checkbox)"
   * ></po-checkbox>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoCheckboxComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  changeModelValue(value) {
    if (value === null) {
      this.checkboxValue = "mixed";
    } else {
      this.checkboxValue = typeof value === "boolean" || value === null ? value : false;
    }
    this.changeDetector.detectChanges();
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  get iconNameLib() {
    return this._iconToken.NAME_LIB;
  }
  static ɵfac = function PoCheckboxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCheckboxComponent)(ɵɵdirectiveInject(ICONS_DICTIONARY, 8), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoCheckboxComponent,
    selectors: [["po-checkbox"]],
    viewQuery: function PoCheckboxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1F, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.checkboxLabel = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoCheckboxComponent),
      multi: true
    }]), ɵɵInheritDefinitionFeature],
    decls: 8,
    vars: 17,
    consts: [["checkboxLabel", ""], [3, "p-disabled"], [1, "po-field-container-content"], [1, "container-po-checkbox", 3, "click", "keydown"], ["role", "checkbox", 1, "po-checkbox-outline", 3, "blur", "tabindex"], ["aria-label", " ", 1, "po-checkbox", 3, "id", "ngClass"], ["class", "po-checkbox-label", "tabindex", "-1", 3, "p-disabled", "p-for", "p-label", 4, "ngIf"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-disabled", "p-help", "p-show-additional-help", "p-show-additional-help-icon"], ["tabindex", "-1", 1, "po-checkbox-label", 3, "p-disabled", "p-for", "p-label"]],
    template: function PoCheckboxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2)(2, "div", 3);
        ɵɵlistener("click", function PoCheckboxComponent_Template_div_click_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.checkOption(ctx.checkboxValue));
        })("keydown", function PoCheckboxComponent_Template_div_keydown_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event, ctx.checkboxValue));
        });
        ɵɵelementStart(3, "div", 4, 0);
        ɵɵlistener("blur", function PoCheckboxComponent_Template_div_blur_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        });
        ɵɵelement(5, "span", 5);
        ɵɵtemplate(6, PoCheckboxComponent_po_label_6_Template, 1, 3, "po-label", 6);
        ɵɵelementEnd()()();
        ɵɵelementStart(7, "po-field-container-bottom", 7);
        ɵɵlistener("p-additional-help", function PoCheckboxComponent_Template_po_field_container_bottom_p_additional_help_7_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.emitAdditionalHelp());
        });
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled);
        ɵɵadvance(2);
        ɵɵattribute("checked", ctx.checkboxValue);
        ɵɵadvance();
        ɵɵproperty("tabindex", ctx.disabled || ctx.disabladTabindex ? -1 : 0);
        ɵɵattribute("p-size", ctx.size)("aria-checked", ctx.checkboxValue);
        ɵɵadvance(2);
        ɵɵproperty("id", ctx.id)("ngClass", ctx.iconNameLib === "AnimaliaIcon" ? "po-checkbox-phosphor" : "po-checkbox-poicon");
        ɵɵattribute("aria-checked", ctx.checkboxValue)("aria-disabled", ctx.disabled)("required", ctx.checkBoxRequired);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.label);
        ɵɵadvance();
        ɵɵproperty("p-additional-help-tooltip", ctx.getAdditionalHelpTooltip())("p-append-in-body", ctx.appendBox)("p-disabled", ctx.disabled)("p-help", ctx.help)("p-show-additional-help", ctx.displayAdditionalHelp)("p-show-additional-help-icon", ctx.showAdditionalHelpIcon());
      }
    },
    dependencies: [NgClass, NgIf, PoLabelComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxComponent, [{
    type: Component,
    args: [{
      selector: "po-checkbox",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoCheckboxComponent),
        multi: true
      }],
      standalone: false,
      template: `<po-field-container [p-disabled]="disabled">
  <div class="po-field-container-content">
    <div
      class="container-po-checkbox"
      [attr.checked]="checkboxValue"
      (click)="checkOption(checkboxValue)"
      (keydown)="onKeyDown($event, checkboxValue)"
    >
      <div
        #checkboxLabel
        role="checkbox"
        class="po-checkbox-outline"
        [attr.p-size]="size"
        [tabindex]="disabled || disabladTabindex ? -1 : 0"
        [attr.aria-checked]="checkboxValue"
        (blur)="onBlur()"
      >
        <span
          [attr.aria-checked]="checkboxValue"
          aria-label=" "
          [id]="id"
          class="po-checkbox"
          [ngClass]="iconNameLib === 'AnimaliaIcon' ? 'po-checkbox-phosphor' : 'po-checkbox-poicon'"
          [attr.aria-disabled]="disabled"
          [attr.required]="checkBoxRequired"
        >
        </span>

        <po-label
          *ngIf="label"
          class="po-checkbox-label"
          tabindex="-1"
          [p-disabled]="disabled"
          [p-for]="id"
          [p-label]="label"
        >
        </po-label>
      </div>
    </div>
  </div>
  <po-field-container-bottom
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-disabled]="disabled"
    [p-help]="help"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ICONS_DICTIONARY]
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    checkboxLabel: [{
      type: ViewChild,
      args: ["checkboxLabel", {
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCheckboxComponent, {
    className: "PoCheckboxComponent",
    filePath: "lib/components/po-field/po-checkbox/po-checkbox.component.ts",
    lineNumber: 52
  });
})();
var _c0$1E = ["itemList"];
var _c1$G = (a0) => ({
  $implicit: a0
});
function PoItemListComponent_div_1_po_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("p-icon", ctx_r0.icon);
  }
}
function PoItemListComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5, 0);
    ɵɵtemplate(2, PoItemListComponent_div_1_po_icon_2_Template, 1, 1, "po-icon", 6);
    ɵɵelementStart(3, "span", 7);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-item-list__separator", ctx_r0.separator)("po-item-list__disabled", ctx_r0.disabled || !ctx_r0.visible)("po-item-list__selected", (ctx_r0.selected || ctx_r0.activeTabs) && !ctx_r0.disabled)("po-item-list__hidden", ctx_r0.tabHide)("po-item-list__danger", ctx_r0.danger);
    ɵɵattribute("aria-disabled", ctx_r0.disabled || !ctx_r0.visible)("aria-label", ctx_r0.label);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function PoItemListComponent_div_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("innerHTML", ctx_r0.getLabelFormatted(ctx_r0.label), ɵɵsanitizeHtml);
  }
}
function PoItemListComponent_div_2_ng_template_3_Template(rf, ctx) {
}
function PoItemListComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 9, 0);
    ɵɵlistener("click", function PoItemListComponent_div_2_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onComboItem(ctx_r0.item, $event));
    });
    ɵɵtemplate(2, PoItemListComponent_div_2_span_2_Template, 1, 1, "span", 10)(3, PoItemListComponent_div_2_ng_template_3_Template, 0, 0, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-item-list__separator", ctx_r0.separator)("po-item-list__selected", ctx_r0.selected && !ctx_r0.disabled);
    ɵɵattribute("aria-disabled", ctx_r0.disabled)("aria-label", ctx_r0.label);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.template);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template == null ? null : ctx_r0.template.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(9, _c1$G, ctx_r0.templateContext));
  }
}
function PoItemListComponent_div_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 16);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function PoItemListComponent_div_3_ng_template_3_Template(rf, ctx) {
}
function PoItemListComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13);
    ɵɵlistener("click", function PoItemListComponent_div_3_Template_div_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onCheckboxItem());
    })("keydown", function PoItemListComponent_div_3_Template_div_keydown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onCheckboxItemEmit($event));
    })("keyup", function PoItemListComponent_div_3_Template_div_keyup_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onCheckboxItemEmit($event));
    });
    ɵɵelement(1, "po-checkbox", 14);
    ɵɵtemplate(2, PoItemListComponent_div_3_span_2_Template, 2, 1, "span", 15)(3, PoItemListComponent_div_3_ng_template_3_Template, 0, 0, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-item-list__separator", ctx_r0.separator)("po-item-list__selected", ctx_r0.selected && !ctx_r0.disabled)("po-item-list__disabled", ctx_r0.disabled);
    ɵɵattribute("aria-disabled", ctx_r0.disabled)("aria-label", ctx_r0.label);
    ɵɵadvance();
    ɵɵproperty("p-disabled-tabindex", true)("p-checkboxValue", ctx_r0.checkboxValue === null ? "mixed" : ctx_r0.checkboxValue)("p-disabled", ctx_r0.disabled);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.template);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template == null ? null : ctx_r0.template.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(14, _c1$G, ctx_r0.templateContext));
  }
}
var PoItemListComponent = class _PoItemListComponent extends PoItemListBaseComponent {
  sanitized;
  itemList;
  selectedView;
  param;
  clickListener;
  constructor(sanitized) {
    super();
    this.sanitized = sanitized;
  }
  shouldUpdateSelected(changes) {
    return !!(changes.searchValue && changes.label && changes.searchValue.currentValue === changes.label.currentValue);
  }
  ngOnChanges(changes) {
    if (this.shouldUpdateSelected(changes)) {
      this.selected = true;
    }
    if (this.isTabs) {
      if (changes.tabHide?.currentValue || changes.disabled?.currentValue) {
        this.tabsItem.emit(this.item);
      } else if (changes.activeTabs?.currentValue) {
        this.emitActiveTabs(this.item);
      }
    }
  }
  onCheckboxItem() {
    const option = {
      [this.fieldValue]: this.value,
      [this.fieldLabel]: this.label
    };
    const selected = !this.checkboxValue;
    this.checkboxItem.emit({
      option,
      selected
    });
  }
  onComboItem(options, event) {
    const option = {
      [this.fieldValue]: this.value,
      [this.fieldLabel]: this.label
    };
    this.selectedView = options;
    this.comboItem.emit(__spreadProps(__spreadValues({}, option), {
      event
    }));
  }
  compareObjects(obj1, obj2) {
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  }
  onCheckboxItemEmit(event) {
    if (event && event.code === "Enter" || event.code === "Space") {
      this.onCheckboxItem();
    }
  }
  getLabelFormatted(label) {
    const sanitizedLabel = this.sanitizeTagHTML(label);
    let format = sanitizedLabel;
    if (this.isFiltering || this.validateForOptionsLabel()) {
      const labelInput = this.sanitizeTagHTML(this.searchValue.toString().toLowerCase());
      const labelLowerCase = sanitizedLabel.toLowerCase();
      const openTagBold = '<span class="po-font-text-large-bold">';
      const closeTagBold = "</span>";
      let startString;
      let middleString;
      let endString;
      switch (this.filterMode) {
        case PoItemListFilterMode.startsWith:
        case PoItemListFilterMode.contains:
          const indexOfLabelInput = labelLowerCase.indexOf(labelInput);
          if (indexOfLabelInput > -1) {
            startString = sanitizedLabel.substring(0, indexOfLabelInput);
            middleString = sanitizedLabel.substring(indexOfLabelInput, indexOfLabelInput + labelInput.length);
            endString = sanitizedLabel.substring(indexOfLabelInput + labelInput.length);
            format = startString + openTagBold + middleString + closeTagBold + endString;
          }
          break;
        case PoItemListFilterMode.endsWith:
          const lastIndexOfLabelInput = labelLowerCase.lastIndexOf(labelInput);
          if (lastIndexOfLabelInput > -1) {
            startString = sanitizedLabel.substring(0, lastIndexOfLabelInput);
            middleString = sanitizedLabel.substring(lastIndexOfLabelInput);
            format = startString + openTagBold + middleString + closeTagBold;
          }
          break;
      }
    }
    return this.safeHtml(format);
  }
  validateForOptionsLabel() {
    return this.comboService && this.searchValue && !this.compareCache && this.shouldMarkLetters;
  }
  safeHtml(value) {
    return this.sanitized.bypassSecurityTrustHtml(value);
  }
  sanitizeTagHTML(value = "") {
    return value.replace(/\</gm, "&lt;").replace(/\>/g, "&gt;");
  }
  static ɵfac = function PoItemListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoItemListComponent)(ɵɵdirectiveInject(DomSanitizer));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoItemListComponent,
    selectors: [["po-item-list"]],
    viewQuery: function PoItemListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1E, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemList = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 4,
    vars: 3,
    consts: [["itemList", ""], [3, "keydown", "ngSwitch"], ["class", "po-item-list po-item-list__action", 3, "po-item-list__separator", "po-item-list__disabled", "po-item-list__selected", "po-item-list__hidden", "po-item-list__danger", 4, "ngSwitchDefault"], ["class", "po-item-list po-item-list__option", 3, "po-item-list__separator", "po-item-list__selected", "click", 4, "ngSwitchCase"], ["class", "po-item-list po-item-list__check", 3, "po-item-list__separator", "po-item-list__selected", "po-item-list__disabled", "click", "keydown", "keyup", 4, "ngSwitchCase"], [1, "po-item-list", "po-item-list__action"], ["class", "po-popup-icon-item", 3, "p-icon", 4, "ngIf"], [1, "po-item-list-label"], [1, "po-popup-icon-item", 3, "p-icon"], [1, "po-item-list", "po-item-list__option", 3, "click"], ["class", "po-item-list-label", 3, "innerHTML", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "po-item-list-label", 3, "innerHTML"], [1, "po-item-list", "po-item-list__check", 3, "click", "keydown", "keyup"], [3, "p-disabled-tabindex", "p-checkboxValue", "p-disabled"], ["class", "po-item-list__label", 4, "ngIf"], [1, "po-item-list__label"]],
    template: function PoItemListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0, 1);
        ɵɵlistener("keydown", function PoItemListComponent_Template_ng_container_keydown_0_listener($event) {
          return ctx.onCheckboxItemEmit($event);
        });
        ɵɵtemplate(1, PoItemListComponent_div_1_Template, 5, 14, "div", 2)(2, PoItemListComponent_div_2_Template, 4, 11, "div", 3)(3, PoItemListComponent_div_3_Template, 4, 16, "div", 4);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngSwitch", ctx.type);
        ɵɵadvance(2);
        ɵɵproperty("ngSwitchCase", "option");
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", "check");
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgSwitchDefault, PoCheckboxComponent, PoIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoItemListComponent, [{
    type: Component,
    args: [{
      selector: "po-item-list",
      standalone: false,
      template: `<ng-container [ngSwitch]="type" (keydown)="onCheckboxItemEmit($event)">
  <div
    *ngSwitchDefault
    #itemList
    [class.po-item-list__separator]="separator"
    [class.po-item-list__disabled]="disabled || !visible"
    [class.po-item-list__selected]="(selected || activeTabs) && !disabled"
    [class.po-item-list__hidden]="tabHide"
    [attr.aria-disabled]="disabled || !visible"
    [attr.aria-label]="label"
    [class.po-item-list__danger]="danger"
    class="po-item-list po-item-list__action"
  >
    <po-icon *ngIf="icon" class="po-popup-icon-item" [p-icon]="icon"></po-icon>
    <span class="po-item-list-label">{{ label }}</span>
  </div>

  <div
    *ngSwitchCase="'option'"
    #itemList
    class="po-item-list po-item-list__option"
    [class.po-item-list__separator]="separator"
    [class.po-item-list__selected]="selected && !disabled"
    [attr.aria-disabled]="disabled"
    [attr.aria-label]="label"
    (click)="onComboItem(item, $event)"
  >
    <span *ngIf="!template" class="po-item-list-label" [innerHTML]="getLabelFormatted(label)"></span>

    <ng-template [ngTemplateOutlet]="template?.templateRef" [ngTemplateOutletContext]="{ $implicit: templateContext }">
    </ng-template>
  </div>

  <div
    *ngSwitchCase="'check'"
    class="po-item-list po-item-list__check"
    [class.po-item-list__separator]="separator"
    [class.po-item-list__selected]="selected && !disabled"
    [class.po-item-list__disabled]="disabled"
    [attr.aria-disabled]="disabled"
    [attr.aria-label]="label"
    (click)="onCheckboxItem()"
    (keydown)="onCheckboxItemEmit($event)"
    (keyup)="onCheckboxItemEmit($event)"
  >
    <po-checkbox
      [p-disabled-tabindex]="true"
      [p-checkboxValue]="checkboxValue === null ? 'mixed' : checkboxValue"
      [p-disabled]="disabled"
    ></po-checkbox>

    <span class="po-item-list__label" *ngIf="!template">{{ label }}</span>

    <ng-template [ngTemplateOutlet]="template?.templateRef" [ngTemplateOutletContext]="{ $implicit: templateContext }">
    </ng-template>
  </div>
</ng-container>
`
    }]
  }], () => [{
    type: DomSanitizer
  }], {
    itemList: [{
      type: ViewChild,
      args: ["itemList", {
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoItemListComponent, {
    className: "PoItemListComponent",
    filePath: "lib/components/po-listbox/po-item-list/po-item-list.component.ts",
    lineNumber: 14
  });
})();
var _c0$1D = ["inputElement"];
var PoSearchListComponent = class _PoSearchListComponent {
  cd;
  inputElement;
  /** Propriedade que recebe as literais definidas no `po-listbox`. */
  literals;
  fieldValue;
  /** Evento que será disparado a cada tecla digitada no campo de busca. */
  change = new EventEmitter();
  _placeholder;
  constructor(cd) {
    this.cd = cd;
  }
  /**
   * @optional
   *
   * @description
   *
   * Placeholder do campo de pesquisa.
   *
   * > Caso o mesmo não seja informado, o valor padrão será traduzido com base no idioma do navegador (pt, es e en).
   *
   * @default `Buscar`
   */
  set placeholder(placeholder) {
    this._placeholder = placeholder && this.isTypeof(placeholder, "string") ? placeholder : this.literals.placeholderSearch;
  }
  get placeholder() {
    return this._placeholder || this.literals.placeholderSearch;
  }
  get inputValue() {
    return this.inputElement.nativeElement.value;
  }
  onChange(event) {
    this.change.emit({
      event,
      [this.fieldValue]: this.inputElement.nativeElement.value
    });
  }
  setFocus() {
    this.inputElement.nativeElement.focus();
  }
  clean() {
    this.inputElement.nativeElement.value = "";
    this.cd.markForCheck();
  }
  isTypeof(object, type) {
    return typeof object === type;
  }
  static ɵfac = function PoSearchListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSearchListComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoSearchListComponent,
    selectors: [["po-search-list"]],
    viewQuery: function PoSearchListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1D, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputElement = _t.first);
      }
    },
    inputs: {
      literals: [0, "p-literals", "literals"],
      fieldValue: [0, "p-field-value", "fieldValue"],
      placeholder: [0, "p-placeholder", "placeholder"]
    },
    outputs: {
      change: "p-change"
    },
    standalone: false,
    decls: 5,
    vars: 1,
    consts: [["inputElement", ""], [1, "po-field-container-content", "po-listbox-container-search"], [1, "po-field-icon-container-left"], ["p-icon", "ICON_SEARCH", 1, "po-field-icon", "po-icon-input"], ["type", "text", 1, "po-input", "po-input-icon-left", "po-listbox-search-input", 3, "keyup", "placeholder"]],
    template: function PoSearchListComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 1)(1, "div", 2);
        ɵɵelement(2, "po-icon", 3);
        ɵɵelementEnd();
        ɵɵelementStart(3, "input", 4, 0);
        ɵɵlistener("keyup", function PoSearchListComponent_Template_input_keyup_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onChange($event));
        });
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("placeholder", ctx.placeholder);
      }
    },
    dependencies: [PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSearchListComponent, [{
    type: Component,
    args: [{
      selector: "po-search-list",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div class="po-field-container-content po-listbox-container-search">\n  <div class="po-field-icon-container-left">\n    <po-icon p-icon="ICON_SEARCH" class="po-field-icon po-icon-input"></po-icon>\n  </div>\n\n  <input\n    #inputElement\n    class="po-input po-input-icon-left po-listbox-search-input"\n    type="text"\n    [placeholder]="placeholder"\n    (keyup)="onChange($event)"\n  />\n</div>\n'
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    inputElement: [{
      type: ViewChild,
      args: ["inputElement", {
        read: ElementRef,
        static: true
      }]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    fieldValue: [{
      type: Input,
      args: ["p-field-value"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    placeholder: [{
      type: Input,
      args: ["p-placeholder"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSearchListComponent, {
    className: "PoSearchListComponent",
    filePath: "lib/components/po-listbox/po-search-list/po-search-list.component.ts",
    lineNumber: 26
  });
})();
var _c0$1C = ["listbox"];
var _c1$F = ["listboxItemList"];
var _c2$k = ["searchElement"];
var _c3$g = [[["", "p-popup-header-template", ""]]];
var _c4$5 = ["[p-popup-header-template]"];
function PoListBoxComponent_po_search_list_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-search-list", 8, 2);
    ɵɵlistener("p-change", function PoListBoxComponent_po_search_list_3_Template_po_search_list_p_change_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.callChangeSearch($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-literals", ctx_r1.literalSearch)("p-field-value", ctx_r1.fieldValueSearch)("p-placeholder", ctx_r1.placeholderSearch);
  }
}
function PoListBoxComponent_ng_container_4_li_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 12);
    ɵɵlistener("click", function PoListBoxComponent_ng_container_4_li_3_Template_li_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.changeAll.emit());
    })("keydown", function PoListBoxComponent_ng_container_4_li_3_Template_li_keydown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.changeAllEmit($event));
    })("keydown", function PoListBoxComponent_ng_container_4_li_3_Template_li_keydown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelectAllCheckboxKeyDown($event));
    });
    ɵɵelement(1, "po-item-list", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵattribute("aria-checked", ctx_r1.checkboxAllValue === null ? "mixed" : ctx_r1.checkboxAllValue);
    ɵɵadvance();
    ɵɵproperty("p-selected", ctx_r1.checkboxAllValue)("p-label", ctx_r1.literals.selectAll)("p-checkbox-value", ctx_r1.checkboxAllValue);
  }
}
function PoListBoxComponent_ng_container_4_li_4_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r5 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r5.label, " ");
  }
}
function PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-item-list", 18);
    ɵɵlistener("p-selectcheckbox-item", function PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template_po_item_list_p_selectcheckbox_item_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.checkboxClicked($event));
    })("p-selectcombo-item", function PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template_po_item_list_p_selectcombo_item_0_listener() {
      ɵɵrestoreView(_r6);
      const item_r5 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.optionClicked(item_r5));
    })("p-emit-item-tabs", function PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template_po_item_list_p_emit_item_tabs_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onSelectTabs($event));
    })("p-activated-tabs", function PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template_po_item_list_p_activated_tabs_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onActivatedTabs($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r5 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-disabled", ctx_r1.returnBooleanValue(item_r5, "disabled"))("p-visible", ctx_r1.returnBooleanValue(item_r5, "visible"))("p-checkbox-value", ctx_r1.isSelectedItem(item_r5))("p-label", item_r5[ctx_r1.fieldLabel])("p-value", item_r5[ctx_r1.fieldValue])("p-selected", ctx_r1.isSelectedItem(item_r5) || item_r5.selected)("p-active-tabs", item_r5.active)("p-separator", item_r5.separator)("p-danger", item_r5.danger || item_r5.type === "danger")("p-icon", item_r5.icon)("p-type", ctx_r1.type)("p-item", item_r5)("p-tab-hide", item_r5.hide)("p-is-tabs", ctx_r1.isTabs)("p-field-value", ctx_r1.fieldValue)("p-field-label", ctx_r1.fieldLabel)("p-template", ctx_r1.template)("p-template-context", item_r5)("p-search-value", ctx_r1.searchValue)("p-filter-mode", ctx_r1.filterMode)("p-filtering", ctx_r1.isFiltering)("p-should-mark-letter", ctx_r1.shouldMarkLetters)("p-compare-cache", ctx_r1.compareCache)("p-combo-service", ctx_r1.comboService);
    ɵɵattribute("data-item-list", ctx_r1.formatItemList(item_r5));
  }
}
function PoListBoxComponent_ng_container_4_li_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 14);
    ɵɵlistener("click", function PoListBoxComponent_ng_container_4_li_4_Template_li_click_0_listener() {
      const item_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelectItem(item_r5));
    })("keydown", function PoListBoxComponent_ng_container_4_li_4_Template_li_keydown_0_listener($event) {
      const item_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onKeyDown(item_r5, $event));
    });
    ɵɵtemplate(1, PoListBoxComponent_ng_container_4_li_4_label_1_Template, 2, 1, "label", 15)(2, PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template, 1, 25, "po-item-list", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("po-listbox-item", ctx_r1.visible);
    ɵɵproperty("cdkOption", item_r5[ctx_r1.fieldLabel])("cdkOptionDisabled", ctx_r1.returnBooleanValue(item_r5, "disabled") || ctx_r1.returnBooleanValue(item_r5, "visible") === false || item_r5.options);
    ɵɵattribute("aria-selected", ctx_r1.isSelectedItem(item_r5) || item_r5.selected);
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r5.options);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.returnBooleanValue(item_r5, "visible") !== false && !item_r5.options);
  }
}
function PoListBoxComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "ul", 9, 3);
    ɵɵtemplate(3, PoListBoxComponent_ng_container_4_li_3_Template, 2, 4, "li", 10)(4, PoListBoxComponent_ng_container_4_li_4_Template, 3, 7, "li", 11);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("cdkListboxMultiple", ctx_r1.type === "check");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.type === "check" && ctx_r1.items.length && !(ctx_r1.searchElement == null ? null : ctx_r1.searchElement.inputValue) && !ctx_r1.hideSelectAll);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.items);
  }
}
function PoListBoxComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵelement(1, "po-loading-overlay", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-listbox-container-loading-default", !ctx_r1.infiniteLoading);
    ɵɵadvance();
    ɵɵproperty("p-size", ctx_r1.getSizeLoading())("p-text", ctx_r1.getTextLoading());
  }
}
function PoListBoxComponent_ng_template_6_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21)(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.literals.noItems, "");
  }
}
function PoListBoxComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoListBoxComponent_ng_template_6_div_0_Template, 3, 1, "div", 20);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", !ctx_r1.items.length && !ctx_r1.isServerSearching && ctx_r1.type !== "action");
  }
}
var PoListBoxComponent = class _PoListBoxComponent extends PoListBoxBaseComponent {
  element;
  renderer;
  router;
  changeDetector;
  listbox;
  listboxItemList;
  searchElement;
  scrollEvent$;
  subscriptionScrollEvent;
  constructor(element, renderer, languageService, router, changeDetector) {
    super(languageService);
    this.element = element;
    this.renderer = renderer;
    this.router = router;
    this.changeDetector = changeDetector;
  }
  ngAfterViewInit() {
    this.setListBoxMaxHeight();
    this.listboxItemList?.nativeElement.focus();
    this.changeDetector.detectChanges();
  }
  ngOnChanges(changes) {
    if (changes?.items) {
      this.setListBoxMaxHeight();
    }
    if (this.visible && this.infiniteScroll) {
      this.checkInfiniteScroll();
    }
  }
  ngOnDestroy() {
    if (this.subscriptionScrollEvent && this.subscriptionScrollEvent.unsubscribe) {
      this.subscriptionScrollEvent.unsubscribe();
    }
  }
  onSelectItem(itemListAction) {
    const isDisabled = itemListAction.hasOwnProperty("disabled") && itemListAction.disabled !== null && itemListAction.disabled !== void 0 ? this.returnBooleanValue(itemListAction, "disabled") : false;
    const isVisible = itemListAction.hasOwnProperty("visible") && itemListAction.visible !== null && itemListAction.visible !== void 0 ? this.returnBooleanValue(itemListAction, "visible") : true;
    if (this.isTabs && !itemListAction.disabled && !itemListAction.hide) {
      this.onClickTabs(itemListAction);
    }
    if (itemListAction && itemListAction.action && !isDisabled && isVisible) {
      itemListAction.action(this.param || itemListAction);
    }
    if (itemListAction && itemListAction.url && !isDisabled && isVisible) {
      return this.openUrl(itemListAction.url);
    }
  }
  onSelectAllCheckboxKeyDown(event) {
    if (event.code === "Tab") {
      this.closeEvent.emit();
    }
  }
  onKeyDown(itemListAction, event) {
    event.preventDefault();
    if (event && event.code === "Enter" || event.code === "Space") {
      switch (this.type) {
        case "check":
          this.onSelectCheckBoxItem(itemListAction);
          break;
        case "option":
          this.optionClicked(itemListAction);
          break;
        case "action":
          this.onSelectItem(itemListAction);
          break;
      }
    }
    if (event && event.code === "Escape" || event.code === "Tab") {
      this.closeEvent.emit();
    }
  }
  checkboxClicked({
    option,
    selected
  }) {
    if (this.type === "check") {
      this.change.emit({
        selected,
        option
      });
    }
  }
  optionClicked(option) {
    if (this.type === "option") {
      this.items.filter((item) => item[this.fieldValue] === option[this.fieldValue] ? item["selected"] = true : item["selected"] = false);
      this.selectCombo.emit(__spreadValues({}, option));
    }
  }
  onSelectCheckBoxItem(option) {
    const selected = !this.isSelectedItem(option);
    this.checkboxClicked({
      option,
      selected
    });
  }
  isSelectedItem(option) {
    return this.selectedOptions.some((selectedItem) => selectedItem[this.fieldValue] === option[this.fieldValue]);
  }
  changeAllEmit(event) {
    if (event && event.code === "Enter" || event.code === "Space") {
      this.changeAll.emit();
    }
  }
  onSelectTabs(tab) {
    if (this.isTabs && tab) {
      this.changeStateTabs.emit(tab);
    }
  }
  onActivatedTabs(tab) {
    this.activatedTab.emit(tab);
  }
  callChangeSearch(event) {
    this.changeSearch.emit(event);
  }
  showMoreInfiniteScroll({
    target
  }) {
    const scrollPosition = target.offsetHeight + target.scrollTop;
    if (scrollPosition >= target.scrollHeight * (this.infiniteScrollDistance / 110)) {
      this.UpdateInfiniteScroll.emit();
    }
  }
  scrollListener(componentListner) {
    return fromEvent(componentListner, "scroll").pipe(debounceTime(100));
  }
  setFocus() {
    this.listboxItemList.nativeElement.focus();
  }
  checkInfiniteScroll() {
    if (this.hasInfiniteScroll()) {
      this.includeInfiniteScroll();
    }
  }
  getSizeLoading() {
    const width = this.listbox.nativeElement.offsetWidth || this.containerWidth;
    if (width > 180) {
      return "md";
    } else if (width >= 140) {
      return "sm";
    } else {
      return "xs";
    }
  }
  getTextLoading() {
    const width = this.listbox.nativeElement.offsetWidth || this.containerWidth;
    return width < 140 ? " " : "";
  }
  hasInfiniteScroll() {
    this.changeDetector.detectChanges();
    return this.infiniteScroll && this.listboxItemList?.nativeElement.scrollHeight;
  }
  checkTemplate() {
    if (this.cache || this.infiniteScroll) {
      return this.items.length;
    } else {
      return !this.isServerSearching && this.items.length;
    }
  }
  includeInfiniteScroll() {
    this.scrollEvent$ = this.scrollListener(this.listboxItemList?.nativeElement);
    this.subscriptionScrollEvent = this.scrollEvent$.subscribe((event) => {
      this.showMoreInfiniteScroll(event);
    });
  }
  returnBooleanValue(itemListAction, property) {
    return isTypeof(itemListAction[property], "function") ? itemListAction[property](this.param || itemListAction) : itemListAction[property];
  }
  setListBoxMaxHeight() {
    const itemsLength = this.items.length;
    if (itemsLength > 6) {
      if (this.type === "check" && !this.hideSearch) {
        this.renderer.setStyle(this.listbox.nativeElement, "maxHeight", `${44 * 6 - 44 / 3 + 60}px`);
      } else {
        this.renderer.setStyle(this.listbox.nativeElement, "maxHeight", `${44 * 6 - 44 / 3}px`);
      }
    }
  }
  openUrl(url) {
    if (isExternalLink(url)) {
      return openExternalLink(url);
    }
    if (url) {
      return this.router.navigate([url]);
    }
  }
  onClickTabs(tab) {
    if (!tab.disabled) {
      this.clickTab.emit(tab);
    }
  }
  formatItemList(item) {
    if (this.isTabs) {
      return item.id;
    } else {
      try {
        return JSON.stringify(item);
      } catch (error) {
        return item;
      }
    }
  }
  static ɵfac = function PoListBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoListBoxComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoListBoxComponent,
    selectors: [["po-listbox"]],
    viewQuery: function PoListBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1C, 7);
        ɵɵviewQuery(_c1$F, 5);
        ɵɵviewQuery(_c2$k, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listbox = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listboxItemList = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchElement = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    ngContentSelectors: _c4$5,
    decls: 8,
    vars: 8,
    consts: [["listbox", ""], ["noDataTemplate", ""], ["searchElement", ""], ["listboxItemList", ""], [1, "po-listbox", 3, "hidden"], [3, "p-literals", "p-field-value", "p-placeholder", "p-change", 4, "ngIf"], [4, "ngIf", "ngIfElse"], [3, "po-listbox-container-loading-default", 4, "ngIf"], [3, "p-change", "p-literals", "p-field-value", "p-placeholder"], ["cdkListbox", "", 1, "po-listbox-list", 3, "cdkListboxMultiple"], ["cdkOption", "selectAll", 3, "click", "keydown", 4, "ngIf"], [3, "po-listbox-item", "cdkOption", "cdkOptionDisabled", "click", "keydown", 4, "ngFor", "ngForOf"], ["cdkOption", "selectAll", 3, "click", "keydown"], ["p-type", "check", "p-value", "selectAll", 3, "p-selected", "p-label", "p-checkbox-value"], [3, "click", "keydown", "cdkOption", "cdkOptionDisabled"], ["class", "po-combo-item-title", 4, "ngIf"], [3, "p-disabled", "p-visible", "p-checkbox-value", "p-label", "p-value", "p-selected", "p-active-tabs", "p-separator", "p-danger", "p-icon", "p-type", "p-item", "p-tab-hide", "p-is-tabs", "p-field-value", "p-field-label", "p-template", "p-template-context", "p-search-value", "p-filter-mode", "p-filtering", "p-should-mark-letter", "p-compare-cache", "p-combo-service", "p-selectcheckbox-item", "p-selectcombo-item", "p-emit-item-tabs", "p-activated-tabs", 4, "ngIf"], [1, "po-combo-item-title"], [3, "p-selectcheckbox-item", "p-selectcombo-item", "p-emit-item-tabs", "p-activated-tabs", "p-disabled", "p-visible", "p-checkbox-value", "p-label", "p-value", "p-selected", "p-active-tabs", "p-separator", "p-danger", "p-icon", "p-type", "p-item", "p-tab-hide", "p-is-tabs", "p-field-value", "p-field-label", "p-template", "p-template-context", "p-search-value", "p-filter-mode", "p-filtering", "p-should-mark-letter", "p-compare-cache", "p-combo-service"], [3, "p-size", "p-text"], ["class", "po-listbox-container-no-data po-text-center", 4, "ngIf"], [1, "po-listbox-container-no-data", "po-text-center"]],
    template: function PoListBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c3$g);
        ɵɵelementStart(0, "div", 4, 0);
        ɵɵprojection(2);
        ɵɵtemplate(3, PoListBoxComponent_po_search_list_3_Template, 2, 3, "po-search-list", 5)(4, PoListBoxComponent_ng_container_4_Template, 5, 3, "ng-container", 6)(5, PoListBoxComponent_div_5_Template, 2, 4, "div", 7)(6, PoListBoxComponent_ng_template_6_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        const noDataTemplate_r7 = ɵɵreference(7);
        ɵɵclassProp("po-listbox-check", ctx.type === "check" || ctx.type === "option");
        ɵɵproperty("hidden", ctx.visible);
        ɵɵattribute("data-type", ctx.type);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", !ctx.hideSearch && ctx.type === "check");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.checkTemplate())("ngIfElse", noDataTemplate_r7);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isServerSearching && ctx.type !== "action");
      }
    },
    dependencies: [NgForOf, NgIf, PoLoadingOverlayComponent, CdkListbox, CdkOption, PoItemListComponent, PoSearchListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListBoxComponent, [{
    type: Component,
    args: [{
      selector: "po-listbox",
      standalone: false,
      template: `<div
  #listbox
  class="po-listbox"
  [class.po-listbox-check]="type === 'check' || type === 'option'"
  [attr.data-type]="type"
  [hidden]="visible"
>
  <ng-content select="[p-popup-header-template]"></ng-content>

  <po-search-list
    #searchElement
    *ngIf="!hideSearch && type === 'check'"
    (p-change)="callChangeSearch($event)"
    [p-literals]="literalSearch"
    [p-field-value]="fieldValueSearch"
    [p-placeholder]="placeholderSearch"
  ></po-search-list>

  <ng-container *ngIf="checkTemplate(); else noDataTemplate">
    <ul #listboxItemList cdkListbox [cdkListboxMultiple]="type === 'check'" class="po-listbox-list">
      <li
        cdkOption="selectAll"
        *ngIf="type === 'check' && items.length && !searchElement?.inputValue && !hideSelectAll"
        [attr.aria-checked]="checkboxAllValue === null ? 'mixed' : checkboxAllValue"
        (click)="changeAll.emit()"
        (keydown)="changeAllEmit($event)"
        (keydown)="onSelectAllCheckboxKeyDown($event)"
      >
        <po-item-list
          [p-selected]="checkboxAllValue"
          p-type="check"
          [p-label]="literals.selectAll"
          p-value="selectAll"
          [p-checkbox-value]="checkboxAllValue"
        >
        </po-item-list>
      </li>
      <li
        [class.po-listbox-item]="visible"
        *ngFor="let item of items"
        [cdkOption]="item[fieldLabel]"
        [cdkOptionDisabled]="
          returnBooleanValue(item, 'disabled') || returnBooleanValue(item, 'visible') === false || item.options
        "
        [attr.aria-selected]="isSelectedItem(item) || item.selected"
        (click)="onSelectItem(item)"
        (keydown)="onKeyDown(item, $event)"
      >
        <label *ngIf="item.options" class="po-combo-item-title">
          {{ item.label }}
        </label>
        <po-item-list
          *ngIf="returnBooleanValue(item, 'visible') !== false && !item.options"
          [p-disabled]="returnBooleanValue(item, 'disabled')"
          [p-visible]="returnBooleanValue(item, 'visible')"
          [p-checkbox-value]="isSelectedItem(item)"
          [attr.data-item-list]="formatItemList(item)"
          [p-label]="item[fieldLabel]"
          [p-value]="item[fieldValue]"
          [p-selected]="isSelectedItem(item) || item.selected"
          [p-active-tabs]="item.active"
          [p-separator]="item.separator"
          [p-danger]="item.danger || item.type === 'danger'"
          [p-icon]="item.icon"
          [p-type]="type"
          [p-item]="item"
          [p-tab-hide]="item.hide"
          [p-is-tabs]="isTabs"
          [p-field-value]="fieldValue"
          [p-field-label]="fieldLabel"
          [p-template]="template"
          [p-template-context]="item"
          (p-selectcheckbox-item)="checkboxClicked($event)"
          (p-selectcombo-item)="optionClicked(item)"
          (p-emit-item-tabs)="onSelectTabs($event)"
          (p-activated-tabs)="onActivatedTabs($event)"
          [p-search-value]="searchValue"
          [p-filter-mode]="filterMode"
          [p-filtering]="isFiltering"
          [p-should-mark-letter]="shouldMarkLetters"
          [p-compare-cache]="compareCache"
          [p-combo-service]="comboService"
        ></po-item-list>
      </li>
    </ul>
  </ng-container>

  <div *ngIf="isServerSearching && type !== 'action'" [class.po-listbox-container-loading-default]="!infiniteLoading">
    <po-loading-overlay [p-size]="getSizeLoading()" [p-text]="getTextLoading()"></po-loading-overlay>
  </div>

  <ng-template #noDataTemplate>
    <div
      *ngIf="!items.length && !isServerSearching && type !== 'action'"
      class="po-listbox-container-no-data po-text-center"
    >
      <span> {{ literals.noItems }}</span>
    </div>
  </ng-template>
</div>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: PoLanguageService
  }, {
    type: Router
  }, {
    type: ChangeDetectorRef
  }], {
    listbox: [{
      type: ViewChild,
      args: ["listbox", {
        static: true
      }]
    }],
    listboxItemList: [{
      type: ViewChild,
      args: ["listboxItemList", {
        static: false
      }]
    }],
    searchElement: [{
      type: ViewChild,
      args: ["searchElement"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoListBoxComponent, {
    className: "PoListBoxComponent",
    filePath: "lib/components/po-listbox/po-listbox.component.ts",
    lineNumber: 28
  });
})();
var _c0$1B = ["popupRef"];
var _c1$E = ["listbox"];
var _c2$j = ["poListBoxRef"];
var _c3$f = [[["", "p-popup-header-template", ""]]];
var _c4$4 = ["[p-popup-header-template]"];
function PoPopupComponent_div_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMapInterpolate1("po-popup-arrow po-arrow-", ctx_r1.arrowDirection, "");
  }
}
function PoPopupComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3, 0);
    ɵɵtemplate(2, PoPopupComponent_div_0_div_2_Template, 1, 3, "div", 4);
    ɵɵelementStart(3, "div", 5)(4, "po-listbox", 6, 1);
    ɵɵlistener("p-close", function PoPopupComponent_div_0_Template_po_listbox_p_close_4_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelementStart(7, "div", 7);
    ɵɵprojection(8);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r1.hideArrow);
    ɵɵadvance(2);
    ɵɵproperty("p-items", ctx_r1.actions)("p-param", ctx_r1.param);
  }
}
var PoPopupComponent = class _PoPopupComponent extends PoPopupBaseComponent {
  renderer;
  router;
  poControlPosition;
  changeDetector;
  popupRef;
  listbox;
  //utilizado apenas no theme builder
  poListBoxRef;
  constructor(viewContainerRef, renderer, router, poControlPosition, changeDetector) {
    super();
    this.renderer = renderer;
    this.router = router;
    this.poControlPosition = poControlPosition;
    this.changeDetector = changeDetector;
  }
  /**
   * Fecha o componente *popup*.
   *
   * > Por padrão, este comportamento é acionado somente ao clicar fora do componente ou em determinada ação / url.
   */
  close() {
    this.removeListeners();
    this.showPopup = false;
    this.closeEvent.emit();
  }
  onActionClick(popupAction) {
    const actionNoDisabled = popupAction && !this.returnBooleanValue(popupAction, "disabled");
    if (popupAction && popupAction.action && actionNoDisabled) {
      this.close();
      popupAction.action(this.param || popupAction);
    }
    if (popupAction && popupAction.url && actionNoDisabled) {
      this.close();
      return this.openUrl(popupAction.url);
    }
  }
  /**
   * Abre o componente *popup*.
   *
   * > É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
   */
  open(param) {
    this.oldTarget = this.target;
    this.param = param;
    this.showPopup = true;
    this.changeDetector.detectChanges();
    this.validateInitialContent();
  }
  returnBooleanValue(popupAction, property) {
    return isTypeof(popupAction[property], "function") ? popupAction[property](this.param || popupAction) : popupAction[property];
  }
  /**
   * Responsável por abrir e fechar o *popup*.
   *
   * Quando disparado abrirá o *popup* e caso o mesmo já estiver aberto e possuir o mesmo `target` irá fecha-lo.
   *
   * É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
   */
  toggle(param) {
    this.showPopup && this.oldTarget === this.target ? this.close() : this.open(param);
  }
  checkAllActionIsInvisible() {
    if (this.actions.every((item) => item.visible === false)) {
      return true;
    }
    return false;
  }
  clickedOutDisabledItem(event) {
    const containsItemDisabled = this.elementContains(event.target, "po-popup-item-disabled") || this.elementContains(event.target.parentElement, "po-popup-item-disabled");
    return !containsItemDisabled;
  }
  clickedOutHeaderTemplate(event) {
    const popupHeaderTemplate = this.popupRef && this.popupRef.nativeElement.querySelector("[p-popup-header-template]");
    return !(popupHeaderTemplate && popupHeaderTemplate.contains(event.target));
  }
  clickedOutTarget(event) {
    return this.target && !this.target.contains(event.target);
  }
  closePopupOnClickout(event) {
    if (this.clickedOutTarget(event) && this.clickedOutDisabledItem(event) && this.clickedOutHeaderTemplate(event)) {
      this.close();
    }
  }
  elementContains(element, className) {
    return element && element.classList.contains(className);
  }
  hasContentToShow() {
    return !!(this.popupRef?.nativeElement && this.listbox?.nativeElement);
  }
  initializeListeners() {
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.close();
    });
    this.clickoutListener = this.renderer.listen("document", "click", (event) => {
      this.closePopupOnClickout(event);
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  onScroll = ({
    target
  }) => {
    const {
      showPopup,
      popupRef
    } = this;
    if (showPopup && popupRef?.nativeElement && !popupRef.nativeElement.contains(target)) {
      this.close();
    }
  };
  openUrl(url) {
    if (isExternalLink(url)) {
      return openExternalLink(url);
    }
    if (url) {
      return this.router.navigate([url]);
    }
  }
  removeListeners() {
    if (this.clickoutListener) {
      this.clickoutListener();
    }
    if (this.resizeListener) {
      this.resizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
  }
  setPosition() {
    if (this.listbox.nativeElement.querySelector(".po-listbox")) {
      this.poControlPosition.setElements(this.popupRef.nativeElement, 8, this.target, this.customPositions, false, this.isCornerAlign);
      this.poControlPosition.adjustPosition(this.position);
      this.arrowDirection = this.poControlPosition.getArrowDirection();
    }
  }
  validateInitialContent() {
    if (this.hasContentToShow()) {
      this.setPosition();
      this.initializeListeners();
    } else {
      this.close();
    }
  }
  static ɵfac = function PoPopupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPopupComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(PoControlPositionService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPopupComponent,
    selectors: [["po-popup"]],
    viewQuery: function PoPopupComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1B, 5, ElementRef);
        ɵɵviewQuery(_c1$E, 5, ElementRef);
        ɵɵviewQuery(_c2$j, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupRef = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listbox = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poListBoxRef = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoControlPositionService]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c4$4,
    decls: 1,
    vars: 1,
    consts: [["popupRef", ""], ["listbox", "", "poListBoxRef", ""], ["class", "po-popup", 4, "ngIf"], [1, "po-popup"], [3, "class", 4, "ngIf"], [1, "po-popup-container"], ["p-type", "action", 3, "p-close", "p-items", "p-param"], ["p-popup-header-template", ""]],
    template: function PoPopupComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c3$f);
        ɵɵtemplate(0, PoPopupComponent_div_0_Template, 9, 3, "div", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.showPopup && ctx.actions.length && !ctx.checkAllActionIsInvisible());
      }
    },
    dependencies: [NgIf, PoListBoxComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopupComponent, [{
    type: Component,
    args: [{
      selector: "po-popup",
      providers: [PoControlPositionService],
      standalone: false,
      template: '<div #popupRef class="po-popup" *ngIf="showPopup && actions.length && !checkAllActionIsInvisible()">\n  <div *ngIf="!hideArrow" class="po-popup-arrow po-arrow-{{ arrowDirection }}"></div>\n\n  <div class="po-popup-container">\n    <po-listbox #listbox #poListBoxRef p-type="action" [p-items]="actions" [p-param]="param" (p-close)="close()">\n      <div p-popup-header-template>\n        <ng-content select="[p-popup-header-template]"></ng-content>\n      </div>\n    </po-listbox>\n  </div>\n</div>\n'
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: Renderer2
  }, {
    type: Router
  }, {
    type: PoControlPositionService
  }, {
    type: ChangeDetectorRef
  }], {
    popupRef: [{
      type: ViewChild,
      args: ["popupRef", {
        read: ElementRef
      }]
    }],
    listbox: [{
      type: ViewChild,
      args: ["listbox", {
        read: ElementRef
      }]
    }],
    poListBoxRef: [{
      type: ViewChild,
      args: ["poListBoxRef"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPopupComponent, {
    className: "PoPopupComponent",
    filePath: "lib/components/po-popup/po-popup.component.ts",
    lineNumber: 39
  });
})();
var PoBreadcrumbFavoriteService = class _PoBreadcrumbFavoriteService {
  http;
  _url;
  _bodyParams;
  get url() {
    return this._url;
  }
  get bodyParams() {
    return this._bodyParams;
  }
  constructor(http) {
    this.http = http;
  }
  configService(url, params, item) {
    this._url = url;
    this._bodyParams = {
      isFavorite: false,
      url: item.link,
      params
    };
  }
  sendStatusFavorite(status) {
    this.bodyParams["isFavorite"] = status;
    return this.http.post(this.url, this.bodyParams);
  }
  getFavorite() {
    return this.http.get(this.url, {
      responseType: "json",
      params: {
        url: this.bodyParams["url"]
      }
    });
  }
  static ɵfac = function PoBreadcrumbFavoriteService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoBreadcrumbFavoriteService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoBreadcrumbFavoriteService,
    factory: _PoBreadcrumbFavoriteService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBreadcrumbFavoriteService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }], null);
})();
function PoBreadcrumbFavoriteComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.literals == null ? null : ctx_r0.literals.unfavorite);
  }
}
function PoBreadcrumbFavoriteComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.literals == null ? null : ctx_r0.literals.favorite);
  }
}
var PoBreadcrumbLiterals = {
  en: {
    favorite: "Favorite",
    unfavorite: "Unfavorite"
  },
  es: {
    favorite: "Favor",
    unfavorite: "Desfavorecer"
  },
  pt: {
    favorite: "Favoritar",
    unfavorite: "Desfavoritar"
  },
  ru: {
    favorite: "Любимый",
    unfavorite: "Немилость"
  }
};
var PoBreadcrumbFavoriteComponent = class _PoBreadcrumbFavoriteComponent {
  service;
  languageService;
  // URL do serviço.
  favoriteService;
  // Item do breadcrumb ativo.
  itemActive;
  // Parâmetro que será enviado junto com o serviço de favoritar.
  paramsService;
  // Esconde literal e mantém apenas icone
  hiddenLiteral = false;
  favorite = false;
  literals;
  getSubscription;
  setSubscription;
  constructor(service, languageService) {
    this.service = service;
    this.languageService = languageService;
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues({}, PoBreadcrumbLiterals[language]);
  }
  ngOnInit() {
    this.service.configService(this.favoriteService, this.paramsService, this.itemActive);
    this.getStatusFavorite();
  }
  ngOnDestroy() {
    if (this.getSubscription) {
      this.getSubscription.unsubscribe();
    }
    if (this.setSubscription) {
      this.setSubscription.unsubscribe();
    }
  }
  toggleFavoriteAction() {
    this.favorite ? this.setStatusFavorite(false) : this.setStatusFavorite(true);
  }
  getStatusFavorite() {
    this.getSubscription = this.service.getFavorite().subscribe((result) => this.favorite = result.isFavorite);
  }
  setStatusFavorite(status) {
    this.setSubscription = this.service.sendStatusFavorite(status).subscribe((result) => this.favorite = result.isFavorite);
  }
  static ɵfac = function PoBreadcrumbFavoriteComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoBreadcrumbFavoriteComponent)(ɵɵdirectiveInject(PoBreadcrumbFavoriteService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoBreadcrumbFavoriteComponent,
    selectors: [["po-breadcrumb-favorite"]],
    inputs: {
      favoriteService: [0, "p-favorite-service", "favoriteService"],
      itemActive: [0, "p-item-active", "itemActive"],
      paramsService: [0, "p-params-service", "paramsService"],
      hiddenLiteral: [0, "p-hidden-literal", "hiddenLiteral"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoBreadcrumbFavoriteService])],
    decls: 4,
    vars: 4,
    consts: [["tabindex", "0", "role", "button", 1, "po-breadcrumb-favorite", "po-clickable", 3, "click", "keyup.enter"], ["p-icon", "ICON_STAR", 1, "po-breadcrumb-favorite-star", "po-clickable"], ["class", "po-hidden-sm po-breadcrumb-favorite-label", 4, "ngIf"], [1, "po-hidden-sm", "po-breadcrumb-favorite-label"]],
    template: function PoBreadcrumbFavoriteComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵlistener("click", function PoBreadcrumbFavoriteComponent_Template_div_click_0_listener() {
          return ctx.toggleFavoriteAction();
        })("keyup.enter", function PoBreadcrumbFavoriteComponent_Template_div_keyup_enter_0_listener() {
          return ctx.toggleFavoriteAction();
        });
        ɵɵelement(1, "po-icon", 1);
        ɵɵtemplate(2, PoBreadcrumbFavoriteComponent_span_2_Template, 2, 1, "span", 2)(3, PoBreadcrumbFavoriteComponent_span_3_Template, 2, 1, "span", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵclassProp("po-breadcrumb-favorite-star-active", ctx.favorite);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.favorite && !ctx.hiddenLiteral);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.favorite && !ctx.hiddenLiteral);
      }
    },
    dependencies: [NgIf, PoIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBreadcrumbFavoriteComponent, [{
    type: Component,
    args: [{
      selector: "po-breadcrumb-favorite",
      providers: [PoBreadcrumbFavoriteService],
      standalone: false,
      template: '<div\n  tabindex="0"\n  role="button"\n  class="po-breadcrumb-favorite po-clickable"\n  (click)="toggleFavoriteAction()"\n  (keyup.enter)="toggleFavoriteAction()"\n>\n  <po-icon\n    p-icon="ICON_STAR"\n    class="po-breadcrumb-favorite-star po-clickable"\n    [class.po-breadcrumb-favorite-star-active]="favorite"\n  >\n  </po-icon>\n  <span class="po-hidden-sm po-breadcrumb-favorite-label" *ngIf="favorite && !hiddenLiteral">{{\n    literals?.unfavorite\n  }}</span>\n  <span class="po-hidden-sm po-breadcrumb-favorite-label" *ngIf="!favorite && !hiddenLiteral">{{\n    literals?.favorite\n  }}</span>\n</div>\n'
    }]
  }], () => [{
    type: PoBreadcrumbFavoriteService
  }, {
    type: PoLanguageService
  }], {
    favoriteService: [{
      type: Input,
      args: ["p-favorite-service"]
    }],
    itemActive: [{
      type: Input,
      args: ["p-item-active"]
    }],
    paramsService: [{
      type: Input,
      args: ["p-params-service"]
    }],
    hiddenLiteral: [{
      type: Input,
      args: ["p-hidden-literal"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoBreadcrumbFavoriteComponent, {
    className: "PoBreadcrumbFavoriteComponent",
    filePath: "lib/components/po-breadcrumb/po-breadcrumb-favorite/po-breadcrumb-favorite.component.ts",
    lineNumber: 42
  });
})();
var _c0$1A = ["breadcrumb"];
var _c1$D = ["dropdownIcon"];
var _c2$i = ["target"];
var _c3$e = ["popup"];
function PoBreadcrumbComponent_ul_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "ul", 9, 1)(2, "li")(3, "po-link", 10);
    ɵɵlistener("p-action", function PoBreadcrumbComponent_ul_3_Template_po_link_p_action_3_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitAction(ctx_r1.itemsView[0]));
    });
    ɵɵelementEnd()();
    ɵɵelement(4, "po-icon", 11);
    ɵɵelementStart(5, "li", 12, 2);
    ɵɵlistener("click", function PoBreadcrumbComponent_ul_3_Template_li_click_5_listener() {
      ɵɵrestoreView(_r1);
      const popup_r3 = ɵɵreference(16);
      return ɵɵresetView(popup_r3.toggle());
    })("keyup", function PoBreadcrumbComponent_ul_3_Template_li_keyup_5_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.openPopup($event));
    });
    ɵɵelement(7, "po-icon", 13);
    ɵɵelementEnd();
    ɵɵelement(8, "po-icon", 11);
    ɵɵelementStart(9, "li")(10, "po-link", 10);
    ɵɵlistener("p-action", function PoBreadcrumbComponent_ul_3_Template_po_link_p_action_10_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitAction(ctx_r1.itemsView[ctx_r1.itemsView.length - 2]));
    });
    ɵɵelementEnd()();
    ɵɵelement(11, "po-icon", 11);
    ɵɵelementStart(12, "li")(13, "span", 14);
    ɵɵtext(14);
    ɵɵelementEnd()();
    ɵɵelementStart(15, "po-popup", 15, 3);
    ɵɵlistener("p-close", function PoBreadcrumbComponent_ul_3_Template_po_popup_p_close_15_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.closePopUp());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const target_r4 = ɵɵreference(6);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("p-label", ctx_r1.itemsView[0].label)("p-url", ctx_r1.itemsView[0].link);
    ɵɵadvance(2);
    ɵɵattribute("aria-label", ctx_r1.literals.literalButtonPopup);
    ɵɵadvance(5);
    ɵɵproperty("p-label", ctx_r1.itemsView[ctx_r1.itemsView.length - 2].label)("p-url", ctx_r1.itemsView[ctx_r1.itemsView.length - 2].link);
    ɵɵadvance(3);
    ɵɵattribute("aria-current", ctx_r1.itemsView[ctx_r1.itemsView.length - 1].label);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.itemsView[ctx_r1.itemsView.length - 1].label);
    ɵɵadvance();
    ɵɵproperty("p-hide-arrow", true)("p-actions", ctx_r1.itemsViewPopup)("p-target", target_r4);
  }
}
function PoBreadcrumbComponent_ul_4_li_1_po_link_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-link", 10);
    ɵɵlistener("p-action", function PoBreadcrumbComponent_ul_4_li_1_po_link_1_Template_po_link_p_action_0_listener() {
      ɵɵrestoreView(_r5);
      const item_r6 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.emitAction(item_r6));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r6 = ɵɵnextContext().$implicit;
    ɵɵproperty("p-label", item_r6.label)("p-url", item_r6.link);
  }
}
function PoBreadcrumbComponent_ul_4_li_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r6 = ɵɵnextContext().$implicit;
    ɵɵattribute("aria-current", item_r6.label);
    ɵɵadvance();
    ɵɵtextInterpolate(item_r6.label);
  }
}
function PoBreadcrumbComponent_ul_4_li_1_po_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 11);
  }
}
function PoBreadcrumbComponent_ul_4_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 18);
    ɵɵtemplate(1, PoBreadcrumbComponent_ul_4_li_1_po_link_1_Template, 1, 2, "po-link", 19)(2, PoBreadcrumbComponent_ul_4_li_1_span_2_Template, 2, 2, "span", 20)(3, PoBreadcrumbComponent_ul_4_li_1_po_icon_3_Template, 1, 0, "po-icon", 21);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const itemIndex_r7 = ctx.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !(itemIndex_r7 === ctx_r1.itemsView.length - 1));
    ɵɵadvance();
    ɵɵproperty("ngIf", itemIndex_r7 === ctx_r1.itemsView.length - 1);
    ɵɵadvance();
    ɵɵproperty("ngIf", !(itemIndex_r7 === ctx_r1.itemsView.length - 1));
  }
}
function PoBreadcrumbComponent_ul_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul", 16);
    ɵɵtemplate(1, PoBreadcrumbComponent_ul_4_li_1_Template, 4, 3, "li", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.itemsView);
  }
}
function PoBreadcrumbComponent_po_breadcrumb_favorite_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-breadcrumb-favorite", 22);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-favorite-service", ctx_r1.favoriteService)("p-item-active", ctx_r1.items[ctx_r1.items.length - 1])("p-params-service", ctx_r1.paramsService)("p-hidden-literal", ctx_r1.hiddenLiteralFavorite);
  }
}
var poBreadcrumbLiterals = {
  en: {
    literalButtonPopup: "Menu pop up collapsed"
  },
  es: {
    literalButtonPopup: "Menú pop up colapsado"
  },
  pt: {
    literalButtonPopup: "Menu pop up colapsado"
  },
  ru: {
    literalButtonPopup: "меню свернуто"
  }
};
var PoBreadcrumbComponent = class _PoBreadcrumbComponent extends PoBreadcrumbBaseComponent {
  element;
  renderer;
  languageService;
  breadcrumbElement;
  dropdownIcon;
  svgTarget;
  popupContainer;
  showDropdown = false;
  showDropdownToggle = false;
  dropdownItems;
  literals;
  hiddenLiteralFavorite = false;
  _breadcrumbItemsLenght = 0;
  calculatedElement = false;
  differ;
  hiddenWithoutResize = false;
  initialized = false;
  timeoutResize;
  constructor(differs, element, renderer, languageService) {
    super();
    this.element = element;
    this.renderer = renderer;
    this.languageService = languageService;
    this.differ = differs.find([]).create(null);
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues({}, poBreadcrumbLiterals[language]);
  }
  ngAfterViewInit() {
    this.initialized = true;
    this.initializeResizeListener();
  }
  ngDoCheck() {
    const breadcrumbWidth = this.breadcrumbElement.nativeElement.offsetWidth;
    if (breadcrumbWidth && !this.calculatedElement && this.initialized) {
      this.initBreadcrumbSize();
    }
    if (this.hiddenWithoutResize) {
      this.debounceResize();
      this.hiddenWithoutResize = false;
    }
    this.checkChangeOnItems();
  }
  ngOnDestroy() {
    this.removeResizeListener();
  }
  emitAction(item) {
    if (item.action) {
      item.action();
    }
  }
  openPopup(event) {
    if (event.code === "Enter" || event.code === "Space") {
      this.popupContainer.open();
    }
  }
  closePopUp() {
    this.svgTarget.nativeElement.focus();
  }
  checkChangeOnItems() {
    if (this.differ) {
      const changes = this.differ.diff(this.items);
      if (changes) {
        this.calcBreadcrumbItemsWidth();
        this.calculatedElement = false;
      }
    }
  }
  calcBreadcrumb() {
    const breadcrumbFavorite = this.getBreadcrumbFavoriteWidth();
    const existLabel = this.existsFavoritelabel();
    const breadcrumb = this.getBreadcrumbWidth(breadcrumbFavorite, existLabel);
    const breadcrumbTooltip = this.getBreadcrumbTooltipWidth();
    if (breadcrumb <= this._breadcrumbItemsLenght) {
      this.enableBreadcrumbResponsive();
    } else {
      this.disableBreadcrumbResponsive();
    }
    if (breadcrumbTooltip && breadcrumb <= breadcrumbTooltip) {
      this.hiddenLiteralFavorite = true;
    } else {
      this.hiddenLiteralFavorite = false;
    }
  }
  getBreadcrumbFavoriteWidth() {
    return this.favoriteService ? this.element.nativeElement.querySelector(".po-breadcrumb-favorite").offsetWidth + 20 : 0;
  }
  getBreadcrumbTooltipWidth() {
    return this.favoriteService ? this.element.nativeElement.querySelector(".po-breadcrumb-tooltip")?.offsetWidth : 0;
  }
  existsFavoritelabel() {
    return !!this.element.nativeElement.querySelector(".po-breadcrumb-favorite-label");
  }
  getBreadcrumbWidth(breadcrumbFavorite, existLabel) {
    const widthSpan = !existLabel ? 95 : 0;
    return this.element.nativeElement.querySelector(".po-breadcrumb").offsetWidth - (breadcrumbFavorite + widthSpan);
  }
  calcBreadcrumbItemsWidth() {
    const breadcrumbItem = this.element.nativeElement.querySelectorAll(".po-breadcrumb-item");
    this._breadcrumbItemsLenght = Array.from(breadcrumbItem).map((breadcrumb) => breadcrumb["offsetWidth"]).reduce((a, b) => a + b, 16);
  }
  enableBreadcrumbResponsive() {
    this.showDropdownToggle = true;
  }
  disableBreadcrumbResponsive() {
    this.showDropdownToggle = false;
    this.itemsView = [].concat(this.items);
    this.showDropdown = false;
  }
  debounceResize() {
    clearTimeout(this.timeoutResize);
    this.timeoutResize = setTimeout(() => {
      if (this.calculatedElement && !this.hiddenWithoutResize && this.breadcrumbElement.nativeElement.offsetWidth === 0) {
        this.hiddenWithoutResize = true;
      } else {
        this.calcBreadcrumb();
      }
    }, 50);
  }
  initBreadcrumbSize() {
    this.calcBreadcrumbItemsWidth();
    this.calcBreadcrumb();
    this.calculatedElement = true;
  }
  initializeResizeListener() {
    this.resizeListener = this.renderer.listen("window", "resize", (event) => {
      this.debounceResize();
    });
  }
  removeResizeListener() {
    this.resizeListener();
  }
  static ɵfac = function PoBreadcrumbComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoBreadcrumbComponent)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoBreadcrumbComponent,
    selectors: [["po-breadcrumb"]],
    viewQuery: function PoBreadcrumbComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1A, 7, ElementRef);
        ɵɵviewQuery(_c1$D, 5, ElementRef);
        ɵɵviewQuery(_c2$i, 5, ElementRef);
        ɵɵviewQuery(_c3$e, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.breadcrumbElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdownIcon = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgTarget = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupContainer = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 3,
    consts: [["breadcrumb", ""], ["dropdownIcon", ""], ["target", ""], ["popup", ""], [1, "po-breadcrumb"], [1, "po-breadcrumb-items"], ["class", "po-breadcrumb-item po-clickable po-breadcrumb-tooltip", 4, "ngIf"], ["class", "po-breadcrumb-item-container", 4, "ngIf"], [3, "p-favorite-service", "p-item-active", "p-params-service", "p-hidden-literal", 4, "ngIf"], [1, "po-breadcrumb-item", "po-clickable", "po-breadcrumb-tooltip"], [3, "p-action", "p-label", "p-url"], ["p-icon", "ICON_ARROW_RIGHT po-breadcrumb-icon-arrow"], ["role", "button", "tabindex", "0", 1, "po-breadcrumb-icon-more", 3, "click", "keyup"], ["p-icon", "ICON_MORE_VERT"], ["role", "link", "tabindex", "0", 1, "po-breadcrumb-item-activate"], ["p-position", "bottom-right", 3, "p-close", "p-hide-arrow", "p-actions", "p-target"], [1, "po-breadcrumb-item-container"], ["class", "po-breadcrumb-item", 4, "ngFor", "ngForOf"], [1, "po-breadcrumb-item"], [3, "p-label", "p-url", "p-action", 4, "ngIf"], ["class", "po-breadcrumb-item-activate", "role", "link", "tabindex", "0", 4, "ngIf"], ["p-icon", "ICON_ARROW_RIGHT po-breadcrumb-icon-arrow", 4, "ngIf"], [3, "p-favorite-service", "p-item-active", "p-params-service", "p-hidden-literal"]],
    template: function PoBreadcrumbComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "nav", 4, 0)(2, "div", 5);
        ɵɵtemplate(3, PoBreadcrumbComponent_ul_3_Template, 17, 10, "ul", 6)(4, PoBreadcrumbComponent_ul_4_Template, 2, 1, "ul", 7);
        ɵɵelementEnd();
        ɵɵtemplate(5, PoBreadcrumbComponent_po_breadcrumb_favorite_5_Template, 1, 4, "po-breadcrumb-favorite", 8);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.showDropdownToggle && ctx.itemsView.length >= 4);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.showDropdownToggle || ctx.itemsView.length < 4);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.favoriteService);
      }
    },
    dependencies: [NgForOf, NgIf, PoLinkComponent, PoPopupComponent, PoIconComponent, PoBreadcrumbFavoriteComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBreadcrumbComponent, [{
    type: Component,
    args: [{
      selector: "po-breadcrumb",
      standalone: false,
      template: '<nav class="po-breadcrumb" #breadcrumb>\n  <div class="po-breadcrumb-items">\n    <ul\n      #dropdownIcon\n      *ngIf="showDropdownToggle && itemsView.length >= 4"\n      class="po-breadcrumb-item po-clickable po-breadcrumb-tooltip"\n    >\n      <li>\n        <po-link\n          [p-label]="itemsView[0].label"\n          [p-url]="itemsView[0].link"\n          (p-action)="emitAction(itemsView[0])"\n        ></po-link>\n      </li>\n\n      <po-icon p-icon="ICON_ARROW_RIGHT po-breadcrumb-icon-arrow"></po-icon>\n\n      <li\n        #target\n        class="po-breadcrumb-icon-more"\n        [attr.aria-label]="literals.literalButtonPopup"\n        role="button"\n        tabindex="0"\n        (click)="popup.toggle()"\n        (keyup)="openPopup($event)"\n      >\n        <po-icon p-icon="ICON_MORE_VERT"></po-icon>\n      </li>\n      <po-icon p-icon="ICON_ARROW_RIGHT po-breadcrumb-icon-arrow"></po-icon>\n\n      <li>\n        <po-link\n          [p-label]="itemsView[itemsView.length - 2].label"\n          [p-url]="itemsView[itemsView.length - 2].link"\n          (p-action)="emitAction(itemsView[itemsView.length - 2])"\n        ></po-link>\n      </li>\n      <po-icon p-icon="ICON_ARROW_RIGHT po-breadcrumb-icon-arrow"></po-icon>\n\n      <li>\n        <span\n          class="po-breadcrumb-item-activate"\n          role="link"\n          tabindex="0"\n          [attr.aria-current]="itemsView[itemsView.length - 1].label"\n          >{{ itemsView[itemsView.length - 1].label }}</span\n        >\n      </li>\n      <po-popup\n        #popup\n        p-position="bottom-right"\n        (p-close)="closePopUp()"\n        [p-hide-arrow]="true"\n        [p-actions]="itemsViewPopup"\n        [p-target]="target"\n      >\n      </po-popup>\n    </ul>\n\n    <ul *ngIf="!showDropdownToggle || itemsView.length < 4" class="po-breadcrumb-item-container">\n      <li *ngFor="let item of itemsView; let itemIndex = index" class="po-breadcrumb-item">\n        <po-link\n          *ngIf="!(itemIndex === itemsView.length - 1)"\n          [p-label]="item.label"\n          [p-url]="item.link"\n          (p-action)="emitAction(item)"\n        ></po-link>\n        <span\n          class="po-breadcrumb-item-activate"\n          role="link"\n          tabindex="0"\n          *ngIf="itemIndex === itemsView.length - 1"\n          [attr.aria-current]="item.label"\n          >{{ item.label }}</span\n        >\n        <po-icon\n          *ngIf="!(itemIndex === itemsView.length - 1)"\n          p-icon="ICON_ARROW_RIGHT po-breadcrumb-icon-arrow"\n        ></po-icon>\n      </li>\n    </ul>\n  </div>\n\n  <po-breadcrumb-favorite\n    *ngIf="favoriteService"\n    [p-favorite-service]="favoriteService"\n    [p-item-active]="items[items.length - 1]"\n    [p-params-service]="paramsService"\n    [p-hidden-literal]="hiddenLiteralFavorite"\n  >\n  </po-breadcrumb-favorite>\n</nav>\n'
    }]
  }], () => [{
    type: IterableDiffers
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: PoLanguageService
  }], {
    breadcrumbElement: [{
      type: ViewChild,
      args: ["breadcrumb", {
        read: ElementRef,
        static: true
      }]
    }],
    dropdownIcon: [{
      type: ViewChild,
      args: ["dropdownIcon", {
        read: ElementRef
      }]
    }],
    svgTarget: [{
      type: ViewChild,
      args: ["target", {
        read: ElementRef
      }]
    }],
    popupContainer: [{
      type: ViewChild,
      args: ["popup"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoBreadcrumbComponent, {
    className: "PoBreadcrumbComponent",
    filePath: "lib/components/po-breadcrumb/po-breadcrumb.component.ts",
    lineNumber: 52
  });
})();
var PoLinkModule = class _PoLinkModule {
  static ɵfac = function PoLinkModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLinkModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoLinkModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, RouterModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLinkModule, [{
    type: NgModule,
    args: [{
      declarations: [PoLinkComponent],
      imports: [CommonModule, RouterModule],
      exports: [PoLinkComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoLinkModule, {
    declarations: [PoLinkComponent],
    imports: [CommonModule, RouterModule],
    exports: [PoLinkComponent]
  });
})();
var PoLabelModule = class _PoLabelModule {
  static ɵfac = function PoLabelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLabelModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoLabelModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLabelModule, [{
    type: NgModule,
    args: [{
      declarations: [PoLabelComponent],
      exports: [PoLabelComponent],
      imports: [CommonModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoLabelModule, {
    declarations: [PoLabelComponent],
    imports: [CommonModule],
    exports: [PoLabelComponent]
  });
})();
var PoFieldContainerModule = class _PoFieldContainerModule {
  static ɵfac = function PoFieldContainerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoFieldContainerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoFieldContainerModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoLabelModule, PoIconModule, PoTooltipModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldContainerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoLabelModule, PoIconModule, PoTooltipModule],
      exports: [PoFieldContainerBottomComponent, PoFieldContainerComponent],
      declarations: [PoFieldContainerBottomComponent, PoFieldContainerComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoFieldContainerModule, {
    declarations: [PoFieldContainerBottomComponent, PoFieldContainerComponent],
    imports: [CommonModule, PoLabelModule, PoIconModule, PoTooltipModule],
    exports: [PoFieldContainerBottomComponent, PoFieldContainerComponent]
  });
})();
var PoCheckboxModule = class _PoCheckboxModule {
  static ɵfac = function PoCheckboxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCheckboxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoCheckboxModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, PoLabelModule, PoFieldContainerModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxModule, [{
    type: NgModule,
    args: [{
      declarations: [PoCheckboxComponent],
      exports: [PoCheckboxComponent],
      imports: [CommonModule, FormsModule, PoLabelModule, PoFieldContainerModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoCheckboxModule, {
    declarations: [PoCheckboxComponent],
    imports: [CommonModule, FormsModule, PoLabelModule, PoFieldContainerModule],
    exports: [PoCheckboxComponent]
  });
})();
var PoOverlayModule = class _PoOverlayModule {
  static ɵfac = function PoOverlayModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoOverlayModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoOverlayModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoOverlayModule, [{
    type: NgModule,
    args: [{
      declarations: [PoOverlayComponent],
      imports: [CommonModule],
      exports: [PoOverlayComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoOverlayModule, {
    declarations: [PoOverlayComponent],
    imports: [CommonModule],
    exports: [PoOverlayComponent]
  });
})();
var PoLoadingModule = class _PoLoadingModule {
  static ɵfac = function PoLoadingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLoadingModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoLoadingModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoLanguageModule, PoOverlayModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingModule, [{
    type: NgModule,
    args: [{
      declarations: [PoLoadingComponent, PoLoadingIconComponent, PoLoadingOverlayComponent],
      exports: [PoLoadingComponent, PoLoadingIconComponent, PoLoadingOverlayComponent],
      imports: [CommonModule, PoLanguageModule, PoOverlayModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoLoadingModule, {
    declarations: [PoLoadingComponent, PoLoadingIconComponent, PoLoadingOverlayComponent],
    imports: [CommonModule, PoLanguageModule, PoOverlayModule],
    exports: [PoLoadingComponent, PoLoadingIconComponent, PoLoadingOverlayComponent]
  });
})();
var PoListBoxModule = class _PoListBoxModule {
  static ɵfac = function PoListBoxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoListBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoListBoxModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoCheckboxModule, PoIconModule, PoLoadingModule, CdkListboxModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListBoxModule, [{
    type: NgModule,
    args: [{
      declarations: [PoListBoxComponent, PoItemListComponent, PoSearchListComponent],
      exports: [PoListBoxComponent],
      imports: [CommonModule, PoCheckboxModule, PoIconModule, PoLoadingModule, CdkListboxModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoListBoxModule, {
    declarations: [PoListBoxComponent, PoItemListComponent, PoSearchListComponent],
    imports: [CommonModule, PoCheckboxModule, PoIconModule, PoLoadingModule, CdkListboxModule],
    exports: [PoListBoxComponent]
  });
})();
var PoPopupModule = class _PoPopupModule {
  static ɵfac = function PoPopupModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPopupModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoPopupModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoListBoxModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoListBoxModule],
      declarations: [PoPopupComponent],
      exports: [PoPopupComponent],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoPopupModule, {
    declarations: [PoPopupComponent],
    imports: [CommonModule, PoListBoxModule],
    exports: [PoPopupComponent]
  });
})();
var PoBreadcrumbModule = class _PoBreadcrumbModule {
  static ɵfac = function PoBreadcrumbModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoBreadcrumbModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoBreadcrumbModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, RouterModule, PoLinkModule, PoPopupModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBreadcrumbModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, PoLinkModule, PoPopupModule, PoIconModule],
      declarations: [PoBreadcrumbComponent, PoBreadcrumbFavoriteComponent],
      exports: [PoBreadcrumbComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoBreadcrumbModule, {
    declarations: [PoBreadcrumbComponent, PoBreadcrumbFavoriteComponent],
    imports: [CommonModule, RouterModule, PoLinkModule, PoPopupModule, PoIconModule],
    exports: [PoBreadcrumbComponent]
  });
})();
var PoButtonKind;
(function(PoButtonKind2) {
  PoButtonKind2["primary"] = "primary";
  PoButtonKind2["secondary"] = "secondary";
  PoButtonKind2["tertiary"] = "tertiary";
})(PoButtonKind || (PoButtonKind = {}));
var PoButtonSize;
(function(PoButtonSize2) {
  PoButtonSize2["medium"] = "medium";
  PoButtonSize2["large"] = "large";
})(PoButtonSize || (PoButtonSize = {}));
var PoButtonType;
(function(PoButtonType2) {
  PoButtonType2["Submit"] = "submit";
  PoButtonType2["Button"] = "button";
  PoButtonType2["Reset"] = "reset";
})(PoButtonType || (PoButtonType = {}));
var PoButtonBaseComponent = class _PoButtonBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Label do botão.
   */
  label;
  /**
   * @optional
   *
   * @description
   * Ícone exibido ao lado esquerdo do label do botão.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](https://po-ui.io/icons). conforme exemplo abaixo:
   * ```
   * <po-button p-icon="an an-user" p-label="PO button"></po-button>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-button p-icon="fa fa-podcast" p-label="PO button"></po-button>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-button [p-icon]="template" p-label="button template ionic"></po-button>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   */
  icon;
  /**
   * @optional
   *
   * @description
   * Define o tipo do botão.
   *
   * @default `PoButtonType.Button`
   */
  type = PoButtonType.Button;
  // Evento disparado ao sair do campo.
  blur = new EventEmitter();
  /** Ação que será executada quando o usuário clicar sobre o `po-button`. */
  click = new EventEmitter();
  _danger = false;
  _disabled = false;
  _loading = false;
  _kind = PoButtonKind.secondary;
  _size = PoButtonSize.medium;
  hasSize = false;
  /**
   * @optional
   *
   * @description
   *
   * Exibe um ícone de carregamento à esquerda do _label_ do botão.
   *
   * > Quando esta propriedade estiver habilitada, desabilitará o botão.
   *
   * @default `false`
   */
  set loading(value) {
    this._loading = convertToBoolean(value);
  }
  get loading() {
    return this._loading;
  }
  /**
   * @optional
   *
   * @description
   *
   * Deve ser usado em ações irreversíveis que o usuário precisa ter cuidado ao executá-la, como a exclusão de um registro.
   *
   * > A propriedade `p-kind="tertiary"` será inativada ao utilizar esta propriedade.
   */
  set danger(value) {
    this._danger = this.kind !== PoButtonKind.tertiary ? value : false;
  }
  get danger() {
    return this._danger;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho do `po-button`.
   *
   * Valores válidos:
   * - `medium`: o `po-button` fica do tamanho padrão, com 44px de altura.;
   * - `large`: o `po-button` fica maior, com 56px de altura.;
   *
   * @default `medium`
   *
   */
  set size(value) {
    this._size = PoButtonSize[value] ? PoButtonSize[value] : PoButtonSize.medium;
    this.hasSize = true;
  }
  get size() {
    return this._size;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o estilo do `po-button`.
   *
   * Valores válidos:
   *  - `primary`: deixa o `po-button` com destaque, deve ser usado para ações primárias.
   *  - `secondary`: estilo padrão do `po-button`.
   *  - `tertiary`: o `po-button` é exibido sem cor do fundo, recebendo menos destaque entre as ações.
   *
   * @default `secondary`
   */
  set kind(value) {
    this._kind = PoButtonKind[value] ? PoButtonKind[value] : PoButtonKind.secondary;
  }
  get kind() {
    return this._kind;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o `po-button` e não permite que o usuário interaja com o mesmo.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = value === "" ? true : convertToBoolean(value);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define um `aria-label` para o `po-button`.
   *
   * Caso esta propriedade não seja informada será considerada a label do botão.
   *
   * > Em caso de botões com apenas ícone a atribuição de valor à esta propriedade é muito importante para acessibilidade.
   */
  ariaLabel;
  static ɵfac = function PoButtonBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoButtonBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoButtonBaseComponent,
    hostVars: 3,
    hostBindings: function PoButtonBaseComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("p-danger", ctx.danger)("p-size", ctx.size)("p-kind", ctx.kind);
      }
    },
    inputs: {
      label: [0, "p-label", "label"],
      icon: [0, "p-icon", "icon"],
      type: [0, "p-type", "type"],
      loading: [0, "p-loading", "loading"],
      danger: [2, "p-danger", "danger", convertToBoolean],
      size: [0, "p-size", "size"],
      kind: [0, "p-kind", "kind"],
      disabled: [0, "p-disabled", "disabled"],
      ariaLabel: [0, "p-aria-label", "ariaLabel"]
    },
    outputs: {
      blur: "p-blur",
      click: "p-click"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonBaseComponent, [{
    type: Directive
  }], null, {
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }],
    type: [{
      type: Input,
      args: ["p-type"]
    }],
    blur: [{
      type: Output,
      args: ["p-blur"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }],
    loading: [{
      type: Input,
      args: ["p-loading"]
    }],
    danger: [{
      type: HostBinding,
      args: ["attr.p-danger"]
    }, {
      type: Input,
      args: [{
        alias: "p-danger",
        transform: convertToBoolean
      }]
    }],
    size: [{
      type: HostBinding,
      args: ["attr.p-size"]
    }, {
      type: Input,
      args: ["p-size"]
    }],
    kind: [{
      type: HostBinding,
      args: ["attr.p-kind"]
    }, {
      type: Input,
      args: ["p-kind"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    ariaLabel: [{
      type: Input,
      args: ["p-aria-label"]
    }]
  });
})();
var _c0$1z = ["button"];
function PoButtonComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵelement(1, "po-loading-icon", 7);
    ɵɵelementEnd();
  }
}
function PoButtonComponent_po_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-icon", ctx_r1.icon);
  }
}
function PoButtonComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
var PoButtonComponent = class _PoButtonComponent extends PoButtonBaseComponent {
  buttonElement;
  onBlur() {
    this.blur.emit();
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoButtonComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoButtonComponent, { static: true }) button: PoButtonComponent;
   *
   * focusButton() {
   *   this.button.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.buttonElement.nativeElement.focus();
    }
  }
  onClick() {
    this.click.emit(null);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoButtonComponent_BaseFactory;
    return function PoButtonComponent_Factory(__ngFactoryType__) {
      return (ɵPoButtonComponent_BaseFactory || (ɵPoButtonComponent_BaseFactory = ɵɵgetInheritedFactory(_PoButtonComponent)))(__ngFactoryType__ || _PoButtonComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoButtonComponent,
    selectors: [["po-button"]],
    viewQuery: function PoButtonComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1z, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.buttonElement = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 9,
    consts: [["button", ""], [1, "po-button", 3, "blur", "click", "type", "disabled"], ["class", "po-button-loading-icon", 4, "ngIf"], [1, "po-button-container"], ["class", "po-button-icon", 3, "p-icon", 4, "ngIf"], ["class", "po-button-label", 4, "ngIf"], [1, "po-button-loading-icon"], ["p-neutral-color", "", "p-size", "sm"], [1, "po-button-icon", 3, "p-icon"], [1, "po-button-label"]],
    template: function PoButtonComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "button", 1, 0);
        ɵɵlistener("blur", function PoButtonComponent_Template_button_blur_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        })("click", function PoButtonComponent_Template_button_click_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onClick());
        });
        ɵɵtemplate(2, PoButtonComponent_div_2_Template, 2, 0, "div", 2);
        ɵɵelementStart(3, "div", 3);
        ɵɵtemplate(4, PoButtonComponent_po_icon_4_Template, 1, 1, "po-icon", 4)(5, PoButtonComponent_span_5_Template, 2, 1, "span", 5);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("type", ctx.type)("disabled", ctx.disabled || ctx.loading);
        ɵɵattribute("p-size", ctx.size)("p-kind", ctx.kind)("p-danger", ctx.danger)("aria-label", ctx.ariaLabel);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.icon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.label);
      }
    },
    dependencies: [NgIf, PoLoadingIconComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonComponent, [{
    type: Component,
    args: [{
      selector: "po-button",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<button\n  #button\n  class="po-button"\n  [type]="type"\n  [attr.p-size]="size"\n  [attr.p-kind]="kind"\n  [attr.p-danger]="danger"\n  [disabled]="disabled || loading"\n  [attr.aria-label]="ariaLabel"\n  (blur)="onBlur()"\n  (click)="onClick()"\n>\n  <div *ngIf="loading" class="po-button-loading-icon">\n    <po-loading-icon p-neutral-color p-size="sm"></po-loading-icon>\n  </div>\n\n  <div class="po-button-container">\n    <po-icon *ngIf="icon" class="po-button-icon" [p-icon]="icon"></po-icon>\n    <span *ngIf="label" class="po-button-label">{{ label }}</span>\n  </div>\n</button>\n'
    }]
  }], null, {
    buttonElement: [{
      type: ViewChild,
      args: ["button", {
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoButtonComponent, {
    className: "PoButtonComponent",
    filePath: "lib/components/po-button/po-button.component.ts",
    lineNumber: 35
  });
})();
var PoButtonModule = class _PoButtonModule {
  static ɵfac = function PoButtonModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoButtonModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoButtonModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoLoadingModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoLoadingModule, PoIconModule],
      declarations: [PoButtonComponent],
      exports: [PoButtonComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoButtonModule, {
    declarations: [PoButtonComponent],
    imports: [CommonModule, PoLoadingModule, PoIconModule],
    exports: [PoButtonComponent]
  });
})();
var PoButtonGroupToggle;
(function(PoButtonGroupToggle2) {
  PoButtonGroupToggle2["Multiple"] = "multiple";
  PoButtonGroupToggle2["None"] = "none";
  PoButtonGroupToggle2["Single"] = "single";
})(PoButtonGroupToggle || (PoButtonGroupToggle = {}));
var PO_TOGGLE_TYPE_DEFAULT = "none";
var PoButtonGroupBaseComponent = class _PoButtonGroupBaseComponent {
  /** Lista de botões. */
  buttons = [];
  _toggle = PO_TOGGLE_TYPE_DEFAULT;
  /**
   * @optional
   *
   * @description
   *
   * Define o modo de seleção de botões.
   *
   * > Veja os valores válidos no *enum* `PoButtonGroupToggle`.
   *
   * @default `none`
   */
  set toggle(value) {
    this._toggle = Object.values(PoButtonGroupToggle).includes(value) ? value : PO_TOGGLE_TYPE_DEFAULT;
    this.checkSelecteds(this._toggle);
  }
  get toggle() {
    return this._toggle;
  }
  onButtonClick(buttonClicked, buttonIndex) {
    if (this.toggle === PoButtonGroupToggle.Single) {
      this.buttons.forEach((button, index) => button.selected = index === buttonIndex ? !buttonClicked.selected : false);
    } else if (this.toggle === PoButtonGroupToggle.Multiple) {
      buttonClicked.selected = !buttonClicked.selected;
    }
  }
  checkSelecteds(toggleMode) {
    if (toggleMode === PoButtonGroupToggle.None) {
      this.deselectAllButtons();
    } else if (toggleMode === PoButtonGroupToggle.Single) {
      const hasMoreOneSelected = this.buttons.filter((button) => button.selected).length > 1;
      if (hasMoreOneSelected) {
        this.deselectAllButtons();
      }
    }
  }
  deselectAllButtons() {
    this.buttons.forEach((button) => button.selected = false);
  }
  static ɵfac = function PoButtonGroupBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoButtonGroupBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoButtonGroupBaseComponent,
    inputs: {
      buttons: [0, "p-buttons", "buttons"],
      toggle: [0, "p-toggle", "toggle"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonGroupBaseComponent, [{
    type: Directive
  }], null, {
    buttons: [{
      type: Input,
      args: ["p-buttons"]
    }],
    toggle: [{
      type: Input,
      args: ["p-toggle"]
    }]
  });
})();
function PoButtonGroupComponent_po_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 2);
    ɵɵlistener("p-click", function PoButtonGroupComponent_po_button_1_Template_po_button_p_click_0_listener() {
      const ctx_r1 = ɵɵrestoreView(_r1);
      const button_r3 = ctx_r1.$implicit;
      const i_r4 = ctx_r1.index;
      const ctx_r4 = ɵɵnextContext();
      ctx_r4.onButtonClick(button_r3, i_r4);
      return ɵɵresetView(button_r3.action(button_r3));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const button_r3 = ctx.$implicit;
    ɵɵclassProp("po-button-group-button-selected", button_r3.selected)("po-button-group-disabled", button_r3.disabled);
    ɵɵproperty("p-disabled", button_r3.disabled)("p-icon", button_r3.icon)("p-label", button_r3.label)("p-tooltip", !button_r3.disabled ? button_r3.tooltip : void 0);
  }
}
var PoButtonGroupComponent = class _PoButtonGroupComponent extends PoButtonGroupBaseComponent {
  constructor(viewRef) {
    super();
  }
  static ɵfac = function PoButtonGroupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoButtonGroupComponent)(ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoButtonGroupComponent,
    selectors: [["po-button-group"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 1,
    consts: [[1, "po-button-group-container"], ["class", "po-sm-12 po-button-group", "p-tooltip-position", "bottom", 3, "po-button-group-button-selected", "po-button-group-disabled", "p-disabled", "p-icon", "p-label", "p-tooltip", "p-click", 4, "ngFor", "ngForOf"], ["p-tooltip-position", "bottom", 1, "po-sm-12", "po-button-group", 3, "p-click", "p-disabled", "p-icon", "p-label", "p-tooltip"]],
    template: function PoButtonGroupComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoButtonGroupComponent_po_button_1_Template, 1, 8, "po-button", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.buttons);
      }
    },
    dependencies: [NgForOf, PoButtonComponent, PoTooltipDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonGroupComponent, [{
    type: Component,
    args: [{
      selector: "po-button-group",
      standalone: false,
      template: '<div class="po-button-group-container">\n  <po-button\n    *ngFor="let button of buttons; index as i"\n    class="po-sm-12 po-button-group"\n    [class.po-button-group-button-selected]="button.selected"\n    [class.po-button-group-disabled]="button.disabled"\n    p-tooltip-position="bottom"\n    [p-disabled]="button.disabled"\n    [p-icon]="button.icon"\n    [p-label]="button.label"\n    [p-tooltip]="!button.disabled ? button.tooltip : undefined"\n    (p-click)="onButtonClick(button, i); button.action(button)"\n  >\n  </po-button>\n</div>\n'
    }]
  }], () => [{
    type: ViewContainerRef
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoButtonGroupComponent, {
    className: "PoButtonGroupComponent",
    filePath: "lib/components/po-button-group/po-button-group.component.ts",
    lineNumber: 36
  });
})();
var PoButtonGroupModule = class _PoButtonGroupModule {
  static ɵfac = function PoButtonGroupModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoButtonGroupModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoButtonGroupModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoButtonModule, PoTooltipModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonGroupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoButtonModule, PoTooltipModule],
      declarations: [PoButtonGroupComponent],
      exports: [PoButtonGroupComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoButtonGroupModule, {
    declarations: [PoButtonGroupComponent],
    imports: [CommonModule, PoButtonModule, PoTooltipModule],
    exports: [PoButtonGroupComponent]
  });
})();
var PoCalendarMode;
(function(PoCalendarMode2) {
  PoCalendarMode2["Range"] = "range";
})(PoCalendarMode || (PoCalendarMode = {}));
var PoDateService = class _PoDateService {
  dateRegex = new RegExp("^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])$");
  isoRegex = new RegExp("^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:Z|-0[1-9]|-1\\d|-2[0-3]|-00:?(?:0[1-9]|[0-5]\\d)|\\+[01]\\d|\\+2[0-3])(?:|:?[0-5]\\d)$");
  /**
   * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
   *
   * @param dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
   * @param minDate Definir `true` caso seja `minDate`.
   * @param maxDate Definir `true` caso seja `maxDate`.
   */
  convertIsoToDate(dateString, minDate, maxDate) {
    if (dateString) {
      const {
        year,
        month,
        day
      } = this.getDateFromIso(dateString);
      if (minDate) {
        const date = new Date(year, month - 1, day, 0, 0, 0);
        this.setYearFrom0To100(date, year);
        return date;
      } else if (maxDate) {
        const date = new Date(year, month - 1, day, 23, 59, 59);
        this.setYearFrom0To100(date, year);
        return date;
      } else {
        const miliseconds = Date.parse(dateString);
        const timezone = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 6e4;
        return new Date(miliseconds + timezone);
      }
    }
  }
  /**
   * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
   *
   * @param date Data no formato `Date`.
   */
  convertDateToISO(date) {
    if (date) {
      const fullYear = date.getFullYear();
      const getMonth = date.getMonth() + 1;
      const day = date.getDate() < 10 ? "0" + date.getDate() : date.getDate();
      const month = getMonth < 10 ? "0" + getMonth : getMonth;
      const year = this.formatYear(fullYear);
      return year + "-" + month + "-" + day;
    } else {
      return null;
    }
  }
  /**
   * Método responsável por adicionar zeros a esquerda do anos em formato string.
   *
   * @param year Ano a ser validado.
   */
  formatYear(year) {
    if (year > 999) {
      return year.toString();
    }
    if (year > 99 && year < 1e3) {
      return `0${year}`;
    }
    if (year > 9 && year < 100) {
      return `00${year}`;
    }
    if (year >= 0 && year < 10) {
      return `000${year}`;
    }
  }
  /**
   * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
   *
   * @param isoDate Ano em formato string.
   */
  getDateFromIso(isoDate) {
    const day = parseInt(isoDate.substring(8, 10), 10);
    const month = parseInt(isoDate.substring(5, 7), 10);
    const year = parseInt(isoDate.substring(0, 4), 10);
    return {
      year,
      month,
      day
    };
  }
  /**
   * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
   * caso `isMindate` seja igual a `false` .
   *
   * @param date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
   * @param isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
   */
  getDateForDateRange(date, isMinDate) {
    const lastHour = isMinDate ? [0, 0, 0] : [23, 59, 59];
    if (date instanceof Date) {
      const {
        year,
        month,
        day
      } = this.splitDate(date);
      const validDate = new Date(year, month, day, ...lastHour);
      this.setYearFrom0To100(validDate, year);
      return validDate;
    } else if (this.isValidIso(date)) {
      return this.convertIsoToDate(date, isMinDate, !isMinDate);
    }
  }
  /**
   * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
   *
   * @param dateA primeira data
   * @param dateB segunda data
   */
  isDateRangeValid(dateA = "", dateB = "") {
    const dateASplitted = dateA.split("-").map((item) => parseInt(item, 10));
    const dateBSplitted = dateB.split("-").map((item) => parseInt(item, 10));
    for (let index = 0; index <= dateASplitted.length; index++) {
      if (dateASplitted[index] > dateBSplitted[index]) {
        return true;
      } else if (dateASplitted[index] < dateBSplitted[index]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
   *
   * @param stringDate Data.
   */
  isValidIso(stringDate) {
    return this.dateRegex.test(stringDate) || this.isoRegex.test(stringDate);
  }
  /**
   * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
   *
   * @param date Data.
   * @param year .
   */
  setYearFrom0To100(date, year) {
    if (year >= 0 && year < 100) {
      date.setFullYear(year);
    }
  }
  /**
   * Método responsável por retornar o dia , mês e ano de uma data informada.
   *
   * @param date Valor da data.
   */
  splitDate(date) {
    const year = date.getFullYear();
    const month = date.getMonth();
    const day = date.getDate();
    return {
      year,
      month,
      day
    };
  }
  /**
   * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
   *
   * @param date Data a ser validada.
   * @param minDate Data inicial.
   * @param maxDate Data final.
   */
  validateDateRange(date, minDate, maxDate) {
    if (minDate && maxDate) {
      return date >= minDate && date <= maxDate;
    } else if (minDate && !maxDate) {
      return date >= minDate;
    } else if (!minDate && maxDate) {
      return date <= maxDate;
    } else {
      return true;
    }
  }
  /**
   * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
   * 'Date' padrão do javascript.
   *
   * @param date Data que será validada.
   */
  validateDate(date) {
    const validDate = date instanceof Date ? this.convertDateToISO(date) : date;
    return this.isValidIso(validDate) ? validDate : void 0;
  }
  static ɵfac = function PoDateService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDateService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoDateService,
    factory: _PoDateService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDateService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var PoDateTimeModule = class _PoDateTimeModule {
  static ɵfac = function PoDateTimeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDateTimeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoDateTimeModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoDateService]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDateTimeModule, [{
    type: NgModule,
    args: [{
      providers: [PoDateService],
      bootstrap: []
    }]
  }], null, null);
})();
var PoCalendarBaseComponent = class _PoCalendarBaseComponent {
  poDate;
  languageService;
  /** Evento disparado ao selecionar um dia do calendário. */
  change = new EventEmitter();
  activateDate;
  value;
  onTouched = null;
  propagateChange = null;
  today = /* @__PURE__ */ new Date();
  shortLanguage;
  _locale;
  _maxDate;
  _minDate;
  _mode;
  /**
   * @optional
   *
   * @description
   *
   * Idioma do calendário.
   *
   * > O locale padrão sera recuperado com base no [`PoI18nService`](/documentation/po-i18n) ou *browser*.
   */
  set locale(locale) {
    this._locale = poLocales.includes(locale) ? locale : this.shortLanguage;
  }
  get locale() {
    return this._locale;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a data máxima possível de ser selecionada.
   *
   * Pode receber os seguintes formatos de data:
   *
   * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
   * ```
   * this.date = '2017-11-28T00:00:00-02:00';
   * ```
   *
   * - **Data (E8601DAw.): yyyy-mm-dd**
   * ```
   * this.date = '2017-11-28';
   * ```
   *
   * - **JavaScript Date Object:**
   * ```
   * this.date = new Date(2017, 10, 28);
   * ```
   */
  set maxDate(maxDate) {
    this._maxDate = this.poDate.getDateForDateRange(maxDate, false);
  }
  get maxDate() {
    return this._maxDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a data mínima possível de ser selecionada.
   *
   * Pode receber os seguintes formatos de data:
   *
   * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
   * ```
   * this.date = '2017-11-28T00:00:00-02:00';
   * ```
   *
   * - **Data (E8601DAw.): yyyy-mm-dd**
   * ```
   * this.date = '2017-11-28';
   * ```
   *
   * - **JavaScript Date Object:**
   * ```
   * this.date = new Date(2017, 10, 28);
   * ```
   */
  set minDate(minDate) {
    this._minDate = this.poDate.getDateForDateRange(minDate, true);
  }
  get minDate() {
    return this._minDate;
  }
  /**
   * Propriedade que permite informar o modo de exibição do calendar.
   *
   * Implementa o enum `PoCalendarMode`.
   */
  set mode(value) {
    this._mode = value;
    this.setActivateDate();
  }
  get mode() {
    return this._mode;
  }
  get isRange() {
    return this.mode === PoCalendarMode.Range;
  }
  constructor(poDate, languageService) {
    this.poDate = poDate;
    this.languageService = languageService;
    this.shortLanguage = languageService.getShortLanguage();
    this._locale = this.languageService.getShortLanguage();
  }
  setActivateDate(date) {
    let newData;
    if (typeof date !== "string") {
      const temporaryDate = new Date(date);
      const year = temporaryDate.getFullYear();
      const month = ("0" + (temporaryDate.getMonth() + 1)).slice(-2);
      const day = ("0" + temporaryDate.getDate()).slice(-2);
      const formattedDate = `${year}-${month}-${day}`;
      newData = formattedDate + "T00:00:00";
    } else {
      newData = date + "T00:00:00";
    }
    const activateDate = date ? date : this.verifyActivateDate();
    let checkedStart;
    let checkedEnd;
    if (this.isRange) {
      if (new Date(newData).getDate() > 28) {
        checkedStart = new Date(activateDate);
        checkedEnd = new Date(checkedStart.getFullYear(), checkedStart.getMonth() + 1, 0, 23, 59, 59, 999);
        checkedEnd.setMilliseconds(checkedEnd.getMilliseconds() + 1);
      } else {
        checkedStart = typeof activateDate === "string" ? this.poDate.convertIsoToDate(activateDate) : new Date(activateDate);
        checkedEnd = new Date(new Date(checkedStart).setMonth(checkedStart.getMonth() + 1));
      }
      this.activateDate = {
        start: checkedStart,
        end: checkedEnd
      };
    } else {
      this.activateDate = new Date(activateDate);
    }
  }
  verifyActivateDate() {
    let today = this.today;
    if (this.minDate && this.minDate > this.today) {
      today = this.minDate;
    } else if (this.maxDate && this.maxDate < this.today) {
      today = this.maxDate;
    }
    return today;
  }
  static ɵfac = function PoCalendarBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCalendarBaseComponent)(ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoCalendarBaseComponent,
    inputs: {
      locale: [0, "p-locale", "locale"],
      maxDate: [0, "p-max-date", "maxDate"],
      minDate: [0, "p-min-date", "minDate"],
      mode: [0, "p-mode", "mode"]
    },
    outputs: {
      change: "p-change"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoDateService
  }, {
    type: PoLanguageService
  }], {
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    locale: [{
      type: Input,
      args: ["p-locale"]
    }],
    maxDate: [{
      type: Input,
      args: ["p-max-date"]
    }],
    minDate: [{
      type: Input,
      args: ["p-min-date"]
    }],
    mode: [{
      type: Input,
      args: ["p-mode"]
    }]
  });
})();
var poCalendarServiceFirstWeekDayDefault = 0;
var PoCalendarService = class _PoCalendarService {
  monthDates(year, month, dayFormatter = null, weekFormatter = null) {
    if (typeof month !== "number" || month < 0 || month > 11) {
      throw Error("month must be a number (Jan is 0)");
    }
    const weeks = [];
    let week = [];
    let i = 0;
    let date = new Date(year, month, 1);
    if (year >= 0 && year < 100) {
      date.setFullYear(year);
    }
    date = this.weekStartDate(date);
    do {
      for (i = 0; i < 7; i++) {
        week.push(dayFormatter ? dayFormatter(date) : date);
        date = new Date(date.getTime());
        date.setDate(date.getDate() + 1);
      }
      weeks.push(weekFormatter ? weekFormatter(week) : week);
      week = [];
    } while (date.getMonth() <= month && date.getFullYear() === year);
    return weeks;
  }
  monthDays(year, month) {
    const getDayOrZero = function(date) {
      return date.getMonth() === month ? date : 0;
    };
    return this.monthDates(year, month, getDayOrZero);
  }
  weekStartDate(date) {
    const startDate = new Date(date.getTime());
    while (startDate.getDay() !== poCalendarServiceFirstWeekDayDefault) {
      startDate.setDate(startDate.getDate() - 1);
    }
    return startDate;
  }
  static ɵfac = function PoCalendarService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCalendarService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoCalendarService,
    factory: _PoCalendarService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var PoCalendarLangService = class _PoCalendarLangService {
  language = poLocaleDefault;
  months = [{
    pt: "Janeiro",
    en: "January",
    es: "Enero",
    ru: "Январь"
  }, {
    pt: "Fevereiro",
    en: "February",
    es: "Febrero",
    ru: "Февраль"
  }, {
    pt: "Março",
    en: "March",
    es: "Marzo",
    ru: "Март"
  }, {
    pt: "Abril",
    en: "April",
    es: "Abril",
    ru: "Апрель"
  }, {
    pt: "Maio",
    en: "May",
    es: "Mayo",
    ru: "Май"
  }, {
    pt: "Junho",
    en: "June",
    es: "Junio",
    ru: "Июнь"
  }, {
    pt: "Julho",
    en: "July",
    es: "Julio",
    ru: "Июль"
  }, {
    pt: "Agosto",
    en: "August",
    es: "Agosto",
    ru: "Август"
  }, {
    pt: "Setembro",
    en: "September",
    es: "Setiembre",
    ru: "Сентябрь"
  }, {
    pt: "Outubro",
    en: "October",
    es: "Octubre",
    ru: "Октябрь"
  }, {
    pt: "Novembro",
    en: "November",
    es: "Noviembre",
    ru: "Ноябрь"
  }, {
    pt: "Dezembro",
    en: "December",
    es: "Diciembre",
    ru: "Декабрь"
  }];
  shortWeekDays = [{
    pt: "Dom",
    en: "Sun",
    es: "Dom",
    ru: "Вс"
  }, {
    pt: "Seg",
    en: "Mon",
    es: "Lun",
    ru: "Пн"
  }, {
    pt: "Ter",
    en: "Tue",
    es: "Mar",
    ru: "Вт"
  }, {
    pt: "Qua",
    en: "Wed",
    es: "Mié",
    ru: "Ср"
  }, {
    pt: "Qui",
    en: "Thu",
    es: "Jue",
    ru: "Чт"
  }, {
    pt: "Sex",
    en: "Fri",
    es: "Vie",
    ru: "Пт"
  }, {
    pt: "Sáb",
    en: "Sat",
    es: "Sáb",
    ru: "Сб"
  }];
  monthLabel = {
    pt: "Mês",
    en: "Month",
    es: "Mes",
    ru: "Месяц"
  };
  yearLabel = {
    pt: "Ano",
    en: "Year",
    es: "Año",
    ru: "Год"
  };
  todayLabel = {
    pt: "Hoje",
    en: "Today",
    es: "Hoy",
    ru: "Сегодня"
  };
  getMonth(month) {
    return this.months[month][this.language];
  }
  getMonthLabel() {
    return this.monthLabel[this.language];
  }
  getMonthsArray() {
    const arrMonths = Array();
    for (let i = 0; i < this.months.length; i++) {
      arrMonths.push(this.months[i][this.language]);
    }
    return arrMonths;
  }
  getWeekDays(day) {
    return this.shortWeekDays[day][this.language];
  }
  getWeekDaysArray() {
    const arrWeekDays = Array();
    for (let i = 0; i < this.shortWeekDays.length; i++) {
      const weekDay = this.shortWeekDays[i][this.language];
      arrWeekDays.push(weekDay.toLowerCase());
    }
    return arrWeekDays;
  }
  getYearLabel() {
    return this.yearLabel[this.language];
  }
  getTodayLabel() {
    return this.todayLabel[this.language];
  }
  setLanguage(language) {
    if (language && language.length >= 2) {
      language = language.toLowerCase().slice(0, 2);
      this.language = poLocales.includes(language) ? language : poLocaleDefault;
    }
  }
  static ɵfac = function PoCalendarLangService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCalendarLangService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoCalendarLangService,
    factory: _PoCalendarLangService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarLangService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _c0$1y = ["*"];
function PoCalendarHeaderComponent_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-icon", 4);
    ɵɵlistener("click", function PoCalendarHeaderComponent_po_icon_1_Template_po_icon_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.previous.emit());
    });
    ɵɵelementEnd();
  }
}
function PoCalendarHeaderComponent_po_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-icon", 5);
    ɵɵlistener("click", function PoCalendarHeaderComponent_po_icon_4_Template_po_icon_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.next.emit());
    });
    ɵɵelementEnd();
  }
}
var PoCalendarHeaderComponent = class _PoCalendarHeaderComponent {
  hidePrevious = false;
  hideNext = false;
  previous = new EventEmitter();
  next = new EventEmitter();
  constructor() {
  }
  static ɵfac = function PoCalendarHeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCalendarHeaderComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoCalendarHeaderComponent,
    selectors: [["po-calendar-header"]],
    inputs: {
      hidePrevious: [0, "p-hide-previous", "hidePrevious"],
      hideNext: [0, "p-hide-next", "hideNext"]
    },
    outputs: {
      previous: "p-previous",
      next: "p-next"
    },
    standalone: false,
    ngContentSelectors: _c0$1y,
    decls: 5,
    vars: 2,
    consts: [[1, "po-calendar-header"], ["p-icon", "ICON_ARROW_LEFT", "class", "po-calendar-header-left", 3, "click", 4, "ngIf"], ["attr-calendar", "", 1, "po-calendar-header-title"], ["p-icon", "ICON_ARROW_RIGHT", "class", "po-calendar-header-right", 3, "click", 4, "ngIf"], ["p-icon", "ICON_ARROW_LEFT", 1, "po-calendar-header-left", 3, "click"], ["p-icon", "ICON_ARROW_RIGHT", 1, "po-calendar-header-right", 3, "click"]],
    template: function PoCalendarHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoCalendarHeaderComponent_po_icon_1_Template, 1, 0, "po-icon", 1);
        ɵɵelementStart(2, "div", 2);
        ɵɵprojection(3);
        ɵɵelementEnd();
        ɵɵtemplate(4, PoCalendarHeaderComponent_po_icon_4_Template, 1, 0, "po-icon", 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", (ctx.previous == null ? null : ctx.previous.observers) && !ctx.hidePrevious);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", (ctx.next == null ? null : ctx.next.observers.length) && !ctx.hideNext);
      }
    },
    dependencies: [NgIf, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarHeaderComponent, [{
    type: Component,
    args: [{
      selector: "po-calendar-header",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div class="po-calendar-header">\n  <po-icon\n    p-icon="ICON_ARROW_LEFT"\n    *ngIf="previous?.observers && !hidePrevious"\n    class="po-calendar-header-left"\n    (click)="previous.emit()"\n  >\n  </po-icon>\n  <div class="po-calendar-header-title" attr-calendar>\n    <ng-content></ng-content>\n  </div>\n\n  <po-icon\n    p-icon="ICON_ARROW_RIGHT"\n    *ngIf="next?.observers.length && !hideNext"\n    class="po-calendar-header-right"\n    (click)="next.emit()"\n  >\n  </po-icon>\n</div>\n'
    }]
  }], () => [], {
    hidePrevious: [{
      type: Input,
      args: ["p-hide-previous"]
    }],
    hideNext: [{
      type: Input,
      args: ["p-hide-next"]
    }],
    previous: [{
      type: Output,
      args: ["p-previous"]
    }],
    next: [{
      type: Output,
      args: ["p-next"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCalendarHeaderComponent, {
    className: "PoCalendarHeaderComponent",
    filePath: "lib/components/po-calendar/po-calendar-header/po-calendar-header.component.ts",
    lineNumber: 9
  });
})();
function PoCalendarWrapperComponent_ng_container_1_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const weekDay_r3 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", weekDay_r3, " ");
  }
}
function PoCalendarWrapperComponent_ng_container_1_div_10_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r5 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r1.getDayForegroundColor(day_r5));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", day_r5.getDate(), " ");
  }
}
function PoCalendarWrapperComponent_ng_container_1_div_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 11);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_1_div_10_Template_div_click_0_listener() {
      const day_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelectDate(day_r5));
    })("mouseenter", function PoCalendarWrapperComponent_ng_container_1_div_10_Template_div_mouseenter_0_listener() {
      const day_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onMouseEnter(day_r5));
    })("mouseleave", function PoCalendarWrapperComponent_ng_container_1_div_10_Template_div_mouseleave_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onMouseLeave());
    });
    ɵɵtemplate(1, PoCalendarWrapperComponent_ng_container_1_div_10_span_1_Template, 2, 2, "span", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r5 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r1.getDayBackgroundColor(day_r5));
    ɵɵadvance();
    ɵɵproperty("ngIf", day_r5 !== 0);
  }
}
function PoCalendarWrapperComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "po-calendar-header", 2);
    ɵɵlistener("p-previous", function PoCalendarWrapperComponent_ng_container_1_Template_po_calendar_header_p_previous_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onPreviousMonth());
    })("p-next", function PoCalendarWrapperComponent_ng_container_1_Template_po_calendar_header_p_next_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onNextMonth());
    });
    ɵɵelementStart(2, "span", 3);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_1_Template_span_click_2_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectDisplayMode("month"));
    });
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "span", 4);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_1_Template_span_click_4_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectDisplayMode("year"));
    });
    ɵɵtext(5);
    ɵɵelementEnd()();
    ɵɵelementStart(6, "div", 5)(7, "div", 6);
    ɵɵtemplate(8, PoCalendarWrapperComponent_ng_container_1_div_8_Template, 2, 1, "div", 7);
    ɵɵelementEnd();
    ɵɵelementStart(9, "div", 8);
    ɵɵtemplate(10, PoCalendarWrapperComponent_ng_container_1_div_10_Template, 2, 2, "div", 9);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-hide-previous", ctx_r1.isEndPart)("p-hide-next", ctx_r1.isStartPart && !ctx_r1.responsive);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.displayMonth);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.displayYear);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r1.displayWeekDays);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.displayDays);
  }
}
function PoCalendarWrapperComponent_ng_container_2_div_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_2_div_9_Template_div_click_0_listener() {
      const i_r8 = ɵɵrestoreView(_r7).index;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelectMonth(ctx_r1.displayYear, i_r8));
    });
    ɵɵelementStart(1, "span", 13);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const month_r9 = ctx.$implicit;
    const i_r8 = ctx.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r1.getBackgroundColor(i_r8, ctx_r1.displayMonthNumber));
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.getForegroundColor(i_r8, ctx_r1.displayMonthNumber));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", month_r9, " ");
  }
}
function PoCalendarWrapperComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "po-calendar-header", 14);
    ɵɵlistener("p-previous", function PoCalendarWrapperComponent_ng_container_2_Template_po_calendar_header_p_previous_1_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.updateYear(-1));
    })("p-next", function PoCalendarWrapperComponent_ng_container_2_Template_po_calendar_header_p_next_1_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.updateYear(1));
    });
    ɵɵelementStart(2, "span", 4);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_2_Template_span_click_2_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectDisplayMode("year"));
    });
    ɵɵtext(3);
    ɵɵelementEnd()();
    ɵɵelementStart(4, "div", 5)(5, "div", 6)(6, "div", 10);
    ɵɵtext(7);
    ɵɵelementEnd()();
    ɵɵelementStart(8, "div", 15);
    ɵɵtemplate(9, PoCalendarWrapperComponent_ng_container_2_div_9_Template, 3, 3, "div", 16);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ctx_r1.displayYear, " ");
    ɵɵadvance(4);
    ɵɵtextInterpolate1(" ", ctx_r1.monthLabel, " ");
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.displayMonths);
  }
}
function PoCalendarWrapperComponent_ng_container_3_div_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_3_div_8_Template_div_click_0_listener() {
      const year_r12 = ɵɵrestoreView(_r11).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelectYear(year_r12, ctx_r1.displayMonthNumber));
    });
    ɵɵelementStart(1, "span", 13);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const year_r12 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r1.getBackgroundColor(year_r12, ctx_r1.currentYear));
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.getForegroundColor(year_r12, ctx_r1.currentYear));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", year_r12, " ");
  }
}
function PoCalendarWrapperComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "po-calendar-header", 14);
    ɵɵlistener("p-previous", function PoCalendarWrapperComponent_ng_container_3_Template_po_calendar_header_p_previous_1_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.updateYear(-10));
    })("p-next", function PoCalendarWrapperComponent_ng_container_3_Template_po_calendar_header_p_next_1_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.updateYear(10));
    });
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 5)(4, "div", 6)(5, "div", 10);
    ɵɵtext(6);
    ɵɵelementEnd()();
    ɵɵelementStart(7, "div", 18);
    ɵɵtemplate(8, PoCalendarWrapperComponent_ng_container_3_div_8_Template, 3, 3, "div", 19);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate2(" ", ctx_r1.displayStartDecade, " - ", ctx_r1.displayFinalDecade, " ");
    ɵɵadvance(4);
    ɵɵtextInterpolate1(" ", ctx_r1.yearLabel, " ");
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.displayDecade);
  }
}
function PoCalendarWrapperComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 21)(2, "div", 22)(3, "button", 23);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_4_Template_button_click_3_listener() {
      ɵɵrestoreView(_r13);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSelectDate(ctx_r1.today));
    });
    ɵɵtext(4);
    ɵɵelementEnd()()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("disabled", ctx_r1.isTodayUnavailable());
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.displayToday, " ");
  }
}
var PoCalendarWrapperComponent = class _PoCalendarWrapperComponent {
  poCalendarService;
  poCalendarLangService;
  poDate;
  value;
  mode = "day";
  responsive = false;
  partType;
  range = false;
  activateDate = /* @__PURE__ */ new Date();
  selectedValue;
  minDate;
  maxDate;
  hoverValue;
  headerChange = new EventEmitter();
  selectDate = new EventEmitter();
  hoverDate = new Subject().pipe(debounceTime(100));
  currentYear;
  displayDays;
  displayDecade;
  displayFinalDecade;
  displayMonth;
  displayMonthNumber;
  displayMonths = Array();
  displayStartDecade;
  displayWeekDays = Array();
  displayYear;
  displayToday;
  today = /* @__PURE__ */ new Date();
  currentMonthNumber;
  date;
  lastDisplay;
  _locale;
  set locale(value) {
    this._locale = value;
    this.initializeLanguage();
  }
  get locale() {
    return this._locale;
  }
  get monthLabel() {
    return this.poCalendarLangService.getMonthLabel();
  }
  get yearLabel() {
    return this.poCalendarLangService.getYearLabel();
  }
  get isDayVisible() {
    return this.mode === "day";
  }
  get isMonthVisible() {
    return this.mode === "month";
  }
  get isYearVisible() {
    return this.mode === "year";
  }
  get isStartPart() {
    return this.partType === "start";
  }
  get isEndPart() {
    return this.partType === "end";
  }
  constructor(poCalendarService, poCalendarLangService, poDate) {
    this.poCalendarService = poCalendarService;
    this.poCalendarLangService = poCalendarLangService;
    this.poDate = poDate;
  }
  ngOnInit() {
    this.init();
  }
  ngOnChanges(changes) {
    const {
      activateDate
    } = changes;
    if (activateDate) {
      this.updateDate(activateDate.currentValue);
    }
  }
  getBackgroundColor(displayValue, propertyValue) {
    return displayValue === propertyValue ? "po-calendar-box-background-selected" : "po-calendar-box-background";
  }
  getDayBackgroundColor(date) {
    return this.getDayColor(date, "background");
  }
  getDayForegroundColor(date) {
    return this.getDayColor(date, "foreground");
  }
  getForegroundColor(displayValue, propertyValue) {
    return displayValue === propertyValue ? "po-calendar-box-foreground-selected" : "po-calendar-box-foreground";
  }
  isTodayUnavailable() {
    return this.minDate > this.today || this.maxDate < this.today;
  }
  onNextMonth() {
    this.displayMonthNumber < 11 ? this.updateDisplay(this.displayYear, this.displayMonthNumber + 1) : this.updateDisplay(this.displayYear + 1, 0);
    this.headerChange.emit({
      month: this.displayMonthNumber,
      year: this.displayYear
    });
  }
  onPreviousMonth() {
    if (this.displayMonthNumber > 0) {
      this.updateDisplay(this.displayYear, this.displayMonthNumber - 1);
    } else {
      this.updateDisplay(this.displayYear - 1, 11);
    }
    this.headerChange.emit({
      month: this.displayMonthNumber,
      year: this.displayYear
    });
  }
  onMouseEnter(day) {
    this.hoverDate.next(day);
  }
  onMouseLeave() {
    this.hoverDate.next(null);
  }
  // Ao selecionar uma data
  onSelectDate(date) {
    this.selectDate.emit(date);
  }
  // Ao selecionar um mês
  onSelectMonth(year, month) {
    this.selectDisplayMode("day");
    this.updateDisplay(year, month);
    this.headerChange.emit({
      month,
      year
    });
  }
  // Ao selecionar um ano
  onSelectYear(year, month) {
    this.selectDisplayMode(this.lastDisplay === "month" ? "month" : "day");
    this.currentYear = year;
    this.updateDisplay(year, month);
    this.headerChange.emit({
      month,
      year
    });
  }
  selectDisplayMode(mode) {
    this.lastDisplay = this.mode;
    this.mode = mode;
  }
  updateYear(value) {
    this.updateDisplay(this.displayYear + value, this.displayMonthNumber);
  }
  addAllYearsInDecade(year) {
    let i;
    for (i = year; i < year + 10; i++) {
      this.displayDecade.push(i);
    }
  }
  equalsDate(date1, date2) {
    try {
      return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
    } catch (error) {
      return false;
    }
  }
  // Obtém um array de todos os anos desta década
  getDecadeArray(year) {
    this.displayDecade = Array();
    if (year % 10 !== 0) {
      while (year % 10 !== 0) {
        year--;
      }
    }
    this.updateDecade(year);
  }
  getColorForDate(date, local) {
    return this.poDate.validateDateRange(date, this.minDate, this.maxDate) ? `po-calendar-box-${local}-selected` : `po-calendar-box-${local}-selected-disabled`;
  }
  getColorForDefaultDate(date, local) {
    return this.poDate.validateDateRange(date, this.minDate, this.maxDate) ? `po-calendar-box-${local}` : `po-calendar-box-${local}-disabled`;
  }
  getColorForToday(date, local) {
    return this.poDate.validateDateRange(date, this.minDate, this.maxDate) ? `po-calendar-box-${local}-today` : `po-calendar-box-${local}-today-disabled`;
  }
  getColorForDateRange(date, local) {
    return this.poDate.validateDateRange(date, this.minDate, this.maxDate) ? `po-calendar-box-${local}-in-range` : `po-calendar-box-${local}-in-range-disabled`;
  }
  getDayColor(date, local) {
    const start = this.selectedValue?.start;
    const end = this.selectedValue?.end;
    if (this.range && (this.equalsDate(date, start) || this.equalsDate(date, end))) {
      return this.getColorForDate(date, local);
    } else if (this.range && start && end && date > start && date < end) {
      return this.getColorForDateRange(date, local);
    } else if (this.range && start && !end && date > start && date < this.hoverValue) {
      return `po-calendar-box-${local}-hover`;
    } else if (!this.range && this.equalsDate(date, this.value)) {
      return this.getColorForDate(date, local);
    } else if (this.equalsDate(date, this.today)) {
      return this.getColorForToday(date, local);
    } else {
      return this.getColorForDefaultDate(date, local);
    }
  }
  init() {
    this.updateDate(this.activateDate);
    this.initializeLanguage();
    this.selectDisplayMode("day");
  }
  initializeLanguage() {
    this.poCalendarLangService.setLanguage(this.locale);
    this.displayWeekDays = this.poCalendarLangService.getWeekDaysArray();
    this.displayMonths = this.poCalendarLangService.getMonthsArray();
    this.displayMonth = this.displayMonths[this.displayMonthNumber];
    this.displayToday = this.poCalendarLangService.getTodayLabel();
  }
  updateDate(value = /* @__PURE__ */ new Date()) {
    const date = new Date(value);
    this.currentMonthNumber = date.getMonth();
    this.currentYear = date.getFullYear();
    this.updateDisplay(this.currentYear, this.currentMonthNumber);
  }
  updateDecade(year) {
    this.addAllYearsInDecade(year);
    this.displayStartDecade = year;
    this.displayFinalDecade = year + 9;
  }
  updateDisplay(year, month) {
    const calendarArray = this.poCalendarService.monthDays(year, month);
    this.displayDays = [].concat.apply([], calendarArray);
    this.displayMonthNumber = month;
    this.displayMonth = this.displayMonths[month];
    this.displayYear = year;
    this.getDecadeArray(year);
  }
  static ɵfac = function PoCalendarWrapperComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCalendarWrapperComponent)(ɵɵdirectiveInject(PoCalendarService), ɵɵdirectiveInject(PoCalendarLangService), ɵɵdirectiveInject(PoDateService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoCalendarWrapperComponent,
    selectors: [["po-calendar-wrapper"]],
    inputs: {
      value: [0, "p-value", "value"],
      mode: [0, "p-mode", "mode"],
      responsive: [0, "p-responsive", "responsive"],
      partType: [0, "p-part-type", "partType"],
      range: [0, "p-range", "range"],
      activateDate: [0, "p-activate-date", "activateDate"],
      selectedValue: [0, "p-selected-value", "selectedValue"],
      minDate: [0, "p-min-date", "minDate"],
      maxDate: [0, "p-max-date", "maxDate"],
      hoverValue: [0, "p-hover-value", "hoverValue"],
      locale: [0, "p-locale", "locale"]
    },
    outputs: {
      headerChange: "p-header-change",
      selectDate: "p-select-date",
      hoverDate: "p-hover-date"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoCalendarService]), ɵɵNgOnChangesFeature],
    decls: 5,
    vars: 4,
    consts: [[1, "po-calendar-wrapper"], [4, "ngIf"], [3, "p-previous", "p-next", "p-hide-previous", "p-hide-next"], [1, "po-clickable", "po-mr-1", 3, "click"], [1, "po-clickable", 3, "click"], [1, "po-calendar-content"], [1, "po-calendar-labels"], ["class", "po-calendar-label", 4, "ngFor", "ngForOf"], [1, "po-calendar-content-list-day"], ["class", "po-calendar-day", "attr-calendar", "", 3, "ngClass", "click", "mouseenter", "mouseleave", 4, "ngFor", "ngForOf"], [1, "po-calendar-label"], ["attr-calendar", "", 1, "po-calendar-day", 3, "click", "mouseenter", "mouseleave", "ngClass"], [3, "ngClass", 4, "ngIf"], [3, "ngClass"], [3, "p-previous", "p-next"], [1, "po-calendar-content-list-month"], ["class", "po-calendar-month", "attr-calendar", "", 3, "ngClass", "click", 4, "ngFor", "ngForOf"], ["attr-calendar", "", 1, "po-calendar-month", 3, "click", "ngClass"], [1, "po-calendar-content-list-year"], ["class", "po-calendar-year", "attr-calendar", "", 3, "ngClass", "click", 4, "ngFor", "ngForOf"], ["attr-calendar", "", 1, "po-calendar-year", 3, "click", "ngClass"], [1, "po-calendar-footer"], [1, "po-calendar-footer-today"], ["type", "button", 1, "po-calendar-footer-today-button", 3, "click", "disabled"]],
    template: function PoCalendarWrapperComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoCalendarWrapperComponent_ng_container_1_Template, 11, 6, "ng-container", 1)(2, PoCalendarWrapperComponent_ng_container_2_Template, 10, 3, "ng-container", 1)(3, PoCalendarWrapperComponent_ng_container_3_Template, 9, 4, "ng-container", 1)(4, PoCalendarWrapperComponent_ng_container_4_Template, 5, 2, "ng-container", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isDayVisible);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isMonthVisible);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isYearVisible);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.range);
      }
    },
    dependencies: [NgClass, NgForOf, NgIf, PoCalendarHeaderComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarWrapperComponent, [{
    type: Component,
    args: [{
      selector: "po-calendar-wrapper",
      providers: [PoCalendarService],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<div class="po-calendar-wrapper">
  <ng-container *ngIf="isDayVisible">
    <po-calendar-header
      [p-hide-previous]="isEndPart"
      [p-hide-next]="isStartPart && !responsive"
      (p-previous)="onPreviousMonth()"
      (p-next)="onNextMonth()"
    >
      <span class="po-clickable po-mr-1" (click)="selectDisplayMode('month')">{{ displayMonth }}</span>
      <span class="po-clickable" (click)="selectDisplayMode('year')">{{ displayYear }}</span>
    </po-calendar-header>

    <div class="po-calendar-content">
      <div class="po-calendar-labels">
        <div class="po-calendar-label" *ngFor="let weekDay of displayWeekDays">
          {{ weekDay }}
        </div>
      </div>

      <div class="po-calendar-content-list-day">
        <div
          *ngFor="let day of displayDays"
          class="po-calendar-day"
          [ngClass]="getDayBackgroundColor(day)"
          (click)="onSelectDate(day)"
          (mouseenter)="onMouseEnter(day)"
          (mouseleave)="onMouseLeave()"
          attr-calendar
        >
          <span *ngIf="day !== 0" [ngClass]="getDayForegroundColor(day)">
            {{ day.getDate() }}
          </span>
        </div>
      </div>
    </div>
  </ng-container>

  <ng-container *ngIf="isMonthVisible">
    <po-calendar-header (p-previous)="updateYear(-1)" (p-next)="updateYear(1)">
      <span class="po-clickable" (click)="selectDisplayMode('year')">
        {{ displayYear }}
      </span>
    </po-calendar-header>

    <div class="po-calendar-content">
      <div class="po-calendar-labels">
        <div class="po-calendar-label">
          {{ monthLabel }}
        </div>
      </div>
      <div class="po-calendar-content-list-month">
        <div
          *ngFor="let month of displayMonths; let i = index"
          class="po-calendar-month"
          [ngClass]="getBackgroundColor(i, displayMonthNumber)"
          (click)="onSelectMonth(displayYear, i)"
          attr-calendar
        >
          <span [ngClass]="getForegroundColor(i, displayMonthNumber)">
            {{ month }}
          </span>
        </div>
      </div>
    </div>
  </ng-container>

  <ng-container *ngIf="isYearVisible">
    <po-calendar-header (p-previous)="updateYear(-10)" (p-next)="updateYear(10)">
      {{ displayStartDecade }} - {{ displayFinalDecade }}
    </po-calendar-header>

    <div class="po-calendar-content">
      <div class="po-calendar-labels">
        <div class="po-calendar-label">
          {{ yearLabel }}
        </div>
      </div>

      <div class="po-calendar-content-list-year">
        <div
          *ngFor="let year of displayDecade; let i = index"
          class="po-calendar-year"
          [ngClass]="getBackgroundColor(year, currentYear)"
          (click)="onSelectYear(year, displayMonthNumber)"
          attr-calendar
        >
          <span [ngClass]="getForegroundColor(year, currentYear)">
            {{ year }}
          </span>
        </div>
      </div>
    </div>
  </ng-container>

  <ng-container *ngIf="!range">
    <div class="po-calendar-footer">
      <div class="po-calendar-footer-today">
        <button
          type="button"
          class="po-calendar-footer-today-button"
          (click)="onSelectDate(today)"
          [disabled]="isTodayUnavailable()"
        >
          {{ displayToday }}
        </button>
      </div>
    </div>
  </ng-container>
</div>
`
    }]
  }], () => [{
    type: PoCalendarService
  }, {
    type: PoCalendarLangService
  }, {
    type: PoDateService
  }], {
    value: [{
      type: Input,
      args: ["p-value"]
    }],
    mode: [{
      type: Input,
      args: ["p-mode"]
    }],
    responsive: [{
      type: Input,
      args: ["p-responsive"]
    }],
    partType: [{
      type: Input,
      args: ["p-part-type"]
    }],
    range: [{
      type: Input,
      args: ["p-range"]
    }],
    activateDate: [{
      type: Input,
      args: ["p-activate-date"]
    }],
    selectedValue: [{
      type: Input,
      args: ["p-selected-value"]
    }],
    minDate: [{
      type: Input,
      args: ["p-min-date"]
    }],
    maxDate: [{
      type: Input,
      args: ["p-max-date"]
    }],
    hoverValue: [{
      type: Input,
      args: ["p-hover-value"]
    }],
    headerChange: [{
      type: Output,
      args: ["p-header-change"]
    }],
    selectDate: [{
      type: Output,
      args: ["p-select-date"]
    }],
    hoverDate: [{
      type: Output,
      args: ["p-hover-date"]
    }],
    locale: [{
      type: Input,
      args: ["p-locale"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCalendarWrapperComponent, {
    className: "PoCalendarWrapperComponent",
    filePath: "lib/components/po-calendar/po-calendar-wrapper/po-calendar-wrapper.component.ts",
    lineNumber: 17
  });
})();
var _c0$1x = () => ({
  partType: "start"
});
var _c1$C = () => ({
  partType: "end"
});
function PoCalendarComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoCalendarComponent_ng_template_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoCalendarComponent_ng_template_1_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoCalendarComponent_ng_template_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoCalendarComponent_ng_template_1_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const calendarWrapper_r1 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", calendarWrapper_r1)("ngTemplateOutletContext", ɵɵpureFunction0(2, _c1$C));
  }
}
function PoCalendarComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtemplate(1, PoCalendarComponent_ng_template_1_ng_container_1_Template, 1, 0, "ng-container", 5)(2, PoCalendarComponent_ng_template_1_ng_container_2_Template, 2, 3, "ng-container", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const calendarWrapper_r1 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", calendarWrapper_r1)("ngTemplateOutletContext", ɵɵpureFunction0(3, _c0$1x));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isResponsive);
  }
}
function PoCalendarComponent_ng_template_3_ng_template_1_Template(rf, ctx) {
}
function PoCalendarComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, PoCalendarComponent_ng_template_3_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const calendarWrapper_r1 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", calendarWrapper_r1);
  }
}
function PoCalendarComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-calendar-wrapper", 9);
    ɵɵlistener("p-header-change", function PoCalendarComponent_ng_template_5_Template_po_calendar_wrapper_p_header_change_0_listener($event) {
      const partType_r4 = ɵɵrestoreView(_r3).partType;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onHeaderChange($event, partType_r4));
    })("p-select-date", function PoCalendarComponent_ng_template_5_Template_po_calendar_wrapper_p_select_date_0_listener($event) {
      const partType_r4 = ɵɵrestoreView(_r3).partType;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSelectDate($event, partType_r4));
    })("p-hover-date", function PoCalendarComponent_ng_template_5_Template_po_calendar_wrapper_p_hover_date_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onHoverDate($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const partType_r4 = ctx.partType;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-value", ctx_r1.getValue(partType_r4))("p-activate-date", ctx_r1.getActivateDate(partType_r4))("p-locale", ctx_r1.locale)("p-min-date", ctx_r1.minDate)("p-max-date", ctx_r1.maxDate)("p-part-type", partType_r4)("p-range", ctx_r1.isRange)("p-responsive", ctx_r1.isResponsive)("p-selected-value", ctx_r1.value)("p-hover-value", ctx_r1.hoverValue);
  }
}
var providers$6 = [{
  provide: NG_VALUE_ACCESSOR,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoCalendarComponent),
  multi: true
}, {
  provide: NG_VALIDATORS,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoCalendarComponent),
  multi: true
}];
var poCalendarRangeWidth = 600;
var PoCalendarComponent = class _PoCalendarComponent extends PoCalendarBaseComponent {
  changeDetector;
  hoverValue;
  constructor(changeDetector, poDate, languageService) {
    super(poDate, languageService);
    this.changeDetector = changeDetector;
  }
  get isResponsive() {
    return window.innerWidth < poCalendarRangeWidth;
  }
  ngOnInit() {
    this.setActivateDate();
  }
  ngOnChanges(changes) {
    if (changes.minDate || changes.maxDate) {
      this.setActivateDate();
    }
  }
  getActivateDate(partType) {
    if (this.isRange && this.activateDate) {
      return this.activateDate[partType];
    } else {
      return this.activateDate;
    }
  }
  getValue(partType) {
    if (this.isRange && this.value) {
      return this.value[partType];
    } else {
      return this.value;
    }
  }
  onSelectDate(selectedDate, partType) {
    let newValue;
    if (this.isRange) {
      newValue = this.getValueFromSelectedDate(selectedDate);
      if (partType === "end" && (!this.value?.start || this.value.start && this.value.end)) {
        this.setActivateDate(selectedDate);
      }
    } else {
      newValue = selectedDate;
      this.setActivateDate(selectedDate);
    }
    this.value = newValue;
    const newModel = this.convertDateToISO(this.value);
    this.updateModel(newModel);
    this.change.emit(newModel);
  }
  onHoverDate(date) {
    this.hoverValue = date;
  }
  onHeaderChange({
    month,
    year
  }, partType) {
    if (this.isRange) {
      let newStart;
      let newEnd;
      const {
        start,
        end
      } = this.activateDate;
      if (partType === "end") {
        const newYear = month === 0 ? year - 1 : year;
        const daysInMonth = new Date(newYear, month, 0).getDate();
        if (year !== newYear) {
          newStart = new Date(year, month - 1, Math.min(start.getDate(), daysInMonth));
          newEnd = new Date(year, month, Math.min(end.getDate(), daysInMonth));
        } else {
          newStart = new Date(newYear, month - 1, Math.min(start.getDate(), daysInMonth));
          newEnd = new Date(newYear, month, Math.min(end.getDate(), daysInMonth));
        }
      } else {
        const newYear = month === 11 ? year + 1 : year;
        const daysInMonth = new Date(newYear, month + 1, 0).getDate();
        if (year !== newYear) {
          newEnd = new Date(year, month + 1, Math.min(end.getDate(), daysInMonth));
          newStart = new Date(year, month, Math.min(start.getDate(), daysInMonth));
        } else {
          newEnd = new Date(newYear, month + 1, Math.min(end.getDate(), daysInMonth));
          newStart = new Date(newYear, month, Math.min(start.getDate(), daysInMonth));
        }
      }
      this.activateDate = {
        start: newStart,
        end: newEnd
      };
    }
  }
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  registerOnTouched(func) {
    this.onTouched = func;
  }
  validate(c) {
    return null;
  }
  writeValue(value) {
    if (value) {
      this.writeDate(value);
    } else {
      this.value = null;
    }
    const activateDate = this.getValidateStartDate(value);
    this.setActivateDate(activateDate);
    this.changeDetector.markForCheck();
  }
  getValidateStartDate(value) {
    if (this.isRange) {
      return value?.start || null;
    } else if (value instanceof Date || typeof value === "string") {
      return value;
    }
    return null;
  }
  getValueFromSelectedDate(selectedDate) {
    if (!this.value?.start || this.value.start > selectedDate || this.value.end && this.value.start) {
      return {
        start: new Date(selectedDate),
        end: null
      };
    }
    return {
      start: new Date(this.value.start),
      end: new Date(selectedDate)
    };
  }
  convertDateToISO(date) {
    if (this.isRange) {
      const start = date?.start instanceof Date ? this.poDate.convertDateToISO(date.start) : null;
      const end = date?.end instanceof Date ? this.poDate.convertDateToISO(date.end) : null;
      return {
        start,
        end
      };
    } else {
      return this.poDate.convertDateToISO(date);
    }
  }
  convertDateFromIso(stringDate) {
    if (stringDate && typeof stringDate === "string") {
      const {
        year,
        month,
        day
      } = this.poDate.getDateFromIso(stringDate);
      const date = new Date(year, month - 1, day);
      this.poDate.setYearFrom0To100(date, year);
      return date;
    }
    return null;
  }
  updateModel(value) {
    if (this.propagateChange) {
      this.propagateChange(value);
    }
  }
  writeDate(value) {
    if (this.isRange) {
      const start = value?.start;
      const end = value?.end;
      const newStart = start instanceof Date ? new Date(start) : this.convertDateFromIso(start);
      const newEnd = end instanceof Date ? new Date(end) : this.convertDateFromIso(end);
      this.value = {
        start: newStart,
        end: newEnd
      };
    } else {
      this.value = value instanceof Date ? new Date(value) : this.convertDateFromIso(value);
    }
  }
  static ɵfac = function PoCalendarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCalendarComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoCalendarComponent,
    selectors: [["po-calendar"]],
    standalone: false,
    features: [ɵɵProvidersFeature(providers$6), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 7,
    vars: 3,
    consts: [["rangeTemplate", ""], ["calendarTemplate", ""], ["calendarWrapper", ""], [4, "ngIf", "ngIfThen", "ngIfElse"], [1, "po-calendar-range"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngIf"], [1, "po-calendar"], [3, "ngTemplateOutlet"], [3, "p-header-change", "p-select-date", "p-hover-date", "p-value", "p-activate-date", "p-locale", "p-min-date", "p-max-date", "p-part-type", "p-range", "p-responsive", "p-selected-value", "p-hover-value"]],
    template: function PoCalendarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoCalendarComponent_ng_container_0_Template, 1, 0, "ng-container", 3)(1, PoCalendarComponent_ng_template_1_Template, 3, 4, "ng-template", null, 0, ɵɵtemplateRefExtractor)(3, PoCalendarComponent_ng_template_3_Template, 2, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor)(5, PoCalendarComponent_ng_template_5_Template, 1, 10, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const rangeTemplate_r5 = ɵɵreference(2);
        const calendarTemplate_r6 = ɵɵreference(4);
        ɵɵproperty("ngIf", ctx.isRange)("ngIfThen", rangeTemplate_r5)("ngIfElse", calendarTemplate_r6);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, PoCalendarWrapperComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarComponent, [{
    type: Component,
    args: [{
      selector: "po-calendar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: providers$6,
      standalone: false,
      template: `<ng-container *ngIf="isRange; then rangeTemplate; else calendarTemplate"></ng-container>

<ng-template #rangeTemplate>
  <div class="po-calendar-range">
    <ng-container *ngTemplateOutlet="calendarWrapper; context: { partType: 'start' }"></ng-container>
    <ng-container *ngIf="!isResponsive">
      <ng-container *ngTemplateOutlet="calendarWrapper; context: { partType: 'end' }"></ng-container>
    </ng-container>
  </div>
</ng-template>
<ng-template #calendarTemplate>
  <div class="po-calendar">
    <ng-template [ngTemplateOutlet]="calendarWrapper"></ng-template>
  </div>
</ng-template>

<ng-template #calendarWrapper let-partType="partType">
  <po-calendar-wrapper
    [p-value]="getValue(partType)"
    [p-activate-date]="getActivateDate(partType)"
    [p-locale]="locale"
    [p-min-date]="minDate"
    [p-max-date]="maxDate"
    [p-part-type]="partType"
    [p-range]="isRange"
    [p-responsive]="isResponsive"
    [p-selected-value]="value"
    [p-hover-value]="hoverValue"
    (p-header-change)="onHeaderChange($event, partType)"
    (p-select-date)="onSelectDate($event, partType)"
    (p-hover-date)="onHoverDate($event)"
  >
  </po-calendar-wrapper>
</ng-template>
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: PoDateService
  }, {
    type: PoLanguageService
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCalendarComponent, {
    className: "PoCalendarComponent",
    filePath: "lib/components/po-calendar/po-calendar.component.ts",
    lineNumber: 62
  });
})();
var PoCalendarModule = class _PoCalendarModule {
  static ɵfac = function PoCalendarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCalendarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoCalendarModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoIconModule],
      declarations: [PoCalendarComponent, PoCalendarHeaderComponent, PoCalendarWrapperComponent],
      exports: [PoCalendarComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoCalendarModule, {
    declarations: [PoCalendarComponent, PoCalendarHeaderComponent, PoCalendarWrapperComponent],
    imports: [CommonModule, PoIconModule],
    exports: [PoCalendarComponent]
  });
})();
var PoChartType;
(function(PoChartType2) {
  PoChartType2["Area"] = "area";
  PoChartType2["Donut"] = "donut";
  PoChartType2["Pie"] = "pie";
  PoChartType2["Line"] = "line";
  PoChartType2["Column"] = "column";
  PoChartType2["Bar"] = "bar";
})(PoChartType || (PoChartType = {}));
var PoChartPadding = 24;
var PoChartAxisXLabelArea = 56;
var PoChartGridLines = 5;
var PoChartPlotAreaPaddingTop = 8;
var PoChartStartAngle = -Math.PI / 2;
var PoChartDonutDefaultThickness = 40;
var PoChartCompleteCircle = 1e-4;
var durationTime = 1500;
var PoChartAngleStepInterval = Math.PI * 2 / Math.floor(durationTime / 60);
var PoChartMathsService = class _PoChartMathsService {
  /**
   * Calcula e retorna os válores mínimo e máximo das séries.
   *
   * @param series Lista de séries.
   * @param acceptNegativeValues boolean.
   */
  calculateMinAndMaxValues(series, acceptNegativeValues = true) {
    const minValue = this.getDomain(series, "min");
    const maxValue = this.getDomain(series, "max");
    return {
      minValue: !acceptNegativeValues && minValue < 0 ? 0 : minValue,
      maxValue: acceptNegativeValues && maxValue < 0 ? 0 : maxValue
    };
  }
  /**
   * Retorna o valor com maior quantidade de dígitos entre todas as séries.
   * Pode receber uma lista de categorias para o caso de gráfico de barra, ou então a lista de séries se o tipo de gráfico for linha ou coluna.
   *
   * @param data Lista de séries.
   * @param type O tipo do gráfico'.
   * @param options As opções para validação de número de linhas do eixo X'.
   */
  getLongestDataValue(data = [], type, options) {
    if (type === PoChartType.Bar) {
      return this.getLongestData(data);
    } else {
      return this.getAxisXLabelLongestValue(data, this.amountOfGridLines(options?.axis));
    }
  }
  /**
   * Retorna o tamanho da série que tiver mais itens.
   *
   * @param series Lista de séries.
   */
  seriesGreaterLength(series) {
    return series.reduce((result, serie) => result > serie.data.length ? result : serie.data.length, 0);
  }
  /**
   * Retorna o percentual em decimal da série passada pela distância entre os valores mínimos e máximos da série.
   *
   * Se o valor mínimo for negativo o alcance partirá dele como sendo zero %.
   *
   * Por exemplo:
   *    minValue = -10;
   *    maxValue = 0;
   *    serieValue = -8
   *    O resultado será de 0.20;
   *
   * @param minMaxValues Objeto contendo os valores mínimo e máximo de todas as séries.
   * @param serieValue O valor da série.
   */
  getSeriePercentage(minMaxValues, serieValue) {
    const {
      minValue,
      maxValue
    } = minMaxValues;
    const range = maxValue - minValue;
    const displacement = serieValue - minValue;
    const result = displacement / range;
    return isNaN(result) ? 0 : result;
  }
  /**
   * Calcula e retorna uma lista de valores referentes aos textos dos eixos X em relação à quantidade de linhas horizontais.
   *
   * @param minMaxValues Objeto contendo os valores mínimo e máximo de todas as séries.
   * @param gridLines Quantidade de linhas horizontais. Valor default é 5.
   */
  range(minMaxValues, gridLines = 5) {
    const {
      minValue,
      maxValue
    } = minMaxValues;
    const result = [];
    const step = this.getGridLineArea(minMaxValues, gridLines);
    for (let index = minValue; index <= maxValue; index = (index * 10 + step * 10) / 10) {
      result.push(index);
    }
    return result;
  }
  /**
   *
   * Verifica se o valor passado é um Integer ou Float.
   *
   * @param number O valor a ser validado
   */
  verifyIfFloatOrInteger(number) {
    const notABoolean = typeof number !== "boolean";
    const notInfinity = number !== Infinity;
    const isInteger = Number(number) === number && number % 1 === 0 && notInfinity;
    const isFloat = Number(number) === number && number % 1 !== 0 && notInfinity;
    return notABoolean && isInteger || notABoolean && isFloat;
  }
  amountOfGridLines(options) {
    const gridLines = options?.gridLines ?? PoChartGridLines;
    return gridLines && gridLines >= 2 && gridLines <= 10 ? gridLines : PoChartGridLines;
  }
  getAxisXLabelLongestValue(data, gridLines) {
    const allowNegativeData = data.every((dataItem) => dataItem.type === PoChartType.Line);
    const domain = this.calculateMinAndMaxValues(data, allowNegativeData);
    const axisXLabelsList = this.range(domain, gridLines);
    return this.getLongestData(axisXLabelsList);
  }
  // Cálculo que retorna o valor obtido de gridLines em relação ao alcance dos valores mínimos e máximos das séries (maxMinValues)
  getGridLineArea(minMaxValues, gridLines) {
    const percentageValue = this.getFractionFromInt(gridLines - 1);
    const {
      minValue,
      maxValue
    } = minMaxValues;
    const result = percentageValue * (maxValue - minValue) / 100;
    return result === 0 ? 1 : result;
  }
  // Retorna o valor máximo ou mínimo das séries baseado no tipo passado(type).
  getDomain(series, type) {
    const result = Math[type](...series.map((serie) => {
      if (Array.isArray(serie.data)) {
        return Math[type](...serie.data);
      }
    }));
    return isNaN(result) ? 0 : result;
  }
  // Retorna a fração do número passado referente à quantidade de linhas no eixo X (gridLines)
  getFractionFromInt(value) {
    return 1 / value * (100 / 1);
  }
  getLongestData(serie) {
    const newSerie = [...serie];
    return newSerie.sort((longest, current) => current.toString().length - longest.toString().length)["0"];
  }
  static ɵfac = function PoChartMathsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartMathsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoChartMathsService,
    factory: _PoChartMathsService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartMathsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _c0$1w = ["chartLine"];
var PoChartLineBaseComponent = class _PoChartLineBaseComponent {
  mathsService;
  renderer;
  elementRef;
  alignByTheCorners = false;
  categories;
  categoriesCoordinates;
  svgSpace;
  dataLabel;
  insideChart;
  pointClick = new EventEmitter();
  pointHover = new EventEmitter();
  chartLine;
  activeTooltip;
  animate = true;
  chartType;
  seriesPathsCoordinates;
  seriesPointsCoordinates = [];
  firstValidItemFromSerieArray;
  seriesLength;
  _containerSize = {};
  _range = {};
  _series = [];
  set range(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._range = value;
      this.seriePathPointsDefinition(this.containerSize, this._series, this._range);
    }
  }
  get range() {
    return this._range;
  }
  set containerSize(value) {
    this._containerSize = value;
    this.seriePathPointsDefinition(this._containerSize, this.series, this.range);
  }
  get containerSize() {
    return this._containerSize;
  }
  set series(seriesList) {
    const seriesDataArrayFilter = seriesList.filter((serie) => Array.isArray(serie.data));
    if (seriesDataArrayFilter.length) {
      this._series = seriesDataArrayFilter;
      this.animate = true;
      this.seriesLength = this.mathsService.seriesGreaterLength(this.series);
      this.chartType = this._series[0].type;
      this.seriePathPointsDefinition(this.containerSize, seriesDataArrayFilter, this.range);
    } else {
      this._series = [];
    }
  }
  get series() {
    return this._series;
  }
  constructor(mathsService, renderer, elementRef) {
    this.mathsService = mathsService;
    this.renderer = renderer;
    this.elementRef = elementRef;
  }
  onSeriePointClick(selectedItem) {
    this.pointClick.emit(selectedItem);
  }
  trackBy(index) {
    return index;
  }
  getTooltipLabel(data, label, tooltipLabel) {
    const dataLabel = label ? `${label}: ` : "";
    const dataValue = data.toString();
    return tooltipLabel || `${dataLabel}${dataValue}`;
  }
  svgPathCommand() {
    const command = this.firstValidItemFromSerieArray ? "M" : "L";
    this.firstValidItemFromSerieArray = false;
    return command;
  }
  xCoordinate(index, containerSize) {
    const halfCategoryWidth = !this.alignByTheCorners ? (containerSize.svgWidth - containerSize.axisXLabelWidth) / this.seriesLength / 2 : 0;
    const divideIndexBySeriesLength = index / (this.alignByTheCorners ? this.seriesLength - 1 : this.seriesLength);
    const xRatio = isNaN(divideIndexBySeriesLength) ? 0 : divideIndexBySeriesLength;
    return Math.floor(containerSize.axisXLabelWidth + halfCategoryWidth + (containerSize.svgWidth - containerSize.axisXLabelWidth) * xRatio);
  }
  serieCategory(index, categories = []) {
    return categories[index] ?? void 0;
  }
  seriePathPointsDefinition(containerSize, series, range) {
    this.seriesPointsCoordinates = [];
    this.seriesPathsCoordinates = series.map((serie) => {
      if (Array.isArray(serie.data)) {
        let pathCoordinates = "";
        let pointCoordinates = [];
        const color = serie.color;
        this.firstValidItemFromSerieArray = true;
        serie.data.forEach((data, index) => {
          if (this.mathsService.verifyIfFloatOrInteger(data)) {
            const svgPathCommand = this.svgPathCommand();
            const xCoordinate = this.xCoordinate(index, containerSize);
            const yCoordinate = this.yCoordinate(range, data, containerSize);
            const category = this.serieCategory(index, this.categories);
            const label = serie.label;
            const tooltip = serie.tooltip;
            const tooltipLabel = this.getTooltipLabel(data, label, tooltip);
            const isActive = this.chartType === PoChartType.Line;
            pointCoordinates = [...pointCoordinates, {
              category,
              label,
              tooltipLabel,
              data,
              xCoordinate,
              yCoordinate,
              color,
              isActive,
              isFixed: this.dataLabel?.fixed
            }];
            pathCoordinates += ` ${svgPathCommand}${xCoordinate} ${yCoordinate}`;
          }
        });
        pathCoordinates = this.verifyIfClosePath(pathCoordinates, serie.data.length - 1, range, 0, containerSize);
        this.seriesPointsCoordinates = [...this.seriesPointsCoordinates, pointCoordinates];
        return {
          coordinates: pathCoordinates,
          color,
          isActive: true,
          isFixed: this.dataLabel?.fixed
        };
      }
    });
  }
  verifyIfClosePath(pathCoordinates, lastIndex, range, data, containerSize) {
    const {
      axisXLabelWidth,
      svgWidth
    } = containerSize;
    if (this.chartType === PoChartType.Area) {
      const xLastPosition = this.xCoordinate(lastIndex, containerSize);
      const baseYCoordinate = this.yCoordinate(range, data, containerSize);
      const xInitialPosition = Math.floor(this.alignByTheCorners ? axisXLabelWidth : axisXLabelWidth + (svgWidth - axisXLabelWidth) / this.seriesLength / 2);
      return `${pathCoordinates} ${xLastPosition} ${baseYCoordinate} L${xInitialPosition} ${baseYCoordinate} Z`;
    }
    return pathCoordinates;
  }
  yCoordinate(range, data, containerSize) {
    const yRratio = this.mathsService.getSeriePercentage(range, data);
    const yCoordinate = containerSize.svgPlottingAreaHeight - containerSize.svgPlottingAreaHeight * yRratio + PoChartPlotAreaPaddingTop;
    return Math.floor(yCoordinate);
  }
  static ɵfac = function PoChartLineBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartLineBaseComponent)(ɵɵdirectiveInject(PoChartMathsService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoChartLineBaseComponent,
    viewQuery: function PoChartLineBaseComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1w, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartLine = _t.first);
      }
    },
    inputs: {
      alignByTheCorners: [0, "p-align-by-the-corners", "alignByTheCorners"],
      categories: [0, "p-categories", "categories"],
      categoriesCoordinates: [0, "p-categories-coordinates", "categoriesCoordinates"],
      svgSpace: [0, "p-svg-space", "svgSpace"],
      dataLabel: [0, "p-data-label", "dataLabel"],
      insideChart: [0, "p-insideChart", "insideChart"],
      range: [0, "p-range", "range"],
      containerSize: [0, "p-container-size", "containerSize"],
      series: [0, "p-series", "series"]
    },
    outputs: {
      pointClick: "p-point-click",
      pointHover: "p-point-hover"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartLineBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoChartMathsService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    alignByTheCorners: [{
      type: Input,
      args: ["p-align-by-the-corners"]
    }],
    categories: [{
      type: Input,
      args: ["p-categories"]
    }],
    categoriesCoordinates: [{
      type: Input,
      args: ["p-categories-coordinates"]
    }],
    svgSpace: [{
      type: Input,
      args: ["p-svg-space"]
    }],
    dataLabel: [{
      type: Input,
      args: ["p-data-label"]
    }],
    insideChart: [{
      type: Input,
      args: ["p-insideChart"]
    }],
    pointClick: [{
      type: Output,
      args: ["p-point-click"]
    }],
    pointHover: [{
      type: Output,
      args: ["p-point-hover"]
    }],
    chartLine: [{
      type: ViewChild,
      args: ["chartLine"]
    }],
    range: [{
      type: Input,
      args: ["p-range"]
    }],
    containerSize: [{
      type: Input,
      args: ["p-container-size"]
    }],
    series: [{
      type: Input,
      args: ["p-series"]
    }]
  });
})();
var _c0$1v = ["chartPath"];
var _c1$B = ["po-chart-path", ""];
var pathDashoffsetDefaultWidth = 0;
var PoChartPathComponent = class _PoChartPathComponent {
  changeDetector;
  isActive = true;
  chartLine = false;
  coordinates;
  chartPath;
  pathWidth;
  _animate;
  _color;
  set color(value) {
    this._color = value.includes("po-color") && this.chartLine ? value.replace("po-color", "po-border-color") : value;
  }
  get color() {
    return this._color;
  }
  set animate(value) {
    this._animate = value;
    if (!this.animate) {
      this.pathWidth = pathDashoffsetDefaultWidth;
    }
  }
  get animate() {
    return this._animate;
  }
  constructor(changeDetector) {
    this.changeDetector = changeDetector;
  }
  ngAfterViewInit() {
    if (!isIE()) {
      this.pathAnimation();
    }
  }
  pathAnimation() {
    this.pathWidth = this.chartPath.nativeElement.getTotalLength();
    this.changeDetector.detectChanges();
    setTimeout(this.preventsAnimatingAgain.bind(this), 700);
  }
  // Redefine pathWidth para zero após o período da animação para que a linha se expanda normalmente on resize.
  preventsAnimatingAgain() {
    this.pathWidth = pathDashoffsetDefaultWidth;
  }
  static ɵfac = function PoChartPathComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartPathComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartPathComponent,
    selectors: [["", "po-chart-path", ""]],
    viewQuery: function PoChartPathComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1v, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartPath = _t.first);
      }
    },
    inputs: {
      isActive: [2, "p-is-active", "isActive", convertToBoolean],
      chartLine: [2, "p-chart-line", "chartLine", convertToBoolean],
      coordinates: [0, "p-coordinates", "coordinates"],
      color: [0, "p-color", "color"],
      animate: [0, "p-animate", "animate"]
    },
    standalone: false,
    features: [ɵɵInputTransformsFeature],
    attrs: _c1$B,
    decls: 2,
    vars: 11,
    consts: [["chartPath", ""], [1, "po-chart-path"]],
    template: function PoChartPathComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelement(0, "path", 1, 0);
      }
      if (rf & 2) {
        ɵɵclassMap((ctx.color == null ? null : ctx.color.includes("po-border-color")) || (ctx.color == null ? null : ctx.color.includes("po-color")) ? ctx.color : "");
        ɵɵclassProp("po-chart-active-path", ctx.isActive)("po-chart-line-path", ctx.chartLine);
        ɵɵattribute("fill", ctx.chartLine ? "none" : ctx.color)("stroke-dasharray", ctx.pathWidth)("stroke-dashoffset", ctx.pathWidth)("stroke", ctx.chartLine ? ctx.color : "")("d", ctx.coordinates);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartPathComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-path]",
      standalone: false,
      template: `<svg:path #chartPath
  class="po-chart-path"
  [class.po-chart-active-path]="isActive"
  [class.po-chart-line-path]="chartLine"
  [class]="color?.includes('po-border-color') || color?.includes('po-color') ? color : ''"
  [attr.fill]="chartLine ? 'none' : color"
  [attr.stroke-dasharray]="pathWidth"
  [attr.stroke-dashoffset]="pathWidth"
  [attr.stroke]="chartLine ? color : ''"
  [attr.d]="coordinates">
</svg:path> `
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    isActive: [{
      type: Input,
      args: [{
        alias: "p-is-active",
        transform: convertToBoolean
      }]
    }],
    chartLine: [{
      type: Input,
      args: [{
        alias: "p-chart-line",
        transform: convertToBoolean
      }]
    }],
    coordinates: [{
      type: Input,
      args: ["p-coordinates"]
    }],
    chartPath: [{
      type: ViewChild,
      args: ["chartPath", {
        static: true
      }]
    }],
    color: [{
      type: Input,
      args: ["p-color"]
    }],
    animate: [{
      type: Input,
      args: ["p-animate"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartPathComponent, {
    className: "PoChartPathComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-line/po-chart-path/po-chart-path.component.ts",
    lineNumber: 12
  });
})();
var _c0$1u = ["po-chart-series-point", ""];
function PoChartSeriesPointComponent__svg_circle_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "circle", 2);
    ɵɵlistener("click", function PoChartSeriesPointComponent__svg_circle_0_Template_circle_click_0_listener() {
      const item_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onClick(item_r2));
    })("mouseenter", function PoChartSeriesPointComponent__svg_circle_0_Template_circle_mouseenter_0_listener($event) {
      const item_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onMouseEnter($event, item_r2));
    })("mouseleave", function PoChartSeriesPointComponent__svg_circle_0_Template_circle_mouseleave_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onMouseLeave($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap((ctx_r2.strokeColor == null ? null : ctx_r2.strokeColor.includes("po-border-color")) ? ctx_r2.strokeColor : "");
    ɵɵclassProp("po-chart-active-point", item_r2.isActive);
    ɵɵproperty("p-tooltip", !item_r2.isFixed ? item_r2.tooltipLabel : null)("p-append-in-body", true)("p-display-tooltip", !ctx_r2.chartLine && item_r2.isActive && !item_r2.isFixed);
    ɵɵattribute("cx", item_r2.xCoordinate)("cy", item_r2.yCoordinate)("r", ctx_r2.radius)("stroke", ctx_r2.strokeColor);
  }
}
function PoChartSeriesPointComponent_ng_container_2__svg_rect_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "rect", 5);
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵattribute("x", item_r4.xCoordinate - ctx_r2.textWidth / 2 - 2)("y", item_r4.yCoordinate - ctx_r2.radius - 5 - ctx_r2.textHeight / 2 - 4)("width", ctx_r2.textWidth + 4)("height", ctx_r2.textHeight === 0 ? 0 : ctx_r2.textHeight - 2);
  }
}
function PoChartSeriesPointComponent_ng_container_2__svg_text_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "text", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap((ctx_r2.strokeColor == null ? null : ctx_r2.strokeColor.includes("po-border-color")) ? ctx_r2.strokeColor : "");
    ɵɵattribute("x", item_r4.xCoordinate)("y", item_r4.yCoordinate - ctx_r2.radius - 5)("data-id", item_r4.label);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r4.data, " ");
  }
}
function PoChartSeriesPointComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoChartSeriesPointComponent_ng_container_2__svg_rect_1_Template, 1, 4, "rect", 3)(2, PoChartSeriesPointComponent_ng_container_2__svg_text_2_Template, 2, 6, "text", 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r4.isFixed);
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r4.isFixed);
  }
}
var RADIUS_DEFAULT_SIZE = 5;
var RADIUS_HOVER_SIZE = 10;
var ANIMATION_DURATION_TIME = 700;
var PoChartSeriesPointComponent = class _PoChartSeriesPointComponent {
  renderer;
  elementRef;
  animate;
  isActive;
  isFixed;
  chartLine = false;
  // Referência para o svgPathGroup ao qual pertence o ponto. Necessário para reordenação dos svgElements no DOM para tratamento onHover
  relativeTo;
  pointClick = new EventEmitter();
  pointHover = new EventEmitter();
  coordinates$;
  radius = RADIUS_DEFAULT_SIZE;
  strokeColor;
  textWidth = 0;
  textHeight = 0;
  _color;
  _coordinates = [];
  animationState = true;
  set color(value) {
    this.strokeColor = value.includes("po-color") ? value.replace("po-color", "po-border-color") : value;
    this._color = value;
  }
  get color() {
    return this._color;
  }
  set coordinates(value) {
    this._coordinates = value;
    this.coordinates$ = this.displayPointsWithDelay(this._coordinates);
    setTimeout(() => {
      this._coordinates.forEach((item) => this.updateTextDimensions(item));
    });
  }
  get coordinates() {
    return this._coordinates;
  }
  constructor(renderer, elementRef) {
    this.renderer = renderer;
    this.elementRef = elementRef;
  }
  trackBy(index) {
    return index;
  }
  onClick(point) {
    const selectedItem = {
      label: point.label,
      data: point.data,
      category: point.category
    };
    this.pointClick.emit(selectedItem);
  }
  onMouseEnter(event, point) {
    this.updateTextDimensions(point);
    this.setPointAttribute(event.target, true);
    const selectedItem = {
      label: point.label,
      data: point.data,
      category: point.category
    };
    this.pointHover.emit(__spreadValues({
      relativeTo: this.relativeTo
    }, selectedItem));
  }
  onMouseLeave(event) {
    this.setPointAttribute(event.target, false);
  }
  displayPointsWithDelay(coordinates) {
    if (this.animationState && !isIE()) {
      const animationTimer = ANIMATION_DURATION_TIME / coordinates.length;
      return from(coordinates).pipe(concatMap((item, index) => timer(index === 0 || !this.animate ? 0 : animationTimer).pipe(mapTo(item))), scan((acc, curr) => acc.concat(curr), []), tap(() => this.animationState = false));
    } else {
      return from([coordinates]);
    }
  }
  setPointAttribute(target, isHover) {
    this.renderer.setAttribute(target, "r", isHover && !this.isFixed ? RADIUS_HOVER_SIZE.toString() : RADIUS_DEFAULT_SIZE.toString());
    if (this.color.includes("po-color")) {
      this.renderer.setAttribute(target, "class", isHover ? `${this.strokeColor} ${this.color}` : `po-chart-line-point po-chart-active-point ${this.strokeColor}`);
    } else {
      this.renderer[isHover ? "setStyle" : "removeStyle"](target, "fill", isHover ? this.color : void 0);
    }
  }
  updateTextDimensions(item) {
    const svgText = this.elementRef.nativeElement.querySelector(`.po-chart-series-point-text[data-id="${item.label}"]`);
    if (svgText) {
      const bbox = svgText.getBBox();
      this.textWidth = bbox.width;
      this.textHeight = bbox.height;
    }
  }
  static ɵfac = function PoChartSeriesPointComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartSeriesPointComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartSeriesPointComponent,
    selectors: [["", "po-chart-series-point", ""]],
    inputs: {
      animate: [0, "p-animate", "animate"],
      isActive: [2, "p-is-active", "isActive", convertToBoolean],
      isFixed: [2, "p-is-fixed", "isFixed", convertToBoolean],
      chartLine: [2, "p-chart-line", "chartLine", convertToBoolean],
      relativeTo: [0, "p-relative-to", "relativeTo"],
      color: [0, "p-color", "color"],
      coordinates: [0, "p-coordinates", "coordinates"]
    },
    outputs: {
      pointClick: "p-point-click",
      pointHover: "p-point-hover"
    },
    standalone: false,
    features: [ɵɵInputTransformsFeature],
    attrs: _c0$1u,
    decls: 4,
    vars: 8,
    consts: [["p-tooltip-position", "top", "class", "po-chart-line-point", 3, "p-tooltip", "p-append-in-body", "p-display-tooltip", "class", "po-chart-active-point", "click", "mouseenter", "mouseleave", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["p-tooltip-position", "top", 1, "po-chart-line-point", 3, "click", "mouseenter", "mouseleave", "p-tooltip", "p-append-in-body", "p-display-tooltip"], ["class", "po-chart-series-point-text-rect", "rx", "2", "ry", "2", 4, "ngIf"], ["class", "po-chart-series-point-text", "text-anchor", "middle", 3, "class", 4, "ngIf"], ["rx", "2", "ry", "2", 1, "po-chart-series-point-text-rect"], ["text-anchor", "middle", 1, "po-chart-series-point-text"]],
    template: function PoChartSeriesPointComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoChartSeriesPointComponent__svg_circle_0_Template, 1, 11, "circle", 0);
        ɵɵpipe(1, "async");
        ɵɵtemplate(2, PoChartSeriesPointComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
        ɵɵpipe(3, "async");
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ɵɵpipeBind1(1, 4, ctx.coordinates$))("ngForTrackBy", ctx.trackBy);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ɵɵpipeBind1(3, 6, ctx.coordinates$))("ngForTrackBy", ctx.trackBy);
      }
    },
    dependencies: [NgForOf, NgIf, PoTooltipDirective, AsyncPipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartSeriesPointComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-series-point]",
      standalone: false,
      template: `<svg:circle *ngFor="let item of coordinates$ | async; trackBy: trackBy" 
  [p-tooltip]="!item.isFixed ? item.tooltipLabel : null"
  [p-append-in-body]='true'
  [p-display-tooltip]="!chartLine && item.isActive && !item.isFixed"
  p-tooltip-position="top"
  class="po-chart-line-point"
  [class]="strokeColor?.includes('po-border-color') ? strokeColor : ''"
  [class.po-chart-active-point]="item.isActive"
  [attr.cx]="item.xCoordinate"
  [attr.cy]="item.yCoordinate"
  [attr.r]="radius"
  [attr.stroke]="strokeColor"
  (click)="onClick(item)"
  (mouseenter)="onMouseEnter($event, item)"
  (mouseleave)="onMouseLeave($event)"
  >
</svg:circle>

<ng-container *ngFor="let item of coordinates$ | async; trackBy: trackBy">

  <svg:rect 
    *ngIf="item.isFixed"
    [attr.x]="item.xCoordinate - textWidth / 2 - 2"
    [attr.y]="item.yCoordinate - radius - 5 - textHeight / 2 - 4"
    [attr.width]="textWidth + 4"
    [attr.height]="textHeight === 0 ? 0 : textHeight - 2"
    class='po-chart-series-point-text-rect'
    rx="2" ry="2"
  ></svg:rect>

  <svg:text 
    *ngIf="item.isFixed"
    [attr.x]="item.xCoordinate"
    [attr.y]="item.yCoordinate - radius - 5"
    class='po-chart-series-point-text'
    [attr.data-id]="item.label"
    [class]="strokeColor?.includes('po-border-color') ? strokeColor : ''"
    text-anchor="middle">
    {{ item.data }}
  </svg:text>

</ng-container>`
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    animate: [{
      type: Input,
      args: ["p-animate"]
    }],
    isActive: [{
      type: Input,
      args: [{
        alias: "p-is-active",
        transform: convertToBoolean
      }]
    }],
    isFixed: [{
      type: Input,
      args: [{
        alias: "p-is-fixed",
        transform: convertToBoolean
      }]
    }],
    chartLine: [{
      type: Input,
      args: [{
        alias: "p-chart-line",
        transform: convertToBoolean
      }]
    }],
    relativeTo: [{
      type: Input,
      args: ["p-relative-to"]
    }],
    pointClick: [{
      type: Output,
      args: ["p-point-click"]
    }],
    pointHover: [{
      type: Output,
      args: ["p-point-hover"]
    }],
    color: [{
      type: Input,
      args: ["p-color"]
    }],
    coordinates: [{
      type: Input,
      args: ["p-coordinates"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartSeriesPointComponent, {
    className: "PoChartSeriesPointComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-line/po-chart-series-point/po-chart-series-point.component.ts",
    lineNumber: 18
  });
})();
var _c0$1t = ["po-chart-area", ""];
function PoChartAreaComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 2);
    ɵɵlistener("mouseenter", function PoChartAreaComponent__svg_g_2_Template_g_mouseenter_0_listener() {
      const i_r2 = ɵɵrestoreView(_r1).index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onEnter(i_r2));
    })("mouseleave", function PoChartAreaComponent__svg_g_2_Template_g_mouseleave_0_listener() {
      const i_r2 = ɵɵrestoreView(_r1).index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onLeave(i_r2));
    });
    ɵɵelement(1, "g", 3);
    ɵɵelementStart(2, "g", 4);
    ɵɵlistener("p-point-click", function PoChartAreaComponent__svg_g_2_Template_g_p_point_click_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSeriePointClick($event));
    })("p-point-hover", function PoChartAreaComponent__svg_g_2_Template_g_p_point_hover_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSeriePointHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap("po-chart-line-path-group-" + i_r2);
    ɵɵclassProp("po-chart-line-path-blur", item_r4.isBlur);
    ɵɵadvance();
    ɵɵproperty("p-chart-line", ctx_r2.chartType === "line")("p-animate", ctx_r2.animate)("p-color", item_r4.color)("p-coordinates", item_r4 == null ? null : item_r4.coordinates)("p-is-active", item_r4.isFixed);
    ɵɵattribute("key", "po-chart-line-path-" + i_r2);
    ɵɵadvance();
    ɵɵproperty("p-animate", ctx_r2.animate)("p-chart-line", ctx_r2.chartType === "line")("p-color", item_r4.color)("p-coordinates", ctx_r2.seriesPointsCoordinates[i_r2])("p-is-active", ctx_r2.activeTooltip)("p-is-fixed", item_r4.isFixed)("p-relative-to", "po-chart-line-path-group-" + i_r2);
    ɵɵattribute("key", "po-chart-line-path-points-group-" + i_r2);
  }
}
var PoChartAreaComponent = class _PoChartAreaComponent extends PoChartLineBaseComponent {
  mathsService;
  renderer;
  elementRef;
  currentActiveSerieIndex;
  mouseMoveSubscription$;
  previousActiveSerieIndex;
  constructor(mathsService, renderer, elementRef) {
    super(mathsService, renderer, elementRef);
    this.mathsService = mathsService;
    this.renderer = renderer;
    this.elementRef = elementRef;
  }
  onEnter(serieIndex) {
    this.applyActiveItem(this.seriesPathsCoordinates, serieIndex);
    this.initializeListener(serieIndex);
    this.activeTooltip = true;
  }
  onLeave(serieIndex) {
    this.removeListener();
    this.applyActiveItem(this.seriesPathsCoordinates);
    this.applyActiveItem(this.seriesPointsCoordinates[serieIndex], null);
  }
  onSeriePointHover(selectedItem) {
    const _a = selectedItem, {
      relativeTo
    } = _a, item = __objRest(_a, [
      "relativeTo"
    ]);
    this.pointHover.emit(item);
  }
  applyActiveItem(list, index) {
    list.forEach((serie, seriesIndex) => {
      serie["isActive"] = index === void 0 ? true : index === seriesIndex;
    });
  }
  getMouseCoordinates(event) {
    event.preventDefault();
    const {
      svgDomMatrix,
      svgPoint
    } = this.svgSpace;
    svgPoint.x = event.clientX;
    svgPoint.y = event.clientY;
    return svgPoint.matrixTransform(svgDomMatrix);
  }
  initializeListener(serieIndex) {
    let pointPosition;
    this.previousActiveSerieIndex = void 0;
    this.mouseMoveSubscription$ = fromEvent(this.elementRef.nativeElement, "mousemove").pipe(debounceTime(10), tap((event) => pointPosition = this.getMouseCoordinates(event)), switchMap(() => of(this.verifyActiveArea(pointPosition)))).subscribe((activeObjIndex) => {
      if (activeObjIndex !== void 0) {
        this.applyActiveItem(this.seriesPointsCoordinates[serieIndex], activeObjIndex);
      }
    });
  }
  removeListener() {
    this.mouseMoveSubscription$.unsubscribe();
  }
  verifyActiveArea(pointPosition) {
    const {
      x
    } = pointPosition;
    this.currentActiveSerieIndex = this.categoriesCoordinates.findIndex((category, index) => x >= category && index === this.categoriesCoordinates.length - 1 || x >= category && x <= this.categoriesCoordinates[index + 1]);
    if (this.currentActiveSerieIndex >= 0 && this.currentActiveSerieIndex !== this.previousActiveSerieIndex) {
      this.previousActiveSerieIndex = this.currentActiveSerieIndex;
      return this.currentActiveSerieIndex;
    }
    return void 0;
  }
  static ɵfac = function PoChartAreaComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartAreaComponent)(ɵɵdirectiveInject(PoChartMathsService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartAreaComponent,
    selectors: [["", "po-chart-area", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c0$1t,
    decls: 3,
    vars: 2,
    consts: [["chartLine", ""], ["class", "po-chart-line-path-group", 3, "class", "po-chart-line-path-blur", "mouseenter", "mouseleave", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-chart-line-path-group", 3, "mouseenter", "mouseleave"], ["po-chart-path", "", 3, "p-chart-line", "p-animate", "p-color", "p-coordinates", "p-is-active"], ["po-chart-series-point", "", 3, "p-point-click", "p-point-hover", "p-animate", "p-chart-line", "p-color", "p-coordinates", "p-is-active", "p-is-fixed", "p-relative-to"]],
    template: function PoChartAreaComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "g", null, 0);
        ɵɵtemplate(2, PoChartAreaComponent__svg_g_2_Template, 3, 18, "g", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ctx.seriesPathsCoordinates)("ngForTrackBy", ctx.trackBy);
      }
    },
    dependencies: [NgForOf, PoChartPathComponent, PoChartSeriesPointComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartAreaComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-area]",
      standalone: false,
      template: `<svg:g #chartLine>

  <svg:g *ngFor="let item of seriesPathsCoordinates; let i = index; trackBy: trackBy"
    class='po-chart-line-path-group'
    [class]="'po-chart-line-path-group-' + i"
    [class.po-chart-line-path-blur]="item.isBlur"
    (mouseenter)="onEnter(i)"
    (mouseleave)="onLeave(i)"
  >
    <!-- SERIES PATHS -->
    <svg:g po-chart-path
      [p-chart-line]="chartType === 'line'"
      [attr.key]="'po-chart-line-path-' + i"
      [p-animate]="animate"
      [p-color]="item.color" 
      [p-coordinates]="item?.coordinates"
      [p-is-active]="item.isFixed"
      >
    </svg:g>

    <!-- SERIES POINTS -->
    <svg:g po-chart-series-point
      [p-animate]="animate"
      [p-chart-line]="chartType === 'line'"
      [p-color]="item.color"
      [p-coordinates]="seriesPointsCoordinates[i]"
      [p-is-active]="activeTooltip"
      [p-is-fixed]="item.isFixed"
      [p-relative-to]="'po-chart-line-path-group-' + i" 
      [attr.key]="'po-chart-line-path-points-group-' + i"
      (p-point-click)="onSeriePointClick($event)"
      (p-point-hover)="onSeriePointHover($event)"
      ></svg:g>
  </svg:g>

</svg:g>`
    }]
  }], () => [{
    type: PoChartMathsService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartAreaComponent, {
    className: "PoChartAreaComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-line/po-chart-area/po-chart-area.component.ts",
    lineNumber: 16
  });
})();
var _c0$1s = ["po-chart-axis-path", ""];
function PoChartAxisPathComponent__svg_path_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path", 1);
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    ɵɵattribute("d", item_r1.coordinates);
  }
}
function PoChartAxisPathComponent__svg_path_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path", 1);
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    ɵɵattribute("d", item_r2.coordinates);
  }
}
var PoChartAxisPathComponent = class _PoChartAxisPathComponent {
  axisXCoordinates;
  axisYCoordinates;
  constructor() {
  }
  trackBy(index) {
    return index;
  }
  static ɵfac = function PoChartAxisPathComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartAxisPathComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartAxisPathComponent,
    selectors: [["", "po-chart-axis-path", ""]],
    inputs: {
      axisXCoordinates: [0, "p-axis-x-coordinates", "axisXCoordinates"],
      axisYCoordinates: [0, "p-axis-y-coordinates", "axisYCoordinates"]
    },
    standalone: false,
    attrs: _c0$1s,
    decls: 4,
    vars: 4,
    consts: [["class", "po-chart-axis-path", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-chart-axis-path"]],
    template: function PoChartAxisPathComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "g");
        ɵɵtemplate(1, PoChartAxisPathComponent__svg_path_1_Template, 1, 1, "path", 0);
        ɵɵelementEnd();
        ɵɵelementStart(2, "g");
        ɵɵtemplate(3, PoChartAxisPathComponent__svg_path_3_Template, 1, 1, "path", 0);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.axisXCoordinates)("ngForTrackBy", ctx.trackBy);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ctx.axisYCoordinates)("ngForTrackBy", ctx.trackBy);
      }
    },
    dependencies: [NgForOf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartAxisPathComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-axis-path]",
      standalone: false,
      template: '<svg:g>\n  <svg:path *ngFor="let item of axisXCoordinates; trackBy: trackBy"\n    class="po-chart-axis-path" \n    [attr.d]="item.coordinates">\n  </svg:path> \n</svg:g>\n\n<svg:g>\n  <svg:path *ngFor="let item of axisYCoordinates; trackBy: trackBy"\n    class="po-chart-axis-path" \n    [attr.d]="item.coordinates">\n  </svg:path> \n</svg:g>'
    }]
  }], () => [], {
    axisXCoordinates: [{
      type: Input,
      args: ["p-axis-x-coordinates"]
    }],
    axisYCoordinates: [{
      type: Input,
      args: ["p-axis-y-coordinates"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartAxisPathComponent, {
    className: "PoChartAxisPathComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-axis/po-chart-axis-path/po-chart-axis-path.component.ts",
    lineNumber: 10
  });
})();
var PoChartLabelFormat;
(function(PoChartLabelFormat2) {
  PoChartLabelFormat2["Number"] = "number";
  PoChartLabelFormat2["Currency"] = "currency";
})(PoChartLabelFormat || (PoChartLabelFormat = {}));
var _c0$1r = ["po-chart-axis-label", ""];
function PoChartAxisLabelComponent__svg_text_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "text", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("x", item_r1.xCoordinate)("y", item_r1.yCoordinate);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.formatValueAxis(item_r1.label, "x"), " ");
  }
}
function PoChartAxisLabelComponent__svg_text_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "text", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-chart-centered-label", !ctx_r1.alignByTheCorners);
    ɵɵattribute("x", item_r3.xCoordinate)("y", item_r3.yCoordinate);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.formatValueAxis(item_r3.label, "y"), " ");
  }
}
var PoChartAxisLabelComponent = class _PoChartAxisLabelComponent {
  decimalPipe;
  currencyPipe;
  alignByTheCorners = false;
  axisXLabelCoordinates;
  axisYLabelCoordinates;
  type;
  axisOptions;
  constructor(decimalPipe, currencyPipe) {
    this.decimalPipe = decimalPipe;
    this.currencyPipe = currencyPipe;
  }
  trackBy(index) {
    return index;
  }
  formatValueAxis(label, axis) {
    const isCategoryAxisValue = this.type === PoChartType.Bar && axis === "x" || this.type !== PoChartType.Bar && axis === "y";
    if (isCategoryAxisValue) {
      return label;
    }
    if (this.axisOptions?.labelType === PoChartLabelFormat.Currency) {
      return this.currencyPipe.transform(label, null, "symbol", "1.2-2");
    }
    if (this.axisOptions?.labelType === PoChartLabelFormat.Number) {
      return this.decimalPipe.transform(label, "1.2-2");
    }
    return label;
  }
  static ɵfac = function PoChartAxisLabelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartAxisLabelComponent)(ɵɵdirectiveInject(DecimalPipe), ɵɵdirectiveInject(CurrencyPipe));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartAxisLabelComponent,
    selectors: [["", "po-chart-axis-label", ""]],
    inputs: {
      alignByTheCorners: [0, "p-align-by-the-corners", "alignByTheCorners"],
      axisXLabelCoordinates: [0, "p-axis-x-label-coordinates", "axisXLabelCoordinates"],
      axisYLabelCoordinates: [0, "p-axis-y-label-coordinates", "axisYLabelCoordinates"],
      type: [0, "p-type", "type"],
      axisOptions: [0, "p-options", "axisOptions"]
    },
    standalone: false,
    attrs: _c0$1r,
    decls: 4,
    vars: 4,
    consts: [["class", "po-chart-axis-x-label", "dominant-baseline", "middle", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "po-chart-axis-y-label", 3, "po-chart-centered-label", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["dominant-baseline", "middle", 1, "po-chart-axis-x-label"], [1, "po-chart-axis-y-label"]],
    template: function PoChartAxisLabelComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "g");
        ɵɵtemplate(1, PoChartAxisLabelComponent__svg_text_1_Template, 2, 3, "text", 0);
        ɵɵelementEnd();
        ɵɵelementStart(2, "g");
        ɵɵtemplate(3, PoChartAxisLabelComponent__svg_text_3_Template, 2, 5, "text", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.axisXLabelCoordinates)("ngForTrackBy", ctx.trackBy);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ctx.axisYLabelCoordinates)("ngForTrackBy", ctx.trackBy);
      }
    },
    dependencies: [NgForOf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartAxisLabelComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-axis-label]",
      standalone: false,
      template: '<svg:g>\n  <svg:text *ngFor="let item of axisXLabelCoordinates; trackBy: trackBy"\n    class="po-chart-axis-x-label" \n    dominant-baseline="middle"\n    [attr.x]="item.xCoordinate"\n    [attr.y]="item.yCoordinate"> \n    {{ formatValueAxis(item.label, "x") }}\n  </svg:text> \n</svg:g>\n\n<svg:g>\n  <svg:text *ngFor="let item of axisYLabelCoordinates; let first = first; let last = last; trackBy: trackBy"\n    class="po-chart-axis-y-label" \n    [class.po-chart-centered-label]="!alignByTheCorners"\n    [attr.x]="item.xCoordinate"\n    [attr.y]="item.yCoordinate">\n    {{ formatValueAxis(item.label, "y") }}\n  </svg:text> \n</svg:g>'
    }]
  }], () => [{
    type: DecimalPipe
  }, {
    type: CurrencyPipe
  }], {
    alignByTheCorners: [{
      type: Input,
      args: ["p-align-by-the-corners"]
    }],
    axisXLabelCoordinates: [{
      type: Input,
      args: ["p-axis-x-label-coordinates"]
    }],
    axisYLabelCoordinates: [{
      type: Input,
      args: ["p-axis-y-label-coordinates"]
    }],
    type: [{
      type: Input,
      args: ["p-type"]
    }],
    axisOptions: [{
      type: Input,
      args: ["p-options"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartAxisLabelComponent, {
    className: "PoChartAxisLabelComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-axis/po-chart-axis-label/po-chart-axis-label.component.ts",
    lineNumber: 14
  });
})();
var _c0$1q = ["po-chart-axis", ""];
var PoChartAxisComponent = class _PoChartAxisComponent {
  mathsService;
  alignByTheCorners = false;
  type;
  range;
  categoriesCoordinates = new EventEmitter();
  axisXCoordinates;
  axisXLabelCoordinates;
  axisYCoordinates;
  axisYLabelCoordinates;
  axisXLabels = [];
  axisYLabels = [];
  gridLines = PoChartGridLines;
  seriesLength = 0;
  _axisOptions;
  _categories = [];
  _containerSize = {};
  _series = [];
  set series(seriesList) {
    const seriesDataArrayFilter = seriesList.filter((serie) => Array.isArray(serie.data));
    if (seriesDataArrayFilter.length) {
      this._series = seriesDataArrayFilter;
      this.seriesLength = this.mathsService.seriesGreaterLength(this.series);
      this.checkAxisOptions(this.axisOptions);
      this.setAxisXCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
      this.setAxisYCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
    } else {
      this._series = [];
      this.cleanUpCoordinates();
    }
  }
  get series() {
    return this._series;
  }
  set categories(value) {
    this._categories = value;
    if (this.type === PoChartType.Bar) {
      this.setAxisXCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
    } else {
      this.setAxisYCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
    }
  }
  get categories() {
    return this._categories;
  }
  set containerSize(value) {
    this._containerSize = value;
    this.checkAxisOptions(this.axisOptions);
    this.setAxisXCoordinates(this.gridLines, this.seriesLength, this._containerSize, this.range, this.type);
    this.setAxisYCoordinates(this.gridLines, this.seriesLength, this._containerSize, this.range, this.type);
  }
  get containerSize() {
    return this._containerSize;
  }
  set axisOptions(value) {
    this._axisOptions = value;
    this.checkAxisOptions(this._axisOptions);
    if (this.type === PoChartType.Bar) {
      this.setAxisYCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
    } else {
      this.setAxisXCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
    }
  }
  get axisOptions() {
    return this._axisOptions;
  }
  constructor(mathsService) {
    this.mathsService = mathsService;
  }
  setAxisXCoordinates(gridLines, seriesLength, containerSize, minMaxAxisValues, type) {
    if (seriesLength) {
      const amountOfAxisLabels = type === PoChartType.Bar ? seriesLength : gridLines;
      this.calculateAxisXLabelCoordinates(amountOfAxisLabels, containerSize, minMaxAxisValues, type);
    }
    const amountOfAxisXLines = this.amountOfAxisXLines(seriesLength, gridLines, type);
    this.calculateAxisXCoordinates(amountOfAxisXLines, containerSize, minMaxAxisValues);
  }
  amountOfAxisXLines(seriesLength, gridLines, type) {
    if (type === PoChartType.Bar) {
      return seriesLength <= 1 ? 2 : seriesLength + 1;
    }
    return gridLines === 0 ? 1 : gridLines;
  }
  setAxisYCoordinates(gridLines, seriesLength, containerSize, minMaxAxisValues, type) {
    const amountOfAxisY = type === PoChartType.Bar ? gridLines : seriesLength;
    if (seriesLength) {
      this.calculateAxisYLabelCoordinates(amountOfAxisY, containerSize, minMaxAxisValues, type);
    }
    if (type === PoChartType.Area) {
      this.getCategoriesRangeForMouseMove(amountOfAxisY, containerSize);
    }
    this.calculateAxisYCoordinates(amountOfAxisY, containerSize, type, minMaxAxisValues);
  }
  calculateAxisXCoordinates(amountOfAxisX, containerSize, range) {
    const startX = containerSize.axisXLabelWidth;
    const endX = containerSize.svgWidth;
    let coordinatesReferedToZero;
    let coordinatesList = [...Array(amountOfAxisX)].map((_, index) => {
      const yCoordinate = this.calculateAxisXCoordinateY(amountOfAxisX, containerSize, index);
      const coordinates = `M${startX} ${yCoordinate} L${endX}, ${yCoordinate}`;
      return {
        coordinates
      };
    });
    if (this.type !== PoChartType.Bar && range.minValue < 0 && !this.axisXLabels.includes("0")) {
      coordinatesReferedToZero = this.getCoordinatesRelatedToZero(containerSize, range, startX, endX);
      coordinatesList = [...coordinatesList, coordinatesReferedToZero];
    }
    this.axisXCoordinates = coordinatesList;
  }
  getCoordinatesRelatedToZero(containerSize, range, start, end, isAxisY = false) {
    const type = isAxisY ? PoChartType.Bar : PoChartType.Column;
    const basePosition = this.axisCoordinatesForValueZero(range, 0, containerSize, isAxisY);
    const coordinates = {
      column: {
        startX: start,
        endX: end,
        startY: basePosition,
        endY: basePosition
      },
      bar: {
        startX: basePosition,
        endX: basePosition,
        startY: start,
        endY: end
      }
    };
    return {
      coordinates: `M${coordinates[type].startX} ${coordinates[type].startY} L${coordinates[type].endX} ${coordinates[type].endY}`
    };
  }
  axisCoordinatesForValueZero(range, data, containerSize, isAxisY) {
    const {
      axisXLabelWidth,
      svgWidth,
      svgPlottingAreaHeight
    } = containerSize;
    const ratio = this.mathsService.getSeriePercentage(range, data);
    return Math.floor(isAxisY ? axisXLabelWidth + (svgWidth - axisXLabelWidth) * ratio : svgPlottingAreaHeight - svgPlottingAreaHeight * ratio + PoChartPlotAreaPaddingTop);
  }
  calculateAxisXLabelCoordinates(amountOfAxisX, containerSize, minMaxAxisValues, type) {
    this.axisXLabels = this.getAxisXLabels(type, minMaxAxisValues, amountOfAxisX);
    this.axisXLabelCoordinates = [...Array(amountOfAxisX)].map((_, index) => {
      const label = this.axisXLabels[index];
      const xCoordinate = this.calculateAxisXLabelXCoordinate(containerSize.axisXLabelWidth);
      const yCoordinate = this.calculateAxisXLabelYCoordinate(amountOfAxisX, containerSize, type, index);
      return {
        label,
        xCoordinate,
        yCoordinate
      };
    });
  }
  calculateAxisYCoordinates(amountOfAxisY, containerSize, type, range) {
    const startY = PoChartPlotAreaPaddingTop;
    const endY = containerSize.svgPlottingAreaHeight + PoChartPlotAreaPaddingTop;
    const length = amountOfAxisY === 0 || type === PoChartType.Bar ? amountOfAxisY : amountOfAxisY + 1;
    let coordinatesReferedToZero;
    let coordinatesList = [...Array(length)].map((_, index) => {
      const xCoordinate = this.calculateAxisYCoordinateX(containerSize, amountOfAxisY, index);
      const coordinates = `M${xCoordinate} ${startY} L${xCoordinate}, ${endY}`;
      return {
        coordinates
      };
    });
    if (type === PoChartType.Bar && range.minValue < 0 && !this.axisYLabels.includes("0")) {
      coordinatesReferedToZero = this.getCoordinatesRelatedToZero(containerSize, range, startY, endY, true);
      coordinatesList = [...coordinatesList, coordinatesReferedToZero];
    }
    this.axisYCoordinates = [...coordinatesList];
  }
  calculateAxisYLabelCoordinates(amountOfAxisY, containerSize, minMaxAxisValues, type) {
    this.axisYLabels = this.getAxisYLabels(type, minMaxAxisValues, amountOfAxisY);
    this.axisYLabelCoordinates = [...Array(amountOfAxisY)].map((_, index) => {
      const label = this.axisYLabels[index];
      const xCoordinate = this.getAxisXCoordinates(containerSize, amountOfAxisY, type, index);
      const yCoordinate = this.calculateAxisYLabelYCoordinate(containerSize);
      return {
        label,
        xCoordinate,
        yCoordinate
      };
    });
  }
  calculateAxisXLabelXCoordinate(axisXLabelWidth) {
    const labelPoChartPadding = PoChartPadding / 3;
    return axisXLabelWidth - labelPoChartPadding;
  }
  calculateAxisXLabelYCoordinate(amountOfAxisX, containerSize, type, index) {
    const amountOfLines = type === PoChartType.Bar ? amountOfAxisX : amountOfAxisX - 1;
    const yRatio = index / amountOfLines;
    if (type !== PoChartType.Bar) {
      return containerSize.svgPlottingAreaHeight - containerSize.svgPlottingAreaHeight * yRatio + PoChartPlotAreaPaddingTop;
    }
    const halfCategoryHeight = containerSize.svgPlottingAreaHeight / amountOfAxisX / 2;
    return containerSize.svgPlottingAreaHeight - halfCategoryHeight - containerSize.svgPlottingAreaHeight * yRatio + PoChartPlotAreaPaddingTop;
  }
  calculateAxisXCoordinateY(amountOfAxisX, containerSize, index) {
    const yRatio = index / (amountOfAxisX - 1);
    return containerSize.svgPlottingAreaHeight - containerSize.svgPlottingAreaHeight * yRatio + PoChartPlotAreaPaddingTop;
  }
  calculateAxisYLabelYCoordinate(containerSize) {
    const textPoChartPadding = PoChartPadding / 3;
    return containerSize.svgHeight - textPoChartPadding;
  }
  centeredInCategoryArea(containerSize, amountOfAxisY, type, index) {
    const amountOfLines = type === PoChartType.Bar ? amountOfAxisY - 1 : amountOfAxisY;
    const xRatio = index / amountOfLines;
    if (type === PoChartType.Bar) {
      return Math.round(containerSize.axisXLabelWidth + (containerSize.svgWidth - containerSize.axisXLabelWidth) * xRatio);
    }
    const halfCategoryWidth = (containerSize.svgWidth - containerSize.axisXLabelWidth) / amountOfAxisY / 2;
    return Math.round(containerSize.axisXLabelWidth + halfCategoryWidth + (containerSize.svgWidth - containerSize.axisXLabelWidth) * xRatio);
  }
  calculateAxisYCoordinateX(containerSize, amountOfAxisY, index, subtractCategoryWidth = false) {
    const amountOfLines = this.alignByTheCorners ? amountOfAxisY - 1 : amountOfAxisY;
    const halfCategoryWidth = this.alignByTheCorners && subtractCategoryWidth ? (containerSize.svgWidth - containerSize.axisXLabelWidth) / (amountOfAxisY - 1) / 2 : 0;
    const divideIndexByAmountOfLines = index / amountOfLines;
    const xRatio = divideIndexByAmountOfLines === Infinity ? 0 : divideIndexByAmountOfLines;
    return Math.round(containerSize.axisXLabelWidth + (containerSize.svgWidth - containerSize.axisXLabelWidth) * xRatio - halfCategoryWidth);
  }
  checkAxisOptions(options = {}) {
    this.gridLines = options.gridLines && this.isValidGridLinesLengthOption(options.gridLines) ? options.gridLines : PoChartGridLines;
  }
  cleanUpCoordinates() {
    this.axisXCoordinates = [];
    this.axisYCoordinates = [];
    this.axisXLabelCoordinates = [];
    this.axisYLabelCoordinates = [];
    this.seriesLength = 0;
  }
  getAxisXCoordinates(containerSize, amountOfAxisY, type, index) {
    return this.alignByTheCorners ? this.calculateAxisYCoordinateX(containerSize, amountOfAxisY, index) : this.centeredInCategoryArea(containerSize, amountOfAxisY, type, index);
  }
  getCategoriesRangeForMouseMove(amountOfAxisY, containerSize) {
    const categoriesCoordinates = [...Array(amountOfAxisY)].map((_, index) => this.calculateAxisYCoordinateX(containerSize, amountOfAxisY, index, true));
    this.categoriesCoordinates.emit(categoriesCoordinates);
  }
  isValidGridLinesLengthOption(gridLines) {
    return gridLines >= 2 && gridLines <= 10;
  }
  getAxisXLabels(type, minMaxAxisValues, amountOfAxisX) {
    if (type === PoChartType.Bar) {
      const axisXLabelsList = this.formatCategoriesLabels(amountOfAxisX, this.categories);
      return axisXLabelsList.reverse();
    }
    return this.generateAverageOfLabels(minMaxAxisValues, amountOfAxisX);
  }
  getAxisYLabels(type, minMaxAxisValues, amountOfAxisX) {
    return type === PoChartType.Bar ? this.generateAverageOfLabels(minMaxAxisValues, amountOfAxisX) : this.formatCategoriesLabels(amountOfAxisX, this.categories);
  }
  formatCategoriesLabels(amountOfAxisX, categories = []) {
    return [...Array(amountOfAxisX)].map((_, index) => categories[index] ?? "-");
  }
  generateAverageOfLabels(minMaxAxisValues, amountOfAxisLines) {
    const averageLabelsList = this.mathsService.range(minMaxAxisValues, amountOfAxisLines);
    return averageLabelsList.map((label) => {
      const formattedDigit = label.toFixed(label % 1 && 2);
      const removeZeroDigits = formattedDigit.replace(/\.00$/, "").replace(/\-0$/, 0);
      return removeZeroDigits.toString();
    });
  }
  static ɵfac = function PoChartAxisComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartAxisComponent)(ɵɵdirectiveInject(PoChartMathsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartAxisComponent,
    selectors: [["", "po-chart-axis", ""]],
    inputs: {
      alignByTheCorners: [0, "p-align-by-the-corners", "alignByTheCorners"],
      type: [0, "p-type", "type"],
      range: [0, "p-range", "range"],
      series: [0, "p-series", "series"],
      categories: [0, "p-categories", "categories"],
      containerSize: [0, "p-container-size", "containerSize"],
      axisOptions: [0, "p-options", "axisOptions"]
    },
    outputs: {
      categoriesCoordinates: "p-categories-coordinates"
    },
    standalone: false,
    attrs: _c0$1q,
    decls: 2,
    vars: 7,
    consts: [["po-chart-axis-path", "", 3, "p-axis-x-coordinates", "p-axis-y-coordinates"], ["po-chart-axis-label", "", 3, "p-align-by-the-corners", "p-axis-x-label-coordinates", "p-axis-y-label-coordinates", "p-type", "p-options"]],
    template: function PoChartAxisComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelement(0, "g", 0)(1, "g", 1);
      }
      if (rf & 2) {
        ɵɵproperty("p-axis-x-coordinates", ctx.axisXCoordinates)("p-axis-y-coordinates", ctx.axisYCoordinates);
        ɵɵadvance();
        ɵɵproperty("p-align-by-the-corners", ctx.alignByTheCorners)("p-axis-x-label-coordinates", ctx.axisXLabelCoordinates)("p-axis-y-label-coordinates", ctx.axisYLabelCoordinates)("p-type", ctx.type)("p-options", ctx.axisOptions);
      }
    },
    dependencies: [PoChartAxisPathComponent, PoChartAxisLabelComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartAxisComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-axis]",
      standalone: false,
      template: '<svg:g po-chart-axis-path [p-axis-x-coordinates]="axisXCoordinates" [p-axis-y-coordinates]="axisYCoordinates"></svg:g>\n\n<svg:g po-chart-axis-label \n  [p-align-by-the-corners]="alignByTheCorners" \n  [p-axis-x-label-coordinates]="axisXLabelCoordinates" \n  [p-axis-y-label-coordinates]="axisYLabelCoordinates" \n  [p-type]="type"\n  [p-options]="axisOptions"\n  >\n</svg:g>'
    }]
  }], () => [{
    type: PoChartMathsService
  }], {
    alignByTheCorners: [{
      type: Input,
      args: ["p-align-by-the-corners"]
    }],
    type: [{
      type: Input,
      args: ["p-type"]
    }],
    range: [{
      type: Input,
      args: ["p-range"]
    }],
    categoriesCoordinates: [{
      type: Output,
      args: ["p-categories-coordinates"]
    }],
    series: [{
      type: Input,
      args: ["p-series"]
    }],
    categories: [{
      type: Input,
      args: ["p-categories"]
    }],
    containerSize: [{
      type: Input,
      args: ["p-container-size"]
    }],
    axisOptions: [{
      type: Input,
      args: ["p-options"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartAxisComponent, {
    className: "PoChartAxisComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-axis/po-chart-axis.component.ts",
    lineNumber: 22
  });
})();
var PoChartBarBaseComponent = class _PoChartBarBaseComponent {
  mathsService;
  categories;
  barClick = new EventEmitter();
  barHover = new EventEmitter();
  seriesPathsCoordinates;
  seriesGreaterLength;
  _containerSize = {};
  _range = {};
  _series = [];
  set range(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._range = value;
      this.calculateSeriesPathsCoordinates(this.containerSize, this._series, this._range);
    }
  }
  get range() {
    return this._range;
  }
  set containerSize(value) {
    this._containerSize = value;
    this.calculateSeriesPathsCoordinates(this._containerSize, this.series, this.range);
  }
  get containerSize() {
    return this._containerSize;
  }
  set series(seriesList) {
    const seriesDataArrayFilter = seriesList.filter((serie) => Array.isArray(serie.data));
    if (seriesDataArrayFilter.length) {
      this._series = seriesDataArrayFilter;
      this.seriesGreaterLength = this.mathsService.seriesGreaterLength(this.series);
      this.calculateSeriesPathsCoordinates(this.containerSize, seriesDataArrayFilter, this.range);
    } else {
      this._series = [];
    }
  }
  get series() {
    return this._series;
  }
  constructor(mathsService) {
    this.mathsService = mathsService;
  }
  onSerieBarClick(selectedItem) {
    this.barClick.emit(selectedItem);
  }
  onSerieBarHover(selectedItem) {
    this.barHover.emit(selectedItem);
  }
  trackBy(index) {
    return index;
  }
  calculateSeriesPathsCoordinates(containerSize, series, range) {
    this.seriesPathsCoordinates = series.map((serie, seriesIndex) => {
      if (Array.isArray(serie.data)) {
        let pathCoordinates = [];
        serie.data.forEach((data, serieDataIndex) => {
          if (this.mathsService.verifyIfFloatOrInteger(data)) {
            const coordinates = this.barCoordinates(seriesIndex, serieDataIndex, containerSize, range, data);
            const category = this.serieCategory(serieDataIndex, this.categories);
            const label = serie["label"];
            const color = serie["color"];
            const tooltip = serie["tooltip"];
            const tooltipLabel = this.getTooltipLabel(data, label, tooltip);
            pathCoordinates = [...pathCoordinates, {
              category,
              color,
              label,
              tooltipLabel,
              data,
              coordinates
            }];
          }
        });
        return pathCoordinates;
      }
    });
  }
  getTooltipLabel(data, label, tooltipLabel) {
    const dataLabel = label ? `${label}: ` : "";
    const dataValue = data.toString();
    return tooltipLabel || `${dataLabel}${dataValue}`;
  }
  serieCategory(index, categories = []) {
    return categories[index] ?? void 0;
  }
  static ɵfac = function PoChartBarBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartBarBaseComponent)(ɵɵdirectiveInject(PoChartMathsService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoChartBarBaseComponent,
    inputs: {
      categories: [0, "p-categories", "categories"],
      range: [0, "p-range", "range"],
      containerSize: [0, "p-container-size", "containerSize"],
      series: [0, "p-series", "series"]
    },
    outputs: {
      barClick: "p-bar-click",
      barHover: "p-bar-hover"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartBarBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoChartMathsService
  }], {
    categories: [{
      type: Input,
      args: ["p-categories"]
    }],
    barClick: [{
      type: Output,
      args: ["p-bar-click"]
    }],
    barHover: [{
      type: Output,
      args: ["p-bar-hover"]
    }],
    range: [{
      type: Input,
      args: ["p-range"]
    }],
    containerSize: [{
      type: Input,
      args: ["p-container-size"]
    }],
    series: [{
      type: Input,
      args: ["p-series"]
    }]
  });
})();
var _c0$1p = ["po-chart-bar-path", ""];
function PoChartBarPathComponent__svg_path_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "path", 1);
    ɵɵlistener("mouseenter", function PoChartBarPathComponent__svg_path_0_Template_path_mouseenter_0_listener() {
      const item_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onMouseEnter(item_r2));
    })("click", function PoChartBarPathComponent__svg_path_0_Template_path_click_0_listener() {
      const item_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onClick(item_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap((ctx_r2.color == null ? null : ctx_r2.color.includes("po-color")) ? ctx_r2.color : "");
    ɵɵproperty("p-tooltip", item_r2.tooltipLabel)("p-tooltip-position", ctx_r2.tooltipPosition)("p-append-in-body", true);
    ɵɵattribute("fill", ctx_r2.color)("d", item_r2.coordinates);
  }
}
var PoChartBarPathComponent = class _PoChartBarPathComponent {
  color;
  coordinates;
  tooltipPosition;
  barClick = new EventEmitter();
  barHover = new EventEmitter();
  constructor() {
  }
  trackBy(index) {
    return index;
  }
  onClick(item) {
    const selectedItem = {
      label: item.label,
      data: item.data,
      category: item.category
    };
    this.barClick.emit(selectedItem);
  }
  onMouseEnter(item) {
    const selectedItem = {
      label: item.label,
      data: item.data,
      category: item.category
    };
    this.barHover.emit(selectedItem);
  }
  static ɵfac = function PoChartBarPathComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartBarPathComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartBarPathComponent,
    selectors: [["", "po-chart-bar-path", ""]],
    inputs: {
      color: [0, "p-color", "color"],
      coordinates: [0, "p-coordinates", "coordinates"],
      tooltipPosition: [0, "p-tooltip-position", "tooltipPosition"]
    },
    outputs: {
      barClick: "p-bar-click",
      barHover: "p-bar-hover"
    },
    standalone: false,
    attrs: _c0$1p,
    decls: 1,
    vars: 2,
    consts: [["class", "po-chart-bar-path", 3, "p-tooltip", "p-tooltip-position", "p-append-in-body", "class", "mouseenter", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-chart-bar-path", 3, "mouseenter", "click", "p-tooltip", "p-tooltip-position", "p-append-in-body"]],
    template: function PoChartBarPathComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoChartBarPathComponent__svg_path_0_Template, 1, 7, "path", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.coordinates)("ngForTrackBy", ctx.trackBy);
      }
    },
    dependencies: [NgForOf, PoTooltipDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartBarPathComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-bar-path]",
      standalone: false,
      template: `<svg:path *ngFor="let item of coordinates; trackBy: trackBy"
  [p-tooltip]="item.tooltipLabel"
  [p-tooltip-position]="tooltipPosition"
  [p-append-in-body]='true'
  class="po-chart-bar-path"
  [class]="color?.includes('po-color') ? color : ''"
  [attr.fill]="color"
  [attr.d]="item.coordinates"
  (mouseenter)="onMouseEnter(item)"
  (click)="onClick(item)">
</svg:path> 
`
    }]
  }], () => [], {
    color: [{
      type: Input,
      args: ["p-color"]
    }],
    coordinates: [{
      type: Input,
      args: ["p-coordinates"]
    }],
    tooltipPosition: [{
      type: Input,
      args: ["p-tooltip-position"]
    }],
    barClick: [{
      type: Output,
      args: ["p-bar-click"]
    }],
    barHover: [{
      type: Output,
      args: ["p-bar-hover"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartBarPathComponent, {
    className: "PoChartBarPathComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-bar/po-chart-bar-path/po-chart-bar-path.component.ts",
    lineNumber: 10
  });
})();
var _c0$1o = ["po-chart-bar", ""];
function PoChartBarComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g")(1, "g", 1);
    ɵɵlistener("p-bar-click", function PoChartBarComponent__svg_g_1_Template_g_p_bar_click_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSerieBarClick($event));
    })("p-bar-hover", function PoChartBarComponent__svg_g_1_Template_g_p_bar_hover_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSerieBarHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const i_r4 = ctx.index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("po-chart-bar-group-" + i_r4);
    ɵɵadvance();
    ɵɵproperty("p-color", item_r3[0] == null ? null : item_r3[0].color)("p-coordinates", item_r3)("p-tooltip-position", ctx_r1.tooltipPosition);
    ɵɵattribute("key", "po-chart-bar-path-" + i_r4);
  }
}
var PoChartBarComponent = class _PoChartBarComponent extends PoChartBarBaseComponent {
  mathsService;
  tooltipPosition = "right";
  constructor(mathsService) {
    super(mathsService);
    this.mathsService = mathsService;
  }
  barCoordinates(seriesIndex, serieItemDataIndex, containerSize, minMaxSeriesValues, serieValue) {
    const {
      svgPlottingAreaWidth,
      barHeight,
      spaceBetweenBars
    } = this.calculateElementsMeasurements(containerSize);
    const {
      x1,
      x2
    } = this.xCoordinates(minMaxSeriesValues, svgPlottingAreaWidth, containerSize.axisXLabelWidth, containerSize.svgWidth, serieValue);
    const {
      y1,
      y2
    } = this.yCoordinates(seriesIndex, serieItemDataIndex, containerSize.svgPlottingAreaHeight, barHeight, spaceBetweenBars);
    return ["M", x1, y2, "L", x2, y2, "L", x2, y1, "L", x1, y1, "z"].join(" ");
  }
  calculateElementsMeasurements(containerSize) {
    const {
      svgWidth,
      svgPlottingAreaHeight,
      axisXLabelWidth
    } = containerSize;
    const svgPlottingAreaWidth = svgWidth - axisXLabelWidth;
    const categoryHeight = svgPlottingAreaHeight / this.seriesGreaterLength;
    const columnFraction = categoryHeight / (this.series.length + 2);
    const spaceBetweenBars = this.series.length > 1 ? columnFraction / (this.series.length + 2) : 0;
    const barHeight = columnFraction - spaceBetweenBars * (this.series.length - 1) / (this.series.length + 2);
    return {
      svgPlottingAreaWidth,
      barHeight,
      spaceBetweenBars
    };
  }
  xCoordinates(minMaxSeriesValues, svgPlottingAreaWidth, axisXLabelWidth, svgWidth, serieValue) {
    const {
      minValue
    } = minMaxSeriesValues;
    const valueZeroPercentage = this.mathsService.getSeriePercentage(minMaxSeriesValues, minValue < 0 ? 0 : minValue);
    const x1 = axisXLabelWidth + (svgWidth - axisXLabelWidth) * valueZeroPercentage;
    const xRatio = this.mathsService.getSeriePercentage(minMaxSeriesValues, serieValue);
    const x2 = Math.round(svgPlottingAreaWidth * xRatio + axisXLabelWidth);
    return {
      x1,
      x2
    };
  }
  yCoordinates(seriesIndex, serieItemDataIndex, svgPlottingAreaHeight, barHeight, spaceBetweenBars) {
    const spaceBetweenAxisAndBars = barHeight;
    const yRatio = serieItemDataIndex / this.seriesGreaterLength;
    const y1 = Math.round(PoChartPlotAreaPaddingTop + svgPlottingAreaHeight * yRatio + spaceBetweenAxisAndBars + barHeight * seriesIndex + spaceBetweenBars * seriesIndex);
    const y2 = Math.round(y1 + barHeight);
    return {
      y1,
      y2
    };
  }
  static ɵfac = function PoChartBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartBarComponent)(ɵɵdirectiveInject(PoChartMathsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartBarComponent,
    selectors: [["", "po-chart-bar", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c0$1o,
    decls: 2,
    vars: 2,
    consts: [[3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["po-chart-bar-path", "", 3, "p-bar-click", "p-bar-hover", "p-color", "p-coordinates", "p-tooltip-position"]],
    template: function PoChartBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "g");
        ɵɵtemplate(1, PoChartBarComponent__svg_g_1_Template, 2, 6, "g", 0);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.seriesPathsCoordinates)("ngForTrackBy", ctx.trackBy);
      }
    },
    dependencies: [NgForOf, PoChartBarPathComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartBarComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-bar]",
      standalone: false,
      template: `<svg:g>
  <svg:g *ngFor="let item of seriesPathsCoordinates; let i = index; trackBy: trackBy"
    [class]="'po-chart-bar-group-' + i"
  >
    <!-- SERIES PATHS -->
    <svg:g po-chart-bar-path
      [attr.key]="'po-chart-bar-path-' + i"
      [p-color]="item[0]?.color" 
      [p-coordinates]="item"
      [p-tooltip-position]="tooltipPosition"
      (p-bar-click)="onSerieBarClick($event)"
      (p-bar-hover)="onSerieBarHover($event)"
      >
      </svg:g>
  </svg:g>
</svg:g>`
    }]
  }], () => [{
    type: PoChartMathsService
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartBarComponent, {
    className: "PoChartBarComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-bar/po-chart-bar.component.ts",
    lineNumber: 16
  });
})();
var _c0$1n = ["po-chart-column", ""];
function PoChartColumnComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g")(1, "g", 1);
    ɵɵlistener("p-bar-click", function PoChartColumnComponent__svg_g_1_Template_g_p_bar_click_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSerieBarClick($event));
    })("p-bar-hover", function PoChartColumnComponent__svg_g_1_Template_g_p_bar_hover_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSerieBarHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const i_r4 = ctx.index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("po-chart-bar-group-" + i_r4);
    ɵɵadvance();
    ɵɵproperty("p-color", item_r3[0] == null ? null : item_r3[0].color)("p-coordinates", item_r3)("p-tooltip-position", ctx_r1.tooltipPosition);
    ɵɵattribute("key", "po-chart-bar-path-" + i_r4);
  }
}
var PoChartColumnComponent = class _PoChartColumnComponent extends PoChartBarBaseComponent {
  mathsService;
  tooltipPosition = "top";
  constructor(mathsService) {
    super(mathsService);
    this.mathsService = mathsService;
  }
  barCoordinates(seriesIndex, serieItemDataIndex, containerSize, minMaxSeriesValues, serieValue) {
    const {
      svgWidth,
      axisXLabelWidth,
      svgPlottingAreaHeight
    } = containerSize;
    const {
      chartBarPlotArea,
      barWidth,
      spaceBetweenBars
    } = this.calculateElementsMeasurements(svgWidth, axisXLabelWidth);
    const {
      x1,
      x2
    } = this.xCoordinates(seriesIndex, serieItemDataIndex, chartBarPlotArea, barWidth, spaceBetweenBars, axisXLabelWidth);
    const {
      y1,
      y2
    } = this.yCoordinates(minMaxSeriesValues, svgPlottingAreaHeight, serieValue);
    return ["M", x1, y2, "L", x2, y2, "L", x2, y1, "L", x1, y1, "z"].join(" ");
  }
  calculateElementsMeasurements(svgWidth, axisXLabelWidth) {
    const chartBarPlotArea = svgWidth - axisXLabelWidth;
    const categoryWidth = chartBarPlotArea / this.seriesGreaterLength;
    const columnFraction = categoryWidth / (this.series.length + 2);
    const spaceBetweenBars = this.series.length > 1 ? columnFraction / (this.series.length + 2) : 0;
    const barWidth = columnFraction - spaceBetweenBars * (this.series.length - 1) / (this.series.length + 2);
    return {
      chartBarPlotArea,
      barWidth,
      spaceBetweenBars
    };
  }
  xCoordinates(seriesIndex, serieItemDataIndex, chartBarPlotArea, barWidth, spaceBetweenBars, axisXLabelWidth) {
    const spaceBetweenAxisAndBars = barWidth;
    const xRatio = serieItemDataIndex / this.seriesGreaterLength;
    const x1 = Math.round(axisXLabelWidth + chartBarPlotArea * xRatio + spaceBetweenAxisAndBars + barWidth * seriesIndex + spaceBetweenBars * seriesIndex);
    const x2 = Math.round(x1 + barWidth);
    return {
      x1,
      x2
    };
  }
  yCoordinates(minMaxSeriesValues, svgPlottingAreaHeight, serieValue) {
    const {
      minValue
    } = minMaxSeriesValues;
    const minValuePercentage = this.mathsService.getSeriePercentage(minMaxSeriesValues, minValue < 0 ? 0 : minValue);
    const y1 = Math.round(svgPlottingAreaHeight - svgPlottingAreaHeight * minValuePercentage + PoChartPlotAreaPaddingTop);
    const yRatio = this.mathsService.getSeriePercentage(minMaxSeriesValues, serieValue);
    const y2 = Math.round(svgPlottingAreaHeight - svgPlottingAreaHeight * yRatio + PoChartPlotAreaPaddingTop);
    return {
      y1,
      y2
    };
  }
  static ɵfac = function PoChartColumnComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartColumnComponent)(ɵɵdirectiveInject(PoChartMathsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartColumnComponent,
    selectors: [["", "po-chart-column", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    attrs: _c0$1n,
    decls: 2,
    vars: 2,
    consts: [[3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["po-chart-bar-path", "", 3, "p-bar-click", "p-bar-hover", "p-color", "p-coordinates", "p-tooltip-position"]],
    template: function PoChartColumnComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "g");
        ɵɵtemplate(1, PoChartColumnComponent__svg_g_1_Template, 2, 6, "g", 0);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.seriesPathsCoordinates)("ngForTrackBy", ctx.trackBy);
      }
    },
    dependencies: [NgForOf, PoChartBarPathComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartColumnComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-column]",
      standalone: false,
      template: `<svg:g>
  <svg:g *ngFor="let item of seriesPathsCoordinates; let i = index; trackBy: trackBy"
    [class]="'po-chart-bar-group-' + i"
  >
    <!-- SERIES PATHS -->
    <svg:g po-chart-bar-path
      [attr.key]="'po-chart-bar-path-' + i"
      [p-color]="item[0]?.color" 
      [p-coordinates]="item"
      [p-tooltip-position]="tooltipPosition"
      (p-bar-click)="onSerieBarClick($event)"
      (p-bar-hover)="onSerieBarHover($event)"
      >
      </svg:g>
  </svg:g>
</svg:g>`
    }]
  }], () => [{
    type: PoChartMathsService
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartColumnComponent, {
    className: "PoChartColumnComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-bar/po-chart-column/po-chart-column.component.ts",
    lineNumber: 16
  });
})();
var PoDefaultColors = [["#29B6C5"], ["#0C6C94", "#29B6C5"], ["#0C6C94", "#29B6C5", "#C9ECF0"], ["#0C6C94", "#0B92B4", "#29B6C5", "#94DAE2"], ["#0C6C94", "#0B92B4", "#29B6C5", "#94DAE2", "#C9ECF0"], ["#0C6C94", "#00A5C5", "#0082A8", "#31628D", "#364473", "#32285C"], ["#0C6C94", "#00AACB", "#018DAE", "#277099", "#325783", "#35426E", "#32285D"], ["#0C6C94", "#00AFCE", "#0194B6", "#117FA2", "#0088AC", "#23789F", "#2B6992", "#32285C"], ["#0C6C94", "#00BAD5", "#00A7C7", "#0197B8", "#0088AC", "#23789F", "#2B6992", "#315C87", "#32285C"], ["#0C6C94", "#00BAD5", "#00A7C7", "#0197B8", "#0088AC", "#23789F", "#2B6992", "#315C87", "#364E7C", "#32285C"], ["#0C6C94", "#00BAD5", "#00A7C7", "#0197B8", "#0088AC", "#23789F", "#2B6992", "#315C87", "#364E7C", "#36436F", "#32285C"], ["#0C6C94", "#00BAD5", "#00A7C7", "#0197B8", "#0088AC", "#23789F", "#2B6992", "#315C87", "#364E7C", "#36436F", "#333565", "#32285C"]];
var PoDefaultColorsTextBlack = ["#94DAE2", "#C9ECF0"];
var poColorPalette = Object.values(PoColorPaletteEnum);
var PoColorService = class _PoColorService {
  defaultColors = [];
  colorBlack = "#000000";
  /**
   * Avalia a propriedade `color` na lista de items passada. Caso sim, trata se é decimal ou string `po-color`. Caso não haja, retorna a cor default.
   *
   * @param data
   */
  getColors(data) {
    this.verifyIfHasColorProperty(data);
    return data.map((dataItem, index) => {
      if (dataItem.color) {
        dataItem.color = this.verifyIfIsPoColorPalette(dataItem.color);
        return dataItem;
      }
      const color = this.defaultColors[index] === void 0 ? this.colorBlack : this.defaultColors[index];
      return __spreadProps(__spreadValues({}, dataItem), {
        color
      });
    });
  }
  verifyIfHasColorProperty(data) {
    const hasColorProperty = data.every((dataItem) => dataItem.hasOwnProperty("color") && dataItem.color?.length > 0);
    if (!hasColorProperty) {
      this.defaultColors = this.getDefaultColors(data.length);
    }
  }
  verifyIfIsPoColorPalette(color) {
    if (poColorPalette.includes(color)) {
      return `po-${color}`;
    }
    return color;
  }
  getDefaultColors(length) {
    if (length === 1) {
      return PoDefaultColors[0];
    }
    const colorsLength = PoDefaultColors.length;
    if (length > colorsLength) {
      const quantityDuplicates = length / colorsLength;
      let colors2 = PoDefaultColors[colorsLength - 1];
      for (let i = 0; i <= quantityDuplicates; i++) {
        colors2 = colors2.concat(PoDefaultColors[colorsLength]);
      }
      return colors2;
    }
    return PoDefaultColors[length - 1];
  }
  static ɵfac = function PoColorService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoColorService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoColorService,
    factory: _PoColorService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoColorService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var poChartDefaultHeight = 400;
var poChartMinHeight = 200;
var PoChartBaseComponent = class _PoChartBaseComponent {
  colorService;
  /** Define o título do gráfico. */
  title;
  /**
   * @optional
   *
   * @description
   *
   * Evento executado quando o usuário clicar sobre um elemento do gráfico.
   *
   * O evento emitirá o seguinte parâmetro:
   * - *donut* e *pie*: um objeto contendo a categoria e valor da série.
   * - *area*, *line*, *column* e *bar*: um objeto contendo o nome da série, valor e categoria do eixo do gráfico.
   */
  seriesClick = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado quando o usuário passar o *mouse* sobre um elemento do gráfico.
   *
   * O evento emitirá o seguinte parâmetro de acordo com o tipo de gráfico:
   * - *donut* e *pie*: um objeto contendo a categoria e valor da série.
   * - *area*, *line*, *column* e *bar*: um objeto contendo a categoria, valor da série e categoria do eixo do gráfico.
   */
  seriesHover = new EventEmitter();
  // manipulação das séries tratadas internamente para preservar 'p-series';
  chartSeries = [];
  chartType;
  svgContainerSize;
  _options;
  _categories;
  _height;
  _series;
  _type;
  defaultType;
  /**
   * @optional
   *
   * @description
   *
   * Define a altura do gráfico.
   *
   * > O valor mínimo aceito nesta propriedade é 200.
   *
   * @default `400px`
   */
  set height(value) {
    const intValue = convertToInt(value);
    let height;
    if (isTypeof(value, "number")) {
      height = intValue <= poChartMinHeight ? poChartMinHeight : intValue;
    } else {
      height = this.setDefaultHeight();
    }
    this._height = height;
    this.getSvgContainerSize();
    this.rebuildComponentRef();
  }
  get height() {
    return this._height || this.setDefaultHeight();
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o tipo de gráfico.
   *
   * É possível também combinar gráficos dos tipos linha e coluna. Para isso, opte pela declaração de `type` conforme a interface `PoChartSerie`.
   *
   * > Note que, se houver declaração de tipo de gráfico tanto em `p-type` quanto em `PochartSerie.type`, o valor `{ type }` da primeira série anulará o valor definido em `p-type`.
   *
   * Se não passado valor, o padrão será relativo à primeira série passada em `p-series`:
   * - Se `p-series = [{ data: [1,2,3] }]`: será `PoChartType.Column`.
   * - Se `p-series = [{ data: 1 }]`: será `PoChartType.Pie`.
   *
   * > Veja os valores válidos no *enum* `PoChartType`.
   */
  set type(value) {
    this._type = Object.values(PoChartType).includes(value) ? value : void 0;
    this.rebuildComponentRef();
  }
  get type() {
    return this._type;
  }
  /**
   * @description
   *
   * Define os elementos do gráfico que serão criados dinamicamente.
   */
  set series(value) {
    this._series = value || [];
    if (Array.isArray(this._series) && this._series.length) {
      this.setTypeDefault(this._series[0]);
    } else {
      this.transformObjectToArrayObject(this.series);
      this.rebuildComponentRef();
    }
  }
  get series() {
    return this._series;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define os nomes das categorias que serão plotadas no eixo X do gráfico caso seja do tipo `bar`, ou então nos eixos Y do grid de gráficos dos tipos `area`, `columnn` e `line`.
   *
   * > Gráficos do tipo `bar` dimensionam a área do gráfico de acordo com a largura do maior texto de categorias. No entanto, é uma boa prática optar por palavras curtas para que a leitura do gráfico não seja prejudicada.
   *
   * > Caso não seja especificado um valor para a categoria, será plotado um hífen na categoria referente a cada série.
   */
  set categories(value) {
    if (Array.isArray(value)) {
      this._categories = value;
    }
  }
  get categories() {
    return this._categories;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as configurações usadas no `po-chart`.
   *
   * É possível, por exemplo, definir as configurações de exibição das legendas,
   * configurar os eixos(*axis*) para os gráficos dos tipos `area`, `line`, `column` e `bar` da seguinte forma:
   *
   * ```
   *  chartOptions: PoChartOptions = {
   *    legend: true,
   *    axis: {
   *      minRange: 0,
   *      maxRange: 100,
   *      gridLines: 5,
   *    },
   *  };
   * ```
   */
  set options(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._options = value;
      if (this._options.hasOwnProperty("legend") && typeof this._options.legend === "boolean") {
        this.getSvgContainerSize();
      }
    }
  }
  get options() {
    return this._options;
  }
  /**
   * @optional
   *
   * @description
   *
   * Permite configurar as propriedades de exibição dos rótulos das séries no gráfico.
   *
   * Essa configuração possibilita fixar os valores das séries diretamente no gráfico, alterando o comportamento visual:
   * - Os valores das séries permanecem visíveis, sem a necessidade de hover.
   * - O *tooltip* não será exibido.
   * - Os marcadores (*bullets*) terão seu estilo ajustado.
   * - As outras séries ficarão com opacidade reduzida ao passar o mouse sobre a série ativa.
   *
   * > Disponível apenas para gráficos do tipo `line`.
   *
   * #### Exemplo de utilização:
   * ```typescript
   * dataLabel: PoChartDataLabel = {
   *   fixed: true,
   * };
   * ```
   */
  dataLabel;
  constructor(colorService) {
    this.colorService = colorService;
  }
  get isTypeCircular() {
    return this.defaultType === PoChartType.Pie || this.defaultType === PoChartType.Donut;
  }
  ngOnChanges(changes) {
    const isArrayOfseries = Array.isArray(this.series) && this.series.length > 0;
    if (changes.series && isArrayOfseries || changes.type && isArrayOfseries || changes.categories && isArrayOfseries) {
      this.validateSerieAndAddType(this.series);
    }
    if (changes.type && !this.isTypeCircular || changes.categories && !this.isTypeCircular) {
      this.svgContainerSize = __spreadProps(__spreadValues({}, this.svgContainerSize), {
        axisXLabelWidth: this.calculateAxisXLabelArea()
      });
    }
  }
  onSeriesClick(event) {
    this.seriesClick.emit(event);
  }
  onSeriesHover(event) {
    this.seriesHover.emit(event);
  }
  setDefaultHeight() {
    return poChartDefaultHeight;
  }
  transformObjectToArrayObject(serie) {
    this.chartSeries = typeof serie === "object" && Object.keys(serie).length ? [__spreadValues({}, serie)] : [];
  }
  setTypeDefault(serie) {
    const data = serie.data;
    const serieType = Object.values(PoChartType).includes(serie.type) ? serie.type : void 0;
    this.defaultType = serieType ? serieType : Array.isArray(data) ? PoChartType.Column : PoChartType.Pie;
  }
  validateSerieAndAddType(series) {
    const filteredSeries = series.filter((serie) => this.isTypeCircular ? typeof serie.data === "number" : Array.isArray(serie.data));
    this.chartSeries = this.appendType(this.appendColors(filteredSeries));
  }
  appendColors(series) {
    return this.colorService.getColors(series);
  }
  appendType(series) {
    return series.map((serie, index) => {
      if (index === 0) {
        this.chartType = Object.values(PoChartType).includes(serie.type) ? serie.type : this.type || this.defaultType;
      }
      return __spreadProps(__spreadValues({}, serie), {
        type: serie.type || this.chartType
      });
    });
  }
  static ɵfac = function PoChartBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartBaseComponent)(ɵɵdirectiveInject(PoColorService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoChartBaseComponent,
    inputs: {
      title: [0, "p-title", "title"],
      height: [0, "p-height", "height"],
      type: [0, "p-type", "type"],
      series: [0, "p-series", "series"],
      categories: [0, "p-categories", "categories"],
      options: [0, "p-options", "options"],
      dataLabel: [0, "p-data-label", "dataLabel"]
    },
    outputs: {
      seriesClick: "p-series-click",
      seriesHover: "p-series-hover"
    },
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoColorService
  }], {
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    seriesClick: [{
      type: Output,
      args: ["p-series-click"]
    }],
    seriesHover: [{
      type: Output,
      args: ["p-series-hover"]
    }],
    height: [{
      type: Input,
      args: ["p-height"]
    }],
    type: [{
      type: Input,
      args: ["p-type"]
    }],
    series: [{
      type: Input,
      args: ["p-series"]
    }],
    categories: [{
      type: Input,
      args: ["p-categories"]
    }],
    options: [{
      type: Input,
      args: ["p-options"]
    }],
    dataLabel: [{
      type: Input,
      args: ["p-data-label"]
    }]
  });
})();
var PoChartSvgContainerService = class _PoChartSvgContainerService {
  constructor() {
  }
  /**
   * Retorna um objeto do tipo PoChartContainerSize contendo as dimensões necessárias para plotagem do SVG.
   *
   * @param chartHeight
   * @param chartWrapperWidth
   * @param chartHeaderHeight
   * @param chartLegendHeight
   */
  calculateSVGContainerMeasurements(chartHeight = 0, chartWrapperWidth = 0, chartHeaderHeight = 0, chartLegendHeight = 0) {
    const svgWidth = this.svgWidth(chartWrapperWidth);
    const centerX = this.center(chartWrapperWidth);
    const svgHeight = this.svgHeight(chartHeight, chartHeaderHeight, chartLegendHeight);
    const centerY = this.center(svgHeight);
    const svgPlottingAreaHeight = this.svgPlottingAreaHeight(svgHeight);
    return {
      svgWidth,
      svgHeight,
      centerX,
      centerY,
      svgPlottingAreaHeight
    };
  }
  // Largura do container.
  svgWidth(chartWrapperWidth) {
    const wrapperWidth = chartWrapperWidth - PoChartPadding * 2;
    return wrapperWidth > 0 ? wrapperWidth : 0;
  }
  // O centro do container. Usado para gráficos do tipo circular.
  center(dimension) {
    return dimension / 2;
  }
  // Altura do container
  svgHeight(chartHeight, chartHeaderHeight, chartLegendHeight) {
    const subtractedHeights = chartHeight - chartHeaderHeight - chartLegendHeight - PoChartPadding * 2;
    return subtractedHeights <= 0 ? 0 : subtractedHeights;
  }
  /**
   * Altura da área de plotagem.
   * Subtrai a altura do container SVG pelo padding superior + área para overflow de labels do eixo X.
   */
  svgPlottingAreaHeight(svgHeight) {
    return svgHeight - PoChartPadding - 8;
  }
  static ɵfac = function PoChartSvgContainerService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartSvgContainerService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoChartSvgContainerService,
    factory: _PoChartSvgContainerService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartSvgContainerService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var _c0$1m = ["po-chart-line", ""];
function PoChartLineComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 2);
    ɵɵlistener("mouseenter", function PoChartLineComponent__svg_g_2_Template_g_mouseenter_0_listener() {
      const i_r2 = ɵɵrestoreView(_r1).index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onEnter(i_r2));
    })("mouseleave", function PoChartLineComponent__svg_g_2_Template_g_mouseleave_0_listener() {
      const i_r2 = ɵɵrestoreView(_r1).index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onLeave(i_r2));
    });
    ɵɵelement(1, "g", 3);
    ɵɵelementStart(2, "g", 4);
    ɵɵlistener("p-point-click", function PoChartLineComponent__svg_g_2_Template_g_p_point_click_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSeriePointClick($event));
    })("p-point-hover", function PoChartLineComponent__svg_g_2_Template_g_p_point_hover_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSeriePointHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap("po-chart-line-path-group-" + i_r2);
    ɵɵclassProp("po-chart-line-path-blur", item_r4.isBlur);
    ɵɵadvance();
    ɵɵproperty("p-chart-line", ctx_r2.chartType === "line")("p-animate", ctx_r2.animate)("p-color", item_r4.color)("p-coordinates", item_r4 == null ? null : item_r4.coordinates)("p-is-active", item_r4.isFixed);
    ɵɵattribute("key", "po-chart-line-path-" + i_r2);
    ɵɵadvance();
    ɵɵproperty("p-animate", ctx_r2.animate)("p-chart-line", ctx_r2.chartType === "line")("p-color", item_r4.color)("p-coordinates", ctx_r2.seriesPointsCoordinates[i_r2])("p-is-active", ctx_r2.activeTooltip)("p-is-fixed", item_r4.isFixed)("p-relative-to", "po-chart-line-path-group-" + i_r2);
    ɵɵattribute("key", "po-chart-line-path-points-group-" + i_r2);
  }
}
var PoChartLineComponent = class _PoChartLineComponent extends PoChartLineBaseComponent {
  mathsService;
  renderer;
  elementRef;
  selectedPath;
  constructor(mathsService, renderer, elementRef) {
    super(mathsService, renderer, elementRef);
    this.mathsService = mathsService;
    this.renderer = renderer;
    this.elementRef = elementRef;
  }
  ngOnChanges(changes) {
    if (changes.insideChart && !this.insideChart) {
      this.seriesPathsCoordinates.forEach((item) => item.isBlur = false);
    }
  }
  onEnter(serieIndex) {
    const newPath = this.seriesPathsCoordinates[serieIndex];
    if (this.selectedPath !== newPath) {
      this.onLeave(serieIndex);
      this.selectedPath = newPath;
    }
    if (this.dataLabel?.fixed) {
      this.seriesPathsCoordinates.filter((e) => e !== this.selectedPath).map((e) => e.isBlur = true);
    }
    return null;
  }
  onLeave(serieIndex) {
    const newPath = this.seriesPathsCoordinates[serieIndex];
    if (this.dataLabel?.fixed && this.selectedPath !== newPath) {
      this.seriesPathsCoordinates.map((e) => e.isBlur = false);
    }
    return null;
  }
  onSeriePointHover(selectedItem) {
    const _a = selectedItem, {
      relativeTo
    } = _a, item = __objRest(_a, [
      "relativeTo"
    ]);
    this.reorderSVGGroup(relativeTo);
    this.pointHover.emit(item);
  }
  // É necessário reordenar os svgs on hover pois eventualmente os elemntos svg ficam por trás de outros. Não há z-index para svgElement.
  reorderSVGGroup(pathGroup) {
    const pathGroupElement = this.elementRef.nativeElement.querySelectorAll(`.${pathGroup}`);
    this.animate = false;
    this.renderer.appendChild(this.chartLine.nativeElement, pathGroupElement[0]);
  }
  static ɵfac = function PoChartLineComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartLineComponent)(ɵɵdirectiveInject(PoChartMathsService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartLineComponent,
    selectors: [["", "po-chart-line", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    attrs: _c0$1m,
    decls: 3,
    vars: 2,
    consts: [["chartLine", ""], ["class", "po-chart-line-path-group", 3, "class", "po-chart-line-path-blur", "mouseenter", "mouseleave", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-chart-line-path-group", 3, "mouseenter", "mouseleave"], ["po-chart-path", "", 3, "p-chart-line", "p-animate", "p-color", "p-coordinates", "p-is-active"], ["po-chart-series-point", "", 3, "p-point-click", "p-point-hover", "p-animate", "p-chart-line", "p-color", "p-coordinates", "p-is-active", "p-is-fixed", "p-relative-to"]],
    template: function PoChartLineComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "g", null, 0);
        ɵɵtemplate(2, PoChartLineComponent__svg_g_2_Template, 3, 18, "g", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ctx.seriesPathsCoordinates)("ngForTrackBy", ctx.trackBy);
      }
    },
    dependencies: [NgForOf, PoChartPathComponent, PoChartSeriesPointComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartLineComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-line]",
      standalone: false,
      template: `<svg:g #chartLine>

  <svg:g *ngFor="let item of seriesPathsCoordinates; let i = index; trackBy: trackBy"
    class='po-chart-line-path-group'
    [class]="'po-chart-line-path-group-' + i"
    [class.po-chart-line-path-blur]="item.isBlur"
    (mouseenter)="onEnter(i)"
    (mouseleave)="onLeave(i)"
  >
    <!-- SERIES PATHS -->
    <svg:g po-chart-path
      [p-chart-line]="chartType === 'line'"
      [attr.key]="'po-chart-line-path-' + i"
      [p-animate]="animate"
      [p-color]="item.color" 
      [p-coordinates]="item?.coordinates"
      [p-is-active]="item.isFixed"
      >
    </svg:g>

    <!-- SERIES POINTS -->
    <svg:g po-chart-series-point
      [p-animate]="animate"
      [p-chart-line]="chartType === 'line'"
      [p-color]="item.color"
      [p-coordinates]="seriesPointsCoordinates[i]"
      [p-is-active]="activeTooltip"
      [p-is-fixed]="item.isFixed"
      [p-relative-to]="'po-chart-line-path-group-' + i" 
      [attr.key]="'po-chart-line-path-points-group-' + i"
      (p-point-click)="onSeriePointClick($event)"
      (p-point-hover)="onSeriePointHover($event)"
      ></svg:g>
  </svg:g>

</svg:g>`
    }]
  }], () => [{
    type: PoChartMathsService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartLineComponent, {
    className: "PoChartLineComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-line/po-chart-line.component.ts",
    lineNumber: 12
  });
})();
var _c0$1l = ["svgPaths"];
var _c1$A = ["svgLabels"];
var PoChartCircularComponent = class _PoChartCircularComponent {
  ngZone;
  changeDetector;
  containerSize;
  circularClick = new EventEmitter();
  circularHover = new EventEmitter();
  svgPaths;
  svgLabels;
  canDisplayLabels = false;
  seriesLabels = [];
  seriesList;
  showLabels = false;
  innerRadius;
  totalValue;
  _options;
  _series;
  animate;
  set options(value) {
    if (!isNaN(value?.innerRadius)) {
      this._options = value;
      this.innerRadius = Math.min(Math.max(this._options.innerRadius, 0), 100);
    }
  }
  get options() {
    return this._options;
  }
  set series(value) {
    this._series = value;
    this.animate = true;
  }
  get series() {
    return this._series;
  }
  constructor(ngZone, changeDetector) {
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
  }
  onSerieClick(selectedItem) {
    this.circularClick.emit(selectedItem);
  }
  onSerieHover(selectedItem) {
    this.circularHover.emit(selectedItem);
  }
  calculateAngle(data, totalValue) {
    return data / totalValue * (Math.PI * 2);
  }
  drawSeries(series = [], height) {
    this.seriesList = [];
    this.showLabels = false;
    this.totalValue = this.calculateTotalValue(series);
    if (this.totalValue && this.totalValue > 0) {
      this.seriesList = this.validateSeries(series);
      this.changeDetector.detectChanges();
      if (this.seriesList.length && this.svgPaths) {
        this.initDrawPaths(this.seriesList, this.totalValue, height);
      }
    }
  }
  calculateTotalValue(series) {
    return series.reduce((previousValue, serie) => {
      const data = serie.data ? serie.data : serie.value;
      return previousValue + (data > 0 ? data : 0);
    }, 0);
  }
  calculateSerieCoordinates(series, totalValue, height) {
    let startRadianAngle;
    let endRadianAngle = PoChartStartAngle;
    series.forEach((serie, index) => {
      startRadianAngle = endRadianAngle;
      endRadianAngle = startRadianAngle + this.calculateAngle(serie.data, totalValue) - PoChartCompleteCircle;
      const coordinates = this.calculateCoordinates(height, startRadianAngle, endRadianAngle);
      this.svgPaths.toArray()[index].applyCoordinates(coordinates);
      this.showLabels = this.canDisplayLabels;
    });
  }
  calculateCoordinatesWithAnimation(series, totalValue, height, startRadianAngle, endRadianAngle, currentRadianAngle = 0, seriesIndex = 0) {
    const finishedCurrentSerie = currentRadianAngle > endRadianAngle;
    const finishedAllSeries = seriesIndex === series.length;
    if (finishedAllSeries) {
      this.animate = false;
      return;
    }
    if (finishedCurrentSerie) {
      this.setSerieLabelCoordinates(seriesIndex);
      currentRadianAngle = 0;
      seriesIndex++;
      startRadianAngle = startRadianAngle + endRadianAngle;
      endRadianAngle = seriesIndex < series.length ? this.calculateAngle(series[seriesIndex].data, totalValue) : void 0;
    } else {
      currentRadianAngle += PoChartAngleStepInterval;
      const currentEndRadianAngle = this.calculateCurrentEndAngle(currentRadianAngle, startRadianAngle, endRadianAngle);
      const coordinates = this.calculateCoordinates(height, startRadianAngle, currentEndRadianAngle);
      this.svgPaths.toArray()[seriesIndex].applyCoordinates(coordinates);
    }
    window.requestAnimationFrame(this.calculateCoordinatesWithAnimation.bind(this, series, totalValue, height, startRadianAngle, endRadianAngle, currentRadianAngle, seriesIndex));
  }
  calculateCurrentEndAngle(currentRadianAngle, startRadianAngle, endRadianAngle) {
    const isSerieDrawCompleted = startRadianAngle + currentRadianAngle > startRadianAngle + endRadianAngle;
    return isSerieDrawCompleted ? startRadianAngle + endRadianAngle - PoChartCompleteCircle : startRadianAngle + currentRadianAngle;
  }
  initDrawPaths(seriesList, totalValue, height) {
    if (!this.animate) {
      this.calculateSerieCoordinates(seriesList, totalValue, height);
    } else {
      const startRadianAngle = PoChartStartAngle;
      const endRadianAngle = this.calculateAngle(seriesList[0].data, totalValue);
      this.ngZone.runOutsideAngular(() => this.calculateCoordinatesWithAnimation(seriesList, totalValue, height, startRadianAngle, endRadianAngle));
    }
  }
  setSerieLabelCoordinates(index) {
    if (this.svgLabels.toArray().length) {
      this.svgLabels.toArray()[index].applyCoordinates(this.seriesLabels[index]);
    }
  }
  validateSeries(series) {
    return series.reduce((seriesList, serie) => {
      const data = serie.data ?? serie.value;
      if (data && data > 0) {
        const color = serie.color;
        const label = serie.label;
        const tooltip = serie.tooltip;
        const tooltipLabel = this.getTooltipLabel(data, label, tooltip);
        seriesList = [...seriesList, {
          data,
          color,
          label,
          tooltipLabel
        }];
      }
      return seriesList;
    }, []);
  }
  static ɵfac = function PoChartCircularComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartCircularComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoChartCircularComponent,
    viewQuery: function PoChartCircularComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1l, 5);
        ɵɵviewQuery(_c1$A, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgPaths = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgLabels = _t);
      }
    },
    inputs: {
      containerSize: [0, "p-container-size", "containerSize"],
      options: [0, "p-options", "options"],
      series: [0, "p-series", "series"]
    },
    outputs: {
      circularClick: "p-circular-click",
      circularHover: "p-circular-hover"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartCircularComponent, [{
    type: Directive
  }], () => [{
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], {
    containerSize: [{
      type: Input,
      args: ["p-container-size"]
    }],
    circularClick: [{
      type: Output,
      args: ["p-circular-click"]
    }],
    circularHover: [{
      type: Output,
      args: ["p-circular-hover"]
    }],
    svgPaths: [{
      type: ViewChildren,
      args: ["svgPaths"]
    }],
    svgLabels: [{
      type: ViewChildren,
      args: ["svgLabels"]
    }],
    options: [{
      type: Input,
      args: ["p-options"]
    }],
    series: [{
      type: Input,
      args: ["p-series"]
    }]
  });
})();
var PoChartTooltipDirective = class _PoChartTooltipDirective {
  elementRef;
  renderer;
  tooltip;
  lastTooltipText;
  tooltipElement;
  tooltipText;
  tooltipTextContent;
  constructor(elementRef, renderer) {
    this.elementRef = elementRef;
    this.renderer = renderer;
  }
  onMouseEnter(event) {
    this.tooltipElement ? this.showTooltip() : this.createTooltip();
    this.tooltipPosition(event);
    this.lastTooltipText = this.tooltip;
  }
  onMouseLeave() {
    this.hideTooltip();
  }
  onMouseMove(event) {
    this.tooltipPosition(event);
  }
  calculateTooltipPosition(event) {
    const displacement = 12;
    return {
      left: event.clientX - this.tooltipElement.offsetWidth / 2,
      top: event.clientY - this.tooltipElement.offsetHeight - displacement
    };
  }
  createTooltip() {
    const chartWrapper = this.elementRef.nativeElement.closest(".po-chart-wrapper");
    this.tooltipElement = this.renderer.createElement("div");
    this.renderer.addClass(this.tooltipElement, "po-chart-tooltip");
    this.renderer.addClass(this.tooltipElement, "po-tooltip");
    this.renderer.setStyle(this.tooltipElement, "transition", "visibility .3s, opacity .3s linear");
    this.renderer.setStyle(this.tooltipElement, "opacity", 0.9);
    const divArrow = this.renderer.createElement("div");
    this.renderer.addClass(divArrow, "po-tooltip-arrow");
    this.renderer.addClass(divArrow, "po-arrow-bottom");
    this.tooltipText = this.renderer.createElement("p");
    this.renderer.addClass(this.tooltipText, "po-tooltip-content");
    this.tooltipTextContent = this.renderer.createText(this.tooltip);
    this.renderer.appendChild(this.tooltipText, this.tooltipTextContent);
    this.renderer.appendChild(this.tooltipElement, divArrow);
    this.renderer.appendChild(this.tooltipElement, this.tooltipText);
    this.renderer.appendChild(chartWrapper, this.tooltipElement);
  }
  hideTooltip() {
    this.renderer.setStyle(this.tooltipElement, "opacity", 0);
    this.renderer.setStyle(this.tooltipElement, "visibility", "hidden");
  }
  showTooltip() {
    this.renderer.setStyle(this.tooltipElement, "opacity", 0.9);
    this.renderer.setStyle(this.tooltipElement, "visibility", "visible");
    this.updatetooltipTextContent();
  }
  tooltipPosition(event) {
    const tooltipPositions = this.calculateTooltipPosition(event);
    this.renderer.setStyle(this.tooltipElement, "left", `${tooltipPositions.left}px`);
    this.renderer.setStyle(this.tooltipElement, "top", `${tooltipPositions.top}px`);
  }
  updatetooltipTextContent() {
    if (this.lastTooltipText !== this.tooltip) {
      this.renderer.removeChild(this.tooltipText, this.tooltipTextContent);
      this.tooltipTextContent = this.renderer.createText(this.tooltip);
      this.renderer.appendChild(this.tooltipText, this.tooltipTextContent);
    }
  }
  static ɵfac = function PoChartTooltipDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartTooltipDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoChartTooltipDirective,
    selectors: [["", "p-chart-tooltip", ""]],
    hostBindings: function PoChartTooltipDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("mouseenter", function PoChartTooltipDirective_mouseenter_HostBindingHandler($event) {
          return ctx.onMouseEnter($event);
        })("mouseleave", function PoChartTooltipDirective_mouseleave_HostBindingHandler() {
          return ctx.onMouseLeave();
        })("mousemove", function PoChartTooltipDirective_mousemove_HostBindingHandler($event) {
          return ctx.onMouseMove($event);
        });
      }
    },
    inputs: {
      tooltip: [0, "p-chart-tooltip", "tooltip"]
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartTooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[p-chart-tooltip]",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    tooltip: [{
      type: Input,
      args: ["p-chart-tooltip"]
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter", ["$event"]]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }],
    onMouseMove: [{
      type: HostListener,
      args: ["mousemove", ["$event"]]
    }]
  });
})();
var _c0$1k = ["svgPath"];
var _c1$z = ["po-chart-circular-path", ""];
var PoChartCircularPathComponent = class _PoChartCircularPathComponent {
  renderer;
  serie;
  onClick = new EventEmitter();
  onHover = new EventEmitter();
  svgPath;
  constructor(renderer) {
    this.renderer = renderer;
  }
  applyCoordinates(coordinates) {
    this.renderer.setAttribute(this.svgPath.nativeElement, "d", coordinates);
  }
  onMouseClick() {
    const {
      label,
      data
    } = this.serie;
    this.onClick.emit({
      label,
      data
    });
  }
  onMouseEnter() {
    const {
      label,
      data
    } = this.serie;
    this.onHover.emit({
      label,
      data
    });
  }
  static ɵfac = function PoChartCircularPathComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartCircularPathComponent)(ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartCircularPathComponent,
    selectors: [["", "po-chart-circular-path", ""]],
    viewQuery: function PoChartCircularPathComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1k, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgPath = _t.first);
      }
    },
    inputs: {
      serie: [0, "p-serie", "serie"]
    },
    outputs: {
      onClick: "p-on-click",
      onHover: "p-on-hover"
    },
    standalone: false,
    attrs: _c1$z,
    decls: 2,
    vars: 4,
    consts: [["svgPath", ""], [1, "po-path-item", 3, "click", "mouseenter", "p-chart-tooltip"]],
    template: function PoChartCircularPathComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "path", 1, 0);
        ɵɵlistener("click", function PoChartCircularPathComponent_Template_path_click_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onMouseClick());
        })("mouseenter", function PoChartCircularPathComponent_Template_path_mouseenter_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onMouseEnter());
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMap((ctx.serie == null ? null : ctx.serie.color.includes("po-color")) ? ctx.serie.color : "");
        ɵɵproperty("p-chart-tooltip", ctx.serie == null ? null : ctx.serie.tooltipLabel);
        ɵɵattribute("fill", ctx.serie == null ? null : ctx.serie.color);
      }
    },
    dependencies: [PoChartTooltipDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartCircularPathComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-circular-path]",
      standalone: false,
      template: `<svg:path #svgPath
  class="po-path-item"
  [class]="serie?.color.includes('po-color') ? serie.color : ''"
  [p-chart-tooltip]="serie?.tooltipLabel"
  [attr.fill]="serie?.color"
  (click)="onMouseClick()"
  (mouseenter)="onMouseEnter()"
  >
</svg:path> 
`
    }]
  }], () => [{
    type: Renderer2
  }], {
    serie: [{
      type: Input,
      args: ["p-serie"]
    }],
    onClick: [{
      type: Output,
      args: ["p-on-click"]
    }],
    onHover: [{
      type: Output,
      args: ["p-on-hover"]
    }],
    svgPath: [{
      type: ViewChild,
      args: ["svgPath", {
        read: ElementRef
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartCircularPathComponent, {
    className: "PoChartCircularPathComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-circular/po-chart-circular-path/po-chart-circular-path.component.ts",
    lineNumber: 10
  });
})();
var _c0$1j = ["svgLabel"];
var _c1$y = ["po-chart-circular-label", ""];
var PoChartCircularLabelComponent = class _PoChartCircularLabelComponent {
  changeDetection;
  renderer;
  serie;
  showLabel;
  svgLabel;
  constructor(changeDetection, renderer) {
    this.changeDetection = changeDetection;
    this.renderer = renderer;
  }
  applyCoordinates(coordinates) {
    this.renderer.setAttribute(this.svgLabel.nativeElement, "x", coordinates.xCoordinate.toString());
    this.renderer.setAttribute(this.svgLabel.nativeElement, "y", coordinates.yCoordinate.toString());
    this.showLabel = true;
    this.changeDetection.detectChanges();
  }
  static ɵfac = function PoChartCircularLabelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartCircularLabelComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartCircularLabelComponent,
    selectors: [["", "po-chart-circular-label", ""]],
    viewQuery: function PoChartCircularLabelComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1j, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgLabel = _t.first);
      }
    },
    inputs: {
      serie: [0, "p-serie", "serie"],
      showLabel: [0, "p-show-label", "showLabel"]
    },
    standalone: false,
    attrs: _c1$y,
    decls: 3,
    vars: 6,
    consts: [["svgLabel", ""], ["dominant-baseline", "middle", 1, "po-chart-label"]],
    template: function PoChartCircularLabelComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "text", 1, 0);
        ɵɵtext(2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("po-invisible", !ctx.showLabel);
        ɵɵattribute("fill", ctx.serie == null ? null : ctx.serie.color)("x", ctx.serie == null ? null : ctx.serie.xCoordinate)("y", ctx.serie == null ? null : ctx.serie.yCoordinate);
        ɵɵadvance(2);
        ɵɵtextInterpolate1(" ", ctx.serie == null ? null : ctx.serie.label, "\n");
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartCircularLabelComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-circular-label]",
      standalone: false,
      template: '<svg:text #svgLabel \n  class="po-chart-label" \n  dominant-baseline="middle"\n  [class.po-invisible]="!showLabel"\n  [attr.fill]="serie?.color"\n  [attr.x]="serie?.xCoordinate"\n  [attr.y]="serie?.yCoordinate">\n  {{ serie?.label }}\n</svg:text> '
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }], {
    serie: [{
      type: Input,
      args: ["p-serie"]
    }],
    showLabel: [{
      type: Input,
      args: ["p-show-label"]
    }],
    svgLabel: [{
      type: ViewChild,
      args: ["svgLabel", {
        read: ElementRef
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartCircularLabelComponent, {
    className: "PoChartCircularLabelComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-circular/po-chart-circular-label/po-chart-circular-label.component.ts",
    lineNumber: 10
  });
})();
var _c0$1i = ["po-chart-pie", ""];
function PoChartPieComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g")(1, "g", 4, 0);
    ɵɵlistener("p-on-click", function PoChartPieComponent__svg_g_1_Template_g_p_on_click_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSerieClick($event));
    })("p-on-hover", function PoChartPieComponent__svg_g_1_Template_g_p_on_hover_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSerieHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const i_r4 = ctx.index;
    ɵɵadvance();
    ɵɵproperty("p-serie", item_r3);
    ɵɵattribute("key", "po-chart-circular-path-" + i_r4);
  }
}
function PoChartPieComponent__svg_g_2__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g");
    ɵɵelement(1, "g", 5, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const i_r6 = ctx.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("p-serie", item_r5)("p-show-label", ctx_r1.showLabels);
    ɵɵattribute("key", "po-chart-circular-label-" + i_r6);
  }
}
function PoChartPieComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g");
    ɵɵtemplate(1, PoChartPieComponent__svg_g_2__svg_g_1_Template, 3, 3, "g", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.seriesLabels);
  }
}
var PoChartPieComponent = class _PoChartPieComponent extends PoChartCircularComponent {
  /* istanbul ignore next */
  constructor(ngZone, changeDetector) {
    super(ngZone, changeDetector);
  }
  ngOnChanges(changes) {
    if (changes.series || changes.containerSize) {
      this.drawSeries(this.series, this.containerSize.svgHeight);
    }
  }
  calculateCoordinates(height, startRadianAngle, endRadianAngle) {
    const radius = height / 2;
    const sinAlpha = Math.sin(startRadianAngle);
    const cosAlpha = Math.cos(startRadianAngle);
    const sinBeta = Math.sin(endRadianAngle);
    const cosBeta = Math.cos(endRadianAngle);
    const startX = radius + cosAlpha * radius;
    const startY = radius + sinAlpha * radius;
    const endX = radius + cosBeta * radius;
    const endY = radius + sinBeta * radius;
    const largeArc = endRadianAngle - startRadianAngle > Math.PI;
    return ["M", startX, startY, "A", radius, radius, 0, largeArc ? "1,1" : "0,1", endX, endY, "L", radius, radius, "Z"].join(" ");
  }
  getTooltipLabel(data, label, tooltipLabel) {
    const dataLabel = label ? `${label}: ` : "";
    const dataValue = data.toString();
    return tooltipLabel || `${dataLabel}${dataValue}`;
  }
  static ɵfac = function PoChartPieComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartPieComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartPieComponent,
    selectors: [["", "po-chart-pie", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    attrs: _c0$1i,
    decls: 3,
    vars: 2,
    consts: [["svgPaths", ""], ["svgLabels", ""], [4, "ngFor", "ngForOf"], [4, "ngIf"], ["po-chart-circular-path", "", 3, "p-on-click", "p-on-hover", "p-serie"], ["po-chart-circular-label", "", 3, "p-serie", "p-show-label"]],
    template: function PoChartPieComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "g");
        ɵɵtemplate(1, PoChartPieComponent__svg_g_1_Template, 3, 2, "g", 2)(2, PoChartPieComponent__svg_g_2_Template, 2, 1, "g", 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.seriesList);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.canDisplayLabels);
      }
    },
    dependencies: [NgForOf, NgIf, PoChartCircularPathComponent, PoChartCircularLabelComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartPieComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-pie]",
      standalone: false,
      template: `<svg:g>
  <!-- SERIES PATHS -->
  <svg:g *ngFor="let item of seriesList; let i = index">
    <svg:g #svgPaths po-chart-circular-path
      [attr.key]="'po-chart-circular-path-' + i"
      [p-serie]="item"
      (p-on-click)="onSerieClick($event)"
      (p-on-hover)="onSerieHover($event)">
    </svg:g>
  </svg:g>

  <!-- SERIES LABELS -->
  <svg:g *ngIf="canDisplayLabels">
    <svg:g *ngFor="let item of seriesLabels; let i = index">
      <svg:g #svgLabels po-chart-circular-label
        [attr.key]="'po-chart-circular-label-' + i"
        [p-serie]="item"
        [p-show-label]="showLabels">
      </svg:g>
    </svg:g>
  </svg:g>
</svg:g>

`
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartPieComponent, {
    className: "PoChartPieComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-circular/po-chart-pie/po-chart-pie.component.ts",
    lineNumber: 10
  });
})();
var _c0$1h = ["po-chart-donut", ""];
function PoChartDonutComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g")(1, "g", 4, 0);
    ɵɵlistener("p-on-click", function PoChartDonutComponent__svg_g_1_Template_g_p_on_click_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSerieClick($event));
    })("p-on-hover", function PoChartDonutComponent__svg_g_1_Template_g_p_on_hover_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSerieHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const i_r4 = ctx.index;
    ɵɵadvance();
    ɵɵproperty("p-serie", item_r3);
    ɵɵattribute("key", "po-chart-circular-path-" + i_r4);
  }
}
function PoChartDonutComponent__svg_g_2__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g");
    ɵɵelement(1, "g", 5, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const i_r6 = ctx.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("p-serie", item_r5)("p-show-label", ctx_r1.showLabels);
    ɵɵattribute("key", "po-chart-circular-label-" + i_r6);
  }
}
function PoChartDonutComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g");
    ɵɵtemplate(1, PoChartDonutComponent__svg_g_2__svg_g_1_Template, 3, 3, "g", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.seriesLabels);
  }
}
var PoChartDonutComponent = class _PoChartDonutComponent extends PoChartCircularComponent {
  poChartBlackColor = "#000000";
  poChartWhiteColor = "#ffffff";
  /* istanbul ignore next */
  constructor(ngZone, changeDetector) {
    super(ngZone, changeDetector);
  }
  ngOnChanges(changes) {
    if (changes.series || changes.containerSize || changes.options) {
      this.drawSeries(this.series, this.containerSize.svgHeight);
      this.applySeriesLabels(this.seriesList, this.containerSize.svgHeight);
    }
  }
  calculateCoordinates(height, startRadianAngle, endRadianAngle) {
    const radius = height / 2;
    const innerRadius = this.getInnerRadius(radius);
    const sinAlpha = Math.sin(startRadianAngle);
    const cosAlpha = Math.cos(startRadianAngle);
    const sinBeta = Math.sin(endRadianAngle);
    const cosBeta = Math.cos(endRadianAngle);
    const startX = radius + cosAlpha * radius;
    const startY = radius + sinAlpha * radius;
    const endX = radius + cosBeta * radius;
    const endY = radius + sinBeta * radius;
    const startInnerX = radius + cosAlpha * innerRadius;
    const startInnerY = radius + sinAlpha * innerRadius;
    const endInnerX = radius + cosBeta * innerRadius;
    const endInnerY = radius + sinBeta * innerRadius;
    const largeArc = endRadianAngle - startRadianAngle > Math.PI;
    this.verifyDisplayLabels(radius, innerRadius);
    return ["M", startX, startY, "A", radius, radius, 0, largeArc ? "1,1" : "0,1", endX, endY, "L", endInnerX, endInnerY, "A", innerRadius, innerRadius, 0, largeArc ? "1,0" : "0,0", startInnerX, startInnerY, "Z"].join(" ");
  }
  getTooltipLabel(data, label, tooltipLabel) {
    const dataLabel = label ? `${label}: ` : "";
    const dataValue = this.getPercentValue(data, this.totalValue) + "%";
    return tooltipLabel || `${dataLabel}${dataValue}`;
  }
  applySeriesLabels(seriesList, height) {
    let startRadianAngle = PoChartStartAngle;
    let endRadianAngle = PoChartStartAngle;
    this.seriesLabels = seriesList.map((serie) => {
      startRadianAngle = endRadianAngle;
      endRadianAngle = startRadianAngle + this.calculateAngle(serie.data, this.totalValue);
      const label = this.getPercentValue(serie.data, this.totalValue) + "% ";
      const color = this.getTextColor(serie.color);
      const coordinates = this.calculateLabelCoordinates(height, startRadianAngle, endRadianAngle);
      return __spreadProps(__spreadValues({}, coordinates), {
        label,
        color
      });
    });
  }
  calculateLabelCoordinates(height, startRadianAngle, endRadianAngle) {
    const radius = height / 2;
    const innerRadius = this.getInnerRadius(radius);
    const sliceCenterAngle = (startRadianAngle + endRadianAngle) / 2;
    const labelRadius = innerRadius + (radius - innerRadius) / 2;
    const xCoordinate = labelRadius * Math.cos(sliceCenterAngle) + radius;
    const yCoordinate = labelRadius * Math.sin(sliceCenterAngle) + radius;
    return {
      xCoordinate,
      yCoordinate
    };
  }
  getInnerRadius(radius) {
    const defaultInnerRadius = radius - PoChartDonutDefaultThickness;
    return this.innerRadius >= 0 ? this.innerRadius / 100 * radius : defaultInnerRadius;
  }
  getPercentValue(value, totalValue) {
    const percentValue = value / totalValue * 100;
    const floatPercentValue = convertNumberToDecimal(percentValue, 2);
    return String(floatPercentValue).replace(".", ",");
  }
  getTextColor(color) {
    if (PoDefaultColorsTextBlack.includes(color)) {
      return this.poChartBlackColor;
    }
    return this.poChartWhiteColor;
  }
  verifyDisplayLabels(radius, innerRadius) {
    this.canDisplayLabels = radius - innerRadius >= radius - (radius - PoChartDonutDefaultThickness);
  }
  static ɵfac = function PoChartDonutComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartDonutComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartDonutComponent,
    selectors: [["", "po-chart-donut", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    attrs: _c0$1h,
    decls: 3,
    vars: 2,
    consts: [["svgPaths", ""], ["svgLabels", ""], [4, "ngFor", "ngForOf"], [4, "ngIf"], ["po-chart-circular-path", "", 3, "p-on-click", "p-on-hover", "p-serie"], ["po-chart-circular-label", "", 3, "p-serie", "p-show-label"]],
    template: function PoChartDonutComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "g");
        ɵɵtemplate(1, PoChartDonutComponent__svg_g_1_Template, 3, 2, "g", 2)(2, PoChartDonutComponent__svg_g_2_Template, 2, 1, "g", 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.seriesList);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.canDisplayLabels);
      }
    },
    dependencies: [NgForOf, NgIf, PoChartCircularPathComponent, PoChartCircularLabelComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartDonutComponent, [{
    type: Component,
    args: [{
      selector: "[po-chart-donut]",
      standalone: false,
      template: `<svg:g>
  <!-- SERIES PATHS -->
  <svg:g *ngFor="let item of seriesList; let i = index">
    <svg:g #svgPaths po-chart-circular-path
      [attr.key]="'po-chart-circular-path-' + i"
      [p-serie]="item"
      (p-on-click)="onSerieClick($event)"
      (p-on-hover)="onSerieHover($event)">
    </svg:g>
  </svg:g>

  <!-- SERIES LABELS -->
  <svg:g *ngIf="canDisplayLabels">
    <svg:g *ngFor="let item of seriesLabels; let i = index">
      <svg:g #svgLabels po-chart-circular-label
        [attr.key]="'po-chart-circular-label-' + i"
        [p-serie]="item"
        [p-show-label]="showLabels">
      </svg:g>
    </svg:g>
  </svg:g>
</svg:g>

`
    }]
  }], () => [{
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartDonutComponent, {
    className: "PoChartDonutComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-circular/po-chart-donut/po-chart-donut.component.ts",
    lineNumber: 14
  });
})();
var _c0$1g = ["svgELement"];
function PoChartContainerComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 9);
    ɵɵlistener("p-categories-coordinates", function PoChartContainerComponent__svg_g_2_Template_g_p_categories_coordinates_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.getCategoriesCoordinates($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-align-by-the-corners", ctx_r2.alignByTheCorners)("p-range", ctx_r2.range)("p-type", ctx_r2.type)("p-series", ctx_r2.series)("p-container-size", ctx_r2.containerSize)("p-options", ctx_r2.axisOptions)("p-categories", ctx_r2.categories);
  }
}
function PoChartContainerComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 10);
    ɵɵlistener("p-bar-hover", function PoChartContainerComponent__svg_g_3_Template_g_p_bar_hover_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieHover($event));
    })("p-bar-click", function PoChartContainerComponent__svg_g_3_Template_g_p_bar_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-align-by-the-corners", ctx_r2.alignByTheCorners)("p-svg-space", ctx_r2.svgSpace)("p-categories", ctx_r2.categories)("p-categories-coordinates", ctx_r2.categoriesCoordinates)("p-range", ctx_r2.range)("p-series", ctx_r2.seriesByType["area"])("p-container-size", ctx_r2.containerSize);
  }
}
function PoChartContainerComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 11);
    ɵɵlistener("p-bar-hover", function PoChartContainerComponent__svg_g_4_Template_g_p_bar_hover_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieHover($event));
    })("p-bar-click", function PoChartContainerComponent__svg_g_4_Template_g_p_bar_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-categories", ctx_r2.categories)("p-range", ctx_r2.range)("p-series", ctx_r2.seriesByType["column"])("p-container-size", ctx_r2.containerSize);
  }
}
function PoChartContainerComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 12);
    ɵɵlistener("p-point-hover", function PoChartContainerComponent__svg_g_5_Template_g_p_point_hover_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieHover($event));
    })("p-point-click", function PoChartContainerComponent__svg_g_5_Template_g_p_point_click_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-categories", ctx_r2.categories)("p-range", ctx_r2.range)("p-series", ctx_r2.seriesByType["line"])("p-container-size", ctx_r2.containerSize)("p-data-label", ctx_r2.dataLabel)("p-insideChart", ctx_r2.insideChart);
  }
}
function PoChartContainerComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 13);
    ɵɵlistener("p-bar-hover", function PoChartContainerComponent__svg_g_6_Template_g_p_bar_hover_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieHover($event));
    })("p-bar-click", function PoChartContainerComponent__svg_g_6_Template_g_p_bar_click_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-categories", ctx_r2.categories)("p-range", ctx_r2.range)("p-series", ctx_r2.seriesByType["bar"])("p-container-size", ctx_r2.containerSize);
  }
}
function PoChartContainerComponent__svg_g_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 14);
    ɵɵlistener("p-circular-hover", function PoChartContainerComponent__svg_g_7_Template_g_p_circular_hover_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieHover($event));
    })("p-circular-click", function PoChartContainerComponent__svg_g_7_Template_g_p_circular_click_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-series", ctx_r2.seriesByType["pie"])("p-container-size", ctx_r2.containerSize);
  }
}
function PoChartContainerComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 15);
    ɵɵlistener("p-circular-hover", function PoChartContainerComponent__svg_g_8_Template_g_p_circular_hover_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieHover($event));
    })("p-circular-click", function PoChartContainerComponent__svg_g_8_Template_g_p_circular_click_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-options", ctx_r2.options)("p-series", ctx_r2.seriesByType["donut"])("p-container-size", ctx_r2.containerSize);
  }
}
var PoChartContainerComponent = class _PoChartContainerComponent {
  mathsService;
  categories;
  type;
  containerSize;
  dataLabel;
  serieClick = new EventEmitter();
  serieHover = new EventEmitter();
  svgELement;
  alignByTheCorners;
  axisOptions;
  categoriesCoordinates;
  range;
  seriesByType;
  svgSpace;
  viewBox;
  insideChart;
  _options;
  _series = [];
  set options(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._options = value;
      this.verifyAxisOptions(this._options);
    }
  }
  get options() {
    return this._options;
  }
  set series(data) {
    this._series = data;
    this.setAlignByTheCorners(this._series);
    this.setSeriesByType(this._series);
    this.setRange(this._series, this.options);
  }
  get series() {
    return this._series;
  }
  get isTypeCircular() {
    return this.type === PoChartType.Pie || this.type === PoChartType.Donut;
  }
  constructor(mathsService) {
    this.mathsService = mathsService;
  }
  ngOnChanges(changes) {
    if (changes.type || changes.containerSize) {
      this.setViewBox();
      this.setSvgSpace();
    }
    if (changes.dataLabel) {
      this.updateRangeAxis();
    }
  }
  updateRangeAxis() {
    if (this.dataLabel?.fixed === true) {
      const calculatedMaxValue = this.mathsService.calculateMinAndMaxValues(this.series).maxValue + 5;
      const newMaxValue = Math.max(calculatedMaxValue, this.range.maxValue);
      if (this.range.maxValue !== newMaxValue) {
        this.range.maxValue = newMaxValue;
        this.axisOptions.maxRange = newMaxValue;
      }
    }
  }
  getCategoriesCoordinates(value) {
    this.categoriesCoordinates = value;
  }
  onSerieClick(event) {
    this.serieClick.emit(event);
  }
  onSerieHover(event) {
    this.serieHover.emit(event);
  }
  getRange(series, options = {}) {
    const domain = this.mathsService.calculateMinAndMaxValues(series);
    const minValue = !options.axis?.minRange && domain.minValue > 0 ? 0 : options.axis?.minRange < domain.minValue ? options.axis.minRange : domain.minValue;
    const maxValue = options.axis?.maxRange > domain.maxValue ? options.axis.maxRange : domain.maxValue;
    const updatedDomainValues = {
      minValue,
      maxValue
    };
    return __spreadValues(__spreadValues({}, domain), updatedDomainValues);
  }
  setSvgSpace() {
    const svgPoint = this.svgELement.nativeElement.createSVGPoint();
    const svgDomMatrix = this.svgELement.nativeElement.getScreenCTM()?.inverse();
    this.svgSpace = {
      svgPoint,
      svgDomMatrix
    };
  }
  setAlignByTheCorners(series) {
    this.alignByTheCorners = series.every((serie) => serie.type === PoChartType.Area || serie.type === PoChartType.Bar);
  }
  setRange(series, options = {}) {
    if (!this.isTypeCircular) {
      this.range = this.getRange(series, options);
    }
  }
  setSeriesByType(series) {
    this.seriesByType = {
      [PoChartType.Area]: series.filter((serie) => serie.type === PoChartType.Area),
      [PoChartType.Column]: series.filter((serie) => serie.type === PoChartType.Column),
      [PoChartType.Bar]: series.filter((serie) => serie.type === PoChartType.Bar),
      [PoChartType.Line]: series.filter((serie) => serie.type === PoChartType.Line),
      [PoChartType.Donut]: series.filter((serie) => serie.type === PoChartType.Donut),
      [PoChartType.Pie]: series.filter((serie) => serie.type === PoChartType.Pie)
    };
  }
  setViewBox() {
    const {
      svgWidth,
      svgHeight
    } = this.containerSize;
    const viewBoxWidth = this.isTypeCircular ? svgHeight : svgWidth;
    const offsetXY = 1;
    this.viewBox = `${offsetXY} -${offsetXY} ${viewBoxWidth} ${this.containerSize.svgHeight}`;
  }
  verifyAxisOptions(options) {
    if (!this.isTypeCircular && options.hasOwnProperty("axis")) {
      this.range = this.getRange(this.series, this.options);
      this.axisOptions = __spreadValues(__spreadValues({}, this.axisOptions), options.axis);
    }
  }
  onChartMouseEnter() {
    this.insideChart = true;
  }
  onChartMouseLeave() {
    this.insideChart = false;
  }
  static ɵfac = function PoChartContainerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartContainerComponent)(ɵɵdirectiveInject(PoChartMathsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartContainerComponent,
    selectors: [["po-chart-container"]],
    viewQuery: function PoChartContainerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1g, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgELement = _t.first);
      }
    },
    inputs: {
      categories: [0, "p-categories", "categories"],
      type: [0, "p-type", "type"],
      containerSize: [0, "p-container-size", "containerSize"],
      dataLabel: [0, "p-data-label", "dataLabel"],
      options: [0, "p-options", "options"],
      series: [0, "p-series", "series"]
    },
    outputs: {
      serieClick: "p-serie-click",
      serieHover: "p-serie-hover"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature],
    decls: 9,
    vars: 10,
    consts: [["svgELement", ""], ["preserveAspectRatio", "xMidYMin meet", 1, "po-chart-svg-element", 3, "mouseenter", "mouseleave"], ["po-chart-axis", "", 3, "p-align-by-the-corners", "p-range", "p-type", "p-series", "p-container-size", "p-options", "p-categories", "p-categories-coordinates", 4, "ngIf"], ["po-chart-area", "", 3, "p-align-by-the-corners", "p-svg-space", "p-categories", "p-categories-coordinates", "p-range", "p-series", "p-container-size", "p-bar-hover", "p-bar-click", 4, "ngIf"], ["po-chart-column", "", 3, "p-categories", "p-range", "p-series", "p-container-size", "p-bar-hover", "p-bar-click", 4, "ngIf"], ["po-chart-line", "", 3, "p-categories", "p-range", "p-series", "p-container-size", "p-data-label", "p-insideChart", "p-point-hover", "p-point-click", 4, "ngIf"], ["po-chart-bar", "", 3, "p-categories", "p-range", "p-series", "p-container-size", "p-bar-hover", "p-bar-click", 4, "ngIf"], ["po-chart-pie", "", 3, "p-series", "p-container-size", "p-circular-hover", "p-circular-click", 4, "ngIf"], ["po-chart-donut", "", 3, "p-options", "p-series", "p-container-size", "p-circular-hover", "p-circular-click", 4, "ngIf"], ["po-chart-axis", "", 3, "p-categories-coordinates", "p-align-by-the-corners", "p-range", "p-type", "p-series", "p-container-size", "p-options", "p-categories"], ["po-chart-area", "", 3, "p-bar-hover", "p-bar-click", "p-align-by-the-corners", "p-svg-space", "p-categories", "p-categories-coordinates", "p-range", "p-series", "p-container-size"], ["po-chart-column", "", 3, "p-bar-hover", "p-bar-click", "p-categories", "p-range", "p-series", "p-container-size"], ["po-chart-line", "", 3, "p-point-hover", "p-point-click", "p-categories", "p-range", "p-series", "p-container-size", "p-data-label", "p-insideChart"], ["po-chart-bar", "", 3, "p-bar-hover", "p-bar-click", "p-categories", "p-range", "p-series", "p-container-size"], ["po-chart-pie", "", 3, "p-circular-hover", "p-circular-click", "p-series", "p-container-size"], ["po-chart-donut", "", 3, "p-circular-hover", "p-circular-click", "p-options", "p-series", "p-container-size"]],
    template: function PoChartContainerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "svg", 1, 0);
        ɵɵlistener("mouseenter", function PoChartContainerComponent_Template_svg_mouseenter_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onChartMouseEnter());
        })("mouseleave", function PoChartContainerComponent_Template_svg_mouseleave_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onChartMouseLeave());
        });
        ɵɵtemplate(2, PoChartContainerComponent__svg_g_2_Template, 1, 7, "g", 2)(3, PoChartContainerComponent__svg_g_3_Template, 1, 7, "g", 3)(4, PoChartContainerComponent__svg_g_4_Template, 1, 4, "g", 4)(5, PoChartContainerComponent__svg_g_5_Template, 1, 6, "g", 5)(6, PoChartContainerComponent__svg_g_6_Template, 1, 4, "g", 6)(7, PoChartContainerComponent__svg_g_7_Template, 1, 2, "g", 7)(8, PoChartContainerComponent__svg_g_8_Template, 1, 3, "g", 8);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵattribute("viewBox", ctx.viewBox)("width", ctx.containerSize.svgWidth)("height", ctx.containerSize.svgHeight);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.isTypeCircular);
        ɵɵadvance();
        ɵɵproperty("ngIf", (ctx.type === "area" || ctx.type === "line" || ctx.type === "column") && ctx.seriesByType["area"].length);
        ɵɵadvance();
        ɵɵproperty("ngIf", (ctx.type === "area" || ctx.type === "line" || ctx.type === "column") && ctx.seriesByType["column"].length);
        ɵɵadvance();
        ɵɵproperty("ngIf", (ctx.type === "area" || ctx.type === "line" || ctx.type === "column") && ctx.seriesByType["line"].length);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "bar");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "pie");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "donut");
      }
    },
    dependencies: [NgIf, PoChartAreaComponent, PoChartAxisComponent, PoChartLineComponent, PoChartPieComponent, PoChartDonutComponent, PoChartBarComponent, PoChartColumnComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartContainerComponent, [{
    type: Component,
    args: [{
      selector: "po-chart-container",
      standalone: false,
      template: `<svg:svg
  #svgELement
  class="po-chart-svg-element"
  preserveAspectRatio="xMidYMin meet"
  [attr.viewBox]="viewBox"
  [attr.width]="containerSize.svgWidth"
  [attr.height]="containerSize.svgHeight"
  (mouseenter)="onChartMouseEnter()"
  (mouseleave)="onChartMouseLeave()"
>
  <!-- axis -->
  <svg:g
    *ngIf="!isTypeCircular"
    po-chart-axis
    [p-align-by-the-corners]="alignByTheCorners"
    [p-range]="range"
    [p-type]="type"
    [p-series]="series"
    [p-container-size]="containerSize"
    [p-options]="axisOptions"
    [p-categories]="categories"
    (p-categories-coordinates)="getCategoriesCoordinates($event)"
  ></svg:g>

  <!-- chart area -->
  <svg:g
    *ngIf="(type === 'area' || type === 'line' || type === 'column') && seriesByType['area'].length"
    po-chart-area
    [p-align-by-the-corners]="alignByTheCorners"
    [p-svg-space]="svgSpace"
    [p-categories]="categories"
    [p-categories-coordinates]="categoriesCoordinates"
    [p-range]="range"
    [p-series]="seriesByType['area']"
    [p-container-size]="containerSize"
    (p-bar-hover)="onSerieHover($event)"
    (p-bar-click)="onSerieClick($event)"
  ></svg:g>

  <!-- chart column -->
  <svg:g
    *ngIf="(type === 'area' || type === 'line' || type === 'column') && seriesByType['column'].length"
    po-chart-column
    [p-categories]="categories"
    [p-range]="range"
    [p-series]="seriesByType['column']"
    [p-container-size]="containerSize"
    (p-bar-hover)="onSerieHover($event)"
    (p-bar-click)="onSerieClick($event)"
  ></svg:g>

  <!-- chart line -->
  <svg:g
    *ngIf="(type === 'area' || type === 'line' || type === 'column') && seriesByType['line'].length"
    po-chart-line
    [p-categories]="categories"
    [p-range]="range"
    [p-series]="seriesByType['line']"
    [p-container-size]="containerSize"
    [p-data-label]="dataLabel"
    [p-insideChart]="insideChart"
    (p-point-hover)="onSerieHover($event)"
    (p-point-click)="onSerieClick($event)"
  ></svg:g>

  <!-- chart bar -->
  <svg:g
    *ngIf="type === 'bar'"
    po-chart-bar
    [p-categories]="categories"
    [p-range]="range"
    [p-series]="seriesByType['bar']"
    [p-container-size]="containerSize"
    (p-bar-hover)="onSerieHover($event)"
    (p-bar-click)="onSerieClick($event)"
  ></svg:g>

  <svg:g
    *ngIf="type === 'pie'"
    po-chart-pie
    [p-series]="seriesByType['pie']"
    [p-container-size]="containerSize"
    (p-circular-hover)="onSerieHover($event)"
    (p-circular-click)="onSerieClick($event)"
  ></svg:g>

  <svg:g
    *ngIf="type === 'donut'"
    po-chart-donut
    [p-options]="options"
    [p-series]="seriesByType['donut']"
    [p-container-size]="containerSize"
    (p-circular-hover)="onSerieHover($event)"
    (p-circular-click)="onSerieClick($event)"
  ></svg:g>
</svg:svg>
`
    }]
  }], () => [{
    type: PoChartMathsService
  }], {
    categories: [{
      type: Input,
      args: ["p-categories"]
    }],
    type: [{
      type: Input,
      args: ["p-type"]
    }],
    containerSize: [{
      type: Input,
      args: ["p-container-size"]
    }],
    dataLabel: [{
      type: Input,
      args: ["p-data-label"]
    }],
    serieClick: [{
      type: Output,
      args: ["p-serie-click"]
    }],
    serieHover: [{
      type: Output,
      args: ["p-serie-hover"]
    }],
    svgELement: [{
      type: ViewChild,
      args: ["svgELement", {
        static: true
      }]
    }],
    options: [{
      type: Input,
      args: ["p-options"]
    }],
    series: [{
      type: Input,
      args: ["p-series"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartContainerComponent, {
    className: "PoChartContainerComponent",
    filePath: "lib/components/po-chart/po-chart-container/po-chart-container.component.ts",
    lineNumber: 17
  });
})();
function PoChartLegendComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵelement(1, "div", 4);
    ɵɵelementStart(2, "span", 5);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const serie_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵclassMap((serie_r1.color == null ? null : serie_r1.color.includes("po-color")) ? serie_r1.color : "");
    ɵɵstyleProp("background", serie_r1.color);
    ɵɵadvance(2);
    ɵɵtextInterpolate(serie_r1.label || serie_r1.category);
  }
}
var PoChartLegendComponent = class _PoChartLegendComponent {
  type;
  _series;
  set series(value) {
    this._series = value;
  }
  get series() {
    return this._series;
  }
  static ɵfac = function PoChartLegendComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartLegendComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartLegendComponent,
    selectors: [["po-chart-legend"]],
    inputs: {
      type: [0, "p-type", "type"],
      series: [0, "p-series", "series"]
    },
    standalone: false,
    decls: 3,
    vars: 1,
    consts: [[1, "po-chart-legend"], [1, "po-chart-legend-container"], ["class", "po-chart-legend-item", 4, "ngFor", "ngForOf"], [1, "po-chart-legend-item"], [1, "po-chart-legend-square"], [1, "po-chart-legend-text"]],
    template: function PoChartLegendComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "div", 1);
        ɵɵtemplate(2, PoChartLegendComponent_div_2_Template, 4, 5, "div", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ctx.series);
      }
    },
    dependencies: [NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartLegendComponent, [{
    type: Component,
    args: [{
      selector: "po-chart-legend",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<div class="po-chart-legend">
  <div class="po-chart-legend-container">
    <div class="po-chart-legend-item" *ngFor="let serie of series; let i = index">
      <div
        class="po-chart-legend-square"
        [class]="serie.color?.includes('po-color') ? serie.color : ''"
        [style.background]="serie.color"
      ></div>
      <span class="po-chart-legend-text">{{ serie.label || serie.category }}</span>
    </div>
  </div>
</div>
`
    }]
  }], null, {
    type: [{
      type: Input,
      args: ["p-type"]
    }],
    series: [{
      type: Input,
      args: ["p-series"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartLegendComponent, {
    className: "PoChartLegendComponent",
    filePath: "lib/components/po-chart/po-chart-legend/po-chart-legend.component.ts",
    lineNumber: 11
  });
})();
var PoResizeObserverDirective = class _PoResizeObserverDirective {
  elementRef;
  resize = new EventEmitter();
  subscription = new Subscription();
  observer;
  chartWidthResize$ = new Subject();
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
  ngOnDestroy() {
    if (this.isResizeObserverSupported) {
      this.observer.unobserve(this.elementRef.nativeElement);
      this.subscription.unsubscribe();
    }
  }
  ngOnInit() {
    if (this.isResizeObserverSupported) {
      this.observer = new window.ResizeObserver(() => {
        this.chartWidthResize$.next({});
      });
      this.observer.observe(this.elementRef.nativeElement);
      this.subscription.add(this.chartWidthResize$.pipe(debounceTime(20)).subscribe((_) => {
        this.resize.emit();
      }));
    }
  }
  get isResizeObserverSupported() {
    return typeof window.ResizeObserver === "function";
  }
  static ɵfac = function PoResizeObserverDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoResizeObserverDirective)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoResizeObserverDirective,
    selectors: [["", "p-resize-observer", ""]],
    outputs: {
      resize: "p-resize-observer"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoResizeObserverDirective, [{
    type: Directive,
    args: [{
      selector: "[p-resize-observer]",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }], {
    resize: [{
      type: Output,
      args: ["p-resize-observer"]
    }]
  });
})();
var _c0$1f = ["chartContainer"];
var _c1$x = ["chartHeader"];
var _c2$h = ["chartLegend"];
var _c3$d = ["chartWrapper"];
function PoChartComponent_ng_template_7_Template(rf, ctx) {
}
function PoChartComponent_div_9_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoChartComponent_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, PoChartComponent_div_9_ng_container_1_Template, 1, 0, "ng-container", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const chartLegendGroup_r2 = ɵɵreference(11);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", chartLegendGroup_r2);
  }
}
function PoChartComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-chart-legend", 11, 4);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-series", ctx_r2.chartSeries)("p-type", ctx_r2.type);
  }
}
var PoChartComponent = class _PoChartComponent extends PoChartBaseComponent {
  colorService;
  changeDetector;
  containerService;
  componentFactoryResolver;
  elementRef;
  mathsService;
  renderer;
  chartContainer;
  chartHeader;
  chartLegend;
  chartWrapper;
  calculatedComponentRefElement = false;
  calculatedSvgContainerElement = false;
  componentRef;
  initialized = false;
  windowResizeListener = new Subject();
  subscription = new Subscription();
  mappings = {};
  constructor(colorService, changeDetector, containerService, componentFactoryResolver, elementRef, mathsService, renderer) {
    super(colorService);
    this.colorService = colorService;
    this.changeDetector = changeDetector;
    this.containerService = containerService;
    this.componentFactoryResolver = componentFactoryResolver;
    this.elementRef = elementRef;
    this.mathsService = mathsService;
    this.renderer = renderer;
  }
  onResize = () => {
    this.getSvgContainerSize();
    this.windowResizeListener.next({});
  };
  ngAfterViewInit() {
    this.initialized = true;
    this.getSvgContainerSize();
  }
  ngDoCheck() {
    const charWrapperWidth = this.chartWrapper.nativeElement.offsetWidth;
    const isDynamicChart = this.getComponentType(this.type);
    if (charWrapperWidth && this.initialized && !isDynamicChart && !this.calculatedSvgContainerElement) {
      this.getSvgContainerSize();
      this.calculatedSvgContainerElement = true;
    }
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
    this.removeWindowResizeListener();
  }
  resizeAction() {
    this.getSvgContainerSize();
    this.windowResizeListener.next({});
    this.changeDetector.detectChanges();
  }
  ngOnInit() {
    this.getSvgContainerSize();
  }
  rebuildComponentRef() {
    if (this.componentRef) {
      this.componentRef.destroy();
    }
  }
  calculateAxisXLabelArea() {
    const axisXLabels = this.chartType === PoChartType.Bar ? this.categories : this.chartSeries;
    return this.getAxisXLabelArea(this.mathsService.getLongestDataValue(axisXLabels, this.chartType, this.options));
  }
  getSvgContainerSize() {
    let axisXLabelWidth;
    const {
      chartHeaderHeight,
      chartLegendHeight,
      chartWrapperWidth
    } = this.getChartMeasurements();
    if (!this.isTypeCircular) {
      axisXLabelWidth = this.calculateAxisXLabelArea();
    }
    this.svgContainerSize = __spreadProps(__spreadValues({}, this.containerService.calculateSVGContainerMeasurements(this.height, chartWrapperWidth, chartHeaderHeight, chartLegendHeight)), {
      axisXLabelWidth
    });
  }
  chartLegendHeight(chartLegend) {
    return chartLegend ? chartLegend.nativeElement.offsetHeight : 0;
  }
  createComponent() {
    const componentType = this.getComponentType(this.type);
    const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
    this.componentRef = this.chartContainer.createComponent(factory);
    const instance = this.componentRef.instance;
    this.setComponentRefProperties(instance);
    return instance;
  }
  dynamicComponentSetting() {
    const instance = this.createComponent();
    this.setResizeListenerSubscribe(instance);
    this.changeDetector.detectChanges();
    this.setClickSubscribe(instance);
    this.setHoverSubscribe(instance);
  }
  getAxisXLabelArea(axisXLabel) {
    const labelPoChartPadding = PoChartPadding / 3;
    const spanElement = this.renderer.createElement("span");
    this.renderer.addClass(spanElement, "po-chart-axis-x-label");
    const formattedLabel = typeof axisXLabel === "number" ? axisXLabel.toFixed(2) : axisXLabel;
    spanElement.innerHTML = formattedLabel;
    this.renderer.appendChild(this.elementRef.nativeElement, spanElement);
    const axisXLabelWidth = Math.ceil(spanElement.offsetWidth) + labelPoChartPadding;
    this.renderer.removeChild(this.elementRef.nativeElement, spanElement);
    return axisXLabelWidth > PoChartAxisXLabelArea ? axisXLabelWidth : PoChartAxisXLabelArea;
  }
  getComponentType(typeName) {
    return this.mappings[typeName];
  }
  getChartMeasurements() {
    const chartWrapperWidth = this.chartWrapper.nativeElement.offsetWidth;
    const chartHeaderHeight = this.chartHeader.nativeElement.offsetHeight;
    const chartLegendHeight = this.chartLegendHeight(this.chartLegend);
    return {
      chartWrapperWidth,
      chartHeaderHeight,
      chartLegendHeight
    };
  }
  removeWindowResizeListener() {
    if (this.onResize) {
      this.onResize = () => {
      };
    }
  }
  setComponentRefProperties(instance) {
    const {
      chartHeaderHeight,
      chartLegendHeight,
      chartWrapperWidth
    } = this.getChartMeasurements();
    instance.chartHeader = chartHeaderHeight;
    instance.chartLegend = chartLegendHeight;
    instance.chartWrapper = chartWrapperWidth;
    instance.colors = PoDefaultColors[0];
    instance.height = this.height;
    instance.type = this.type;
    instance.series = this.chartSeries || [];
  }
  setClickSubscribe(instance) {
    this.subscription.add(instance.onSerieClick.subscribe((event) => {
      this.onSeriesClick(event);
    }));
  }
  setHoverSubscribe(instance) {
    this.subscription.add(instance.onSerieHover.subscribe((event) => {
      this.onSeriesHover(event);
    }));
  }
  setResizeListenerSubscribe(instance) {
    this.subscription.add(this.windowResizeListener.subscribe(() => {
      const measuresForComponentRef = this.getChartMeasurements();
      instance.chartWrapper = measuresForComponentRef.chartWrapperWidth;
      instance.chartHeader = measuresForComponentRef.chartHeaderHeight;
      instance.chartLegend = measuresForComponentRef.chartLegendHeight;
    }));
  }
  static ɵfac = function PoChartComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartComponent)(ɵɵdirectiveInject(PoColorService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoChartSvgContainerService), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoChartMathsService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoChartComponent,
    selectors: [["po-chart"]],
    viewQuery: function PoChartComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1f, 7, ViewContainerRef);
        ɵɵviewQuery(_c1$x, 7);
        ɵɵviewQuery(_c2$h, 5, ElementRef);
        ɵɵviewQuery(_c3$d, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartHeader = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartLegend = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartWrapper = _t.first);
      }
    },
    hostBindings: function PoChartComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("resize", function PoChartComponent_resize_HostBindingHandler() {
          return ctx.onResize();
        }, false, ɵɵresolveWindow);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 12,
    vars: 8,
    consts: [["chartWrapper", ""], ["chartHeader", ""], ["chartContainer", ""], ["chartLegendGroup", ""], ["chartLegend", ""], [1, "po-chart-wrapper", 3, "p-resize-observer"], [1, "po-chart-header"], [1, "po-chart-title"], [3, "p-serie-click", "p-serie-hover", "p-options", "p-type", "p-series", "p-categories", "p-container-size", "p-data-label"], [4, "ngIf"], [4, "ngTemplateOutlet"], [3, "p-series", "p-type"]],
    template: function PoChartComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 5, 0);
        ɵɵlistener("p-resize-observer", function PoChartComponent_Template_div_p_resize_observer_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.resizeAction());
        });
        ɵɵelementStart(2, "div", 6, 1)(4, "div", 7);
        ɵɵtext(5);
        ɵɵelementEnd()();
        ɵɵelementStart(6, "po-chart-container", 8);
        ɵɵlistener("p-serie-click", function PoChartComponent_Template_po_chart_container_p_serie_click_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onSeriesClick($event));
        })("p-serie-hover", function PoChartComponent_Template_po_chart_container_p_serie_hover_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onSeriesHover($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(7, PoChartComponent_ng_template_7_Template, 0, 0, "ng-template", null, 2, ɵɵtemplateRefExtractor)(9, PoChartComponent_div_9_Template, 2, 1, "div", 9);
        ɵɵelementEnd();
        ɵɵtemplate(10, PoChartComponent_ng_template_10_Template, 2, 2, "ng-template", null, 3, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance(5);
        ɵɵtextInterpolate(ctx.title);
        ɵɵadvance();
        ɵɵproperty("p-options", ctx.options)("p-type", ctx.chartType)("p-series", ctx.chartSeries)("p-categories", ctx.categories)("p-container-size", ctx.svgContainerSize)("p-data-label", ctx.dataLabel);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", (ctx.options == null ? null : ctx.options.legend) !== false);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, PoChartContainerComponent, PoChartLegendComponent, PoResizeObserverDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartComponent, [{
    type: Component,
    args: [{
      selector: "po-chart",
      standalone: false,
      template: '<div #chartWrapper class="po-chart-wrapper" (p-resize-observer)="resizeAction()">\n  <div #chartHeader class="po-chart-header">\n    <div class="po-chart-title">{{ title }}</div>\n  </div>\n\n  <po-chart-container\n    [p-options]="options"\n    [p-type]="chartType"\n    [p-series]="chartSeries"\n    [p-categories]="categories"\n    [p-container-size]="svgContainerSize"\n    [p-data-label]="dataLabel"\n    (p-serie-click)="onSeriesClick($event)"\n    (p-serie-hover)="onSeriesHover($event)"\n  ></po-chart-container>\n\n  <!-- Injeção de gráficos do tipo gauge. Remover na depreciação.  -->\n  <ng-template #chartContainer></ng-template>\n\n  <div *ngIf="options?.legend !== false">\n    <ng-container *ngTemplateOutlet="chartLegendGroup"></ng-container>\n  </div>\n</div>\n\n<ng-template #chartLegendGroup>\n  <po-chart-legend #chartLegend [p-series]="chartSeries" [p-type]="type"> </po-chart-legend>\n</ng-template>\n'
    }]
  }], () => [{
    type: PoColorService
  }, {
    type: ChangeDetectorRef
  }, {
    type: PoChartSvgContainerService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: ElementRef
  }, {
    type: PoChartMathsService
  }, {
    type: Renderer2
  }], {
    chartContainer: [{
      type: ViewChild,
      args: ["chartContainer", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    chartHeader: [{
      type: ViewChild,
      args: ["chartHeader", {
        static: true
      }]
    }],
    chartLegend: [{
      type: ViewChild,
      args: ["chartLegend", {
        read: ElementRef
      }]
    }],
    chartWrapper: [{
      type: ViewChild,
      args: ["chartWrapper", {
        static: true
      }]
    }],
    onResize: [{
      type: HostListener,
      args: ["window:resize"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartComponent, {
    className: "PoChartComponent",
    filePath: "lib/components/po-chart/po-chart.component.ts",
    lineNumber: 59
  });
})();
var PoChartModule = class _PoChartModule {
  static ɵfac = function PoChartModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoChartModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoChartModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [DecimalPipe, CurrencyPipe],
    imports: [CommonModule, PoTooltipModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoTooltipModule],
      declarations: [PoChartAreaComponent, PoChartAxisComponent, PoChartAxisPathComponent, PoChartAxisLabelComponent, PoChartComponent, PoChartContainerComponent, PoChartLegendComponent, PoChartLineComponent, PoChartPathComponent, PoChartPieComponent, PoChartDonutComponent, PoChartSeriesPointComponent, PoChartBarComponent, PoChartColumnComponent, PoChartBarPathComponent, PoChartCircularPathComponent, PoChartCircularLabelComponent, PoChartTooltipDirective, PoResizeObserverDirective],
      exports: [PoChartComponent],
      providers: [DecimalPipe, CurrencyPipe]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoChartModule, {
    declarations: [PoChartAreaComponent, PoChartAxisComponent, PoChartAxisPathComponent, PoChartAxisLabelComponent, PoChartComponent, PoChartContainerComponent, PoChartLegendComponent, PoChartLineComponent, PoChartPathComponent, PoChartPieComponent, PoChartDonutComponent, PoChartSeriesPointComponent, PoChartBarComponent, PoChartColumnComponent, PoChartBarPathComponent, PoChartCircularPathComponent, PoChartCircularLabelComponent, PoChartTooltipDirective, PoResizeObserverDirective],
    imports: [CommonModule, PoTooltipModule],
    exports: [PoChartComponent]
  });
})();
var PoContainerBaseComponent = class _PoContainerBaseComponent {
  _height;
  _noBorder = false;
  _noPadding = false;
  /**
   * @optional
   *
   * @description
   *
   * Define a altura do `po-container`.
   *
   * > Caso não seja definido um valor, a altura se ajustará de acordo com o conteúdo.
   */
  set height(value) {
    this._height = convertToInt(value);
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita a borda e a sombra em torno do `po-container`.
   *
   * @default `false`
   */
  set noBorder(value) {
    this._noBorder = convertToBoolean(value);
  }
  get noBorder() {
    return this._noBorder;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o espaçamento interno do `po-container`.
   *
   * @default `false`
   */
  set noPadding(value) {
    this._noPadding = convertToBoolean(value);
  }
  get noPadding() {
    return this._noPadding;
  }
  /**
   * @optional
   *
   * @description
   *
   * Título do Container.
   */
  title;
  static ɵfac = function PoContainerBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoContainerBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoContainerBaseComponent,
    inputs: {
      height: [0, "p-height", "height"],
      noBorder: [0, "p-no-border", "noBorder"],
      noPadding: [0, "p-no-padding", "noPadding"],
      title: [0, "p-title", "title"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoContainerBaseComponent, [{
    type: Directive
  }], null, {
    height: [{
      type: Input,
      args: ["p-height"]
    }],
    noBorder: [{
      type: Input,
      args: ["p-no-border"]
    }],
    noPadding: [{
      type: Input,
      args: ["p-no-padding"]
    }],
    title: [{
      type: Input,
      args: ["p-title"]
    }]
  });
})();
var _c0$1e = ["*"];
function PoContainerComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.title, " ");
  }
}
var PoContainerComponent = class _PoContainerComponent extends PoContainerBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoContainerComponent_BaseFactory;
    return function PoContainerComponent_Factory(__ngFactoryType__) {
      return (ɵPoContainerComponent_BaseFactory || (ɵPoContainerComponent_BaseFactory = ɵɵgetInheritedFactory(_PoContainerComponent)))(__ngFactoryType__ || _PoContainerComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoContainerComponent,
    selectors: [["po-container"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0$1e,
    decls: 4,
    vars: 7,
    consts: [[1, "po-container"], ["class", "po-container-title", 4, "ngIf"], [1, "po-container-content"], [1, "po-container-title"]],
    template: function PoContainerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoContainerComponent_div_1_Template, 2, 1, "div", 1);
        ɵɵelementStart(2, "div", 2);
        ɵɵprojection(3);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.title);
        ɵɵadvance();
        ɵɵstyleProp("height", ctx.height ? ctx.height + "px" : "auto");
        ɵɵclassProp("po-container-no-border", ctx.noBorder)("po-container-no-padding", ctx.noPadding);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoContainerComponent, [{
    type: Component,
    args: [{
      selector: "po-container",
      standalone: false,
      template: `<div class="po-container">
  <div class="po-container-title" *ngIf="title">
    {{ title }}
  </div>
  <div
    class="po-container-content"
    [class.po-container-no-border]="noBorder"
    [class.po-container-no-padding]="noPadding"
    [style.height]="height ? height + 'px' : 'auto'"
  >
    <ng-content></ng-content>
  </div>
</div>
`
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoContainerComponent, {
    className: "PoContainerComponent",
    filePath: "lib/components/po-container/po-container.component.ts",
    lineNumber: 31
  });
})();
var PoContainerModule = class _PoContainerModule {
  static ɵfac = function PoContainerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoContainerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoContainerModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoContainerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      exports: [PoContainerComponent],
      declarations: [PoContainerComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoContainerModule, {
    declarations: [PoContainerComponent],
    imports: [CommonModule],
    exports: [PoContainerComponent]
  });
})();
var PoDisclaimerLiterals = {
  en: {
    remove: "Remove"
  },
  es: {
    remove: "Eliminar"
  },
  pt: {
    remove: "Remover"
  },
  ru: {
    remove: "удалять"
  }
};
var PO_DISCLAIMER_TYPES = ["default", "danger"];
var PO_DISCLAIMER_DEFAULT_TYPE = "default";
var PoDisclaimerBaseComponent = class _PoDisclaimerBaseComponent {
  languageService;
  /**
   * Label que aparecerá dentro do po-disclaimer.
   * Quando não for definido um label será apresentada a propriedade p-value.
   */
  label;
  /** Valor do po-disclaimer. */
  value;
  /** Nome da propriedade vinculada à este po-disclaimer. */
  property;
  disclaimerCustomWidth = 201;
  lastDisclaimer = false;
  tooltipPosition = "bottom";
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao fechar o disclaimer.
   * Para este evento será passado como parâmetro um objeto com value, label e property.
   */
  closeAction = new EventEmitter();
  clickNumber = new EventEmitter();
  literals;
  showDisclaimer = true;
  _type = "default";
  _hideClose = false;
  /**
   * @description
   *
   * Esta propriedade esconde o botão para fechamento do po-disclaimer, ao utilizar esta propriedade
   * sem passar valor a mesma é setada como false, onde o botão de fechamento está visível.
   *
   * @default false
   */
  set hideClose(value) {
    this._hideClose = value === "" ? true : convertToBoolean(value);
  }
  get hideClose() {
    return this._hideClose;
  }
  /**
   * @description
   *
   * Tipo do po-disclaimer. Pode ser 'default' ou 'danger'.
   *
   * @default default
   * @optional
   */
  set type(type) {
    this._type = PO_DISCLAIMER_TYPES.includes(type) ? type : PO_DISCLAIMER_DEFAULT_TYPE;
  }
  get type() {
    return this._type;
  }
  constructor(languageService) {
    this.languageService = languageService;
    const language = this.languageService?.getShortLanguage();
    this.literals = __spreadValues({}, PoDisclaimerLiterals[language]);
  }
  close() {
    this.showDisclaimer = false;
    this.closeAction.emit({
      value: this.value,
      label: this.label,
      property: this.property
    });
  }
  getLabel() {
    return this.label ? this.label : this.value;
  }
  setAriaLabel() {
    return this.label ? this.label + " " + this.literals.remove : this.value + " " + this.literals.remove;
  }
  static ɵfac = function PoDisclaimerBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDisclaimerBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoDisclaimerBaseComponent,
    inputs: {
      label: [0, "p-label", "label"],
      value: [0, "p-value", "value"],
      property: [0, "p-property", "property"],
      disclaimerCustomWidth: [0, "p-disclaimer-custom-width", "disclaimerCustomWidth"],
      lastDisclaimer: [0, "p-last-disclaimer", "lastDisclaimer"],
      tooltipPosition: [0, "p-tooltip-position", "tooltipPosition"],
      hideClose: [0, "p-hide-close", "hideClose"],
      type: [0, "p-type", "type"]
    },
    outputs: {
      closeAction: "p-close-action",
      clickNumber: "p-click-number"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }],
    property: [{
      type: Input,
      args: ["p-property"]
    }],
    disclaimerCustomWidth: [{
      type: Input,
      args: ["p-disclaimer-custom-width"]
    }],
    lastDisclaimer: [{
      type: Input,
      args: ["p-last-disclaimer"]
    }],
    tooltipPosition: [{
      type: Input,
      args: ["p-tooltip-position"]
    }],
    closeAction: [{
      type: Output,
      args: ["p-close-action"]
    }],
    clickNumber: [{
      type: Output,
      args: ["p-click-number"]
    }],
    hideClose: [{
      type: Input,
      args: ["p-hide-close"]
    }],
    type: [{
      type: Input,
      args: ["p-type"]
    }]
  });
})();
var _c0$1d = ["disclaimerContainer"];
function PoDisclaimerComponent_div_2_po_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-icon", 7);
    ɵɵlistener("click", function PoDisclaimerComponent_div_2_po_icon_4_Template_po_icon_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.close());
    })("keydown", function PoDisclaimerComponent_div_2_po_icon_4_Template_po_icon_keydown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onKeyPress($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("po-disclaimer-remove-danger", ctx_r1.type === "danger");
    ɵɵattribute("aria-label", ctx_r1.setAriaLabel())("role", !ctx_r1.hideClose ? "button" : "");
  }
}
function PoDisclaimerComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("click", function PoDisclaimerComponent_div_2_Template_div_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitLastDisclaimer(ctx_r1.lastDisclaimer));
    })("keydown.enter", function PoDisclaimerComponent_div_2_Template_div_keydown_enter_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitLastDisclaimer(ctx_r1.lastDisclaimer));
    });
    ɵɵelementStart(1, "div", 4)(2, "span", 5);
    ɵɵtext(3);
    ɵɵelementEnd()();
    ɵɵtemplate(4, PoDisclaimerComponent_div_2_po_icon_4_Template, 1, 4, "po-icon", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-disclaimer-remove-all", ctx_r1.hideClose)("po-disclaimer-danger", ctx_r1.type === "danger");
    ɵɵproperty("p-tooltip", ctx_r1.getWidthDisclaimer() ? ctx_r1.getLabel() : "")("p-tooltip-position", ctx_r1.tooltipPosition)("tabindex", ctx_r1.hideClose ? "0" : "-1");
    ɵɵadvance();
    ɵɵclassProp("show-close", !ctx_r1.hideClose);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.getLabel(), " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hideClose === false);
  }
}
var PoDisclaimerComponent = class _PoDisclaimerComponent extends PoDisclaimerBaseComponent {
  disclaimerContainer;
  onKeyPress(event) {
    if (isKeyCodeEnter(event)) {
      this.close();
    }
  }
  emitLastDisclaimer(isLast) {
    if (isLast) {
      this.clickNumber.emit();
    }
  }
  getWidthDisclaimer() {
    return this.disclaimerContainer.nativeElement.offsetWidth > this.disclaimerCustomWidth;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoDisclaimerComponent_BaseFactory;
    return function PoDisclaimerComponent_Factory(__ngFactoryType__) {
      return (ɵPoDisclaimerComponent_BaseFactory || (ɵPoDisclaimerComponent_BaseFactory = ɵɵgetInheritedFactory(_PoDisclaimerComponent)))(__ngFactoryType__ || _PoDisclaimerComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDisclaimerComponent,
    selectors: [["po-disclaimer"]],
    viewQuery: function PoDisclaimerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1d, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.disclaimerContainer = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 1,
    consts: [["disclaimerContainer", ""], [1, "disclaimer-container"], ["class", "po-disclaimer", 3, "po-disclaimer-remove-all", "po-disclaimer-danger", "p-tooltip", "p-tooltip-position", "tabindex", "click", "keydown.enter", 4, "ngIf"], [1, "po-disclaimer", 3, "click", "keydown.enter", "p-tooltip", "p-tooltip-position", "tabindex"], [1, "po-disclaimer-label"], [1, "label"], ["p-icon", "ICON_CLOSE", "class", "po-disclaimer-remove po-clickable", "tabindex", "0", 3, "po-disclaimer-remove-danger", "click", "keydown", 4, "ngIf"], ["p-icon", "ICON_CLOSE", "tabindex", "0", 1, "po-disclaimer-remove", "po-clickable", 3, "click", "keydown"]],
    template: function PoDisclaimerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 1, 0);
        ɵɵtemplate(2, PoDisclaimerComponent_div_2_Template, 5, 11, "div", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showDisclaimer === true);
      }
    },
    dependencies: [NgIf, PoIconComponent, PoTooltipDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerComponent, [{
    type: Component,
    args: [{
      selector: "po-disclaimer",
      standalone: false,
      template: `<div #disclaimerContainer class="disclaimer-container">
  <div
    *ngIf="showDisclaimer === true"
    class="po-disclaimer"
    [class.po-disclaimer-remove-all]="hideClose"
    [class.po-disclaimer-danger]="type === 'danger'"
    [p-tooltip]="getWidthDisclaimer() ? getLabel() : ''"
    [p-tooltip-position]="tooltipPosition"
    [tabindex]="hideClose ? '0' : '-1'"
    (click)="emitLastDisclaimer(lastDisclaimer)"
    (keydown.enter)="emitLastDisclaimer(lastDisclaimer)"
  >
    <div class="po-disclaimer-label" [class.show-close]="!hideClose">
      <span class="label">
        {{ getLabel() }}
      </span>
    </div>
    <po-icon
      p-icon="ICON_CLOSE"
      *ngIf="hideClose === false"
      [attr.aria-label]="setAriaLabel()"
      [attr.role]="!hideClose ? 'button' : ''"
      class="po-disclaimer-remove po-clickable"
      tabindex="0"
      [class.po-disclaimer-remove-danger]="type === 'danger'"
      (click)="close()"
      (keydown)="onKeyPress($event)"
    ></po-icon>
  </div>
</div>
`
    }]
  }], null, {
    disclaimerContainer: [{
      type: ViewChild,
      args: ["disclaimerContainer", {
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDisclaimerComponent, {
    className: "PoDisclaimerComponent",
    filePath: "lib/components/po-disclaimer/po-disclaimer.component.ts",
    lineNumber: 24
  });
})();
var PoDisclaimerModule = class _PoDisclaimerModule {
  static ɵfac = function PoDisclaimerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDisclaimerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoDisclaimerModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoIconModule, PoTooltipModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoIconModule, PoTooltipModule],
      declarations: [PoDisclaimerComponent],
      exports: [PoDisclaimerComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDisclaimerModule, {
    declarations: [PoDisclaimerComponent],
    imports: [CommonModule, PoIconModule, PoTooltipModule],
    exports: [PoDisclaimerComponent]
  });
})();
var poDisclaimerGroupLiteralsDefault = {
  en: {
    removeAll: "Remove all"
  },
  es: {
    removeAll: "Eliminar todos"
  },
  pt: {
    removeAll: "Remover todos"
  },
  ru: {
    removeAll: "Удалить все"
  }
};
var PoDisclaimerGroupBaseComponent = class _PoDisclaimerGroupBaseComponent {
  changeDetector;
  /** Título do grupo de *disclaimers*. */
  title;
  /**
   * @optional
   *
   * @description
   *
   * Função que será disparada quando a lista de *disclaimers* for modificada.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função que será disparada quando um *disclaimer* for removido da lista de *disclaimers* pelo usuário.
   *
   * Recebe como parâmetro um objeto conforme a interface `PoDisclaimerGroupRemoveAction`.
   */
  remove = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função que será disparada quando todos os *disclaimers* forem removidos da lista de *disclaimers* pelo usuário,
   * utilizando o botão "remover todos".
   *
   * Recebe como parâmetro uma lista contendo todos os `disclaimers` removidos.
   */
  removeAll = new EventEmitter();
  literals;
  _disclaimers = [];
  _hideRemoveAll = false;
  differ;
  previousDisclaimers = [];
  /** Lista de *disclaimers*. */
  /**
   * @description
   *
   * Lista de *disclaimers*.
   *
   * Para que a lista de *disclaimers* seja atualizada dinamicamente deve-se passar uma nova referência do array de `PoDisclaimer`.
   *
   * Exemplo adicionando um *disclaimer* no array:
   *
   * ```
   * this.disclaimers = [...this.disclaimers, disclaimer];
   * ```
   *
   * ou
   *
   * ```
   * this.disclaimers = this.disclaimers.concat(disclaimer);
   * ```
   */
  set disclaimers(value) {
    this.previousDisclaimers = [...this.disclaimers];
    this._disclaimers = this.checkDisclaimers(value);
  }
  get disclaimers() {
    return this._disclaimers;
  }
  /**
   * @optional
   *
   * @description
   *
   * Oculta o botão para remover todos os *disclaimers* do grupo.
   *
   * > Por padrão, o mesmo é exibido à partir de dois ou mais *disclaimers* com a opção `hideClose` habilitada.
   *
   * @default `false`
   */
  set hideRemoveAll(value) {
    this._hideRemoveAll = value === "" ? true : convertToBoolean(value);
  }
  get hideRemoveAll() {
    return this._hideRemoveAll;
  }
  constructor(differs, languageService, changeDetector) {
    this.changeDetector = changeDetector;
    const language = languageService.getShortLanguage();
    this.differ = differs.find([]).create(null);
    this.literals = __spreadValues(__spreadValues({}, poDisclaimerGroupLiteralsDefault[poLocaleDefault]), poDisclaimerGroupLiteralsDefault[language]);
  }
  ngDoCheck() {
    this.checkChanges();
  }
  isRemoveAll() {
    return !this.hideRemoveAll && this.disclaimers.filter((c) => !c.hideClose).length > 1;
  }
  onKeyPress(event) {
    if (isKeyCodeEnter(event)) {
      this.removeAllItems();
    }
  }
  removeAllItems() {
    const removeItems = [];
    this.disclaimers.forEach((disclaimer) => {
      if (!disclaimer.hideClose) {
        removeItems.push(disclaimer);
      }
    });
    removeItems.forEach((disclaimer) => this.removeDisclaimer(disclaimer));
    this.emitChangeDisclaimers();
    this.removeAll.emit([...removeItems]);
  }
  removeDisclaimer(disclaimer) {
    const itemIndex = this.disclaimers.findIndex((d) => d["$id"] === disclaimer["$id"]);
    this.disclaimers.splice(itemIndex, 1);
  }
  emitChangeDisclaimers() {
    setTimeout(() => {
      this.change.emit(this.disclaimers);
    });
    this.previousDisclaimers = [...this._disclaimers];
    this.changeDetector?.detectChanges();
  }
  checkChanges() {
    if (this.differ) {
      const changes = this.differ.diff(this.disclaimers);
      if (changes && this.disclaimersAreChanged(this.disclaimers)) {
        this.emitChangeDisclaimers();
      }
    } else {
      this.changeDetector?.detectChanges();
    }
  }
  checkDisclaimers(disclaimers) {
    if (Array.isArray(disclaimers)) {
      for (let i = 0; i < disclaimers.length; i++) {
        const disclaimer = disclaimers[i];
        if (disclaimer.value || disclaimer.value === 0 || disclaimer.value === false) {
          disclaimer["$id"] = uuid();
        } else {
          disclaimers.splice(i, 1);
          i--;
        }
      }
      return disclaimers;
    }
    return [];
  }
  disclaimersAreChanged(disclaimers) {
    const currentValues = disclaimers;
    if (currentValues.length !== this.previousDisclaimers.length) {
      return true;
    }
    return currentValues.some((disclaimer, index) => disclaimer.value !== this.previousDisclaimers[index].value || disclaimer.property !== this.previousDisclaimers[index].property);
  }
  static ɵfac = function PoDisclaimerGroupBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDisclaimerGroupBaseComponent)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoDisclaimerGroupBaseComponent,
    inputs: {
      title: [0, "p-title", "title"],
      disclaimers: [0, "p-disclaimers", "disclaimers"],
      hideRemoveAll: [0, "p-hide-remove-all", "hideRemoveAll"]
    },
    outputs: {
      change: "p-change",
      remove: "p-remove",
      removeAll: "p-remove-all"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerGroupBaseComponent, [{
    type: Directive
  }], () => [{
    type: IterableDiffers
  }, {
    type: PoLanguageService
  }, {
    type: ChangeDetectorRef
  }], {
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    remove: [{
      type: Output,
      args: ["p-remove"]
    }],
    removeAll: [{
      type: Output,
      args: ["p-remove-all"]
    }],
    disclaimers: [{
      type: Input,
      args: ["p-disclaimers"]
    }],
    hideRemoveAll: [{
      type: Input,
      args: ["p-hide-remove-all"]
    }]
  });
})();
var PoDisclaimerRemoveComponent = class _PoDisclaimerRemoveComponent {
  /** Texto exibido.  */
  label;
  /** Ação para remover todos.  */
  removeAllAction = new EventEmitter();
  // Emite a ação de remover todos.
  removeAction() {
    this.removeAllAction.emit();
  }
  static ɵfac = function PoDisclaimerRemoveComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDisclaimerRemoveComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDisclaimerRemoveComponent,
    selectors: [["po-disclaimer-remove"]],
    inputs: {
      label: [0, "p-label", "label"]
    },
    outputs: {
      removeAllAction: "p-remove-all-action"
    },
    standalone: false,
    decls: 1,
    vars: 1,
    consts: [["p-type", "danger", 1, "po-clickable", 3, "p-click", "p-value"]],
    template: function PoDisclaimerRemoveComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "po-tag", 0);
        ɵɵlistener("p-click", function PoDisclaimerRemoveComponent_Template_po_tag_p_click_0_listener() {
          return ctx.removeAction();
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-value", ctx.label);
      }
    },
    dependencies: [PoTagComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerRemoveComponent, [{
    type: Component,
    args: [{
      selector: "po-disclaimer-remove",
      standalone: false,
      template: '<po-tag class="po-clickable" p-type="danger" [p-value]="label" (p-click)="removeAction()"> </po-tag>\n'
    }]
  }], null, {
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    removeAllAction: [{
      type: Output,
      args: ["p-remove-all-action"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDisclaimerRemoveComponent, {
    className: "PoDisclaimerRemoveComponent",
    filePath: "lib/components/po-disclaimer-group/po-disclaimer-remove/po-disclaimer-remove.component.ts",
    lineNumber: 15
  });
})();
function PoDisclaimerGroupComponent_div_0_po_disclaimer_remove_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-disclaimer-remove", 5);
    ɵɵlistener("keydown", function PoDisclaimerGroupComponent_div_0_po_disclaimer_remove_3_Template_po_disclaimer_remove_keydown_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onKeyPress($event));
    })("p-remove-all-action", function PoDisclaimerGroupComponent_div_0_po_disclaimer_remove_3_Template_po_disclaimer_remove_p_remove_all_action_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.removeAllItems());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-label", ctx_r1.literals.removeAll);
  }
}
function PoDisclaimerGroupComponent_div_0_po_tag_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-tag", 6);
    ɵɵlistener("p-close", function PoDisclaimerGroupComponent_div_0_po_tag_4_Template_po_tag_p_close_0_listener($event) {
      const disclaimer_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onCloseAction(disclaimer_r4, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const disclaimer_r4 = ctx.$implicit;
    ɵɵproperty("p-value", disclaimer_r4.label || disclaimer_r4.value)("p-removable", !disclaimer_r4.hideClose);
  }
}
function PoDisclaimerGroupComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, PoDisclaimerGroupComponent_div_0_po_disclaimer_remove_3_Template, 1, 1, "po-disclaimer-remove", 3)(4, PoDisclaimerGroupComponent_div_0_po_tag_4_Template, 1, 2, "po-tag", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isRemoveAll());
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.disclaimers);
  }
}
var PoDisclaimerGroupComponent = class _PoDisclaimerGroupComponent extends PoDisclaimerGroupBaseComponent {
  changeDetector;
  subscription = new Subscription();
  el = inject(ElementRef);
  constructor(differs, languageService, changeDetector) {
    super(differs, languageService, changeDetector);
    this.changeDetector = changeDetector;
  }
  ngAfterViewInit() {
    this.handleKeyboardNavigationTag();
  }
  ngOnChanges(changes) {
    if (changes.disclaimers) {
      setTimeout(() => {
        this.handleKeyboardNavigationTag();
      });
    }
  }
  onCloseAction(disclaimer, event) {
    const index = this.disclaimers.findIndex((option) => option.value === disclaimer.value);
    this.removeDisclaimer(disclaimer);
    this.emitChangeDisclaimers();
    this.remove.emit({
      removedDisclaimer: __spreadValues({}, disclaimer),
      currentDisclaimers: [...this.disclaimers]
    });
    setTimeout(() => {
      this.focusOnNextTag(index, event);
    }, 300);
  }
  focusOnNextTag(indexClosed, clickOrEnter) {
    if (clickOrEnter === "enter") {
      const tagRemoveElements = this.el.nativeElement.querySelectorAll(".po-tag-remove");
      indexClosed = indexClosed || indexClosed === 0 ? indexClosed : tagRemoveElements.length;
      this.focusOnRemoveTag(tagRemoveElements, indexClosed);
    } else {
      indexClosed = 0;
    }
    this.handleKeyboardNavigationTag(indexClosed);
  }
  handleKeyboardNavigationTag(initialIndex = 0) {
    this.subscription.unsubscribe();
    this.subscription = new Subscription();
    const tagRemoveElements = this.el.nativeElement.querySelectorAll(".po-tag-remove");
    this.initializeTagRemoveElements(tagRemoveElements, initialIndex);
  }
  handleArrowLeft(tagRemoveElements, index) {
    if (index > 0) {
      this.setTabIndex(tagRemoveElements[index], -1);
      tagRemoveElements[index - 1].focus();
      this.setTabIndex(tagRemoveElements[index - 1], 0);
    }
  }
  handleArrowRight(tagRemoveElements, index) {
    if (index < tagRemoveElements.length - 1) {
      this.setTabIndex(tagRemoveElements[index], -1);
      tagRemoveElements[index + 1].focus();
      this.setTabIndex(tagRemoveElements[index + 1], 0);
    }
  }
  setTabIndex(element, tabIndex) {
    element.setAttribute("tabindex", tabIndex);
  }
  initializeTagRemoveElements(tagRemoveElements, initialIndex) {
    tagRemoveElements.forEach((tagRemoveElement, index) => {
      if (index === initialIndex) {
        this.setTabIndex(tagRemoveElements[initialIndex], 0);
      } else if (tagRemoveElements.length === initialIndex) {
        this.setTabIndex(tagRemoveElements[initialIndex - 1], 0);
      } else {
        this.setTabIndex(tagRemoveElement, -1);
      }
      this.subscription.add(fromEvent(tagRemoveElement, "keydown").subscribe((event) => {
        this.handleKeyDown(event, tagRemoveElements, index);
      }));
      if (index !== 0) {
        this.subscription.add(fromEvent(tagRemoveElements, "blur").subscribe(() => {
          this.setTabIndex(tagRemoveElements[index], -1);
          this.setTabIndex(tagRemoveElements[0], 0);
        }));
      }
    });
  }
  handleKeyDown(event, tagRemoveElements, index) {
    const KEY_SPACE = "Space";
    const KEY_ARROW_LEFT = "ArrowLeft";
    const KEY_ARROW_RIGHT = "ArrowRight";
    if (event.code === KEY_SPACE) {
      event.preventDefault();
      event.stopPropagation();
    }
    if (event.key === KEY_ARROW_LEFT) {
      this.handleArrowLeft(tagRemoveElements, index);
    } else if (event.key === KEY_ARROW_RIGHT) {
      this.handleArrowRight(tagRemoveElements, index);
    }
  }
  focusOnRemoveTag(tag, indexClosed) {
    if (tag.length === indexClosed) {
      tag[indexClosed - 1]?.focus();
    } else {
      tag[indexClosed]?.focus();
    }
  }
  static ɵfac = function PoDisclaimerGroupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDisclaimerGroupComponent)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDisclaimerGroupComponent,
    selectors: [["po-disclaimer-group"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 1,
    vars: 1,
    consts: [["class", "po-disclaimer-group", 4, "ngIf"], [1, "po-disclaimer-group"], [1, "po-disclaimer-group-title"], ["class", "po-disclaimer-group-disclaimer-align", 3, "p-label", "keydown", "p-remove-all-action", 4, "ngIf"], ["class", "po-disclaimer-group-disclaimer-align", 3, "p-value", "p-removable", "p-close", 4, "ngFor", "ngForOf"], [1, "po-disclaimer-group-disclaimer-align", 3, "keydown", "p-remove-all-action", "p-label"], [1, "po-disclaimer-group-disclaimer-align", 3, "p-close", "p-value", "p-removable"]],
    template: function PoDisclaimerGroupComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoDisclaimerGroupComponent_div_0_Template, 5, 3, "div", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.disclaimers.length > 0);
      }
    },
    dependencies: [NgForOf, NgIf, PoTagComponent, PoDisclaimerRemoveComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerGroupComponent, [{
    type: Component,
    args: [{
      selector: "po-disclaimer-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div class="po-disclaimer-group" *ngIf="disclaimers.length > 0">\n  <div class="po-disclaimer-group-title">{{ title }}</div>\n\n  <po-disclaimer-remove\n    *ngIf="isRemoveAll()"\n    class="po-disclaimer-group-disclaimer-align"\n    [p-label]="literals.removeAll"\n    (keydown)="onKeyPress($event)"\n    (p-remove-all-action)="removeAllItems()"\n  >\n  </po-disclaimer-remove>\n\n  <po-tag\n    *ngFor="let disclaimer of disclaimers"\n    class="po-disclaimer-group-disclaimer-align"\n    [p-value]="disclaimer.label || disclaimer.value"\n    [p-removable]="!disclaimer.hideClose"\n    (p-close)="onCloseAction(disclaimer, $event)"\n  >\n  </po-tag>\n</div>\n'
    }]
  }], () => [{
    type: IterableDiffers
  }, {
    type: PoLanguageService
  }, {
    type: ChangeDetectorRef
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDisclaimerGroupComponent, {
    className: "PoDisclaimerGroupComponent",
    filePath: "lib/components/po-disclaimer-group/po-disclaimer-group.component.ts",
    lineNumber: 47
  });
})();
var PoDisclaimerGroupModule = class _PoDisclaimerGroupModule {
  static ɵfac = function PoDisclaimerGroupModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDisclaimerGroupModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoDisclaimerGroupModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoDisclaimerModule, PoTagModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerGroupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoDisclaimerModule, PoTagModule],
      declarations: [PoDisclaimerGroupComponent, PoDisclaimerRemoveComponent],
      exports: [PoDisclaimerGroupComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDisclaimerGroupModule, {
    declarations: [PoDisclaimerGroupComponent, PoDisclaimerRemoveComponent],
    imports: [CommonModule, PoDisclaimerModule, PoTagModule],
    exports: [PoDisclaimerGroupComponent]
  });
})();
var PoDropdownBaseComponent = class _PoDropdownBaseComponent {
  /** Adiciona um rótulo ao `dropdown`. */
  label;
  icon = "ICON_ARROW_DOWN";
  open = false;
  _actions;
  _disabled = false;
  /** Lista de ações que serão exibidas no componente. */
  set actions(value) {
    this._actions = Array.isArray(value) ? value : [];
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o campo.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
  }
  get disabled() {
    return this._disabled;
  }
  static ɵfac = function PoDropdownBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDropdownBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoDropdownBaseComponent,
    inputs: {
      label: [0, "p-label", "label"],
      actions: [0, "p-actions", "actions"],
      disabled: [0, "p-disabled", "disabled"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDropdownBaseComponent, [{
    type: Directive
  }], null, {
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    actions: [{
      type: Input,
      args: ["p-actions"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }]
  });
})();
var _c0$1c = ["dropdownRef"];
var _c1$w = ["popupRef"];
var _c2$g = (a0, a1) => ({
  "po-dropdown-button-disabled": a0,
  "po-dropdown-button-open": a1
});
var _c3$c = () => ["bottom-left", "top-left"];
var PoDropdownComponent = class _PoDropdownComponent extends PoDropdownBaseComponent {
  renderer;
  changeDetector;
  dropdownRef;
  popupRef;
  clickoutListener;
  resizeListener;
  constructor(renderer, changeDetector) {
    super();
    this.renderer = renderer;
    this.changeDetector = changeDetector;
  }
  onKeyDown(event) {
    if (isKeyCodeEnter(event)) {
      this.toggleDropdown();
    }
  }
  toggleDropdown() {
    this.dropdownRef && !this.open && !this.disabled ? this.showDropdown() : this.hideDropdown();
  }
  checkClickArea(event) {
    return this.dropdownRef && this.dropdownRef.nativeElement.contains(event.target);
  }
  hideDropdown() {
    this.icon = "ICON_ARROW_DOWN";
    this.removeListeners();
    this.popupRef.close();
    this.open = false;
    this.changeDetector.detectChanges();
  }
  initializeListeners() {
    this.clickoutListener = this.renderer.listen("document", "click", (event) => {
      this.wasClickedOnDropdown(event);
    });
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.hideDropdown();
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  onScroll = ({
    target
  }) => {
    if (this.open && target.className !== "po-popup-container" && !this.isDropdownClosed()) {
      this.hideDropdown();
    }
  };
  isDropdownClosed() {
    const dropdownRect = this.dropdownRef.nativeElement.getBoundingClientRect();
    return dropdownRect.top >= 0 && dropdownRect.bottom <= window.innerHeight;
  }
  removeListeners() {
    if (this.clickoutListener) {
      this.clickoutListener();
    }
    if (this.resizeListener) {
      this.resizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
  }
  showDropdown() {
    this.icon = "ICON_ARROW_UP";
    this.initializeListeners();
    this.popupRef.open();
    this.open = true;
    this.changeDetector.detectChanges();
  }
  wasClickedOnDropdown(event) {
    const clickedOnDropdown = this.checkClickArea(event);
    if (!clickedOnDropdown) {
      this.hideDropdown();
    }
  }
  static ɵfac = function PoDropdownComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDropdownComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDropdownComponent,
    selectors: [["po-dropdown"]],
    viewQuery: function PoDropdownComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1c, 7, ElementRef);
        ɵɵviewQuery(_c1$w, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdownRef = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupRef = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 8,
    vars: 12,
    consts: [["dropdownRef", ""], ["popupRef", ""], [1, "po-dropdown", 3, "click", "keydown", "tabindex"], [1, "po-dropdown-button", 3, "ngClass"], [1, "po-dropdown-icon", 3, "p-icon"], ["p-hide-arrow", "", "p-is-corner-align", "", "p-position", "bottom-left", 3, "p-actions", "p-custom-positions", "p-target"]],
    template: function PoDropdownComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 2, 0);
        ɵɵlistener("click", function PoDropdownComponent_Template_div_click_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.toggleDropdown());
        })("keydown", function PoDropdownComponent_Template_div_keydown_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementStart(2, "div", 3)(3, "span");
        ɵɵtext(4);
        ɵɵelementEnd();
        ɵɵelement(5, "po-icon", 4);
        ɵɵelementEnd()();
        ɵɵelement(6, "po-popup", 5, 1);
      }
      if (rf & 2) {
        const dropdownRef_r2 = ɵɵreference(1);
        ɵɵpropertyInterpolate("tabindex", ctx.disabled ? -1 : 0);
        ɵɵattribute("disabled", ctx.disabled);
        ɵɵadvance(2);
        ɵɵproperty("ngClass", ɵɵpureFunction2(8, _c2$g, ctx.disabled, ctx.open));
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.label);
        ɵɵadvance();
        ɵɵproperty("p-icon", ctx.icon);
        ɵɵadvance();
        ɵɵproperty("p-actions", ctx.actions)("p-custom-positions", ɵɵpureFunction0(11, _c3$c))("p-target", dropdownRef_r2);
      }
    },
    dependencies: [NgClass, PoPopupComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDropdownComponent, [{
    type: Component,
    args: [{
      selector: "po-dropdown",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<div
  #dropdownRef
  class="po-dropdown"
  [attr.disabled]="disabled"
  tabindex="{{ disabled ? -1 : 0 }}"
  (click)="toggleDropdown()"
  (keydown)="onKeyDown($event)"
>
  <div
    class="po-dropdown-button"
    [ngClass]="{ 'po-dropdown-button-disabled': disabled, 'po-dropdown-button-open': open }"
  >
    <span>{{ label }}</span>
    <po-icon class="po-dropdown-icon" [p-icon]="icon"></po-icon>
  </div>
</div>

<po-popup
  #popupRef
  p-hide-arrow
  p-is-corner-align
  p-position="bottom-left"
  [p-actions]="actions"
  [p-custom-positions]="['bottom-left', 'top-left']"
  [p-target]="dropdownRef"
>
</po-popup>
`
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }], {
    dropdownRef: [{
      type: ViewChild,
      args: ["dropdownRef", {
        read: ElementRef,
        static: true
      }]
    }],
    popupRef: [{
      type: ViewChild,
      args: ["popupRef"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDropdownComponent, {
    className: "PoDropdownComponent",
    filePath: "lib/components/po-dropdown/po-dropdown.component.ts",
    lineNumber: 35
  });
})();
var PoDropdownModule = class _PoDropdownModule {
  static ɵfac = function PoDropdownModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDropdownModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoDropdownModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoPopupModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDropdownModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoPopupModule, PoIconModule],
      declarations: [PoDropdownComponent],
      exports: [PoDropdownComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDropdownModule, {
    declarations: [PoDropdownComponent],
    imports: [CommonModule, PoPopupModule, PoIconModule],
    exports: [PoDropdownComponent]
  });
})();
function requiredFailed(required, disabled, value) {
  const valid = typeof value === "string" && value || typeof value === "object" && value && value.length || typeof value === "number" && (value || value === 0) || typeof value === "boolean" && value;
  return required && !disabled && !valid;
}
function maxlengpoailed(maxlength, value, maskNoLengthValidation = false) {
  return validateLength(maxlength, value, "max", maskNoLengthValidation);
}
function minlengpoailed(minlength, value, maskNoLengthValidation = false) {
  return validateLength(minlength, value, "min", maskNoLengthValidation);
}
function validateLength(limit, value, comparison, maskNoLengthValidation = false) {
  if (!limit && limit !== 0) {
    return false;
  }
  const validValue2 = (value || value === 0) && value.toString();
  if (!validValue2) {
    return false;
  }
  const processedValue = maskNoLengthValidation ? validValue2.replace(/[^\w]/g, "") : validValue2;
  if (comparison === "max") {
    return processedValue.length > Number(limit);
  } else if (comparison === "min") {
    return processedValue.length < Number(limit);
  }
  return false;
}
function patternFailed(pattern, value) {
  let reg;
  try {
    reg = new RegExp(pattern);
  } catch (e) {
    return true;
  }
  return pattern && value && !reg.test(value);
}
function minFailed(min, value) {
  const validValue2 = value || value === 0;
  const validMin = min || min === 0;
  return validValue2 && validMin && value < min;
}
function maxFailed(max, value) {
  const validValue2 = value || value === 0;
  const validMax = max || max === 0;
  return validValue2 && validMax && value > max;
}
function dateFailed(value) {
  return value && isNaN(Date.parse(value));
}
var poCheckboxGroupColumnsDefaultLength = 6;
var poCheckboxGroupColumnsTotalLength = 12;
var PoCheckboxGroupBaseComponent = class _PoCheckboxGroupBaseComponent {
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Define que o tooltip (`p-additional-help-tooltip` e/ou `p-error-limit`) será incluído no body da página e não
   * dentro do componente. Essa opção pode ser necessária em cenários com containers que possuem scroll ou overflow
   * escondido, garantindo o posicionamento correto do tooltip próximo ao elemento.
   *
   * > Quando utilizado com `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Nome dos checkboxes */
  name;
  /** Texto de apoio do campo */
  help;
  /** Label do campo */
  label;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * @optional
   *
   * @description
   *
   * Exibe a mensagem setada se o campo estiver vazio e for requerido.
   *
   * > Necessário que a propriedade `p-required` esteja habilitada.
   *
   */
  fieldErrorMessage;
  /**
   * @optional
   *
   * @description
   *
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   *
   * > Caso essa propriedade seja definida como `true`, a mensagem de erro será limitada a duas linhas
   * e um tooltip será exibido ao passar o mouse sobre a mensagem para mostrar o conteúdo completo.
   *
   * @default `false`
   */
  errorLimit = false;
  /**
   * @optional
   *
   * @description
   *
   * Função para atualizar o `ngModel` do componente, necessário quando não for utilizado dentro da tag form.
   *
   * Na versão 12.2.0 do Angular a verificação `strictTemplates` vem true como default. Portanto, para utilizar
   * two-way binding no componente deve se utilizar da seguinte forma:
   *
   * ```
   * <po-checkbox-group ... [ngModel]="checkboxgroupModel" (ngModelChange)="checkboxgroupModel = $event"> </po-checkbox-group>
   * ```
   *
   */
  ngModelChange = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do campo
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  checkboxGroupOptionsView;
  checkedOptions = {};
  checkedOptionsList = [];
  displayAdditionalHelp = false;
  mdColumns = poCheckboxGroupColumnsDefaultLength;
  propagateChange;
  validatorChange;
  _columns = poCheckboxGroupColumnsDefaultLength;
  _disabled = false;
  _indeterminate = false;
  _options;
  _required = false;
  /**
   * @optional
   *
   * @description
   *
   * Possibilita definir a quantidade de colunas para exibição dos itens do *checkbox*.
   * - É possível exibir as opções entre `1` e `4` colunas.
   * - Para resolução `sm` a colunagem invariavelmente passa para `1` coluna.
   * - Quando se trata de resolução `md` e o valor estabelecido para colunas for superior a `2`,
   * o *grid system* será composto por `2` colunas.
   * - Para evitar a quebra de linha, prefira a utilização de `1` coluna para opções com textos grandes.
   *
   * @default `2`
   *
   */
  set columns(value) {
    const columns = convertToInt(value, poCheckboxGroupColumnsDefaultLength);
    this._columns = this.getGridSystemColumns(columns, 4);
    this.mdColumns = this.getGridSystemColumns(columns, 2);
  }
  get columns() {
    return this._columns;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita todos os itens do checkbox.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
    this.validateModel(this.checkIndeterminate());
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Caso exista a necessidade de usar o valor indeterminado (`null`) dentro da lista de opções, é necessário setar
   * a propriedade `p-indeterminate` como `true`, por padrão essa propriedade vem desabilitada (`false`).
   *
   * Quando essa propriedade é setada como `true`, o *po-checkbox-group* passa a devolver um objeto completo para o
   * `ngModel`, diferente do array que contém apenas os valores selecionados.
   *
   * @default `false`
   */
  set indeterminate(indeterminate) {
    this._indeterminate = convertToBoolean(indeterminate);
  }
  get indeterminate() {
    return this._indeterminate;
  }
  /**
   * @optional
   *
   * @description
   * Lista de opções que serão exibidas
   * Nesta propriedade deve ser definido um array de objetos que implementam a interface PoCheckboxGroupOption
   */
  set options(value) {
    this._options = Array.isArray(value) ? value : [];
    this.removeDuplicatedOptions();
    this.setCheckboxGroupOptionsView(this.options);
  }
  get options() {
    return this._options;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel(this.checkIndeterminate());
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  changeValue() {
    const value = this.checkIndeterminate();
    if (this.propagateChange) {
      this.propagateChange(value);
    } else {
      this.ngModelChange.emit(value);
    }
    this.change.emit(value);
  }
  checkIndeterminate() {
    return this.indeterminate ? this.checkedOptions : this.checkedOptionsList;
  }
  checkOption(value) {
    if (!this._disabled && !value.disabled && !value.fixed) {
      this.checkOptionModel(value);
      this.changeValue();
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  registerOnTouched(fn) {
  }
  writeValue(optionsModel) {
    if (optionsModel && this.checkedOptions !== optionsModel) {
      this.generateCheckOptions(optionsModel);
    } else {
      this.checkedOptionsList = [];
      this.checkedOptions = {};
    }
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(abstractControl) {
    if (!this.indeterminate && requiredFailed(this.required, this.disabled, abstractControl.value) || this.isInvalidIndeterminate()) {
      return {
        required: {
          valid: false
        }
      };
    }
  }
  validateModel(model) {
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  checkColumnsRange(columns, maxColumns) {
    const minColumns = 1;
    return columns >= minColumns && columns <= maxColumns;
  }
  checkOptionModel(optionChecked) {
    this.checkedOptions[optionChecked.value] = !this.checkedOptions[optionChecked.value];
    if (!this.indeterminate && this.checkedOptionsList.includes(optionChecked.value)) {
      this.checkedOptionsList.splice(this.checkedOptionsList.indexOf(optionChecked.value), 1);
    } else if (!this.indeterminate) {
      this.checkedOptionsList.push(optionChecked.value);
    }
  }
  generateCheckOptions(optionsModel) {
    this.checkedOptions = {};
    if (optionsModel instanceof Array) {
      this.checkedOptionsList = optionsModel;
      this.options.forEach((option) => {
        this.checkedOptions[option.value] = optionsModel.includes(option.value);
      });
    } else {
      this.options.forEach((option) => {
        optionsModel[option.value] = optionsModel[option.value] === void 0 ? false : optionsModel[option.value];
        this.checkedOptions = optionsModel;
      });
    }
  }
  getGridSystemColumns(columns, maxColumns) {
    const gridSystemColumns = poCheckboxGroupColumnsTotalLength / columns;
    return this.checkColumnsRange(columns, maxColumns) ? gridSystemColumns : poCheckboxGroupColumnsDefaultLength;
  }
  isInvalidIndeterminate() {
    if (this.indeterminate && this.required && this.checkedOptions) {
      return Object.values(this.checkedOptions).every((value) => value === false);
    }
    return false;
  }
  removeDuplicatedOptions() {
    this.options.forEach((option, index) => {
      const duplicatedIndex = this.options.findIndex((optionFind) => optionFind.value === option.value) === index;
      if (!duplicatedIndex) {
        this.options.splice(this.options.indexOf(option), 1);
      }
    });
  }
  setCheckboxGroupOptionsView(optionsList) {
    this.checkboxGroupOptionsView = optionsList.map((option) => __spreadProps(__spreadValues({}, option), {
      id: uuid()
    }));
  }
  static ɵfac = function PoCheckboxGroupBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCheckboxGroupBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoCheckboxGroupBaseComponent,
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      name: "name",
      help: [0, "p-help", "help"],
      label: [0, "p-label", "label"],
      optional: [0, "p-optional", "optional"],
      fieldErrorMessage: [0, "p-field-error-message", "fieldErrorMessage"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      columns: [0, "p-columns", "columns"],
      disabled: [0, "p-disabled", "disabled"],
      indeterminate: [0, "p-indeterminate", "indeterminate"],
      options: [0, "p-options", "options"],
      required: [0, "p-required", "required"],
      showRequired: [0, "p-show-required", "showRequired"]
    },
    outputs: {
      ngModelChange: "ngModelChange",
      additionalHelp: "p-additional-help",
      change: "p-change",
      keydown: "p-keydown"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxGroupBaseComponent, [{
    type: Directive
  }], null, {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    fieldErrorMessage: [{
      type: Input,
      args: ["p-field-error-message"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    ngModelChange: [{
      type: Output,
      args: ["ngModelChange"]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    columns: [{
      type: Input,
      args: ["p-columns"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    indeterminate: [{
      type: Input,
      args: ["p-indeterminate"]
    }],
    options: [{
      type: Input,
      args: ["p-options"]
    }],
    required: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }]
  });
})();
var _c0$1b = ["checkboxLabel"];
function PoCheckboxGroupComponent_li_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li")(1, "po-checkbox", 6, 0);
    ɵɵlistener("p-blur", function PoCheckboxGroupComponent_li_3_Template_po_checkbox_p_blur_1_listener() {
      ɵɵrestoreView(_r1);
      const checkboxLabel_r2 = ɵɵreference(2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onBlur(checkboxLabel_r2));
    })("click", function PoCheckboxGroupComponent_li_3_Template_po_checkbox_click_1_listener() {
      const option_r4 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.checkOption(option_r4));
    })("keydown", function PoCheckboxGroupComponent_li_3_Template_po_checkbox_keydown_1_listener($event) {
      const option_r4 = ɵɵrestoreView(_r1).$implicit;
      const checkboxLabel_r2 = ɵɵreference(2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onKeyDown($event, option_r4, checkboxLabel_r2));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const option_r4 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMapInterpolate2("po-checkbox-group-item po-md-", ctx_r2.mdColumns, " po-lg-", ctx_r2.columns, "");
    ɵɵclassProp("po-checkbox-group-item-disabled", option_r4.disabled || ctx_r2.disabled);
    ɵɵadvance();
    ɵɵproperty("p-label", option_r4.label)("p-disabled", option_r4.disabled || ctx_r2.disabled)("p-checkboxValue", ctx_r2.checkedOptions[option_r4.value] === null ? "mixed" : ctx_r2.checkedOptions[option_r4.value])("p-required", ctx_r2.required);
  }
}
var PoCheckboxGroupComponent = class _PoCheckboxGroupComponent extends PoCheckboxGroupBaseComponent {
  changeDetector;
  checkboxLabels;
  el = inject(ElementRef);
  constructor(changeDetector) {
    super();
    this.changeDetector = changeDetector;
  }
  ngAfterViewChecked() {
    this.changeDetector.detectChanges();
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  onBlur(checkbox) {
    if (!this.isCheckboxOptionFocused(checkbox) && this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoCheckboxGroupComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoCheckboxGroupComponent, { static: true }) checkbox: PoCheckboxGroupComponent;
   *
   * focusCheckbox() {
   *   this.checkbox.focus();
   * }
   * ```
   */
  focus() {
    if (this.checkboxLabels && !this.disabled) {
      const checkboxLabel = this.checkboxLabels.find((_, index) => !this.options[index].disabled);
      if (checkboxLabel) {
        checkboxLabel.checkboxLabel.nativeElement.focus();
      }
    }
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  getErrorPattern() {
    return this.fieldErrorMessage && this.hasInvalidClass() ? this.fieldErrorMessage : "";
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty");
  }
  onKeyDown(event, option, checkbox) {
    const spaceBar = 32;
    if (event.which === spaceBar || event.keyCode === spaceBar) {
      this.checkOption(option);
      event.preventDefault();
    }
    if (this.isCheckboxOptionFocused(checkbox)) {
      this.keydown.emit(event);
    }
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-checkbox-group
   *  #checkboxGroup
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, checkboxGroup)"
   * ></po-checkbox-group>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoCheckboxGroupComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  trackByFn(index) {
    return index;
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  isCheckboxOptionFocused(checkbox) {
    return document.activeElement === checkbox.checkboxLabel.nativeElement;
  }
  static ɵfac = function PoCheckboxGroupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCheckboxGroupComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoCheckboxGroupComponent,
    selectors: [["po-checkbox-group"]],
    viewQuery: function PoCheckboxGroupComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1b, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.checkboxLabels = _t);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoCheckboxGroupComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoCheckboxGroupComponent),
      multi: true
    }]), ɵɵInheritDefinitionFeature],
    decls: 5,
    vars: 16,
    consts: [["checkboxLabel", ""], [3, "p-disabled", "p-label", "p-optional", "p-required", "p-show-required"], ["role", "group", 1, "po-checkbox-group-content"], [1, "po-row"], [3, "class", "po-checkbox-group-item-disabled", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-limit", "p-error-pattern", "p-show-additional-help", "p-show-additional-help-icon"], [3, "p-blur", "click", "keydown", "p-label", "p-disabled", "p-checkboxValue", "p-required"]],
    template: function PoCheckboxGroupComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2)(2, "ul", 3);
        ɵɵtemplate(3, PoCheckboxGroupComponent_li_3_Template, 3, 10, "li", 4);
        ɵɵelementEnd()();
        ɵɵelementStart(4, "po-field-container-bottom", 5);
        ɵɵlistener("p-additional-help", function PoCheckboxGroupComponent_Template_po_field_container_bottom_p_additional_help_4_listener() {
          return ctx.emitAdditionalHelp();
        });
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance();
        ɵɵattribute("aria-label", ctx.label);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ctx.checkboxGroupOptionsView)("ngForTrackBy", ctx.trackByFn);
        ɵɵadvance();
        ɵɵproperty("p-additional-help-tooltip", ctx.getAdditionalHelpTooltip())("p-append-in-body", ctx.appendBox)("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-limit", ctx.errorLimit)("p-error-pattern", ctx.getErrorPattern())("p-show-additional-help", ctx.displayAdditionalHelp)("p-show-additional-help-icon", ctx.showAdditionalHelpIcon());
      }
    },
    dependencies: [NgForOf, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoCheckboxComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxGroupComponent, [{
    type: Component,
    args: [{
      selector: "po-checkbox-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoCheckboxGroupComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoCheckboxGroupComponent),
        multi: true
      }],
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div role="group" [attr.aria-label]="label" class="po-checkbox-group-content">
    <ul class="po-row">
      <li
        *ngFor="let option of checkboxGroupOptionsView; trackBy: trackByFn"
        class="po-checkbox-group-item po-md-{{ mdColumns }} po-lg-{{ columns }}"
        [class.po-checkbox-group-item-disabled]="option.disabled || disabled"
      >
        <po-checkbox
          #checkboxLabel
          [p-label]="option.label"
          [p-disabled]="option.disabled || disabled"
          (p-blur)="onBlur(checkboxLabel)"
          (click)="checkOption(option)"
          (keydown)="onKeyDown($event, option, checkboxLabel)"
          [p-checkboxValue]="checkedOptions[option.value] === null ? 'mixed' : checkedOptions[option.value]"
          [p-required]="required"
        >
        </po-checkbox>
      </li>
    </ul>
  </div>

  <po-field-container-bottom
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-limit]="errorLimit"
    [p-error-pattern]="getErrorPattern()"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    checkboxLabels: [{
      type: ViewChildren,
      args: ["checkboxLabel"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCheckboxGroupComponent, {
    className: "PoCheckboxGroupComponent",
    filePath: "lib/components/po-field/po-checkbox-group/po-checkbox-group.component.ts",
    lineNumber: 57
  });
})();
var PoCheckboxGroupModule = class _PoCheckboxGroupModule {
  static ɵfac = function PoCheckboxGroupModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCheckboxGroupModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoCheckboxGroupModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, PoFieldContainerModule, PoCheckboxModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxGroupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, PoFieldContainerModule, PoCheckboxModule],
      exports: [PoCheckboxGroupComponent],
      declarations: [PoCheckboxGroupComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoCheckboxGroupModule, {
    declarations: [PoCheckboxGroupComponent],
    imports: [CommonModule, FormsModule, PoFieldContainerModule, PoCheckboxModule],
    exports: [PoCheckboxGroupComponent]
  });
})();
var poRadioGroupColumnsDefaultLength = 6;
var poRadioGroupColumnsTotalLength = 12;
var PoRadioGroupBaseComponent = class _PoRadioGroupBaseComponent {
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Define que o tooltip (`p-additional-help-tooltip` e/ou `p-error-limit`) será incluído no body da página e não
   * dentro do componente. Essa opção pode ser necessária em cenários com containers que possuem scroll ou overflow
   * escondido, garantindo o posicionamento correto do tooltip próximo ao elemento.
   *
   * > Quando utilizado com `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Nome das opções. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * @optional
   *
   * @description
   *
   * Exibe a mensagem setada se o campo estiver vazio e for requerido.
   *
   * > Necessário que a propriedade `p-required` esteja habilitada.
   *
   */
  fieldErrorMessage;
  /**
   * @optional
   *
   * @description
   *
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   *
   * > Caso essa propriedade seja definida como `true`, a mensagem de erro será limitada a duas linhas
   * e um tooltip será exibido ao passar o mouse sobre a mensagem para mostrar o conteúdo completo.
   *
   * @default `false`
   */
  errorLimit = false;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento ao alterar valor do campo.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  displayAdditionalHelp = false;
  mdColumns = poRadioGroupColumnsDefaultLength;
  value;
  onTouched = null;
  _columns = poRadioGroupColumnsDefaultLength;
  _disabled = false;
  _options;
  _required = false;
  onChangePropagate = null;
  validatorChange;
  /**
   * @optional
   *
   * @description
   *
   * Define a quantidade de colunas para exibição das opções.
   *
   * **Considerações:**
   *  - É possível exibir as opções entre `1` e `4` colunas.
   *  - O número máximo de colunas é invariável nas seguintes resoluções:
   *    + `sm`: `1`
   *    + `md`: `2`
   *
   * @default `2`
   */
  set columns(value) {
    const columns = convertToInt(value, poRadioGroupColumnsDefaultLength);
    this._columns = this.getGridSystemColumns(columns, 4);
    this.mdColumns = this.getGridSystemColumns(columns, 2);
  }
  get columns() {
    return this._columns;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será desabilitado.
   *
   * @default `false`
   */
  set disabled(disabled) {
    this._disabled = convertToBoolean(disabled);
    this.validateModel();
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel();
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * Lista de opções que serão exibidas.
   * Nesta propriedade deve ser definido um array de objetos que implementam a interface PoRadioGroupOption.
   */
  set options(value) {
    this._options = value;
    removeDuplicatedOptions(this.options);
  }
  get options() {
    return this._options;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho do *radio*
   * @default `medium`
   */
  size;
  // Função que controla quando deve ser emitido onChange e atualiza o Model
  changeValue(changedValue) {
    if (this.onChangePropagate) {
      this.onChangePropagate(changedValue);
    }
    if (this.value !== changedValue) {
      this.change.emit(changedValue);
    }
    this.value = changedValue;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.onChangePropagate = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(abstractControl) {
    if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
  }
  writeValue(modelValue) {
    this.value = modelValue;
    const element = this.getElementByValue(modelValue);
    if (!element && this.onChangePropagate) {
      this.value = void 0;
      this.onChangePropagate(this.value);
    }
  }
  checkColumnsRange(columns, maxColumns) {
    const minColumns = 1;
    return columns >= minColumns && columns <= maxColumns;
  }
  getGridSystemColumns(columns, maxColumns) {
    const gridSystemColumns = poRadioGroupColumnsTotalLength / columns;
    return this.checkColumnsRange(columns, maxColumns) ? gridSystemColumns : poRadioGroupColumnsDefaultLength;
  }
  validateModel() {
    if (this.validatorChange) {
      this.validatorChange();
    }
  }
  static ɵfac = function PoRadioGroupBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRadioGroupBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoRadioGroupBaseComponent,
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      name: "name",
      optional: [0, "p-optional", "optional"],
      fieldErrorMessage: [0, "p-field-error-message", "fieldErrorMessage"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      columns: [0, "p-columns", "columns"],
      disabled: [0, "p-disabled", "disabled"],
      required: [0, "p-required", "required"],
      showRequired: [0, "p-show-required", "showRequired"],
      options: [0, "p-options", "options"],
      size: [0, "p-size", "size"]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      change: "p-change",
      keydown: "p-keydown"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRadioGroupBaseComponent, [{
    type: Directive
  }], null, {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    fieldErrorMessage: [{
      type: Input,
      args: ["p-field-error-message"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    columns: [{
      type: Input,
      args: ["p-columns"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    required: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }],
    options: [{
      type: Input,
      args: ["p-options"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }]
  });
})();
var PoFieldModel = class _PoFieldModel {
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Define que o tooltip (`p-additional-help-tooltip` e/ou `p-error-limit`) será incluído no body da página e não
   * dentro do componente. Essa opção pode ser necessária em cenários com containers que possuem scroll ou overflow
   * escondido, garantindo o posicionamento correto do tooltip próximo ao elemento.
   *
   * > Quando utilizado com `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  /** Rótulo exibido pelo componente. */
  label;
  /** Nome do componente. */
  name;
  /** Texto de apoio para o campo. */
  help;
  /**
   * @optional
   *
   * @description
   *
   * Indica se o campo será desabilitado.
   *
   * @default `false`
   */
  disabled = false;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do campo.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  displayAdditionalHelp = false;
  value;
  onTouched;
  propagateChange;
  constructor() {
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(value) {
    this.onWriteValue(value);
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  emitChange(value) {
    this.change.emit(value);
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-nome-component
   *  #component
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, component)"
   * ></po-nome-component>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoNomeDoComponente): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  updateModel(value) {
    if (this.propagateChange) {
      this.propagateChange(value);
    }
  }
  static ɵfac = function PoFieldModel_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoFieldModel)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoFieldModel,
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      label: [0, "p-label", "label"],
      name: "name",
      help: [0, "p-help", "help"],
      disabled: [2, "p-disabled", "disabled", convertToBoolean]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      change: "p-change",
      keydown: "p-keydown"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldModel, [{
    type: Directive
  }], () => [], {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "p-disabled",
        transform: convertToBoolean
      }]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }]
  });
})();
var PoRadioSize;
(function(PoRadioSize2) {
  PoRadioSize2["Medium"] = "medium";
  PoRadioSize2["Large"] = "large";
})(PoRadioSize || (PoRadioSize = {}));
var _c0$1a = ["radio"];
var _c1$v = ["radioInput"];
function PoRadioComponent_po_label_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-label", 6);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r1.disabled)("p-label", ctx_r1.label);
  }
}
var PoRadioComponent = class _PoRadioComponent extends PoFieldModel {
  changeDetector;
  renderer;
  radio;
  radioInput;
  value = false;
  _size = PoRadioSize.Medium;
  /** Define o valor do *radio* */
  radioValue;
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho do *radio*
   * @default `medium`
   */
  set size(value) {
    this._size = Object.values(PoRadioSize).includes(value) ? value : PoRadioSize.Medium;
  }
  get size() {
    return this._size;
  }
  required;
  /** Define o status do *radio* */
  checked = false;
  // Evento disparado ao sair do campo.
  blur = new EventEmitter();
  /** Emite evento para a tabela ao selecionar ou desselecionar */
  changeSelected = new EventEmitter();
  constructor(changeDetector, renderer) {
    super();
    this.changeDetector = changeDetector;
    this.renderer = renderer;
  }
  /**
   * Função que atribui foco ao *radio*.
   *
   * Para utilizá-la é necessário capturar a referência do componente no DOM através do `ViewChild`, como por exemplo:
   *
   * ```
   * import { ViewChild } from '@angular/core';
   * import { PoRadioComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoRadioComponent, { static: true }) radio: PoRadioComponent;
   *
   * focusRadio() {
   * this.radio.focus();
   * }
   * ```
   *
   */
  focus() {
    if (!this.disabled) {
      this.radioInput.nativeElement.focus();
      this.onKeyup();
    }
  }
  onBlur() {
    this.onTouched?.();
    this.blur.emit();
  }
  onKeyDown(event) {
    if (event.which === PoKeyCodeEnum.space || event.keyCode === PoKeyCodeEnum.space) {
      this.eventClick();
    }
  }
  changeValue(value) {
    if (value) {
      this.value = value;
      this.updateModel(value);
      this.emitChange(this.value);
    }
  }
  eventClick() {
    if (!this.disabled) {
      this.changeValue(!this.value);
      this.changeDetector.detectChanges();
      this.changeSelected.emit(null);
    }
  }
  onWriteValue(value) {
    if (value !== this.value) {
      this.value = !!value;
      this.changeDetector.markForCheck();
    }
  }
  focusOut() {
    this.renderer.removeClass(this.radio.nativeElement, "po-radio-focus");
  }
  onKeyup() {
    this.renderer.addClass(this.radio.nativeElement, "po-radio-focus");
  }
  onKeydown() {
    this.renderer.addClass(this.radio.nativeElement, "po-radio-focus");
  }
  static ɵfac = function PoRadioComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRadioComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoRadioComponent,
    selectors: [["po-radio"]],
    viewQuery: function PoRadioComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$1a, 7);
        ɵɵviewQuery(_c1$v, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radio = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radioInput = _t.first);
      }
    },
    hostBindings: function PoRadioComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("focusout", function PoRadioComponent_focusout_HostBindingHandler($event) {
          return ctx.focusOut($event.target);
        })("keyup", function PoRadioComponent_keyup_HostBindingHandler($event) {
          return ctx.onKeyup($event.target);
        })("keydown", function PoRadioComponent_keydown_HostBindingHandler($event) {
          return ctx.onKeydown($event.target);
        });
      }
    },
    inputs: {
      radioValue: [0, "p-value", "radioValue"],
      size: [0, "p-size", "size"],
      required: [2, "p-required", "required", convertToBoolean],
      checked: [0, "p-checked", "checked"]
    },
    outputs: {
      blur: "p-blur",
      changeSelected: "p-change-selected"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoRadioComponent),
      multi: true
    }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 7,
    consts: [["radio", ""], ["radioInput", ""], [1, "po-radio"], [3, "click", "keydown"], ["type", "radio", 3, "blur", "checked", "disabled", "name", "required", "value"], [3, "p-disabled", "p-label", 4, "ngIf"], [3, "p-disabled", "p-label"]],
    template: function PoRadioComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 2, 0)(2, "label", 3);
        ɵɵlistener("click", function PoRadioComponent_Template_label_click_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventClick());
        })("keydown", function PoRadioComponent_Template_label_keydown_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementStart(3, "input", 4, 1);
        ɵɵlistener("blur", function PoRadioComponent_Template_input_blur_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        });
        ɵɵelementEnd();
        ɵɵtemplate(5, PoRadioComponent_po_label_5_Template, 1, 2, "po-label", 5);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        let tmp_4_0;
        let tmp_6_0;
        ɵɵadvance(3);
        ɵɵproperty("checked", ctx.checked)("disabled", ctx.disabled)("name", (tmp_4_0 = ctx.name) !== null && tmp_4_0 !== void 0 ? tmp_4_0 : "po-input-radio")("required", ctx.required)("value", (tmp_6_0 = ctx.radioValue) !== null && tmp_6_0 !== void 0 ? tmp_6_0 : "");
        ɵɵattribute("p-size", ctx.size);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.label);
      }
    },
    dependencies: [NgIf, PoLabelComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRadioComponent, [{
    type: Component,
    args: [{
      selector: "po-radio",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoRadioComponent),
        multi: true
      }],
      standalone: false,
      template: `<div #radio class="po-radio">
  <label (click)="eventClick()" (keydown)="onKeyDown($event)">
    <input
      #radioInput
      type="radio"
      [attr.p-size]="size"
      [checked]="checked"
      [disabled]="disabled"
      [name]="name ?? 'po-input-radio'"
      [required]="required"
      [value]="radioValue ?? ''"
      (blur)="onBlur()"
    />
    <po-label *ngIf="label" [p-disabled]="disabled" [p-label]="label"></po-label>
  </label>
</div>
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }], {
    radio: [{
      type: ViewChild,
      args: ["radio", {
        static: true
      }]
    }],
    radioInput: [{
      type: ViewChild,
      args: ["radioInput", {
        static: true
      }]
    }],
    radioValue: [{
      type: Input,
      args: ["p-value"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }],
    required: [{
      type: Input,
      args: [{
        alias: "p-required",
        transform: convertToBoolean
      }]
    }],
    checked: [{
      type: Input,
      args: ["p-checked"]
    }],
    blur: [{
      type: Output,
      args: ["p-blur"]
    }],
    changeSelected: [{
      type: Output,
      args: ["p-change-selected"]
    }],
    focusOut: [{
      type: HostListener,
      args: ["focusout", ["$event.target"]]
    }],
    onKeyup: [{
      type: HostListener,
      args: ["keyup", ["$event.target"]]
    }],
    onKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event.target"]]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRadioComponent, {
    className: "PoRadioComponent",
    filePath: "lib/components/po-field/po-radio/po-radio.component.ts",
    lineNumber: 35
  });
})();
var _c0$19 = ["inp"];
var _c1$u = ["inputRadio"];
function PoRadioGroupComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div")(1, "po-radio", 7, 1);
    ɵɵlistener("p-blur", function PoRadioGroupComponent_div_4_Template_po_radio_p_blur_1_listener() {
      ɵɵrestoreView(_r2);
      const inputRadio_r3 = ɵɵreference(2);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onBlur(inputRadio_r3));
    })("keydown", function PoRadioGroupComponent_div_4_Template_po_radio_keydown_1_listener($event) {
      ɵɵrestoreView(_r2);
      const inputRadio_r3 = ɵɵreference(2);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onKeyDown($event, inputRadio_r3));
    })("keyup", function PoRadioGroupComponent_div_4_Template_po_radio_keyup_1_listener($event) {
      const option_r5 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onKeyUp($event, option_r5.value));
    })("click", function PoRadioGroupComponent_div_4_Template_po_radio_click_1_listener() {
      const option_r5 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.eventClick(option_r5.value, option_r5.disabled === true || ctx_r3.disabled));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const option_r5 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassMapInterpolate2("po-radio-group-item po-md-", ctx_r3.mdColumns, " po-lg-", ctx_r3.columns, "");
    ɵɵadvance();
    ɵɵproperty("name", ctx_r3.name)("p-checked", ctx_r3.value === option_r5.value)("p-disabled", option_r5.disabled === true || ctx_r3.disabled)("p-label", option_r5.label)("p-required", ctx_r3.required)("p-size", ctx_r3.size)("p-value", option_r5.value);
  }
}
var PoRadioGroupComponent = class _PoRadioGroupComponent extends PoRadioGroupBaseComponent {
  el;
  cd;
  /** Label do campo. */
  label;
  /** Texto de apoio do campo. */
  help;
  inputEl;
  radioLabels;
  differ;
  constructor(differs, el, cd) {
    super();
    this.el = el;
    this.cd = cd;
    this.differ = differs.find([]).create(null);
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  ngDoCheck() {
    const change = this.differ.diff(this.options);
    if (change) {
      removeDuplicatedOptions(this.options);
    }
    this.cd.markForCheck();
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  eventClick(value, disabled) {
    if (!disabled) {
      this.onTouched?.();
      this.changeValue(value);
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoRadioGroupComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoRadioGroupComponent, { static: true }) radio: PoRadioGroupComponent;
   *
   * focusRadio() {
   *   this.radio.focus();
   * }
   * ```
   */
  focus() {
    if (this.radioLabels && !this.disabled) {
      const radioLabel = this.radioLabels.find((_, index) => !this.options[index].disabled);
      if (radioLabel) {
        radioLabel.focus();
      }
    }
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  getElementByValue(value) {
    return this.inputEl.nativeElement.querySelector(`input[value='${value}']`);
  }
  getErrorPattern() {
    return this.fieldErrorMessage && this.hasInvalidClass() ? this.fieldErrorMessage : "";
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty");
  }
  onBlur(radio) {
    if (!this.isRadioOptionFocused(radio) && this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
  }
  onKeyDown(event, radio) {
    if (this.isRadioOptionFocused(radio)) {
      this.keydown.emit(event);
    }
  }
  onKeyUp(event, value) {
    const key = event.keyCode || event.which;
    if (this.isArrowKey(key)) {
      this.changeValue(value);
    }
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-radio-group
   *  #radioGroup
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, radioGroup)"
   * ></po-radio-group>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoRadioGroupComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  isArrowKey(key) {
    return key >= 37 && key <= 40;
  }
  isRadioOptionFocused(radio) {
    return document.activeElement === radio.radioInput.nativeElement;
  }
  static ɵfac = function PoRadioGroupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRadioGroupComponent)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoRadioGroupComponent,
    selectors: [["po-radio-group"]],
    viewQuery: function PoRadioGroupComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$19, 7, ElementRef);
        ɵɵviewQuery(_c1$u, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radioLabels = _t);
      }
    },
    inputs: {
      label: [0, "p-label", "label"],
      help: [0, "p-help", "help"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoRadioGroupComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoRadioGroupComponent),
      multi: true
    }]), ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 17,
    consts: [["inp", ""], ["inputRadio", ""], [3, "p-disabled", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["role", "radiogroup", 1, "po-radio-group"], [3, "class", 4, "ngFor", "ngForOf"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-disabled", "p-error-limit", "p-error-pattern", "p-help", "p-show-additional-help", "p-show-additional-help-icon"], [3, "p-blur", "keydown", "keyup", "click", "name", "p-checked", "p-disabled", "p-label", "p-required", "p-size", "p-value"]],
    template: function PoRadioGroupComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 2)(1, "div", 3)(2, "div", 4, 0);
        ɵɵtemplate(4, PoRadioGroupComponent_div_4_Template, 3, 11, "div", 5);
        ɵɵelementEnd();
        ɵɵelementStart(5, "po-field-container-bottom", 6);
        ɵɵlistener("p-additional-help", function PoRadioGroupComponent_Template_po_field_container_bottom_p_additional_help_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.emitAdditionalHelp());
        });
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance();
        ɵɵattribute("name", ctx.name);
        ɵɵadvance();
        ɵɵattribute("aria-label", ctx.label)("data-options", ctx.options.length);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ctx.options);
        ɵɵadvance();
        ɵɵproperty("p-additional-help-tooltip", ctx.getAdditionalHelpTooltip())("p-append-in-body", ctx.appendBox)("p-disabled", ctx.disabled)("p-error-limit", ctx.errorLimit)("p-error-pattern", ctx.getErrorPattern())("p-help", ctx.help)("p-show-additional-help", ctx.displayAdditionalHelp)("p-show-additional-help-icon", ctx.showAdditionalHelpIcon());
      }
    },
    dependencies: [NgForOf, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoRadioComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRadioGroupComponent, [{
    type: Component,
    args: [{
      selector: "po-radio-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoRadioGroupComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoRadioGroupComponent),
        multi: true
      }],
      standalone: false,
      template: '<po-field-container\n  [p-disabled]="disabled"\n  [p-label]="label"\n  [p-optional]="optional"\n  [p-required]="required"\n  [p-show-required]="showRequired"\n>\n  <div class="po-field-container-content" [attr.name]="name">\n    <div #inp class="po-radio-group" role="radiogroup" [attr.aria-label]="label" [attr.data-options]="options.length">\n      <div *ngFor="let option of options" class="po-radio-group-item po-md-{{ mdColumns }} po-lg-{{ columns }}">\n        <po-radio\n          #inputRadio\n          [name]="name"\n          [p-checked]="value === option.value"\n          [p-disabled]="option.disabled === true || disabled"\n          [p-label]="option.label"\n          [p-required]="required"\n          [p-size]="size"\n          [p-value]="option.value"\n          (p-blur)="onBlur(inputRadio)"\n          (keydown)="onKeyDown($event, inputRadio)"\n          (keyup)="onKeyUp($event, option.value)"\n          (click)="eventClick(option.value, option.disabled === true || disabled)"\n        >\n        </po-radio>\n      </div>\n    </div>\n\n    <po-field-container-bottom\n      [p-additional-help-tooltip]="getAdditionalHelpTooltip()"\n      [p-append-in-body]="appendBox"\n      [p-disabled]="disabled"\n      [p-error-limit]="errorLimit"\n      [p-error-pattern]="getErrorPattern()"\n      [p-help]="help"\n      [p-show-additional-help]="displayAdditionalHelp"\n      [p-show-additional-help-icon]="showAdditionalHelpIcon()"\n      (p-additional-help)="emitAdditionalHelp()"\n    ></po-field-container-bottom>\n  </div>\n</po-field-container>\n'
    }]
  }], () => [{
    type: IterableDiffers
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    inputEl: [{
      type: ViewChild,
      args: ["inp", {
        read: ElementRef,
        static: true
      }]
    }],
    radioLabels: [{
      type: ViewChildren,
      args: ["inputRadio"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRadioGroupComponent, {
    className: "PoRadioGroupComponent",
    filePath: "lib/components/po-field/po-radio-group/po-radio-group.component.ts",
    lineNumber: 68
  });
})();
var PoRadioModule = class _PoRadioModule {
  static ɵfac = function PoRadioModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRadioModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoRadioModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, PoLabelModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRadioModule, [{
    type: NgModule,
    args: [{
      declarations: [PoRadioComponent],
      exports: [PoRadioComponent],
      imports: [CommonModule, FormsModule, PoLabelModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoRadioModule, {
    declarations: [PoRadioComponent],
    imports: [CommonModule, FormsModule, PoLabelModule],
    exports: [PoRadioComponent]
  });
})();
var PoRadioGroupModule = class _PoRadioGroupModule {
  static ɵfac = function PoRadioGroupModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRadioGroupModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoRadioGroupModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, PoFieldContainerModule, PoRadioModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRadioGroupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, PoFieldContainerModule, PoRadioModule],
      exports: [PoRadioGroupComponent],
      declarations: [PoRadioGroupComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoRadioGroupModule, {
    declarations: [PoRadioGroupComponent],
    imports: [CommonModule, FormsModule, PoFieldContainerModule, PoRadioModule],
    exports: [PoRadioGroupComponent]
  });
})();
var PoCleanBaseComponent = class _PoCleanBaseComponent {
  /** Nesta propriedade deve-se informar o elementRef do campo de entrada que utilizará o po-clean. */
  inputRef;
  /** Valor que será atribuído ao campo quando for clicado no po-clean. */
  defaultValue = "";
  /**
   * @optional
   *
   * @description
   *
   *
   * Evento disparado quando executada ação do po-clean.
   * Este evento deve ser usado para avisar para o componente que está usando o po-clean, que o botão foi disparado,
   * e provavelmente será preciso emitir o evento para atualizar o model.
   */
  changeEvent = new EventEmitter();
  clear() {
    this.setInputValue(this.defaultValue);
    this.changeEvent.emit(this.defaultValue);
  }
  showIcon() {
    return this.defaultValue !== this.getInputValue();
  }
  static ɵfac = function PoCleanBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCleanBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoCleanBaseComponent,
    inputs: {
      inputRef: [0, "p-element-ref", "inputRef"],
      defaultValue: [0, "p-default-value", "defaultValue"]
    },
    outputs: {
      changeEvent: "p-change-event"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCleanBaseComponent, [{
    type: Directive
  }], null, {
    inputRef: [{
      type: Input,
      args: ["p-element-ref"]
    }],
    defaultValue: [{
      type: Input,
      args: ["p-default-value"]
    }],
    changeEvent: [{
      type: Output,
      args: ["p-change-event"]
    }]
  });
})();
function PoCleanComponent_po_icon_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-icon", 1);
    ɵɵlistener("click", function PoCleanComponent_po_icon_0_Template_po_icon_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clear());
    });
    ɵɵelementEnd();
  }
}
var PoCleanComponent = class _PoCleanComponent extends PoCleanBaseComponent {
  setInputValue(value) {
    if (this.inputRef && this.inputRef.nativeElement) {
      this.inputRef.nativeElement.value = value;
    }
  }
  getInputValue() {
    if (this.inputRef && this.inputRef.nativeElement) {
      return this.inputRef.nativeElement.value;
    }
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoCleanComponent_BaseFactory;
    return function PoCleanComponent_Factory(__ngFactoryType__) {
      return (ɵPoCleanComponent_BaseFactory || (ɵPoCleanComponent_BaseFactory = ɵɵgetInheritedFactory(_PoCleanComponent)))(__ngFactoryType__ || _PoCleanComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoCleanComponent,
    selectors: [["po-clean"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 1,
    consts: [["p-icon", "ICON_CLEAR_CONTENT po-field-icon", 3, "click", 4, "ngIf"], ["p-icon", "ICON_CLEAR_CONTENT po-field-icon", 3, "click"]],
    template: function PoCleanComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoCleanComponent_po_icon_0_Template, 1, 0, "po-icon", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.showIcon());
      }
    },
    dependencies: [NgIf, PoIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCleanComponent, [{
    type: Component,
    args: [{
      selector: "po-clean",
      standalone: false,
      template: '<po-icon p-icon="ICON_CLEAR_CONTENT po-field-icon" *ngIf="showIcon()" (click)="clear()"> </po-icon>\n'
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCleanComponent, {
    className: "PoCleanComponent",
    filePath: "lib/components/po-field/po-clean/po-clean.component.ts",
    lineNumber: 22
  });
})();
var PoCleanModule = class _PoCleanModule {
  static ɵfac = function PoCleanModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoCleanModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoCleanModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCleanModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoIconModule],
      exports: [PoCleanComponent],
      declarations: [PoCleanComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoCleanModule, {
    declarations: [PoCleanComponent],
    imports: [CommonModule, PoIconModule],
    exports: [PoCleanComponent]
  });
})();
var PoMask = class {
  mask = "";
  formatModel = false;
  // controle de posição
  initialPosition = 0;
  finalPosition = 0;
  pattern = "";
  get getPattern() {
    return this.pattern;
  }
  valueToInput;
  get getValueToInput() {
    return this.valueToInput;
  }
  set setValueToInput(value) {
    this.valueToInput = value;
  }
  valueToModel;
  get getValueToModel() {
    return this.valueToModel;
  }
  set setValueToModel(value) {
    this.valueToModel = value;
  }
  formattingEnds;
  constructor(mask, formatModel) {
    this.mask = mask;
    this.formatModel = formatModel;
    this.pattern = this.getRegexFromMask(mask);
  }
  keyup($event) {
    if (this.mask) {
      const value = $event.target.value;
      if ($event.keyCode === 17 || $event.keyCode === 91) {
        $event.target.value = this.controlFormatting(value);
        this.resetPositions($event);
      }
      $event.preventDefault();
      switch ($event.keyCode) {
        case 37:
          if (this.initialPosition > 0) {
            this.initialPosition--;
          }
          this.setPositionNotShiftKey($event);
          this.setSelectionRange($event);
          break;
        case 39:
          if (this.initialPosition < value.toString().length) {
            this.initialPosition++;
          }
          this.setPositionNotShiftKey($event);
          this.setSelectionRange($event);
          break;
        case 35:
          this.finalPosition = value.toString().length;
          if ($event.shiftKey) {
            this.setPositions($event);
          } else {
            this.initialPosition = this.finalPosition;
            this.setPositions($event);
          }
          break;
        case 36:
          if ($event.shiftKey) {
            this.finalPosition = this.initialPosition;
            this.initialPosition = 0;
            this.setPositions($event);
          } else {
            this.initialPosition = 0;
            this.finalPosition = 0;
            this.setPositions($event);
          }
          break;
      }
    }
  }
  setPositionNotShiftKey($event) {
    if (!$event.shiftKey) {
      this.finalPosition = this.initialPosition;
    }
  }
  setSelectionRange($event) {
    if (this.initialPosition > this.finalPosition) {
      $event.target.setSelectionRange?.(this.finalPosition, this.initialPosition);
    } else {
      $event.target.setSelectionRange?.(this.initialPosition, this.finalPosition);
    }
  }
  keydown($event) {
    if (this.mask) {
      let value = $event.target.value;
      if ($event.keyCode === 9) {
        return;
      }
      if (!$event.ctrlKey && !$event.metaKey) {
        $event.preventDefault();
      }
      if ($event.ctrlKey || $event.metaKey && $event.keyCode !== 86 || $event.keyCode >= 37 && $event.keyCode <= 40 || $event.keyCode === 16 || $event.keyCode === 9) {
        return;
      }
      if (this.isKeyValid($event.keyCode)) {
        if (this.finalPosition === null) {
          this.finalPosition = this.initialPosition;
        }
        this.revertPositions(this.initialPosition, this.finalPosition);
        switch ($event.keyCode) {
          case 8:
            this.getPosition($event);
            if (this.initialPosition < 0) {
              this.initialPosition = 0;
              this.setPositions($event);
            }
            if (this.initialPosition === this.finalPosition) {
              this.checkMaskBefore($event, -1);
              if (this.initialPosition !== 0) {
                value = value.slice(0, this.initialPosition - 1) + value.slice(this.finalPosition);
                value = this.controlFormatting(value);
                $event.target.value = value;
                this.changePosition($event, -1);
                this.checkMaskBefore($event, -1);
                this.setPositions($event);
                this.resetPositions($event);
              }
            } else {
              this.clearRangeSelection(value, $event, true);
            }
            this.setPositions($event);
            break;
          case 46:
            this.getPosition($event);
            if (this.initialPosition === this.finalPosition) {
              this.checkMaskAfter($event, 1);
              value = value.slice(0, this.initialPosition) + value.slice(this.finalPosition + 1);
              value = this.controlFormatting(value);
              $event.target.value = value;
              this.setPositions($event);
              this.resetPositions($event);
            } else {
              this.clearRangeSelection(value, $event, false);
            }
            this.setPositions($event);
            break;
          default:
            this.getPosition($event);
            value = value.slice(0, this.initialPosition) + $event.key + value.slice(this.finalPosition);
            value = this.controlFormatting(value);
            $event.target.value = value;
            this.changePosition($event, 1);
            this.checkMaskBefore($event, 1);
            this.setPositions($event);
            this.resetPositions($event);
            this.setPositions($event);
        }
      }
    }
  }
  clearRangeSelection(value, $event, isBackspace) {
    value = value.slice(0, this.initialPosition) + value.slice(this.finalPosition);
    value = this.controlFormatting(value);
    $event.target.value = value;
    if (isBackspace) {
      this.checkMaskBefore($event, -1);
    }
    this.setPositions($event);
    this.resetPositions($event);
  }
  // passa a posição do click para o controle de posição
  click($event) {
    this.initialPosition = $event.target.selectionStart;
    this.finalPosition = $event.target.selectionEnd;
  }
  blur($event) {
    if (this.mask) {
      let value = $event.target.value;
      value = this.controlFormatting(value);
      $event.target.value = value;
    }
  }
  revertPositions(initialPosition, finalPosition) {
    if (initialPosition > finalPosition) {
      const tempPosition = initialPosition;
      this.initialPosition = finalPosition;
      this.finalPosition = tempPosition;
    }
  }
  // reseta o controle de posição
  resetPositions($event) {
    this.initialPosition = $event.target.selectionStart;
    this.finalPosition = this.initialPosition;
  }
  // posiciona o cursor de acordo com o controle de posição
  setPositions($event) {
    $event.target.setSelectionRange?.(this.initialPosition, this.finalPosition);
  }
  // muda a posição do cursor e atualiza o controle de posição
  changePosition($event, value) {
    this.initialPosition = this.initialPosition + value;
    this.finalPosition = this.finalPosition + value;
    this.setPositions($event);
  }
  getPosition($event) {
    this.initialPosition = $event.target.selectionStart;
    this.finalPosition = $event.target.selectionEnd;
    this.setPositions($event);
  }
  // Método responsável por controlar a formatação e aplicar todas as máscara possíveis
  // quando houver valores opcionais (?)
  controlFormatting(value) {
    if (!value) {
      this.valueToInput = "";
      this.valueToModel = "";
      return "";
    }
    let valueProcessed;
    let maskTmp = this.mask;
    const arrMasks = [];
    let contMasks = 0;
    while (this.hasOptionalNumber(maskTmp)) {
      arrMasks.push(maskTmp);
      maskTmp = this.replaceOptionalNumber(maskTmp);
    }
    arrMasks.push(maskTmp);
    arrMasks.reverse();
    this.formattingEnds = false;
    while (!this.formattingEnds) {
      this.formattingEnds = true;
      if (!arrMasks[contMasks]) {
        break;
      }
      valueProcessed = this.formatValue(value, arrMasks[contMasks]);
      contMasks++;
    }
    return valueProcessed;
  }
  // Função que formata a máscara com o valor passado
  formatValue(value, mask) {
    mask = mask.replace(/\?/g, "");
    const guide = mask.replace(this.listValidKeys(), "_");
    let contGuide = 0;
    let valueProcessed = "";
    value = this.removeFormattingValue(value);
    for (let i = 0; i < value.length; i++) {
      const charValue = value[i];
      if (!guide[contGuide]) {
        this.formattingEnds = false;
        break;
      }
      while (this.isFixedCharacterGuide(guide[contGuide]) && guide[contGuide]) {
        valueProcessed += guide[contGuide];
        contGuide++;
      }
      if (this.isKeyValidMask(charValue, mask[contGuide])) {
        valueProcessed += charValue;
        contGuide++;
      } else {
        break;
      }
    }
    if (this.formatModel) {
      this.valueToInput = valueProcessed;
      this.valueToModel = valueProcessed;
    } else {
      this.valueToInput = valueProcessed;
      this.valueToModel = this.removeFormattingValue(valueProcessed);
    }
    return valueProcessed;
  }
  // verifica se tem algum caracter de mascara antes do cursor
  checkMaskBefore($event, position) {
    if (this.isFixedCharacterGuide($event.target.value.toString().charAt(this.initialPosition - 1))) {
      this.changePosition($event, position);
      this.checkMaskBefore($event, position);
    }
  }
  // verifica se tem algum caracter de mascara depois do cursor
  checkMaskAfter($event, position) {
    if (this.isFixedCharacterGuide($event.target.value.toString().charAt(this.initialPosition))) {
      this.changePosition($event, position);
      this.checkMaskAfter($event, position);
    }
  }
  // Retorna a máscara sem um valor opcional
  replaceOptionalNumber(mask) {
    let i = 9;
    while (i >= 0) {
      if (mask.indexOf(i + "?") > -1) {
        return mask.replace(i + "?", "");
      }
      i--;
    }
    return mask;
  }
  // Verifica se contém caracteres permitidos somente na máscara \/() +-
  isFixedCharacterGuide(key) {
    return this.testRegex(key, this.getFixedCharacterGuide());
  }
  // Retorna caracteres permitidos somente na máscara \/() +-
  getFixedCharacterGuide() {
    return /[\\\/() +-.\:]/g;
  }
  // Caracteres permitidos de serem digitados
  listValidKeys() {
    return /[a-zA-Z0-9]/g;
  }
  // Se é um dígito válido
  isKeyValid(keyCode) {
    return this.isKeyCodeValid(keyCode);
  }
  // Verifica se a tecla digitada é permitida
  // Permite apenas números, letras, backspace e del
  isKeyCodeValid(keyCode) {
    return keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 105 || keyCode === 8 || keyCode === 9 || keyCode === 46;
  }
  // Se está de acordo com a máscara
  isKeyValidMask(key, keyMask) {
    return this.testRegex(key, this.replaceMask(keyMask));
  }
  // Retorna se a chave foi aprovada pela expressão regular
  testRegex(key, regex) {
    return regex.test(key);
  }
  // Remove a formatacão do valor
  // É possível ser melhorado para remover pontualmente os caracteres fixos de acordo com a máscara
  removeFormattingValue(value) {
    return value.replace(this.getFixedCharacterGuide(), "");
  }
  // Verifica se contém valor opcional na máscara 0-9?
  hasOptionalNumber(mask) {
    return mask.match(/\d\?/g);
  }
  // Retorna a expressão regular correspondente ao comando passado
  replaceMask(char) {
    let regex = /./;
    switch (char) {
      case "0":
        regex = /[0]/;
        break;
      case "1":
        regex = /[0-1]/;
        break;
      case "2":
        regex = /[0-2]/;
        break;
      case "3":
        regex = /[0-3]/;
        break;
      case "4":
        regex = /[0-4]/;
        break;
      case "5":
        regex = /[0-5]/;
        break;
      case "6":
        regex = /[0-6]/;
        break;
      case "7":
        regex = /[0-7]/;
        break;
      case "8":
        regex = /[0-8]/;
        break;
      case "9":
        regex = /[0-9]/;
        break;
      case " ":
        regex = /\s/;
        break;
      case "@":
        regex = /[a-zA-Z]/;
        break;
      case "w":
        regex = /[a-zA-Z0-9]/;
        break;
    }
    return regex;
  }
  getRegexFromMask(mask) {
    if (mask) {
      let pattern;
      if (this.formatModel) {
        pattern = mask.replace(/\\/g, "\\\\");
        pattern = pattern.replace(/\+/g, "\\+");
        pattern = pattern.replace(/\./g, "\\.");
        pattern = pattern.replace(/-/g, "-");
        pattern = pattern.replace(/\(/g, "\\(");
        pattern = pattern.replace(/\)/g, "\\)");
        pattern = pattern.replace(/\//g, "\\/");
        pattern = pattern.replace(/\s/g, "\\s");
        pattern = pattern.replace(/:/g, "\\:");
        pattern = pattern.replace(/\@(?!\s)/g, "\\w");
        pattern = pattern.replace(/\d/g, "\\w");
      } else {
        pattern = mask.replace(/\\/g, "");
        pattern = pattern.replace(/\+/g, "");
        pattern = pattern.replace(/\./g, "");
        pattern = pattern.replace(/-/g, "");
        pattern = pattern.replace(/\(/g, "");
        pattern = pattern.replace(/\)/g, "");
        pattern = pattern.replace(/\//g, "");
        pattern = pattern.replace(/\s/g, "");
        pattern = pattern.replace(/:/g, "");
        pattern = pattern.replace(/\@/g, "\\w");
        pattern = pattern.replace(/\d/g, "\\w");
      }
      return pattern;
    } else {
      return null;
    }
  }
};
var PoDatepickerIsoFormat;
(function(PoDatepickerIsoFormat2) {
  PoDatepickerIsoFormat2["Basic"] = "basic";
  PoDatepickerIsoFormat2["Extended"] = "extended";
})(PoDatepickerIsoFormat || (PoDatepickerIsoFormat = {}));
var poDatepickerFormatDefault = "dd/mm/yyyy";
var PoDatepickerBaseComponent = class _PoDatepickerBaseComponent {
  languageService;
  cd;
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /**
   * @optional
   *
   * @description
   *
   * Função executada para realizar a validação assíncrona personalizada.
   * Executada ao disparar o output `change`.
   *
   * @param value Valor atual preenchido no campo.
   *
   * @returns Retorna Observable com o valor `true` para sinalizar o erro `false` para indicar que não há erro.
   */
  errorAsync;
  /* Nome do componente datepicker. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * Mensagem apresentada quando a data for inválida ou fora do período.
   *
   * > Por padrão, esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja requerido.
   * Para exibir a mensagem com o campo vazio, utilize a propriedade `p-required-field-error-message` em conjunto.
   */
  errorPattern = "";
  /**
   * @optional
   *
   * @description
   *
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   *
   * > Caso essa propriedade seja definida como `true`, a mensagem de erro será limitada a duas linhas
   * e um tooltip será exibido ao passar o mouse sobre a mensagem para mostrar o conteúdo completo.
   *
   * @default `false`
   */
  errorLimit = false;
  /**
   * @optional
   *
   * @description
   *
   * Exibe a mensagem setada na propriedade `p-error-pattern` se o campo estiver vazio e for requerido.
   *
   * > Necessário que a propriedade `p-required` esteja habilitada.
   *
   * @default `false`
   */
  showErrorMessageRequired = false;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao sair do campo.
   */
  onblur = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do campo.
   */
  onchange = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  offset;
  firstStart = true;
  hour = "T00:00:00-00:00";
  isExtendedISO = false;
  objMask;
  onChangeModel = null;
  validatorChange;
  onTouchedModel = null;
  shortLanguage;
  isInvalid;
  hasValidatorRequired;
  _format = poDatepickerFormatDefault;
  _isoFormat;
  _maxDate;
  _minDate;
  _noAutocomplete = false;
  _placeholder = "";
  previousValue;
  subscription = new Subscription();
  _date;
  /**
   * @optional
   *
   * @description
   *
   * Define a propriedade nativa `autocomplete` do campo como `off`.
   *
   * @default `false`
   */
  set noAutocomplete(value) {
    this._noAutocomplete = convertToBoolean(value);
  }
  get noAutocomplete() {
    return this._noAutocomplete;
  }
  /**
   * @optional
   *
   * @description
   *
   * Mensagem que aparecerá enquanto o campo não estiver preenchido.
   */
  set placeholder(placeholder) {
    this._placeholder = isTypeof(placeholder, "string") ? placeholder : "";
  }
  get placeholder() {
    return this._placeholder;
  }
  /** Desabilita o campo. */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  disabled = false;
  set setDisabled(disabled) {
    this.disabled = disabled === "" ? true : convertToBoolean(disabled);
    this.validateModel(convertDateToISOExtended(this.date, this.hour));
  }
  /** Torna o elemento somente leitura. */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  readonly = false;
  set setReadonly(readonly) {
    this.readonly = readonly === "" ? true : convertToBoolean(readonly);
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  required = false;
  set setRequired(required) {
    this.required = required === "" ? true : convertToBoolean(required);
    this.validateModel(convertDateToISOExtended(this.date, this.hour));
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /** Habilita ação para limpar o campo. */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  clean = false;
  set setClean(clean) {
    this.clean = clean === "" ? true : convertToBoolean(clean);
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma data mínima para o `po-datepicker`.
   */
  set minDate(value) {
    if (value instanceof Date) {
      const year = value.getFullYear();
      const date = new Date(year, value.getMonth(), value.getDate(), 0, 0, 0);
      setYearFrom0To100(date, year);
      this._minDate = date;
    } else {
      this._minDate = convertIsoToDate(value, true, false);
    }
    this.validateModel(convertDateToISOExtended(this.date, this.hour));
  }
  get minDate() {
    return this._minDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma data máxima para o `po-datepicker`.
   */
  set maxDate(value) {
    if (value instanceof Date) {
      const year = value.getFullYear();
      const date = new Date(year, value.getMonth(), value.getDate(), 23, 59, 59);
      setYearFrom0To100(date, year);
      this._maxDate = date;
    } else {
      this._maxDate = convertIsoToDate(value, false, true);
    }
    this.validateModel(convertDateToISOExtended(this.date, this.hour));
  }
  get maxDate() {
    return this._maxDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Formato de exibição da data.
   *
   * Valores válidos:
   *  - `dd/mm/yyyy`
   *  - `mm/dd/yyyy`
   *  - `yyyy/mm/dd`
   *
   * @default `dd/mm/yyyy`
   */
  set format(value) {
    if (value) {
      value = value.toLowerCase();
      if (value.match(/dd/) && value.match(/mm/) && value.match(/yyyy/)) {
        this._format = value;
        this.objMask = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
        this.refreshValue(this.date);
        return;
      }
    }
    this._format = poDatepickerFormatDefault;
    this.objMask = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
  }
  get format() {
    return this._format;
  }
  /**
   * @optional
   *
   * @description
   *
   * Padrão de formatação para saída do *model*, independentemente do formato de entrada.
   *
   * > Veja os valores válidos no *enum* `PoDatepickerIsoFormat`.
   */
  set isoFormat(value) {
    if (Object.values(PoDatepickerIsoFormat).includes(value)) {
      this._isoFormat = value;
      this.isExtendedISO = value === PoDatepickerIsoFormat.Extended;
    }
  }
  get isoFormat() {
    return this._isoFormat;
  }
  /**
   * @optional
   *
   * @description
   *
   * Idioma do Datepicker.
   *
   * > O locale padrão sera recuperado com base no [`PoI18nService`](/documentation/po-i18n) ou *browser*.
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  _locale;
  set locale(value) {
    if (value) {
      this._locale = value.length >= 2 ? value : poLocaleDefault;
      this.objMask = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
    } else {
      this._locale = this.shortLanguage;
      this.objMask = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
    }
    this.refreshValue(this.date);
  }
  get locale() {
    return this._locale || this.shortLanguage;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o `calendar` e/ou tooltip (`p-additional-help-tooltip` e/ou `p-error-limit`) serão incluídos no body da
   * página e não dentro do componente. Essa opção pode ser necessária em cenários com containers que possuem scroll ou
   * overflow escondido, garantindo o posicionamento correto de ambos próximo ao elemento.
   *
   * > Quando utilizado com `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  constructor(languageService, cd) {
    this.languageService = languageService;
    this.cd = cd;
  }
  set date(value) {
    this._date = typeof value === "string" ? convertIsoToDate(value, false, false) : value;
  }
  get date() {
    return this._date;
  }
  ngOnInit() {
    this.offset = (/* @__PURE__ */ new Date()).getTimezoneOffset();
    this.formatTimezoneAndHour(this.offset);
    this.objMask = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  // Converte um objeto string em Date
  getDateFromString(dateString) {
    const day = parseInt(dateString.substring(this.format.indexOf("d"), this.format.indexOf("d") + 2), 10);
    const month = parseInt(dateString.substring(this.format.indexOf("m"), this.format.indexOf("m") + 2), 10) - 1;
    const year = parseInt(dateString.substring(this.format.indexOf("y"), this.format.indexOf("y") + 4), 10);
    const date = new Date(year, month, day);
    setYearFrom0To100(date, year);
    return date.getFullYear() === year && date.getMonth() === month && date.getDate() === day ? date : null;
  }
  // Formata a data.
  formatToDate(value) {
    let dateFormatted = this.format;
    dateFormatted = dateFormatted.replace("dd", ("0" + value.getDate()).slice(-2));
    dateFormatted = dateFormatted.replace("mm", ("0" + (value.getMonth() + 1)).slice(-2));
    dateFormatted = dateFormatted.replace("yyyy", formatYear(value.getFullYear()));
    return dateFormatted;
  }
  // Método responsável por controlar o modelo.
  controlModel(date) {
    this.date = date;
    if (date && this.isExtendedISO) {
      this.callOnChange(convertDateToISOExtended(this.date, this.hour));
    } else if (date && !this.isExtendedISO) {
      this.callOnChange(convertDateToISODate(this.date));
    } else {
      date === void 0 ? this.callOnChange("") : this.callOnChange("Data inválida");
    }
  }
  // Executa a função onChange
  callOnChange(value, retry = true) {
    if (this.onChangeModel && value !== this.previousValue) {
      this.onChangeModel(value);
      this.previousValue = value;
    } else if (retry) {
      setTimeout(() => this.callOnChange(value, false));
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnChange(func) {
    this.onChangeModel = func;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnTouched(func) {
    this.onTouchedModel = func;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(c) {
    this.errorPattern = this.errorPattern !== "Data inválida" && this.errorPattern !== "Data fora do período" ? this.errorPattern : "";
    if (!this.hasValidatorRequired && this.showErrorMessageRequired && c.hasValidator(Validators.required)) {
      this.hasValidatorRequired = true;
    }
    if (dateFailed(c.value)) {
      this.errorPattern = this.errorPattern || "Data inválida";
      return {
        date: {
          valid: false
        }
      };
    }
    if (requiredFailed(this.required, this.disabled, c.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
    if (this.date && !validateDateRange(this.date, this._minDate, this._maxDate)) {
      this.errorPattern = this.errorPattern || "Data fora do período";
      return {
        date: {
          valid: false
        }
      };
    }
    if (this.errorPattern !== "") {
      this.subscription?.unsubscribe();
      this.subscription = c.statusChanges.pipe(switchMap((status) => {
        if (status === "INVALID") {
          this.cd.markForCheck();
        }
        return [];
      })).subscribe();
    }
    return null;
  }
  validateModel(model) {
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  // Retorna um objeto do tipo PoMask com a mascara configurada.
  buildMask(format = this.format) {
    let mask = format.toUpperCase();
    mask = mask.replace(/DD/g, "99");
    mask = mask.replace(/MM/g, "99");
    mask = mask.replace(/YYYY/g, "9999");
    return new PoMask(mask, true);
  }
  formatTimezoneAndHour(offset) {
    const offsetAbsolute = Math.abs(offset);
    const timezone = (offset < 0 ? "+" : "-") + ("00" + Math.floor(offsetAbsolute / 60)).slice(-2) + ":" + ("00" + offsetAbsolute % 60).slice(-2);
    this.hour = "T00:00:00" + timezone;
  }
  static ɵfac = function PoDatepickerBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDatepickerBaseComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoDatepickerBaseComponent,
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      errorAsync: [0, "p-error-async", "errorAsync"],
      name: "name",
      optional: [0, "p-optional", "optional"],
      errorPattern: [0, "p-error-pattern", "errorPattern"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      showErrorMessageRequired: [0, "p-required-field-error-message", "showErrorMessageRequired"],
      noAutocomplete: [0, "p-no-autocomplete", "noAutocomplete"],
      placeholder: [0, "p-placeholder", "placeholder"],
      setDisabled: [0, "p-disabled", "setDisabled"],
      setReadonly: [0, "p-readonly", "setReadonly"],
      setRequired: [0, "p-required", "setRequired"],
      showRequired: [0, "p-show-required", "showRequired"],
      setClean: [0, "p-clean", "setClean"],
      minDate: [0, "p-min-date", "minDate"],
      maxDate: [0, "p-max-date", "maxDate"],
      format: [0, "p-format", "format"],
      isoFormat: [0, "p-iso-format", "isoFormat"],
      locale: [0, "p-locale", "locale"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      onblur: "p-blur",
      onchange: "p-change",
      keydown: "p-keydown"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDatepickerBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }, {
    type: ChangeDetectorRef
  }], {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    errorAsync: [{
      type: Input,
      args: ["p-error-async"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    errorPattern: [{
      type: Input,
      args: ["p-error-pattern"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    showErrorMessageRequired: [{
      type: Input,
      args: ["p-required-field-error-message"]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    onblur: [{
      type: Output,
      args: ["p-blur"]
    }],
    onchange: [{
      type: Output,
      args: ["p-change"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    noAutocomplete: [{
      type: Input,
      args: ["p-no-autocomplete"]
    }],
    placeholder: [{
      type: Input,
      args: ["p-placeholder"]
    }],
    setDisabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    setReadonly: [{
      type: Input,
      args: ["p-readonly"]
    }],
    setRequired: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }],
    setClean: [{
      type: Input,
      args: ["p-clean"]
    }],
    minDate: [{
      type: Input,
      args: ["p-min-date"]
    }],
    maxDate: [{
      type: Input,
      args: ["p-max-date"]
    }],
    format: [{
      type: Input,
      args: ["p-format"]
    }],
    isoFormat: [{
      type: Input,
      args: ["p-iso-format"]
    }],
    locale: [{
      type: Input,
      args: ["p-locale"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }]
  });
})();
var PoDatepickerLiterals = {
  en: {
    open: "Open calendar"
  },
  es: {
    open: "Calendario abierto"
  },
  pt: {
    open: "Abrir calendário"
  },
  ru: {
    open: "открытый календарь"
  }
};
var _c0$18 = ["calendar"];
var _c1$t = ["dialogPicker"];
var _c2$f = ["iconDatepicker"];
var _c3$b = ["inp"];
function PoDatepickerComponent_po_clean_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 18);
    ɵɵlistener("p-change-event", function PoDatepickerComponent_po_clean_9_Template_po_clean_p_change_event_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.clear());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-element-ref", ctx_r2.inputEl);
  }
}
function PoDatepickerComponent_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoDatepickerComponent_ng_template_13_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 21);
  }
}
function PoDatepickerComponent_ng_template_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", null, 7);
    ɵɵtemplate(2, PoDatepickerComponent_ng_template_13_div_2_Template, 1, 0, "div", 19);
    ɵɵelementStart(3, "po-calendar", 20, 8);
    ɵɵtwoWayListener("ngModelChange", function PoDatepickerComponent_ng_template_13_Template_po_calendar_ngModelChange_3_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r2.date, $event) || (ctx_r2.date = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDatepickerComponent_ng_template_13_Template_po_calendar_p_change_3_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.dateSelected());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("po-datepicker-popup-calendar", !ctx_r2.verifyMobile());
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r2.verifyMobile());
    ɵɵadvance();
    ɵɵclassProp("po-datepicker-calendar-mobile", ctx_r2.verifyMobile());
    ɵɵtwoWayProperty("ngModel", ctx_r2.date);
    ɵɵproperty("p-max-date", ctx_r2.maxDate)("p-min-date", ctx_r2.minDate)("p-locale", ctx_r2.locale);
  }
}
function PoDatepickerComponent_ng_template_15_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoDatepickerComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoDatepickerComponent_ng_template_15_ng_container_0_Template, 1, 0, "ng-container", 22);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedCalendarContent_r5 = ɵɵreference(14);
    ɵɵproperty("ngTemplateOutlet", sharedCalendarContent_r5);
  }
}
function PoDatepickerComponent_ng_template_17_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoDatepickerComponent_ng_template_17_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoDatepickerComponent_ng_template_17_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 22);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const sharedCalendarContent_r5 = ɵɵreference(14);
    ɵɵproperty("ngTemplateOutlet", sharedCalendarContent_r5);
  }
}
function PoDatepickerComponent_ng_template_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoDatepickerComponent_ng_template_17_ng_template_0_Template, 1, 1, "ng-template", 23);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const trigger_r6 = ɵɵreference(4);
    ɵɵproperty("cdkConnectedOverlayOrigin", trigger_r6)("cdkConnectedOverlayOpen", true);
  }
}
function PoDatepickerComponent_po_field_container_bottom_19_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 24);
    ɵɵlistener("p-additional-help", function PoDatepickerComponent_po_field_container_bottom_19_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.emitAdditionalHelp());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r2.getAdditionalHelpTooltip())("p-append-in-body", ctx_r2.appendBox)("p-help", ctx_r2.help)("p-disabled", ctx_r2.disabled)("p-error-pattern", ctx_r2.getErrorPattern())("p-error-limit", ctx_r2.errorLimit)("p-show-additional-help", ctx_r2.displayAdditionalHelp)("p-show-additional-help-icon", ctx_r2.showAdditionalHelpIcon());
  }
}
var poCalendarContentOffset$1 = 8;
var poCalendarPositionDefault$1 = "bottom-left";
var PoDatepickerComponent = class _PoDatepickerComponent extends PoDatepickerBaseComponent {
  languageService;
  cd;
  controlPosition;
  renderer;
  calendar;
  dialogPicker;
  iconDatepicker;
  inputEl;
  /** Rótulo do campo. */
  label;
  /** Texto de apoio do campo. */
  help;
  displayAdditionalHelp = false;
  el;
  hour;
  id = `po-datepicker[${uuid()}]`;
  visible = false;
  literals;
  eventListenerFunction;
  eventResizeListener;
  clickListener;
  dateRegex = new RegExp("^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])$");
  isoRegex = new RegExp("^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:Z|-0[1-9]|-1\\d|-2[0-3]|-00:?(?:0[1-9]|[0-5]\\d)|\\+[01]\\d|\\+2[0-3])(?:|:?[0-5]\\d)$");
  timeoutChange;
  valueBeforeChange;
  subscriptionValidator = new Subscription();
  get autocomplete() {
    return this.noAutocomplete ? "off" : "on";
  }
  constructor(languageService, cd, controlPosition, renderer, el) {
    super(languageService, cd);
    this.languageService = languageService;
    this.cd = cd;
    this.controlPosition = controlPosition;
    this.renderer = renderer;
    this.shortLanguage = this.languageService.getShortLanguage();
    this.el = el;
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues({}, PoDatepickerLiterals[language]);
  }
  onKeyup($event) {
    if (this.readonly) {
      return;
    }
    this.objMask.keyup($event);
    if (this.objMask.valueToModel || this.objMask.valueToModel === "") {
      if (this.objMask.valueToModel.length >= 10) {
        this.controlModel(this.getDateFromString(this.inputEl.nativeElement.value));
        this.date = this.getDateFromString(this.inputEl.nativeElement.value);
      } else {
        this.date = void 0;
        this.controlModel(this.date);
      }
    } else {
      this.date = void 0;
    }
  }
  onKeydown($event) {
    if (this.readonly) {
      return;
    }
    this.objMask.keydown($event);
  }
  ngAfterViewInit() {
    this.setDialogPickerStyleDisplay("none");
    if (this.autoFocus) {
      this.focus();
    }
    this.renderer.setAttribute(this.iconDatepicker.buttonElement.nativeElement, "aria-label", this.literals.open);
  }
  ngOnDestroy() {
    this.subscriptionValidator?.unsubscribe();
    this.removeListeners();
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoDatepickerComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoDatepickerComponent, { static: true }) datepicker: PoDatepickerComponent;
   *
   * focusDatepicker() {
   *   this.datepicker.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  togglePicker() {
    if (this.disabled || this.readonly) {
      return;
    }
    if (!this.visible) {
      this.setCalendarPosition();
      this.initializeListeners();
      this.visible = true;
    } else {
      this.inputEl.nativeElement.disabled = false;
      this.closeCalendar();
    }
  }
  dateSelected() {
    this.onTouchedModel?.();
    if (!this.verifyMobile()) {
      this.inputEl.nativeElement.focus();
    }
    this.inputEl.nativeElement.value = this.formatToDate(this.date);
    this.controlModel(this.date);
    this.controlChangeEmitter();
    this.closeCalendar();
  }
  // Esconde Picker quando for clicado fora
  wasClickedOnPicker(event) {
    if (!this.dialogPicker || !this.iconDatepicker) {
      return;
    }
    if ((!this.dialogPicker.nativeElement.contains(event.target) || this.hasOverlayClass(event.target)) && !this.iconDatepicker.buttonElement.nativeElement.contains(event.target) && !this.hasAttrCalendar(event.target)) {
      this.closeCalendar();
    }
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty") && (this.inputEl.nativeElement.value !== "" || this.showErrorMessageRequired && (this.required || this.hasValidatorRequired));
  }
  getErrorPattern() {
    return this.errorPattern !== "" && this.hasInvalidClass() ? this.errorPattern : "";
  }
  clear() {
    this.valueBeforeChange = this.formatToDate(this.date);
    this.date = void 0;
    this.controlModel(this.date);
    this.controlChangeEmitter();
  }
  eventOnBlur($event) {
    this.onTouchedModel?.();
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
    const date = this.inputEl.nativeElement.value;
    const newDate = date ? this.getDateFromString(date) : void 0;
    this.objMask.blur($event);
    this.onblur.emit();
    if (this.objMask.valueToModel) {
      if (this.objMask.valueToModel.length >= 10) {
        this.controlModel(newDate);
        this.date = newDate;
      } else {
        this.date = null;
        this.controlModel(this.date);
      }
    } else {
      this.date = void 0;
      this.callOnChange(this.date);
    }
    this.controlChangeEmitter();
  }
  eventOnClick($event) {
    if (this.verifyMobile()) {
      $event.target.blur();
      setTimeout(() => this.togglePicker(), 0);
    } else {
      this.objMask.click($event);
    }
  }
  onKeyDown(event) {
    const isFieldFocused = document.activeElement === this.inputEl.nativeElement;
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  onKeyPress(event) {
    if (isKeyCodeEnter(event) || isKeyCodeSpace(event)) {
      this.togglePicker();
    }
  }
  formatToDate(value) {
    if (!value) {
      return void 0;
    }
    let dateFormatted = replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale));
    dateFormatted = dateFormatted.replace("dd", ("0" + value.getDate()).slice(-2));
    dateFormatted = dateFormatted.replace("mm", ("0" + (value.getMonth() + 1)).slice(-2));
    dateFormatted = dateFormatted.replace("yyyy", formatYear(value.getFullYear()));
    return dateFormatted;
  }
  refreshValue(value) {
    if (value) {
      this.inputEl.nativeElement.value = this.formatToDate(value);
    }
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-datepicker
   *  #datepicker
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, datepicker)"
   * ></po-datepicker>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoDatepickerComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  // Função implementada do ControlValueAccessor
  writeValue(value) {
    if (this.inputEl && value) {
      if (value instanceof Date) {
        const dateString = value.toString();
        this.hour = "T" + dateString.substring(16, 24) + dateString.substring(28, 31) + ":" + dateString.substring(31, 33);
        this.date = value;
        this.inputEl.nativeElement.value = this.formatToDate(value);
      } else if (this.isValidDateIso(value) || this.isValidExtendedIso(value)) {
        if (this.isValidExtendedIso(value)) {
          this.hour = value.substring(10, 25);
        }
        if (this.isoFormat === void 0) {
          this.isExtendedISO = this.isValidExtendedIso(value);
        }
        const day = parseInt(value.substring(8, 10), 10);
        const month = parseInt(value.substring(5, 7), 10) - 1;
        const year = parseInt(value.substring(0, 4), 10);
        const dateTemp = new Date(year, month, day);
        setYearFrom0To100(dateTemp, year);
        this.date = dateTemp;
        this.inputEl.nativeElement.value = this.formatToDate(dateTemp);
      } else {
        this.inputEl.nativeElement.value = "";
        this.date = void 0;
      }
      this.controlModel(this.date);
      const dateModelFormatted = this.formatToDate(this.date);
      this.verifyErrorAsync(dateModelFormatted);
    } else if (this.inputEl) {
      this.inputEl.nativeElement.value = "";
      this.date = void 0;
      this.callOnChange(this.date, false);
    }
    this.valueBeforeChange = this.formatToDate(this.date);
  }
  isValidDateIso(value) {
    return this.dateRegex.test(value);
  }
  isValidExtendedIso(value) {
    return this.isoRegex.test(value);
  }
  hasOverlayClass(element) {
    return element.classList.contains("po-datepicker-calendar-overlay");
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  verifyErrorAsync(value) {
    if (this.errorPattern !== "" && this.errorAsync) {
      const errorAsync = this.errorAsync(value);
      if (isObservable(errorAsync)) {
        this.subscriptionValidator?.unsubscribe();
        this.subscriptionValidator = errorAsync.pipe(switchMap((error) => {
          const element = this.el.nativeElement;
          if (error) {
            element.classList.add("ng-invalid");
            element.classList.add("ng-dirty");
            this.cd.detectChanges();
          } else if (element.classList.contains("ng-invalid") && element.classList.contains("ng-dirty") && !this.isInvalid) {
            element.classList.remove("ng-invalid");
            this.cd.detectChanges();
          }
          return of("");
        })).subscribe();
      }
    }
  }
  /* istanbul ignore next */
  verifyMobile() {
    return isMobile();
  }
  closeCalendar() {
    this.visible = false;
    this.removeListeners();
    this.setDialogPickerStyleDisplay("none");
  }
  controlChangeEmitter() {
    const dateModelFormatted = this.formatToDate(this.date);
    if (dateModelFormatted !== this.valueBeforeChange) {
      this.valueBeforeChange = dateModelFormatted;
      clearTimeout(this.timeoutChange);
      this.timeoutChange = setTimeout(() => {
        this.onchange.emit(dateModelFormatted);
        this.verifyErrorAsync(dateModelFormatted);
      }, 200);
    }
  }
  hasAttrCalendar(element) {
    const attrCalendar = "attr-calendar";
    return element && element.hasAttribute(attrCalendar) || element.parentElement && element.parentElement.hasAttribute(attrCalendar);
  }
  initializeListeners() {
    this.clickListener = this.renderer.listen("document", "click", (event) => {
      this.wasClickedOnPicker(event);
    });
    this.eventResizeListener = this.renderer.listen("window", "resize", () => {
      this.closeCalendar();
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  onScroll = () => {
    this.controlPosition.adjustPosition(poCalendarPositionDefault$1);
  };
  removeListeners() {
    if (this.clickListener) {
      this.clickListener();
    }
    if (this.eventResizeListener) {
      this.eventResizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
  }
  setDialogPickerStyleDisplay(value) {
    if (this.dialogPicker && this.dialogPicker.nativeElement) {
      this.dialogPicker.nativeElement.style.display = value;
    }
  }
  setCalendarPosition() {
    this.setDialogPickerStyleDisplay("block");
    if (this.dialogPicker && this.dialogPicker.nativeElement) {
      this.controlPosition.setElements(this.dialogPicker.nativeElement, poCalendarContentOffset$1, this.inputEl, ["top-left", "top-right", "bottom-left", "bottom-right"], false, true);
      this.controlPosition.adjustPosition(poCalendarPositionDefault$1);
    }
  }
  static ɵfac = function PoDatepickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDatepickerComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoControlPositionService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDatepickerComponent,
    selectors: [["po-datepicker"]],
    viewQuery: function PoDatepickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$18, 7);
        ɵɵviewQuery(_c1$t, 5, ElementRef);
        ɵɵviewQuery(_c2$f, 5);
        ɵɵviewQuery(_c3$b, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.calendar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dialogPicker = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.iconDatepicker = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
      }
    },
    hostBindings: function PoDatepickerComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keyup", function PoDatepickerComponent_keyup_HostBindingHandler($event) {
          return ctx.onKeyup($event);
        })("keydown", function PoDatepickerComponent_keydown_HostBindingHandler($event) {
          return ctx.onKeydown($event);
        });
      }
    },
    inputs: {
      label: [0, "p-label", "label"],
      help: [0, "p-help", "help"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoDatepickerComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoDatepickerComponent),
      multi: true
    }, PoControlPositionService]), ɵɵInheritDefinitionFeature],
    decls: 20,
    vars: 21,
    consts: [["outerContainer", ""], ["trigger", "cdkOverlayOrigin"], ["inp", ""], ["iconDatepicker", ""], ["sharedCalendarContent", ""], ["dropdownDefault", ""], ["dropdownCDK", ""], ["dialogPicker", ""], ["calendar", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], ["cdkOverlayOrigin", "", 1, "po-field-container-content", "po-field-container-content-datepicker"], [1, "po-field-container-input"], ["type", "text", 1, "po-input", "po-datepicker", 3, "blur", "click", "keydown", "autocomplete", "disabled", "id", "placeholder", "readonly", "required"], [1, "po-field-icon-container-right"], ["class", "po-icon-input", 3, "p-element-ref", "p-change-event", 4, "ngIf"], ["p-icon", "ICON_CALENDAR", "p-kind", "tertiary", 1, "po-datepicker-button", 3, "keydown", "p-click", "p-disabled"], [4, "ngIf", "ngIfThen", "ngIfElse"], [3, "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [1, "po-icon-input", 3, "p-change-event", "p-element-ref"], ["class", "po-datepicker-calendar-overlay", 4, "ngIf"], [3, "ngModelChange", "p-change", "ngModel", "p-max-date", "p-min-date", "p-locale"], [1, "po-datepicker-calendar-overlay"], [4, "ngTemplateOutlet"], ["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon"]],
    template: function PoDatepickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 9)(1, "div", null, 0)(3, "div", 10, 1)(5, "div", 11)(6, "input", 12, 2);
        ɵɵlistener("blur", function PoDatepickerComponent_Template_input_blur_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnBlur($event));
        })("click", function PoDatepickerComponent_Template_input_click_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnClick($event));
        })("keydown", function PoDatepickerComponent_Template_input_keydown_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(8, "div", 13);
        ɵɵtemplate(9, PoDatepickerComponent_po_clean_9_Template, 1, 1, "po-clean", 14);
        ɵɵelementEnd()();
        ɵɵelementStart(10, "po-button", 15, 3);
        ɵɵlistener("keydown", function PoDatepickerComponent_Template_po_button_keydown_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyPress($event));
        })("p-click", function PoDatepickerComponent_Template_po_button_p_click_10_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.togglePicker());
        });
        ɵɵelementEnd()();
        ɵɵtemplate(12, PoDatepickerComponent_ng_container_12_Template, 1, 0, "ng-container", 16)(13, PoDatepickerComponent_ng_template_13_Template, 5, 9, "ng-template", null, 4, ɵɵtemplateRefExtractor)(15, PoDatepickerComponent_ng_template_15_Template, 1, 1, "ng-template", null, 5, ɵɵtemplateRefExtractor)(17, PoDatepickerComponent_ng_template_17_Template, 1, 2, "ng-template", null, 6, ɵɵtemplateRefExtractor);
        ɵɵelementEnd();
        ɵɵtemplate(19, PoDatepickerComponent_po_field_container_bottom_19_Template, 1, 8, "po-field-container-bottom", 17);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        const inp_r8 = ɵɵreference(7);
        const dropdownDefault_r9 = ɵɵreference(16);
        const dropdownCDK_r10 = ɵɵreference(18);
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(6);
        ɵɵclassProp("po-input-icon-right", ctx.clean && inp_r8.value);
        ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required);
        ɵɵattribute("name", ctx.name);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
        ɵɵadvance();
        ɵɵproperty("p-disabled", ctx.disabled || ctx.readonly);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.appendBox)("ngIfThen", dropdownCDK_r10)("ngIfElse", dropdownDefault_r9);
        ɵɵadvance(7);
        ɵɵproperty("ngIf", !ctx.readonly);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, NgControlStatus, NgModel, PoFieldContainerBottomComponent, PoFieldContainerComponent, CdkConnectedOverlay, CdkOverlayOrigin, PoCleanComponent, PoCalendarComponent, PoButtonComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDatepickerComponent, [{
    type: Component,
    args: [{
      selector: "po-datepicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoDatepickerComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoDatepickerComponent),
        multi: true
      }, PoControlPositionService],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div #outerContainer>
    <div
      cdkOverlayOrigin
      #trigger="cdkOverlayOrigin"
      class="po-field-container-content po-field-container-content-datepicker"
    >
      <div class="po-field-container-input">
        <input
          #inp
          class="po-input po-datepicker"
          [class.po-input-icon-right]="clean && inp.value"
          type="text"
          [attr.name]="name"
          [autocomplete]="autocomplete"
          [disabled]="disabled"
          [id]="id"
          [placeholder]="disabled ? '' : placeholder"
          [readonly]="readonly"
          [required]="required"
          (blur)="eventOnBlur($event)"
          (click)="eventOnClick($event)"
          (keydown)="onKeyDown($event)"
        />
        <div class="po-field-icon-container-right">
          <po-clean
            class="po-icon-input"
            *ngIf="clean && !disabled && !readonly"
            [p-element-ref]="inputEl"
            (p-change-event)="clear()"
          >
          </po-clean>
        </div>
      </div>
      <po-button
        #iconDatepicker
        class="po-datepicker-button"
        p-icon="ICON_CALENDAR"
        p-kind="tertiary"
        [p-disabled]="disabled || readonly"
        (keydown)="onKeyPress($event)"
        (p-click)="togglePicker()"
      >
      </po-button>
    </div>

    <ng-container *ngIf="appendBox; then dropdownCDK; else dropdownDefault"> </ng-container>

    <ng-template #sharedCalendarContent>
      <div #dialogPicker [class.po-datepicker-popup-calendar]="!verifyMobile()">
        <div *ngIf="verifyMobile()" class="po-datepicker-calendar-overlay"></div>
        <po-calendar
          [class.po-datepicker-calendar-mobile]="verifyMobile()"
          #calendar
          [(ngModel)]="date"
          [p-max-date]="maxDate"
          [p-min-date]="minDate"
          [p-locale]="locale"
          (p-change)="dateSelected()"
        ></po-calendar>
      </div>
    </ng-template>

    <ng-template #dropdownDefault>
      <ng-container *ngTemplateOutlet="sharedCalendarContent"></ng-container>
    </ng-template>

    <ng-template #dropdownCDK>
      <ng-template cdkConnectedOverlay [cdkConnectedOverlayOrigin]="trigger" [cdkConnectedOverlayOpen]="true">
        <ng-container *ngTemplateOutlet="sharedCalendarContent"></ng-container>
      </ng-template>
    </ng-template>
  </div>

  <po-field-container-bottom
    *ngIf="!readonly"
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
    [p-error-limit]="errorLimit"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: PoLanguageService
  }, {
    type: ChangeDetectorRef
  }, {
    type: PoControlPositionService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    calendar: [{
      type: ViewChild,
      args: ["calendar", {
        static: true
      }]
    }],
    dialogPicker: [{
      type: ViewChild,
      args: ["dialogPicker", {
        read: ElementRef,
        static: false
      }]
    }],
    iconDatepicker: [{
      type: ViewChild,
      args: ["iconDatepicker"]
    }],
    inputEl: [{
      type: ViewChild,
      args: ["inp", {
        read: ElementRef,
        static: true
      }]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    onKeyup: [{
      type: HostListener,
      args: ["keyup", ["$event"]]
    }],
    onKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDatepickerComponent, {
    className: "PoDatepickerComponent",
    filePath: "lib/components/po-field/po-datepicker/po-datepicker.component.ts",
    lineNumber: 83
  });
})();
var PoDatepickerModule = class _PoDatepickerModule {
  static ɵfac = function PoDatepickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDatepickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoDatepickerModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, PoFieldContainerModule, OverlayModule, PoCleanModule, PoCalendarModule, PoButtonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDatepickerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, PoFieldContainerModule, OverlayModule, PoCleanModule, PoCalendarModule, PoButtonModule],
      exports: [PoDatepickerComponent],
      declarations: [PoDatepickerComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDatepickerModule, {
    declarations: [PoDatepickerComponent],
    imports: [CommonModule, FormsModule, PoFieldContainerModule, OverlayModule, PoCleanModule, PoCalendarModule, PoButtonModule],
    exports: [PoDatepickerComponent]
  });
})();
var poModalLiterals = {
  en: {
    close: "Close"
  },
  es: {
    close: "Cerrar"
  },
  pt: {
    close: "Fechar"
  },
  ru: {
    close: "Закрыть"
  }
};
var PoModalBaseComponent = class _PoModalBaseComponent {
  /** Título da modal. */
  title;
  /** Evento disparado ao fechar o modal. */
  closeModal = new EventEmitter();
  /**
   * Deve ser definido um objeto que implementa a interface `PoModalAction` contendo a label e a função da primeira ação.
   * Caso esta propriedade não seja definida ou esteja incompleta, automaticamente será adicionado um botão de ação com
   * a função de fechar a modal.
   */
  primaryAction;
  /** Deve ser definido um objeto que implementa a interface `PoModalAction` contendo a label e a função da segunda ação. */
  secondaryAction;
  language;
  literals;
  // Controla se a modal fica oculto ou visível, por padrão é oculto
  isHidden = true;
  // Event emmiter para quando a modal é fechada pelo 'X'.
  onXClosed = new EventEmitter();
  _hideClose = false;
  _size = "md";
  /**
   * Define o tamanho da modal.
   *
   * Valores válidos:
   *  - `sm` (pequeno)
   *  - `md` (médio)
   *  - `lg` (grande)
   *  - `xl` (extra grande)
   *  - `auto` (automático)
   *
   * > Quando informado `auto` a modal calculará automaticamente seu tamanho baseado em seu conteúdo.
   * Caso não seja informado um valor, a modal terá o tamanho definido como `md`.
   *
   */
  set size(value) {
    const sizes = ["sm", "md", "lg", "xl", "auto"];
    this._size = sizes.indexOf(value) > -1 ? value : "md";
  }
  get size() {
    return this._size;
  }
  /**
   * Define o fechamento da modal ao clicar fora da mesma.
   * Informe o valor `true` para ativar o fechamento ao clicar fora da modal.
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  clickOut = false;
  set setClickOut(value) {
    this.clickOut = value === "" ? false : convertToBoolean(value);
  }
  /**
   * @optional
   *
   * @description
   *
   * Oculta o ícone de fechar do cabeçalho da modal.
   *
   * > Caso a propriedade estiver habilitada, não será possível fechar a modal através da tecla *ESC*.
   *
   * @default `false`
   */
  set hideClose(value) {
    this._hideClose = convertToBoolean(value);
  }
  get hideClose() {
    return this._hideClose;
  }
  /**
   * @optional
   *
   * @description
   * Ícone exibido ao lado esquerdo do label do titúlo da modal.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](https://po-ui.io/icons). conforme exemplo abaixo:
   * ```
   * <po-modal p-icon="an an-user" p-title="PO Modal"></po-modal>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-modal p-icon="fa fa-podcast" p-title="PO Modal"></po-modal>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-modal [p-icon]="template" p-title="PO Modal"></po-modal>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   */
  icon;
  constructor(poLanguageService) {
    this.language = poLanguageService.getShortLanguage();
    this.literals = __spreadValues({}, poModalLiterals[this.language]);
  }
  /** Função para fechar a modal. */
  close(xClosed = false) {
    this.closeModal.emit();
    this.isHidden = true;
    if (xClosed) {
      this.onXClosed.emit(xClosed);
    }
  }
  /** Função para abrir a modal. */
  open() {
    this.validPrimaryAction();
    this.isHidden = false;
  }
  validPrimaryAction() {
    if (!this.primaryAction) {
      this.primaryAction = {
        action: () => this.close(),
        label: this.literals.close
      };
    }
    if (!this.primaryAction["action"]) {
      this.primaryAction["action"] = () => this.close();
    }
    if (!this.primaryAction["label"]) {
      this.primaryAction["label"] = this.literals.close;
    }
  }
  static ɵfac = function PoModalBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoModalBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoModalBaseComponent,
    inputs: {
      title: [0, "p-title", "title"],
      primaryAction: [0, "p-primary-action", "primaryAction"],
      secondaryAction: [0, "p-secondary-action", "secondaryAction"],
      size: [0, "p-size", "size"],
      setClickOut: [0, "p-click-out", "setClickOut"],
      hideClose: [0, "p-hide-close", "hideClose"],
      icon: [0, "p-icon", "icon"]
    },
    outputs: {
      closeModal: "p-close"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoModalBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    closeModal: [{
      type: Output,
      args: ["p-close"]
    }],
    primaryAction: [{
      type: Input,
      args: ["p-primary-action"]
    }],
    secondaryAction: [{
      type: Input,
      args: ["p-secondary-action"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }],
    setClickOut: [{
      type: Input,
      args: ["p-click-out"]
    }],
    hideClose: [{
      type: Input,
      args: ["p-hide-close"]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }]
  });
})();
var _c0$17 = ["*"];
var PoModalFooterComponent = class _PoModalFooterComponent {
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o alinhamento padrão, à direita, dos botões de ações que ficam no rodapé da [`PoModal`](/documentation/po-modal).
   *
   * > Caso a propriedade esteja habilitada, o alinhamento deverá ser a esquerda e pode ser personalizado.
   *
   * @default false
   */
  disabledAlign = false;
  static ɵfac = function PoModalFooterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoModalFooterComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoModalFooterComponent,
    selectors: [["po-modal-footer"]],
    inputs: {
      disabledAlign: [0, "p-disabled-align", "disabledAlign"]
    },
    standalone: false,
    ngContentSelectors: _c0$17,
    decls: 2,
    vars: 2,
    consts: [[1, "po-modal-footer"]],
    template: function PoModalFooterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0);
        ɵɵprojection(1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("po-modal-footer-align-right", !ctx.disabledAlign);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoModalFooterComponent, [{
    type: Component,
    args: [{
      selector: "po-modal-footer",
      standalone: false,
      template: '<div class="po-modal-footer" [class.po-modal-footer-align-right]="!disabledAlign">\n  <ng-content></ng-content>\n</div>\n'
    }]
  }], null, {
    disabledAlign: [{
      type: Input,
      args: ["p-disabled-align"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoModalFooterComponent, {
    className: "PoModalFooterComponent",
    filePath: "lib/components/po-modal/po-modal-footer/po-modal-footer.component.ts",
    lineNumber: 24
  });
})();
var PoActiveOverlayService = class _PoActiveOverlayService {
  activeOverlay = [];
  static ɵfac = function PoActiveOverlayService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoActiveOverlayService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoActiveOverlayService,
    factory: _PoActiveOverlayService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoActiveOverlayService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _c0$16 = ["modalContent"];
var _c1$s = ["modalContainer"];
var _c2$e = ["*", [["po-modal-footer"]]];
var _c3$a = ["*", "po-modal-footer"];
function PoModalComponent_div_0_po_icon_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 16);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-icon", ctx_r1.icon);
  }
}
function PoModalComponent_div_0_po_button_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 17);
    ɵɵlistener("p-click", function PoModalComponent_div_0_po_button_12_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.close(true));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-aria-label", ctx_r1.literals.close);
  }
}
function PoModalComponent_div_0_ng_container_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1, 1);
    ɵɵelementContainerEnd();
  }
}
function PoModalComponent_div_0_ng_template_16_po_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 21);
    ɵɵlistener("p-click", function PoModalComponent_div_0_ng_template_16_po_button_2_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.secondaryAction.action());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-danger", ctx_r1.getSecondaryActionButtonDanger())("p-disabled", ctx_r1.secondaryAction.disabled)("p-label", ctx_r1.secondaryAction.label)("p-loading", ctx_r1.secondaryAction.loading);
  }
}
function PoModalComponent_div_0_ng_template_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-modal-footer")(1, "div", 18);
    ɵɵtemplate(2, PoModalComponent_div_0_ng_template_16_po_button_2_Template, 1, 4, "po-button", 19);
    ɵɵelementStart(3, "po-button", 20);
    ɵɵlistener("p-click", function PoModalComponent_div_0_ng_template_16_Template_po_button_p_click_3_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.primaryAction.action());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.secondaryAction);
    ɵɵadvance();
    ɵɵproperty("p-danger", ctx_r1.primaryAction.danger)("p-disabled", ctx_r1.primaryAction.disabled)("p-label", ctx_r1.primaryAction.label)("p-loading", ctx_r1.primaryAction.loading);
  }
}
function PoModalComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4, 0);
    ɵɵlistener("keydown.esc", function PoModalComponent_div_0_Template_div_keydown_esc_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.closeModalOnEscapeKey($event));
    });
    ɵɵelementStart(2, "div", 5);
    ɵɵlistener("mousedown", function PoModalComponent_div_0_Template_div_mousedown_2_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClickOut($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 6)(4, "div", 7)(5, "div", 8, 1)(7, "div", 9)(8, "div", 10);
    ɵɵtemplate(9, PoModalComponent_div_0_po_icon_9_Template, 1, 1, "po-icon", 11);
    ɵɵelementStart(10, "div", 12);
    ɵɵtext(11);
    ɵɵelementEnd()();
    ɵɵtemplate(12, PoModalComponent_div_0_po_button_12_Template, 1, 1, "po-button", 13);
    ɵɵelementEnd();
    ɵɵelementStart(13, "div", 14);
    ɵɵprojection(14);
    ɵɵelementEnd();
    ɵɵtemplate(15, PoModalComponent_div_0_ng_container_15_Template, 2, 0, "ng-container", 15)(16, PoModalComponent_div_0_ng_template_16_Template, 4, 5, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const defaultModalFooterTemplate_r6 = ɵɵreference(17);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(5);
    ɵɵclassMapInterpolate1("po-modal-content po-modal-", ctx_r1.size, "");
    ɵɵadvance(4);
    ɵɵproperty("ngIf", ctx_r1.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.title, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hideClose);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r1.modalFooter)("ngIfElse", defaultModalFooterTemplate_r6);
  }
}
var PoModalComponent = class _PoModalComponent extends PoModalBaseComponent {
  poActiveOverlayService;
  modalContent;
  modalContainer;
  modalFooter;
  firstElement;
  focusFunction;
  focusableElements = "input, select, textarea, button:not([disabled]), a";
  id = uuid();
  sourceElement;
  constructor(poActiveOverlayService, poLanguageService) {
    super(poLanguageService);
    this.poActiveOverlayService = poActiveOverlayService;
  }
  close(xClosed = false) {
    this.poActiveOverlayService.activeOverlay.pop();
    super.close(xClosed);
    this.removeEventListeners();
    if (this.sourceElement) {
      this.sourceElement.focus();
    }
  }
  closeModalOnEscapeKey(event) {
    if (!this.hideClose) {
      event.preventDefault();
      event.stopPropagation();
      this.close();
    }
  }
  getSecondaryActionButtonDanger() {
    return this.secondaryAction && this.secondaryAction.danger && !this.primaryAction.danger ? "true" : "false";
  }
  onClickOut(event) {
    if (this.clickOut && !this.modalContent.nativeElement.contains(event.target)) {
      this.close();
    }
  }
  open() {
    this.sourceElement = document.activeElement;
    super.open();
    this.handleFocus();
  }
  handleFocus() {
    this.poActiveOverlayService.activeOverlay.push(this.id);
    setTimeout(() => {
      if (this.modalContent) {
        this.initFocus();
        document.addEventListener("focus", this.focusFunction, true);
      }
    });
  }
  initFocus() {
    this.focusFunction = (event) => {
      const modalElement = this.modalContent.nativeElement;
      if (!modalElement.contains(event.target) && this.poActiveOverlayService.activeOverlay[this.poActiveOverlayService.activeOverlay.length - 1] === this.id) {
        event.stopPropagation();
        this.firstElement.focus();
      }
    };
    this.setFirstElement();
    if (this.hideClose) {
      this.firstElement.focus();
    } else {
      const firstFieldElement = this.modalContent.nativeElement.querySelectorAll(this.focusableElements)[1] || this.modalContent.nativeElement;
      firstFieldElement.focus();
    }
  }
  removeEventListeners() {
    document.removeEventListener("focus", this.focusFunction, true);
  }
  setFirstElement() {
    this.firstElement = this.modalContent.nativeElement.querySelector(this.focusableElements) || this.modalContent.nativeElement;
  }
  static ɵfac = function PoModalComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoModalComponent)(ɵɵdirectiveInject(PoActiveOverlayService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoModalComponent,
    selectors: [["po-modal"]],
    contentQueries: function PoModalComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PoModalFooterComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalFooter = _t.first);
      }
    },
    viewQuery: function PoModalComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$16, 5, ElementRef);
        ɵɵviewQuery(_c1$s, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalContent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalContainer = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c3$a,
    decls: 1,
    vars: 1,
    consts: [["modalContainer", ""], ["modalContent", ""], ["defaultModalFooterTemplate", ""], ["class", "po-modal", "tabindex", "0", 3, "keydown.esc", 4, "ngIf"], ["tabindex", "0", 1, "po-modal", 3, "keydown.esc"], [1, "po-modal-overlay", 3, "mousedown"], [1, "po-modal-container", "po-pb-2", "po-pt-2"], [1, "po-modal-vertical-align"], ["tabindex", "-1"], [1, "po-modal-header"], [1, "po-modal-title", "po-text-ellipsis"], [3, "p-icon", 4, "ngIf"], [1, "po-text-ellipsis"], ["p-icon", "ICON_CLOSE", "p-kind", "tertiary", 3, "p-aria-label", "p-click", 4, "ngIf"], [1, "po-modal-body"], [4, "ngIf", "ngIfElse"], [3, "p-icon"], ["p-icon", "ICON_CLOSE", "p-kind", "tertiary", 3, "p-click", "p-aria-label"], [1, "po-modal-footer-basic"], ["p-kind", "secondary", 3, "p-danger", "p-disabled", "p-label", "p-loading", "p-click", 4, "ngIf"], ["p-kind", "primary", 1, "po-button-modal-first-action", 3, "p-click", "p-danger", "p-disabled", "p-label", "p-loading"], ["p-kind", "secondary", 3, "p-click", "p-danger", "p-disabled", "p-label", "p-loading"]],
    template: function PoModalComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c2$e);
        ɵɵtemplate(0, PoModalComponent_div_0_Template, 18, 8, "div", 3);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.isHidden);
      }
    },
    dependencies: [NgIf, PoButtonComponent, PoIconComponent, PoModalFooterComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoModalComponent, [{
    type: Component,
    args: [{
      selector: "po-modal",
      standalone: false,
      template: '<div #modalContainer *ngIf="!isHidden" class="po-modal" tabindex="0" (keydown.esc)="closeModalOnEscapeKey($event)">\n  <div class="po-modal-overlay" (mousedown)="onClickOut($event)"></div>\n  <div class="po-modal-container po-pb-2 po-pt-2">\n    <div class="po-modal-vertical-align">\n      <div #modalContent class="po-modal-content po-modal-{{ size }}" tabindex="-1">\n        <div class="po-modal-header">\n          <div class="po-modal-title po-text-ellipsis">\n            <po-icon *ngIf="icon" [p-icon]="icon"></po-icon>\n            <div class="po-text-ellipsis">\n              {{ title }}\n            </div>\n          </div>\n          <po-button\n            *ngIf="!hideClose"\n            [p-aria-label]="literals.close"\n            p-icon="ICON_CLOSE"\n            (p-click)="close(true)"\n            p-kind="tertiary"\n          >\n          </po-button>\n        </div>\n\n        <div class="po-modal-body">\n          <ng-content></ng-content>\n        </div>\n\n        <ng-container *ngIf="modalFooter; else defaultModalFooterTemplate">\n          <ng-content select="po-modal-footer"></ng-content>\n        </ng-container>\n\n        <ng-template #defaultModalFooterTemplate>\n          <po-modal-footer>\n            <div class="po-modal-footer-basic">\n              <po-button\n                *ngIf="secondaryAction"\n                [p-danger]="getSecondaryActionButtonDanger()"\n                [p-disabled]="secondaryAction.disabled"\n                [p-label]="secondaryAction.label"\n                [p-loading]="secondaryAction.loading"\n                p-kind="secondary"\n                (p-click)="secondaryAction.action()"\n              >\n              </po-button>\n\n              <po-button\n                class="po-button-modal-first-action"\n                [p-danger]="primaryAction.danger"\n                [p-disabled]="primaryAction.disabled"\n                [p-label]="primaryAction.label"\n                [p-loading]="primaryAction.loading"\n                p-kind="primary"\n                (p-click)="primaryAction.action()"\n              >\n              </po-button>\n            </div>\n          </po-modal-footer>\n        </ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n'
    }]
  }], () => [{
    type: PoActiveOverlayService
  }, {
    type: PoLanguageService
  }], {
    modalContent: [{
      type: ViewChild,
      args: ["modalContent", {
        read: ElementRef
      }]
    }],
    modalContainer: [{
      type: ViewChild,
      args: ["modalContainer", {
        read: ElementRef
      }]
    }],
    modalFooter: [{
      type: ContentChild,
      args: [PoModalFooterComponent]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoModalComponent, {
    className: "PoModalComponent",
    filePath: "lib/components/po-modal/po-modal.component.ts",
    lineNumber: 36
  });
})();
var PoModalModule = class _PoModalModule {
  static ɵfac = function PoModalModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoModalModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoModalModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoButtonModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoModalModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoButtonModule, PoIconModule],
      declarations: [PoModalComponent, PoModalFooterComponent],
      exports: [PoModalComponent, PoModalFooterComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoModalModule, {
    declarations: [PoModalComponent, PoModalFooterComponent],
    imports: [CommonModule, PoButtonModule, PoIconModule],
    exports: [PoModalComponent, PoModalFooterComponent]
  });
})();
function PoProgressBarComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵelement(1, "div", 3)(2, "div", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-valuenow", ctx_r0.value);
    ɵɵadvance(2);
    ɵɵstyleProp("left", "-" + (100 - ctx_r0.value) + "%");
  }
}
function PoProgressBarComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵelement(1, "div", 6);
    ɵɵelementEnd();
  }
}
var PoProgressBarComponent = class _PoProgressBarComponent {
  indeterminate;
  value;
  get valueScale() {
    return `${this.value / 100}`;
  }
  static ɵfac = function PoProgressBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoProgressBarComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoProgressBarComponent,
    selectors: [["po-progress-bar"]],
    inputs: {
      indeterminate: [0, "p-indeterminate", "indeterminate"],
      value: [0, "p-value", "value"]
    },
    standalone: false,
    decls: 2,
    vars: 2,
    consts: [["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", "aria-live", "polite", "class", "po-progress-bar-default", 4, "ngIf"], ["class", "po-progress-bar-indeterminate-track", 4, "ngIf"], ["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", "aria-live", "polite", 1, "po-progress-bar-default"], [1, "po-progress-bar-element", "po-progress-bar-primary"], [1, "po-progress-bar-element", "po-progress-bar-secondary"], [1, "po-progress-bar-indeterminate-track"], [1, "po-progress-bar-indeterminate-track-bar"]],
    template: function PoProgressBarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoProgressBarComponent_div_0_Template, 3, 3, "div", 0)(1, PoProgressBarComponent_div_1_Template, 2, 0, "div", 1);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.indeterminate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.indeterminate);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoProgressBarComponent, [{
    type: Component,
    args: [{
      selector: "po-progress-bar",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<div
  *ngIf="!indeterminate"
  role="progressbar"
  [attr.aria-valuenow]="value"
  aria-valuemin="0"
  aria-valuemax="100"
  aria-live="polite"
  class="po-progress-bar-default"
>
  <div class="po-progress-bar-element po-progress-bar-primary"></div>
  <div class="po-progress-bar-element po-progress-bar-secondary" [style.left]="'-' + (100 - value) + '%'"></div>
</div>

<div *ngIf="indeterminate" class="po-progress-bar-indeterminate-track">
  <div class="po-progress-bar-indeterminate-track-bar"></div>
</div>
`
    }]
  }], null, {
    indeterminate: [{
      type: Input,
      args: ["p-indeterminate"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoProgressBarComponent, {
    className: "PoProgressBarComponent",
    filePath: "lib/components/po-progress/po-progress-bar/po-progress-bar.component.ts",
    lineNumber: 9
  });
})();
var PoProgressStatus;
(function(PoProgressStatus2) {
  PoProgressStatus2["Default"] = "default";
  PoProgressStatus2["Error"] = "error";
  PoProgressStatus2["Success"] = "success";
})(PoProgressStatus || (PoProgressStatus = {}));
var poProgressLiterals = {
  en: {
    cancel: "Cancel",
    retry: "Retry"
  },
  es: {
    cancel: "Cancelar",
    retry: "Procesar de nuevo"
  },
  pt: {
    cancel: "Cancelar",
    retry: "Tentar Novamente"
  },
  ru: {
    cancel: "Отмена",
    retry: "Повторить попытку"
  }
};
var PoProgressSize;
(function(PoProgressSize2) {
  PoProgressSize2["medium"] = "medium";
  PoProgressSize2["large"] = "large";
})(PoProgressSize || (PoProgressSize = {}));
var poProgressMaxValue = 100;
var poProgressMinValue = 0;
var PoProgressBaseComponent = class _PoProgressBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Desabilita botão de cancelamento na parte inferior da barra de progresso.
   *
   * > Se nenhuma função for passada para o evento `(p-cancel)` ou a barra de progresso estiver com o status `PoProgressStatus.Success`,
   * o ícone de cancelamento não será exibido.
   *
   * @default `false`
   */
  disabledCancel = false;
  /**
   * @optional
   *
   * @description
   *
   * Informação adicional que aparecerá abaixo da barra de progresso ao lado direito.
   */
  info;
  /**
   * @optional
   *
   * @description
   *
   * Ícone que aparecerá ao lado do texto da propriedade `p-info`.
   *
   * Exemplo: `an an-check`.
   */
  infoIcon;
  /**
   * @optional
   *
   * @description
   *
   * Status da barra de progresso que indicará visualmente ao usuário
   * o andamento, por exemplo, se a mesma foi concluída com sucesso.
   *
   * @default `PoProgressStatus.Default`
   */
  status = PoProgressStatus.Default;
  /**
   * @optional
   *
   * @description
   *
   * Texto principal que aparecerá abaixo da barra de progresso no lado esquerdo.
   */
  text;
  /**
   * @optional
   *
   * @description
   *
   * Permite definir uma ação personalizada no componente `po-progress`, exibindo um botão no canto inferior direito
   * da barra de progresso. A ação deve implementar a interface **PoProgressAction**, possibilitando configurar:
   *
   * - **`label`**: Texto exibido no botão (opcional).
   * - **`icon`**: Ícone exibido no botão (opcional).
   * - **`type`**: Tipo do botão (`default` ou `danger`) para indicar a intenção da ação (opcional).
   * - **`disabled`**: Indica se o botão deve estar desabilitado (opcional).
   * - **`visible`**: Determina se o botão será exibido. Pode ser um valor booleano ou uma função que retorna um booleano (opcional).
   *
   * @example
   * **Exemplo de uso:**
   * ```html
   * <po-progress
   *  [p-value]="50"
   *  [p-custom-action]="customAction"
   *  (p-custom-action-click)="onCustomActionClick()"
   * ></po-progress>
   * ```
   *
   * ```typescript
   * customAction: PoProgressAction = {
   *   label: 'Baixar',
   *   icon: 'an an-download',
   *   type: 'default',
   *   visible: () => true
   * };
   *
   * onCustomActionClick() {
   *   console.log('Custom action triggered!');
   * }
   * ```
   *
   * **Cenários comuns:**
   * 1. **Download de Arquivos**: Exibir um botão para realizar o download de um arquivo associado à barra de progresso.
   * 2. **Cancelamento Personalizado**: Adicionar uma ação para interromper ou reverter uma operação em andamento.
   */
  customAction;
  /**
   * @optional
   *
   * @description
   *
   * Evento emitido quando o botão definido em `p-custom-action` é clicado. Este evento retorna informações
   * relacionadas à barra de progresso ou ao arquivo/processo associado, permitindo executar ações específicas.
   *
   * @example
   * **Exemplo de uso:**
   *
   * ```html
   * <po-progress
   *  [p-value]="50"
   *  [p-custom-action]="customAction"
   *  (p-custom-action-click)="onCustomActionClick()"
   * ></po-progress>
   * ```
   *
   * ```typescript
   * customAction: PoProgressAction = {
   *   label: 'Cancelar',
   *   icon: 'an an-x',
   *   type: 'danger',
   *   visible: true
   * };
   *
   * onCustomActionClick() {
   *   console.log('Custom action triggered!');
   * }
   * ```
   *
   * **Cenários comuns:**
   * 1. **Botão de Download**: Disparar o download do arquivo associado à barra de progresso.
   * 2. **Ação Condicional**: Realizar uma validação ou chamada de API antes de prosseguir com a ação.
   */
  customActionClick = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento que será disparado ao clicar no ícone de cancelamento ("x") na parte inferior da barra de progresso.
   *
   * Ao ser disparado, a função receberá como parâmetro o status atual da barra de progresso.
   *
   * > Se nenhuma função for passada para o evento ou a barra de progresso estiver com o status `PoProgressStatus.Success`,
   * o ícone de cancelamento não será exibido.
   */
  cancel = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento que será disparado ao clicar no ícone de tentar novamente na parte inferior da barra de progresso.
   *
   * > o ícone será exibido apenas se informar uma função neste evento e o status da barra de progresso for
   * `PoProgressStatus.Error`.
   */
  retry = new EventEmitter();
  _indeterminate;
  _value = 0;
  _size = "large";
  /**
   * @optional
   *
   * @description
   *
   * Habilita o modo indeterminado na barra de progresso, que mostra uma animação fixa sem um valor estabelecido.
   *
   * Esta opção pode ser utilizada quando não souber quanto tempo levará para que um processo seja concluído.
   *
   * > Caso esta propriedade e a `p-value` seja habilitada, a propriedade `p-value` será ignorada.
   *
   * @default `false`
   */
  set indeterminate(indeterminate) {
    this._indeterminate = convertToBoolean(indeterminate);
  }
  get indeterminate() {
    return this._indeterminate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor que representará o progresso.
   *
   * > Os valores aceitos são números inteiros de `0` à `100`.
   *
   * @default `0`
   */
  set value(value) {
    const integerValue = convertToInt(value, poProgressMinValue);
    const isProgressRangeValue = this.isProgressRangeValue(integerValue);
    this._value = isProgressRangeValue ? integerValue : poProgressMinValue;
  }
  get value() {
    return this._value;
  }
  /**
   * @optional
   *
   * @description
   *
   * Definição do tamanho da altura da barra de progresso.
   *
   * Valores válidos:
   *  - `medium`: tamanho médio
   *  - `large`: tamanho grande
   *
   * @default `large`
   */
  set size(value) {
    this._size = PoProgressSize[value] ? PoProgressSize[value] : PoProgressSize.large;
  }
  get size() {
    return this._size;
  }
  /**
   * @optional
   *
   * @description
   *
   * Ativa a exibição da porcentagem atual da barra de progresso.
   *
   * @default `false`
   */
  showPercentage = false;
  isProgressRangeValue(value) {
    return value >= poProgressMinValue && value <= poProgressMaxValue;
  }
  static ɵfac = function PoProgressBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoProgressBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoProgressBaseComponent,
    inputs: {
      disabledCancel: [2, "p-disabled-cancel", "disabledCancel", convertToBoolean],
      info: [0, "p-info", "info"],
      infoIcon: [0, "p-info-icon", "infoIcon"],
      status: [0, "p-status", "status"],
      text: [0, "p-text", "text"],
      customAction: [0, "p-custom-action", "customAction"],
      indeterminate: [0, "p-indeterminate", "indeterminate"],
      value: [0, "p-value", "value"],
      size: [0, "p-size", "size"],
      showPercentage: [2, "p-show-percentage", "showPercentage", convertToBoolean]
    },
    outputs: {
      customActionClick: "p-custom-action-click",
      cancel: "p-cancel",
      retry: "p-retry"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoProgressBaseComponent, [{
    type: Directive
  }], null, {
    disabledCancel: [{
      type: Input,
      args: [{
        alias: "p-disabled-cancel",
        transform: convertToBoolean
      }]
    }],
    info: [{
      type: Input,
      args: ["p-info"]
    }],
    infoIcon: [{
      type: Input,
      args: ["p-info-icon"]
    }],
    status: [{
      type: Input,
      args: ["p-status"]
    }],
    text: [{
      type: Input,
      args: ["p-text"]
    }],
    customAction: [{
      type: Input,
      args: ["p-custom-action"]
    }],
    customActionClick: [{
      type: Output,
      args: ["p-custom-action-click"]
    }],
    cancel: [{
      type: Output,
      args: ["p-cancel"]
    }],
    retry: [{
      type: Output,
      args: ["p-retry"]
    }],
    indeterminate: [{
      type: Input,
      args: ["p-indeterminate"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }],
    showPercentage: [{
      type: Input,
      args: [{
        alias: "p-show-percentage",
        transform: convertToBoolean
      }]
    }]
  });
})();
function PoProgressComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵelement(1, "po-label", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-label", ctx_r0.text);
  }
}
function PoProgressComponent_po_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 15);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-progress-info-icon-error", ctx_r0.status === "error");
    ɵɵproperty("p-icon", ctx_r0.infoIcon);
  }
}
function PoProgressComponent_po_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 16);
  }
}
function PoProgressComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-progress-info-text-error", ctx_r0.status === "error");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.info);
  }
}
function PoProgressComponent_span_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.value, "%");
  }
}
function PoProgressComponent_po_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 18);
    ɵɵlistener("p-click", function PoProgressComponent_po_button_10_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.emitRetry());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-aria-label", ctx_r0.literals.retry);
  }
}
function PoProgressComponent_po_button_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 19);
    ɵɵlistener("p-click", function PoProgressComponent_po_button_11_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.callAction());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-danger", ctx_r0.customAction.type === "danger")("p-disabled", ctx_r0.actionIsDisabled(ctx_r0.customAction))("p-label", ctx_r0.customAction.label || "")("p-icon", ctx_r0.customAction.icon);
  }
}
function PoProgressComponent_po_button_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 20);
    ɵɵlistener("p-click", function PoProgressComponent_po_button_12_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.emitCancellation());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r0.disabledCancel)("p-aria-label", ctx_r0.literals.cancel)("p-danger", true);
  }
}
var PoProgressComponent = class _PoProgressComponent extends PoProgressBaseComponent {
  language;
  literals;
  get isAllowCancel() {
    return !!this.cancel.observers.length && this.status !== PoProgressStatus.Success;
  }
  get isAllowInfoError() {
    return !!(!this.infoIcon && this.info && this.status === PoProgressStatus.Error);
  }
  get isAllowRetry() {
    return !!this.retry.observers.length && this.status === PoProgressStatus.Error;
  }
  get statusClass() {
    if (this.status === PoProgressStatus.Success) {
      return "po-progress-success";
    }
    if (this.status === PoProgressStatus.Error) {
      return "po-progress-error";
    }
    return "po-progress-default";
  }
  poLanguageService = inject(PoLanguageService);
  router = inject(Router);
  ngOnInit() {
    this.language = this.poLanguageService.getShortLanguage();
    this.literals = __spreadValues({}, poProgressLiterals[this.language]);
  }
  emitCancellation() {
    this.cancel.emit(this.status);
  }
  emitRetry() {
    this.retry.emit();
  }
  actionIsDisabled(action) {
    return isTypeof(action.disabled, "function") ? action.disabled(action) : action.disabled;
  }
  callAction() {
    this.customActionClick.emit();
  }
  isActionVisible(action) {
    if (action && (action.label || action.icon)) {
      return action.visible !== void 0 ? isTypeof(action.visible, "function") ? action.visible() : !!action.visible : true;
    }
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoProgressComponent_BaseFactory;
    return function PoProgressComponent_Factory(__ngFactoryType__) {
      return (ɵPoProgressComponent_BaseFactory || (ɵPoProgressComponent_BaseFactory = ɵɵgetInheritedFactory(_PoProgressComponent)))(__ngFactoryType__ || _PoProgressComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoProgressComponent,
    selectors: [["po-progress"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 13,
    vars: 14,
    consts: [[1, "po-progress", 3, "ngClass"], ["class", "po-progress-description", 4, "ngIf"], [3, "p-indeterminate", "p-value"], [1, "po-progress-info"], [1, "po-progress-info-left"], [3, "p-icon", "po-progress-info-icon-error", 4, "ngIf"], ["p-icon", "ICON_EXCLAMATION", "class", "po-progress-info-icon-error", 4, "ngIf"], ["class", "po-progress-info-text", 3, "po-progress-info-text-error", 4, "ngIf"], [1, "po-progress-info-right"], [4, "ngIf"], ["p-icon", "ICON_REFRESH", "p-kind", "tertiary", 3, "p-aria-label", "p-click", 4, "ngIf"], ["class", "po-progress-custom-button", 3, "p-danger", "p-disabled", "p-label", "p-icon", "p-click", 4, "ngIf"], ["p-icon", "ICON_CLOSE", "p-kind", "secondary", 3, "p-disabled", "p-aria-label", "p-danger", "p-click", 4, "ngIf"], [1, "po-progress-description"], [3, "p-label"], [3, "p-icon"], ["p-icon", "ICON_EXCLAMATION", 1, "po-progress-info-icon-error"], [1, "po-progress-info-text"], ["p-icon", "ICON_REFRESH", "p-kind", "tertiary", 3, "p-click", "p-aria-label"], [1, "po-progress-custom-button", 3, "p-click", "p-danger", "p-disabled", "p-label", "p-icon"], ["p-icon", "ICON_CLOSE", "p-kind", "secondary", 3, "p-click", "p-disabled", "p-aria-label", "p-danger"]],
    template: function PoProgressComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoProgressComponent_div_1_Template, 2, 1, "div", 1);
        ɵɵelement(2, "po-progress-bar", 2);
        ɵɵelementStart(3, "div", 3)(4, "div", 4);
        ɵɵtemplate(5, PoProgressComponent_po_icon_5_Template, 1, 3, "po-icon", 5)(6, PoProgressComponent_po_icon_6_Template, 1, 0, "po-icon", 6)(7, PoProgressComponent_span_7_Template, 2, 3, "span", 7);
        ɵɵelementEnd();
        ɵɵelementStart(8, "div", 8);
        ɵɵtemplate(9, PoProgressComponent_span_9_Template, 2, 1, "span", 9)(10, PoProgressComponent_po_button_10_Template, 1, 1, "po-button", 10)(11, PoProgressComponent_po_button_11_Template, 1, 4, "po-button", 11)(12, PoProgressComponent_po_button_12_Template, 1, 3, "po-button", 12);
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵproperty("ngClass", ctx.statusClass);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.text);
        ɵɵadvance();
        ɵɵclassMapInterpolate1("po-progress-bar po-progress-bar-", ctx.size, "");
        ɵɵproperty("p-indeterminate", ctx.indeterminate)("p-value", ctx.value);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.infoIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isAllowInfoError);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.info);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showPercentage && !ctx.indeterminate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isAllowRetry);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isActionVisible(ctx.customAction));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isAllowCancel);
      }
    },
    dependencies: [NgClass, NgIf, PoButtonComponent, PoIconComponent, PoLabelComponent, PoProgressBarComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoProgressComponent, [{
    type: Component,
    args: [{
      selector: "po-progress",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<div class="po-progress" [ngClass]="statusClass">
  <div *ngIf="text" class="po-progress-description">
    <po-label [p-label]="text"></po-label>
  </div>

  <po-progress-bar
    class="po-progress-bar po-progress-bar-{{ size }}"
    [p-indeterminate]="indeterminate"
    [p-value]="value"
  >
  </po-progress-bar>

  <div class="po-progress-info">
    <div class="po-progress-info-left">
      <po-icon *ngIf="infoIcon" [p-icon]="infoIcon" [class.po-progress-info-icon-error]="status === 'error'"></po-icon>
      <po-icon *ngIf="isAllowInfoError" p-icon="ICON_EXCLAMATION" class="po-progress-info-icon-error"></po-icon>
      <span *ngIf="info" class="po-progress-info-text" [class.po-progress-info-text-error]="status === 'error'">{{
        info
      }}</span>
    </div>
    <div class="po-progress-info-right">
      <span *ngIf="showPercentage && !indeterminate">{{ value }}%</span>

      <po-button
        *ngIf="isAllowRetry"
        p-icon="ICON_REFRESH"
        (p-click)="emitRetry()"
        [p-aria-label]="literals.retry"
        p-kind="tertiary"
      ></po-button>

      <po-button
        *ngIf="isActionVisible(customAction)"
        class="po-progress-custom-button"
        [p-danger]="customAction.type === 'danger'"
        [p-disabled]="actionIsDisabled(customAction)"
        [p-label]="customAction.label || ''"
        [p-icon]="customAction.icon"
        (p-click)="callAction()"
      >
      </po-button>

      <po-button
        *ngIf="isAllowCancel"
        p-icon="ICON_CLOSE"
        (p-click)="emitCancellation()"
        p-kind="secondary"
        [p-disabled]="disabledCancel"
        [p-aria-label]="literals.cancel"
        [p-danger]="true"
      ></po-button>
    </div>
  </div>
</div>
`
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoProgressComponent, {
    className: "PoProgressComponent",
    filePath: "lib/components/po-progress/po-progress.component.ts",
    lineNumber: 35
  });
})();
var PoProgressModule = class _PoProgressModule {
  static ɵfac = function PoProgressModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoProgressModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoProgressModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoButtonModule, PoIconModule, PoLabelModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoProgressModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoButtonModule, PoIconModule, PoLabelModule],
      exports: [PoProgressComponent],
      declarations: [PoProgressBarComponent, PoProgressComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoProgressModule, {
    declarations: [PoProgressBarComponent, PoProgressComponent],
    imports: [CommonModule, PoButtonModule, PoIconModule, PoLabelModule],
    exports: [PoProgressComponent]
  });
})();
var PoActiveOverlayModule = class _PoActiveOverlayModule {
  static ɵfac = function PoActiveOverlayModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoActiveOverlayModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoActiveOverlayModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoActiveOverlayService]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoActiveOverlayModule, [{
    type: NgModule,
    args: [{
      providers: [PoActiveOverlayService],
      bootstrap: []
    }]
  }], null, null);
})();
var PoColorPaletteService = class _PoColorPaletteService {
  getColor(value) {
    return Object.values(PoColorPaletteEnum).includes(value.color) ? value.color : this.getColorFromType(value.type || value.color);
  }
  getColorFromType(type) {
    switch (type) {
      case "danger":
        return PoColorPaletteEnum.Color07;
      case "success":
        return PoColorPaletteEnum.Color11;
      case "warning":
        return PoColorPaletteEnum.Color08;
      default:
        return PoColorPaletteEnum.Color01;
    }
  }
  static ɵfac = function PoColorPaletteService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoColorPaletteService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoColorPaletteService,
    factory: _PoColorPaletteService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoColorPaletteService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var PoColorPaletteModule = class _PoColorPaletteModule {
  static ɵfac = function PoColorPaletteModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoColorPaletteModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoColorPaletteModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoColorPaletteService]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoColorPaletteModule, [{
    type: NgModule,
    args: [{
      providers: [PoColorPaletteService],
      bootstrap: []
    }]
  }], null, null);
})();
var PoComponentInjectorService = class _PoComponentInjectorService {
  componentResolver;
  applicationRef;
  injector;
  constructor(componentResolver, applicationRef, injector) {
    this.componentResolver = componentResolver;
    this.applicationRef = applicationRef;
    this.injector = injector;
  }
  // Cria um dinamicamente no ApplicationRef
  createComponentInApplication(component) {
    const componentRef = this.componentResolver.resolveComponentFactory(component).create(this.injector);
    this.applicationRef.attachView(componentRef.hostView);
    const domElem = componentRef.hostView.rootNodes[0];
    document.body.appendChild(domElem);
    return componentRef;
  }
  // Destrói o componente e remove do ApplicationRef
  destroyComponentInApplication(componentRef) {
    this.applicationRef.detachView(componentRef.hostView);
    componentRef.destroy();
  }
  static ɵfac = function PoComponentInjectorService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoComponentInjectorService)(ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(ApplicationRef), ɵɵinject(Injector));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoComponentInjectorService,
    factory: _PoComponentInjectorService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComponentInjectorService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ComponentFactoryResolver$1
  }, {
    type: ApplicationRef
  }, {
    type: Injector
  }], null);
})();
var PoComponentInjectorModule = class _PoComponentInjectorModule {
  static ɵfac = function PoComponentInjectorModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoComponentInjectorModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoComponentInjectorModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoComponentInjectorService]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComponentInjectorModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [],
      exports: [],
      providers: [PoComponentInjectorService],
      bootstrap: []
    }]
  }], null, null);
})();
var PoControlPositionModule = class _PoControlPositionModule {
  static ɵfac = function PoControlPositionModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoControlPositionModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoControlPositionModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoControlPositionService]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoControlPositionModule, [{
    type: NgModule,
    args: [{
      providers: [PoControlPositionService]
    }]
  }], null, null);
})();
var PoDialogType;
(function(PoDialogType2) {
  PoDialogType2[PoDialogType2["Alert"] = 0] = "Alert";
  PoDialogType2[PoDialogType2["Confirm"] = 1] = "Confirm";
})(PoDialogType || (PoDialogType = {}));
var poDialogAlertLiteralsDefault = {
  en: {
    ok: "Ok"
  },
  es: {
    ok: "Ok"
  },
  pt: {
    ok: "Ok"
  },
  ru: {
    ok: "Ок"
  }
};
var poDialogConfirmLiteralsDefault = {
  en: {
    cancel: "Cancel",
    confirm: "Confirm"
  },
  es: {
    cancel: "Cancelar",
    confirm: "Confirmar"
  },
  pt: {
    cancel: "Cancelar",
    confirm: "Confirmar"
  },
  ru: {
    cancel: "отменить",
    confirm: "подтвердить"
  }
};
var PoDialogComponent = class _PoDialogComponent {
  // ViewChild para o uso do po-modal.component
  poModal;
  // Title do poModal
  title;
  // Message do poModal
  message;
  // Objeto primary do poModal
  primaryAction = {
    label: "ok",
    action: () => {
    }
  };
  // Objeto secondary do poModal
  secondaryAction;
  // Callback executado ao fechar o poModal
  closeAction;
  // Literais usadas nos botão de alerta do poModal
  literalsAlert;
  // Literais usadas nos botões de confirmação do poModal
  literalsConfirm;
  // Atributo para armazenar a referencia do componente criado via serviço.
  componentRef;
  closeSubscription;
  language;
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  ngOnDestroy() {
    this.closeSubscription.unsubscribe();
  }
  ngOnInit() {
    this.closeSubscription = this.poModal.onXClosed.subscribe((close) => this.close(true));
  }
  // Fecha o poModal
  close(xClosed = false) {
    if (xClosed && this.closeAction) {
      this.closeAction();
    }
    this.poModal.close();
    this.destroy();
  }
  destroy() {
    if (this.componentRef) {
      this.componentRef.destroy();
    }
  }
  // Insere os valores recebidos de this.open para o poModal
  configDialog(primaryLabel, primaryAction, secondaryLabel, secondaryAction, closeAction) {
    this.primaryAction = {
      label: primaryLabel,
      action: () => {
        if (primaryAction) {
          primaryAction();
        }
        this.close();
      }
    };
    if (secondaryLabel) {
      this.secondaryAction = {
        label: secondaryLabel,
        action: () => {
          if (secondaryAction) {
            secondaryAction();
          }
          this.close();
        }
      };
    }
    this.closeAction = closeAction;
  }
  // Insere os valores recebidos de po-dialog.service de acordo com o tipo de diálago solicitado
  open(dialogOptions, dialogType, componentRef) {
    this.title = dialogOptions.title;
    this.message = dialogOptions.message;
    this.componentRef = componentRef;
    this.setDialogLiterals(dialogOptions, dialogType);
    switch (dialogType) {
      case PoDialogType.Confirm: {
        this.configDialog(this.literalsConfirm.confirm, dialogOptions.confirm, this.literalsConfirm.cancel, dialogOptions.cancel, dialogOptions.close);
        break;
      }
      case PoDialogType.Alert: {
        this.configDialog(this.literalsAlert.ok, dialogOptions.ok);
        break;
      }
    }
    this.poModal.open();
  }
  setDialogLiterals(dialogOptions, dialogType) {
    const alertLiterals = poDialogAlertLiteralsDefault;
    const confirmLiterals = poDialogConfirmLiteralsDefault;
    const literals = dialogOptions.literals;
    if (dialogType === PoDialogType.Alert) {
      this.literalsAlert = __spreadValues(__spreadValues(__spreadValues({}, alertLiterals[poLocaleDefault]), alertLiterals[this.language]), literals);
    } else {
      this.literalsConfirm = __spreadValues(__spreadValues(__spreadValues({}, confirmLiterals[poLocaleDefault]), confirmLiterals[this.language]), literals);
    }
  }
  static ɵfac = function PoDialogComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDialogComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDialogComponent,
    selectors: [["ng-component"]],
    viewQuery: function PoDialogComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoModalComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poModal = _t.first);
      }
    },
    standalone: false,
    decls: 2,
    vars: 4,
    consts: [[3, "p-title", "p-primary-action", "p-secondary-action"], [3, "innerHtml"]],
    template: function PoDialogComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "po-modal", 0);
        ɵɵelement(1, "div", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-title", ctx.title)("p-primary-action", ctx.primaryAction)("p-secondary-action", ctx.secondaryAction);
        ɵɵadvance();
        ɵɵproperty("innerHtml", ctx.message, ɵɵsanitizeHtml);
      }
    },
    dependencies: [PoModalComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDialogComponent, [{
    type: Component,
    args: [{
      standalone: false,
      template: '<po-modal [p-title]="title" [p-primary-action]="primaryAction" [p-secondary-action]="secondaryAction">\n  <div [innerHtml]="message"></div>\n</po-modal>\n'
    }]
  }], () => [{
    type: PoLanguageService
  }], {
    poModal: [{
      type: ViewChild,
      args: [PoModalComponent, {
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDialogComponent, {
    className: "PoDialogComponent",
    filePath: "lib/services/po-dialog/po-dialog.component.ts",
    lineNumber: 42
  });
})();
var PoDialogBaseService = class {
  /** Exibe um diálogo de confirmação, é possível definir ações para as opções de confirmação e cancelamento. */
  confirm(confirmOptions) {
    this.openDialog(PoDialogType.Confirm, confirmOptions);
  }
  /** Exibe um diálogo de alerta. */
  alert(alertOptions) {
    this.openDialog(PoDialogType.Alert, alertOptions);
  }
};
var PoDialogService = class _PoDialogService extends PoDialogBaseService {
  poComponentInjector;
  constructor(poComponentInjector) {
    super();
    this.poComponentInjector = poComponentInjector;
  }
  openDialog(dialogType, dialogOptions) {
    const componentRef = this.poComponentInjector.createComponentInApplication(PoDialogComponent);
    componentRef.changeDetectorRef.detectChanges();
    componentRef.instance.open(dialogOptions, dialogType, componentRef);
  }
  static ɵfac = function PoDialogService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDialogService)(ɵɵinject(PoComponentInjectorService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoDialogService,
    factory: _PoDialogService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDialogService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PoComponentInjectorService
  }], null);
})();
var PoDialogModule = class _PoDialogModule {
  static ɵfac = function PoDialogModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDialogModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoDialogModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoDialogService],
    imports: [PoModalModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDialogModule, [{
    type: NgModule,
    args: [{
      declarations: [PoDialogComponent],
      imports: [PoModalModule],
      exports: [PoDialogComponent],
      providers: [PoDialogService]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDialogModule, {
    declarations: [PoDialogComponent],
    imports: [PoModalModule],
    exports: [PoDialogComponent]
  });
})();
var PoI18nBasePipe = class {
  transform(value, args) {
    if (!value) {
      return "";
    }
    if (!(args instanceof Array)) {
      args = [args];
    }
    for (const arg of args) {
      value = value.replace(/(\{\w*\})+/, arg);
    }
    return value;
  }
};
var PoI18nPipe = class _PoI18nPipe extends PoI18nBasePipe {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoI18nPipe_BaseFactory;
    return function PoI18nPipe_Factory(__ngFactoryType__) {
      return (ɵPoI18nPipe_BaseFactory || (ɵPoI18nPipe_BaseFactory = ɵɵgetInheritedFactory(_PoI18nPipe)))(__ngFactoryType__ || _PoI18nPipe);
    };
  })();
  static ɵpipe = ɵɵdefinePipe({
    name: "poI18n",
    type: _PoI18nPipe,
    pure: true,
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoI18nPipe, [{
    type: Pipe,
    args: [{
      name: "poI18n",
      standalone: false
    }]
  }], null, null);
})();
var PoMediaQueryService = class _PoMediaQueryService {
  renderer;
  constructor(rendererFactory) {
    this.renderer = rendererFactory.createRenderer(null, null);
  }
  /**
   * Método que replica as regras baseando-se pelos tokens de media query dentro das folhas de estilo do documento, permitindo a modificação dinâmica
   * dos valores CSS correspondentes aos tokens fornecidos.
   *
   * @param {PoMediaQueryTokens} tokens Objeto contendo os tokens que devem ser atualizados. Cada propriedade corresponde a uma variável CSS que será
   * dinamicamente modificada dentro das regras de media query.
   *
   */
  updateTokens(tokens) {
    const styleSheets = document.styleSheets;
    const styleElement = this.createStyleElement();
    const dynamicSheet = styleElement.sheet;
    Array.from(styleSheets).forEach((sheet) => {
      if (sheet) {
        this.processStyleSheet(sheet, tokens, dynamicSheet);
      }
    });
  }
  createStyleElement() {
    const styleElement = this.renderer.createElement("style");
    this.renderer.appendChild(document.head, styleElement);
    return styleElement;
  }
  processStyleSheet(sheet, tokens, dynamicSheet) {
    const rules = sheet.cssRules;
    if (!rules) {
      console.warn("No rules found in stylesheet");
      return;
    }
    Array.from(rules).forEach((rule) => {
      if ("media" in rule) {
        this.updateTokensMediaRule(rule, tokens, dynamicSheet);
      }
    });
  }
  updateTokensMediaRule(mediaRule, tokens, dynamicSheet) {
    if (!dynamicSheet) {
      console.error("dynamicSheet is null or undefined. Cannot insert rule.");
      return;
    }
    const variablesInMediaRule = mediaRule.media.mediaText.match(/var\(--[^)]+\)/g) || [];
    if (variablesInMediaRule.length === 0) return;
    let updatedMediaQuery = "";
    variablesInMediaRule.forEach((variable) => {
      Object.entries(tokens).forEach(([token, breakpoints]) => {
        if (breakpoints) {
          Object.entries(breakpoints).forEach(([breakpointVariable, value]) => {
            if (typeof value === "string") {
              const tokenToCompare = `var(--${breakpointVariable})`;
              if (tokenToCompare === variable) {
                updatedMediaQuery = this.buildMediaQuery(token, value, updatedMediaQuery);
              }
            }
          });
        }
      });
    });
    if (updatedMediaQuery) {
      const cssRules = Array.from(mediaRule.cssRules).map((rule) => rule.cssText).join(" ");
      dynamicSheet.insertRule(`${updatedMediaQuery} { ${cssRules} }`, dynamicSheet.cssRules.length);
    }
  }
  buildMediaQuery(token, value, existingQuery) {
    switch (true) {
      case (token.includes("sm") || token.includes("pull") || token.includes("offset")):
        return `@media (max-width: ${value})`;
      case token.includes("xl"):
        return `@media (min-width: ${value})`;
      case (token.includes("md") || token.includes("lg")):
        return existingQuery ? `${existingQuery} and (max-width: ${value})` : `@media (min-width: ${value})`;
      default:
        return existingQuery;
    }
  }
  static ɵfac = function PoMediaQueryService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMediaQueryService)(ɵɵinject(RendererFactory2));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoMediaQueryService,
    factory: _PoMediaQueryService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMediaQueryService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RendererFactory2
  }], null);
})();
var PoMediaQueryModule = class _PoMediaQueryModule {
  static ɵfac = function PoMediaQueryModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMediaQueryModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoMediaQueryModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoMediaQueryService]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMediaQueryModule, [{
    type: NgModule,
    args: [{
      providers: [PoMediaQueryService],
      bootstrap: []
    }]
  }], null, null);
})();
var PoToasterMode;
(function(PoToasterMode2) {
  PoToasterMode2["Inline"] = "inline";
  PoToasterMode2["Alert"] = "alert";
})(PoToasterMode || (PoToasterMode = {}));
var PoToasterOrientation;
(function(PoToasterOrientation2) {
  PoToasterOrientation2[PoToasterOrientation2["Bottom"] = 0] = "Bottom";
  PoToasterOrientation2[PoToasterOrientation2["Top"] = 1] = "Top";
})(PoToasterOrientation || (PoToasterOrientation = {}));
var PoToasterType;
(function(PoToasterType2) {
  PoToasterType2["Error"] = "error";
  PoToasterType2["Information"] = "information";
  PoToasterType2["Success"] = "success";
  PoToasterType2["Warning"] = "warning";
})(PoToasterType || (PoToasterType = {}));
var poToasterLiterals = {
  en: {
    close: "Close"
  },
  es: {
    close: "Cerrar"
  },
  pt: {
    close: "Fechar"
  },
  ru: {
    close: "близко"
  }
};
var PoToasterBaseComponent = class _PoToasterBaseComponent {
  _isHide;
  /**
   * @optional
   *
   * @description
   *
   * Ação para a notificação.
   */
  action;
  /**
   * @optional
   *
   * @description
   *
   * Label do botão quando houver uma ação definida.
   */
  actionLabel;
  /**
   * @optional
   *
   * @description
   *
   * Mensagem a ser exibida na notificação.
   */
  message;
  /**
   * @optional
   *
   * @description
   *
   * Define se o Toaster esta invisivel.
   *
   * @default `false`
   */
  isHide = false;
  /**
   * @optional
   *
   * @description
   *
   * Evento emitido quando o valor de `isHide` é alterado.
   *
   */
  isHideChange = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Exibe botão de fechar no toaster modo inline.
   *
   * @default `true`
   */
  showClose = true;
  /**
   * @optional
   *
   * @description
   *
   * Mensagem de suporte a ser exibida na notificação.
   */
  supportMessage;
  /**
   * @optional
   *
   * @description
   *
   * Determina o tipo de notificação.
   *
   * Valores aceitos: `error`, `information`, `success` e `warning`.
   * @see PoToasterType
   *
   * @default `PoToasterType.Information`
   */
  type = PoToasterType.Information;
  // Determina o modo do Toaster
  mode = PoToasterMode.Inline;
  // Orientação da notificação, a mesma pode ser exibida na parte superior ou inferior da página.
  orientation = PoToasterOrientation.Bottom;
  // ComponentRef
  componentRef;
  // Posição para notificação aparecer na tela.
  position;
  static ɵfac = function PoToasterBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoToasterBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoToasterBaseComponent,
    inputs: {
      action: [0, "p-action", "action"],
      actionLabel: [0, "p-action-label", "actionLabel"],
      message: [0, "p-message", "message"],
      isHide: [2, "p-hide", "isHide", convertToBoolean],
      showClose: [2, "p-show-close", "showClose", convertToBoolean],
      supportMessage: [0, "p-support-message", "supportMessage"],
      type: [0, "p-type", "type"],
      mode: [0, "p-mode", "mode"]
    },
    outputs: {
      isHideChange: "p-hide-change"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToasterBaseComponent, [{
    type: Directive
  }], null, {
    action: [{
      type: Input,
      args: ["p-action"]
    }],
    actionLabel: [{
      type: Input,
      args: ["p-action-label"]
    }],
    message: [{
      type: Input,
      args: ["p-message"]
    }],
    isHide: [{
      type: Input,
      args: [{
        alias: "p-hide",
        transform: convertToBoolean
      }]
    }],
    isHideChange: [{
      type: Output,
      args: ["p-hide-change"]
    }],
    showClose: [{
      type: Input,
      args: [{
        alias: "p-show-close",
        transform: convertToBoolean
      }]
    }],
    supportMessage: [{
      type: Input,
      args: ["p-support-message"]
    }],
    type: [{
      type: Input,
      args: ["p-type"]
    }],
    mode: [{
      type: Input,
      args: ["p-mode"]
    }]
  });
})();
var _c0$15 = ["toaster"];
var _c1$r = ["buttonClose"];
function PoToasterComponent_po_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-icon", ctx_r0.getIcon());
  }
}
function PoToasterComponent_po_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-icon", ctx_r0.getIcon());
  }
}
function PoToasterComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 14);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.supportMessage);
  }
}
function PoToasterComponent_po_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 15);
    ɵɵlistener("p-click", function PoToasterComponent_po_button_10_Template_po_button_p_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.poToasterAction($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-label", ctx_r0.actionLabel);
  }
}
function PoToasterComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 16);
    ɵɵelement(1, "div", 17);
    ɵɵelementStart(2, "po-button", 18, 1);
    ɵɵlistener("p-click", function PoToasterComponent_div_11_Template_po_button_p_click_2_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.onButtonClose($event));
    });
    ɵɵelementEnd()();
  }
}
var SPACE_BETWEEN_TOASTERS = 8;
var PoToasterComponent = class _PoToasterComponent extends PoToasterBaseComponent {
  changeDetector;
  renderer;
  /* Componente toaster */
  toaster;
  buttonClose;
  alive = true;
  language;
  literals;
  /* Ícone do Toaster */
  icon;
  /* Margem do Toaster referênte à sua orientação e posição*/
  margin = 0;
  /* Observable para monitorar o Close to Toaster */
  observableOnClose = new Subject();
  /* Posição do Toaster*/
  toasterPosition = "po-toaster-bottom";
  /* Tipo do Toaster */
  toasterType;
  constructor(poLanguageService, changeDetector, renderer) {
    super();
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.language = poLanguageService.getShortLanguage();
    this.literals = __spreadValues({}, poToasterLiterals[this.language]);
  }
  ngOnDestroy() {
    this.alive = false;
  }
  ngAfterViewInit() {
    setTimeout(() => {
      this.renderer.addClass(this.toaster.nativeElement, "po-toaster-visible");
      if (this.isInline()) {
        this.configToaster(this);
      }
    });
  }
  ngOnChanges(changes) {
    if (changes.isHide && changes.isHide.previousValue !== void 0) {
      if (changes.isHide.currentValue === true) {
        this.hide();
      } else {
        this.show();
      }
      this.changeDetector.detectChanges();
    }
  }
  /* Muda a posição do Toaster na tela*/
  changePosition(position) {
    setTimeout(() => {
      this.margin = SPACE_BETWEEN_TOASTERS;
      for (let i = 0; i < position; i++) {
        this.margin += this.returnHeightToaster(i) + SPACE_BETWEEN_TOASTERS;
      }
      if (this.orientation === PoToasterOrientation.Top) {
        this.toaster.nativeElement.style.top = this.margin + "px";
      } else {
        this.toaster.nativeElement.style.bottom = this.margin + "px";
      }
    });
  }
  /* Fecha o componente Toaster */
  close() {
    if (this.isAlert()) {
      this.observableOnClose.next(true);
    } else {
      this.hide();
    }
  }
  setFadeOut() {
    this.renderer.removeClass(this.toaster.nativeElement, "po-toaster-visible");
    this.renderer.addClass(this.toaster.nativeElement, "po-toaster-invisible");
  }
  setFadeIn() {
    this.renderer.removeClass(this.toaster.nativeElement, "po-toaster-invisible");
    this.renderer.addClass(this.toaster.nativeElement, "po-toaster-visible");
  }
  /* Configura o Toaster com os atributos passados para ele */
  configToaster(poToaster) {
    this.type = poToaster.type;
    this.message = poToaster.message;
    this.orientation = poToaster.orientation;
    this.position = poToaster.position;
    this.action = poToaster.action;
    this.actionLabel = poToaster.actionLabel;
    this.componentRef = poToaster.componentRef;
    this.mode = poToaster.mode;
    this.showClose = poToaster.showClose;
    this.supportMessage = poToaster.supportMessage;
    if (this.orientation === PoToasterOrientation.Top) {
      this.toasterPosition = "po-toaster-top";
    }
    if (!this.mode) {
      this.mode = PoToasterMode.Inline;
    }
    if (!this.type || !Object.values(PoToasterType).includes(this.type)) {
      this.type = PoToasterType.Information;
    }
    this.changePosition(this.position);
    if (this.type === PoToasterType.Error) {
      this.toaster.nativeElement.setAttribute("role", "alert");
    } else if (this.action && this.actionLabel) {
      this.toaster.nativeElement.setAttribute("role", "alertdialog");
    } else {
      this.toaster.nativeElement.setAttribute("role", "status");
    }
    this.getToasterType();
    this.changeDetector.detectChanges();
    this.buttonClose?.buttonElement.nativeElement.setAttribute("aria-label", this.literals.close);
  }
  hasClose() {
    return this.isAlert() || this.showClose;
  }
  isAlert() {
    return this.mode === "alert";
  }
  isInline() {
    return this.mode === "inline";
  }
  getIcon() {
    return this.icon;
  }
  show() {
    this.isHide = true;
    this.setFadeIn();
    this.renderer.removeAttribute(this.toaster.nativeElement, "hidden");
  }
  hide() {
    this.isHide = true;
    this.setFadeOut();
    this.renderer.setAttribute(this.toaster.nativeElement, "hidden", "true");
  }
  getToasterPosition() {
    return this.toasterPosition;
  }
  getToasterType() {
    switch (this.type) {
      case PoToasterType.Error: {
        this.toasterType = "po-toaster-error";
        this.icon = "ICON_CLOSE";
        break;
      }
      case PoToasterType.Information: {
        this.toasterType = "po-toaster-info";
        this.icon = this.isAlert() ? "ICON_INFO" : "ICON_WARNING";
        break;
      }
      case PoToasterType.Success: {
        this.toasterType = "po-toaster-success";
        this.icon = "ICON_OK";
        break;
      }
      case PoToasterType.Warning: {
        this.toasterType = "po-toaster-warning";
        this.icon = this.isAlert() ? "ICON_EXCLAMATION" : "ICON_WARNING";
        break;
      }
    }
    return this.toasterType;
  }
  onButtonClose(event) {
    if (this.action && !this.actionLabel) {
      this.poToasterAction(event);
    } else {
      this.close();
    }
    if (this.isInline()) {
      this.isHideChange.emit(this.isHide);
    }
  }
  /* Chama a função passada pelo atributo `action` */
  poToasterAction(event) {
    this.action(this);
  }
  returnHeightToaster(position) {
    if (this.orientation === PoToasterOrientation.Top) {
      return document.querySelectorAll(".po-toaster-top")[position].offsetHeight;
    }
    return document.querySelectorAll(".po-toaster-bottom")[position].offsetHeight;
  }
  static ɵfac = function PoToasterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoToasterComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoToasterComponent,
    selectors: [["po-toaster"]],
    viewQuery: function PoToasterComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$15, 5);
        ɵɵviewQuery(_c1$r, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toaster = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.buttonClose = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 12,
    vars: 14,
    consts: [["toaster", ""], ["buttonClose", ""], [3, "hidden"], [1, "po-toaster-icon", 3, "ngClass"], [3, "p-icon", 4, "ngIf"], ["class", "po-toaster-inline-icon", 3, "p-icon", 4, "ngIf"], [1, "po-toaster-actions"], [1, "po-toaster-message"], ["class", "po-toaster-support-message", 4, "ngIf"], [1, "po-toaster-action"], ["p-kind", "tertiary", 3, "p-label", "p-click", 4, "ngIf"], ["class", "po-toaster-close", 4, "ngIf"], [3, "p-icon"], [1, "po-toaster-inline-icon", 3, "p-icon"], [1, "po-toaster-support-message"], ["p-kind", "tertiary", 3, "p-click", "p-label"], [1, "po-toaster-close"], [1, "po-toaster-divider"], ["p-icon", "ICON_CLOSE", "p-kind", "tertiary", 1, "po-toaster-button-close", 3, "p-click"]],
    template: function PoToasterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 2, 0)(2, "div", 3);
        ɵɵtemplate(3, PoToasterComponent_po_icon_3_Template, 1, 1, "po-icon", 4);
        ɵɵelementEnd();
        ɵɵtemplate(4, PoToasterComponent_po_icon_4_Template, 1, 1, "po-icon", 5);
        ɵɵelementStart(5, "div", 6)(6, "div", 7);
        ɵɵtext(7);
        ɵɵtemplate(8, PoToasterComponent_div_8_Template, 2, 1, "div", 8);
        ɵɵelementEnd();
        ɵɵelementStart(9, "div", 9);
        ɵɵtemplate(10, PoToasterComponent_po_button_10_Template, 1, 1, "po-button", 10);
        ɵɵelementEnd()();
        ɵɵtemplate(11, PoToasterComponent_div_11_Template, 4, 0, "div", 11);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMapInterpolate2("\n    po-toaster \n    ", ctx.getToasterType(), " \n    ", ctx.getToasterPosition(), "\n  ");
        ɵɵclassProp("po-toaster-inline", ctx.isInline());
        ɵɵproperty("hidden", ctx.isHide);
        ɵɵadvance(2);
        ɵɵproperty("ngClass", ctx.isAlert() ? "po-toaster-icon-default" : "po-toaster-decoration");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isAlert());
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isInline());
        ɵɵadvance(3);
        ɵɵtextInterpolate1(" ", ctx.message, " ");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.supportMessage);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.action && ctx.actionLabel);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasClose());
      }
    },
    dependencies: [NgClass, NgIf, PoIconComponent, PoButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToasterComponent, [{
    type: Component,
    args: [{
      selector: "po-toaster",
      standalone: false,
      template: `<div
  #toaster
  class="
    po-toaster 
    {{ getToasterType() }} 
    {{ getToasterPosition() }}
  "
  [class.po-toaster-inline]="isInline()"
  [hidden]="isHide"
>
  <div class="po-toaster-icon" [ngClass]="isAlert() ? 'po-toaster-icon-default' : 'po-toaster-decoration'">
    <po-icon *ngIf="isAlert()" [p-icon]="getIcon()"></po-icon>
  </div>

  <po-icon class="po-toaster-inline-icon" *ngIf="isInline()" [p-icon]="getIcon()"></po-icon>

  <div class="po-toaster-actions">
    <div class="po-toaster-message">
      {{ message }}
      <div *ngIf="supportMessage" class="po-toaster-support-message">{{ supportMessage }}</div>
    </div>

    <div class="po-toaster-action">
      <po-button
        *ngIf="action && actionLabel"
        (p-click)="poToasterAction($event)"
        [p-label]="actionLabel"
        p-kind="tertiary"
      ></po-button>
    </div>
  </div>

  <div *ngIf="hasClose()" class="po-toaster-close">
    <div class="po-toaster-divider"></div>
    <po-button
      #buttonClose
      class="po-toaster-button-close"
      (p-click)="onButtonClose($event)"
      p-icon="ICON_CLOSE"
      p-kind="tertiary"
    ></po-button>
  </div>
</div>
`
    }]
  }], () => [{
    type: PoLanguageService
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }], {
    toaster: [{
      type: ViewChild,
      args: ["toaster"]
    }],
    buttonClose: [{
      type: ViewChild,
      args: ["buttonClose"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoToasterComponent, {
    className: "PoToasterComponent",
    filePath: "lib/components/po-toaster/po-toaster.component.ts",
    lineNumber: 45
  });
})();
var PoToasterModule = class _PoToasterModule {
  static ɵfac = function PoToasterModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoToasterModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoToasterModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoIconModule, PoButtonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToasterModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoIconModule, PoButtonModule],
      declarations: [PoToasterComponent],
      exports: [PoToasterComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoToasterModule, {
    declarations: [PoToasterComponent],
    imports: [CommonModule, PoIconModule, PoButtonModule],
    exports: [PoToasterComponent]
  });
})();
var PoNotificationModule = class _PoNotificationModule {
  static ɵfac = function PoNotificationModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNotificationModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoNotificationModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoButtonModule, PoIconModule, PoToasterModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNotificationModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [CommonModule, PoButtonModule, PoIconModule, PoToasterModule],
      exports: [],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoNotificationModule, {
    imports: [CommonModule, PoButtonModule, PoIconModule, PoToasterModule]
  });
})();
var PoThemeA11yEnum;
(function(PoThemeA11yEnum2) {
  PoThemeA11yEnum2["AA"] = "AA";
  PoThemeA11yEnum2["AAA"] = "AAA";
})(PoThemeA11yEnum || (PoThemeA11yEnum = {}));
var PoThemeTypeEnum;
(function(PoThemeTypeEnum2) {
  PoThemeTypeEnum2[PoThemeTypeEnum2["light"] = 0] = "light";
  PoThemeTypeEnum2[PoThemeTypeEnum2["dark"] = 1] = "dark";
})(PoThemeTypeEnum || (PoThemeTypeEnum = {}));
var poThemeDefaultAA = {
  perComponent: {},
  onRoot: {
    /*------------------------------------*\
    COMMON
    \*------------------------------------*/
    "--outline-width": "var(--border-width-md)",
    "--outline-width-focus-visible": "var(--border-width-md)"
  }
};
var poThemeDefaultAAA = {
  perComponent: {},
  onRoot: {
    /*------------------------------------*\
    FONT
    \*------------------------------------*/
    "--font-family": "Roboto",
    "--font-family-theme": "Roboto",
    "--font-family-theme-bold": "Roboto-Bold",
    "--font-family-theme-extra-light": "Roboto-Condensed-Light",
    "--font-family-heading": "Roboto",
    "--font-family-code": "Monospace"
  }
};
var poThemeDefaultActions = {
  /** Cor padrão. */
  default: "var(--color-brand-01-base)",
  /** Cor ao passar o mouse. */
  hover: "var(--color-brand-01-dark)",
  /** Cor quando pressionado. */
  pressed: "var(--color-brand-01-darker)",
  /** Cor quando desabilitado. */
  disabled: "var(--color-neutral-light-30)",
  /** Cor ao focar. */
  focus: "var(--color-brand-01-darkest)"
};
var poThemeDefaultNeutrals = {
  /** Tons de cinza claro. */
  light: {
    "00": "#ffffff",
    "05": "#fbfbfb",
    "10": "#eceeee",
    "20": "#dadedf",
    "30": "#b6bdbf"
  },
  /** Tons de cinza intermediários. */
  mid: {
    "40": "#9da7a9",
    "60": "#6e7c7f"
  },
  /** Tons de cinza escuro. */
  dark: {
    "70": "#4a5c60",
    "80": "#2c3739",
    "90": "#1d2426",
    "95": "#0b0e0e"
  }
};
var poThemeDefaultFeedback = {
  /** Cores para feedback negativo. */
  negative: {
    lightest: "#f6e6e5",
    lighter: "#e3aeab",
    light: "#d58581",
    base: "#be3e37",
    dark: "#9b2d27",
    darker: "#72211d",
    darkest: "#4a1512"
  },
  /** Cores para feedback informativo. */
  info: {
    lightest: "#e3e9f7",
    lighter: "#b0c1e8",
    light: "#7996d7",
    base: "#23489f",
    dark: "#173782",
    darker: "#0f2557",
    darkest: "#081536"
  },
  /** Cores para feedback positivo. */
  positive: {
    lightest: "#def7ed",
    lighter: "#7ecead",
    light: "#41b483",
    base: "#107048",
    dark: "#0f5236",
    darker: "#083a25",
    darkest: "#002415"
  },
  /** Cores para feedback de aviso. */
  warning: {
    lightest: "#fcf6e3",
    lighter: "#f7dd97",
    light: "#f1cd6a",
    base: "#efba2a",
    dark: "#d8a20e",
    darker: "#705200",
    darkest: "#473400"
  }
};
var poThemeDefaultBrands = {
  "01": {
    lightest: "#f2eaf6",
    lighter: "#d9c2e5",
    light: "#bd94d1",
    base: "#753399",
    dark: "#5b1c7d",
    darker: "#400e58",
    darkest: "#260538"
  },
  "02": {
    base: "#b92f72"
  },
  "03": {
    base: "#ffd464"
  }
};
var poThemeDefaultLightValues = {
  perComponent: {},
  onRoot: {}
};
var poThemeDefaultActionsDark = {
  /** Cor padrão. */
  default: "var(--color-brand-01-dark)",
  /** Cor ao passar o mouse. */
  hover: "var(--color-brand-01-darker)",
  /** Cor quando pressionado. */
  pressed: "var(--color-brand-01-darkest)",
  /** Cor quando desabilitado. */
  disabled: "var(--color-neutral-mid-40)",
  /** Cor ao focar. */
  focus: "var(--color-brand-01-darkest)"
};
var poThemeDefaultNeutralsDark = {
  /** Tons de cinza claro. */
  light: {
    "00": "#1c1c1c",
    "05": "#202020",
    "10": "#2b2b2b",
    "20": "#3b3b3b",
    "30": "#5a5a5a"
  },
  /** Tons de cinza intermediários. */
  mid: {
    "40": "#7c7c7c",
    "60": "#a1a1a1"
  },
  /** Tons de cinza escuro. */
  dark: {
    "70": "#c1c1c1",
    "80": "#d9d9d9",
    "90": "#eeeeee",
    "95": "#fbfbfb"
  }
};
var poThemeDefaultFeedbackDark = {
  /** Cores para feedback negativo. */
  negative: {
    lightest: "#4a1512",
    lighter: "#72211d",
    light: "#9b2d27",
    base: "#be3e37",
    dark: "#d58581",
    darker: "#e3aeab",
    darkest: "#f6e6e5"
  },
  /** Cores para feedback informativo. */
  info: {
    lightest: "#081536",
    lighter: "#0f2557",
    light: "#173782",
    base: "#0079b8",
    dark: "#7996d7",
    darker: "#b0c1e8",
    darkest: "#e3e9f7"
  },
  /** Cores para feedback positivo. */
  positive: {
    lightest: "#002415",
    lighter: "#083a25",
    light: "#0f5236",
    base: "#107048",
    dark: "#41b483",
    darker: "#7ecead",
    darkest: "#def7ed"
  },
  /** Cores para feedback de aviso. */
  warning: {
    lightest: "#473400",
    lighter: "#705200",
    light: "#d8a20e",
    base: "#efba2a",
    dark: "#f1cd6a",
    darker: "#f7dd97",
    darkest: "#fcf6e3"
  }
};
var poThemeDefaultBrandsDark = {
  "01": {
    lightest: "#260538",
    lighter: "#400e58",
    light: "#5b1c7d",
    base: "#753399",
    dark: "#bd94d1",
    darker: "#d9c2e5",
    darkest: "#f2eaf6"
  },
  "02": {
    base: "#b92f72"
  },
  "03": {
    base: "#ffd464"
  }
};
var poThemeDefaultDarkValues = {
  perComponent: {
    /** TAB */
    ".po-tab-border-active": {
      "background-color": "var(--color)"
    },
    /** GAUGE */
    ".po-gauge-wrapper": {
      "background-color": "var(--color-neutral-light-00)"
    },
    /** OVERLAY */
    "po-overlay": {
      "--color-overlay": "var(--color-neutral-light-20)"
    },
    /** MODAL */
    "po-modal": {
      "--color-overlay": "var(--color-neutral-light-20)"
    },
    /** TOASTER */
    "po-toaster": {
      "--color-icon": "var(--color-neutral-dark-80)",
      "--color-icon-warning": "var(--color-neutral-light-00)"
    },
    /** BADGE */
    "po-badge": {
      "--color": "var(--color-neutral-dark-95)"
    },
    "po-badge[p-status=warning]": {
      "--color": "var(--color-neutral-light-00)"
    },
    // CHART: AXIS LABEL
    "po-chart po-chart-container > svg .po-chart-axis-x-label, .po-chart-axis-y-label": {
      "fill": "var(--color-neutral-dark-95)"
    },
    // LINK: item visitado
    "po-link": {
      "--text-color-visited": "var(--color-action-default)"
    },
    // focus e outline: po-rich-text-body/ poinfo/ po-list-view/ po-stepper-circle (mudar no po-style)
    "po-rich-text-body .po-rich-text-body:focus-visible, po-info .po-info-link:focus-visible, po-list-view a.po-list-view-title-link:focus-visible, po-stepper-circle .po-stepper-circle:focus-visible": {
      "border-color": "var(--color-action-default);",
      "outline-color": "var(--color-action-focus);",
      "outline-width": "var(--outline-width-focus-visible);",
      "outline-style": "solid;",
      "outline-offset": "2px;"
    },
    // background container
    "po-container": {
      "--background": "var(--color-neutral-light-00);"
    },
    // Background input disabled
    "div.po-lookup-filter-content input.po-input, input.po-input, po-datepicker, po-datepicker-range, po-decimal, po-email, po-input, po-login, po-lookup, po-number, po-password, po-url, po-combo, po-search, po-select, po-multiselect": {
      "--background-disabled": "var(--color-neutral-light-20);"
    },
    // autocomplete dos inputs (setar no po-style)
    "po-input input:-webkit-autofill, po-datepicker input:-webkit-autofill, po-datepicker-range input:-webkit-autofill, po-decimal input:-webkit-autofill, po-email input:-webkit-autofill, po-input input:-webkit-autofill, po-login input:-webkit-autofill, po-lookup input:-webkit-autofill, po-number input:-webkit-autofill, po-password input:-webkit-autofill, po-url input:-webkit-autofill, po-combo input:-webkit-autofill": {
      "-webkit-background-clip": "text",
      "-webkit-text-fill-color": "#ffffff",
      "transition": "background-color 5000s ease-in-out 0s",
      "box-shadow": "inset 0 0 20px 20px #23232329"
    },
    "po-overlay, po-page-slide": {
      "--color-overlay": "var(--color-neutral-light-05)"
    },
    /** SELECT */
    "po-select": {
      "--color-hover": "var(--color-action-hover);"
    }
  },
  onRoot: {
    /* CORES LEGADAS */
    "--color-neutral": "var(--color-neutral-dark-70)",
    "--color-secondary": "var(--color-action-default)",
    "--color-secondary-light-20": "var(--color-brand-01-lighter)",
    "--color-secondary-light-40": "var(--color-brand-01-light)",
    "--color-secondary-dark-20": "var(--color-brand-01-dark)",
    "--color-secondary-dark-40": "var(--color-brand-01-darker)",
    "--color-secondary-dark-80": "var(--color-brand-01-darkest)",
    "--color-black-alpha-10": "rgba(255, 255, 255, 0.1)",
    "--color-black-alpha-15": "rgba(255, 255, 255, 0.15)",
    "--color-black-alpha-30": "rgba(255, 255, 255, 0.3)",
    "--color-primary-light-80": "color-mix(in srgb, var(--color-brand-02-base) 80%, black)",
    "--color-primary-light-95": "color-mix(in srgb, var(--color-brand-02-base) 95%, black)",
    "--color-primary-alpha-50": "color-mix(in srgb, var(--color-brand-02-base) 50%, white)",
    "--color-primary-dark-20": "color-mix(in srgb, var(--color-brand-02-base) 20%, white)",
    "--color-primary-dark-40": "color-mix(in srgb, var(--color-brand-02-base) 40%, white)",
    "--color-secondary-dark-60-alpha-70": "color-mix(in srgb, var(--color-neutral-mid-60) 70%, white)",
    "--color-tertiary-light-90": "color-mix(in srgb, var(--color-brand-03-base) 90%, black)",
    "--color-tertiary-dark-5": "color-mix(in srgb, var(--color-brand-03-base) 5%, white)",
    /* PAGE  */
    "--color-page-background-color-page": "var(--color-neutral-light-05)",
    /* TOOLBAR BADGE */
    "--color-toolbar-color-badge-text": "var(--color-neutral-dark-95)",
    /* POPOVER */
    "--shadow-popover-box-shadow": "0 0 4px 0 var(--color-neutral-light-20)",
    "--shadow-popover-box-shadow-arrow": "-1px -1px 1px 0 var(--color-neutral-light-20)",
    /* CALENDAR */
    "--color-calendar-background-color-box-background-range": "var(--color-brand-01-lightest)",
    /* STEPPER */
    "--color-stepper-circle-disabled": "var(--color-neutral-mid-40)",
    "--color-stepper-bar-disabled": "var(--color-neutral-mid-40)"
  }
};
var poThemeDefaultLight = {
  color: {
    brand: poThemeDefaultBrands,
    action: poThemeDefaultActions,
    neutral: poThemeDefaultNeutrals,
    feedback: poThemeDefaultFeedback
  }
};
var poThemeDefaultDark = {
  color: {
    brand: poThemeDefaultBrandsDark,
    action: poThemeDefaultActionsDark,
    neutral: poThemeDefaultNeutralsDark,
    feedback: poThemeDefaultFeedbackDark
  }
};
var poThemeDefault = {
  name: "default",
  type: [{
    light: poThemeDefaultLight,
    dark: poThemeDefaultDark,
    a11y: PoThemeA11yEnum.AAA
  }, {
    light: poThemeDefaultLight,
    dark: poThemeDefaultDark,
    a11y: PoThemeA11yEnum.AA
  }],
  active: {
    type: PoThemeTypeEnum.light,
    a11y: PoThemeA11yEnum.AAA
  }
};
var PoThemeService = class _PoThemeService {
  document;
  renderer;
  theme;
  _iconToken;
  get iconNameLib() {
    return this._iconToken.NAME_LIB;
  }
  constructor(document2, rendererFactory, value) {
    this.document = document2;
    this.renderer = rendererFactory.createRenderer(null, null);
    this._iconToken = value ?? AnimaliaIconDictionary;
    this.setPerComponentAndOnRoot(void 0, poThemeDefaultAAA.perComponent, poThemeDefaultAAA.onRoot);
    this.setPerComponentAndOnRoot({
      a11y: PoThemeA11yEnum.AA
    }, poThemeDefaultAA.perComponent, poThemeDefaultAA.onRoot);
    this.setPerComponentAndOnRoot({
      type: PoThemeTypeEnum.light
    }, poThemeDefaultLightValues.perComponent, poThemeDefaultLightValues.onRoot);
    this.setPerComponentAndOnRoot({
      type: PoThemeTypeEnum.dark
    }, poThemeDefaultDarkValues.perComponent, poThemeDefaultDarkValues.onRoot);
  }
  /**
   * Aplica um tema ao componente de acordo com o tipo de tema e o nível de acessibilidade especificados.
   *
   * Este método configura o tema do componente com base no objeto `themeConfig` fornecido, no `themeType` e no `a11yLevel`.
   * Além disso, ele pode opcionalmente salvar a preferência de tema no localStorage, se solicitado.
   *
   * @param {PoTheme} themeConfig - Configuração de tema a ser aplicada ao componente.
   * @param {PoThemeTypeEnum} [themeType=PoThemeTypeEnum.light] - (Opcional) Tipo de tema, podendo ser 'light' (claro) ou 'dark' (escuro). O tema claro é o padrão.
   * @param {PoThemeA11yEnum} [a11yLevel=PoThemeA11yEnum.AAA] - (Opcional) Nível de acessibilidade do tema, podendo ser AA ou AAA. Padrão é AAA.
   * @param {boolean} [persistPreference=true] - (Opcional) Define se a preferência de tema deve ser salva no localStorage para persistência. `true` para salvar, `false` para não salvar.
   */
  setTheme(themeConfig, themeType = PoThemeTypeEnum.light, a11yLevel = PoThemeA11yEnum.AAA, persistPreference = true) {
    this.formatTheme(themeConfig, themeType, a11yLevel);
    const _themeActive = Array.isArray(themeConfig.type) && themeConfig.type.length >= 1 ? themeConfig.type.find((e) => e.a11y === a11yLevel) : themeConfig.type;
    const _themeType = _themeActive[PoThemeTypeEnum[themeType]];
    if (!_themeType) {
      return;
    }
    const colorStyles = _themeType.color ? this.generateThemeStyles(_themeType.color) : "";
    const perComponentStyles = _themeType.perComponent ? this.generatePerComponentStyles(_themeType.perComponent) : "";
    const onRootStyles = _themeType.onRoot ? this.generateAdditionalStyles(_themeType.onRoot) : "";
    const additionalStyles = this.generateAdditionalStyles(_themeType);
    const combinedStyles = `
      html.${themeConfig.name}-${PoThemeTypeEnum[themeType]}-${a11yLevel}:root {
        ${colorStyles}
        ${perComponentStyles}
        ${onRootStyles}
        ${additionalStyles}
      }`;
    this.applyThemeStyles(combinedStyles);
    this.changeThemeType(themeConfig, persistPreference);
  }
  /**
   * @docsPrivate
   *
   * Aplica estilos customizados para o componente e para o root HTML, utilizando os tokens definidos.
   *
   * Esse método é chamado para inserir ou atualizar estilos no DOM, aplicando tanto tokens de `onRoot` (ex: `--font-family: 'Roboto'`)
   * quanto estilos específicos de componentes (`perComponent`, como `po-listbox [hidden]: { display: 'flex !important' }`).
   *
   * O seletor CSS gerado leva em consideração o tema (`type`) e as configurações de acessibilidade (`a11y`) do tema ativo.
   * A classe do tema é aplicada no HTML e pode ser formatada como `html[class*="-light-AA"]` para personalizações
   * em temas específicos.
   *
   * @param {PoThemeActive} active - Objeto que define o tema ativo, com `type` e `a11y`.
   * @param {any} perComponent - Objeto contendo os estilos específicos para componentes a serem aplicados.
   * @param {any} onRoot - Objeto contendo tokens de estilo que serão aplicados diretamente no seletor `:root` do HTML.
   *
   * @example
   *
   * // Exemplo de utilização com um tema ativo e tokens de estilo
   * const themeActive = { type: 'light', a11y: 'AA' };
   * const perComponentStyles = {
   *   'po-listbox [hidden]': {
   *     'display': 'flex !important'
   *   }
   * };
   * const onRootStyles = {
   *   '--font-family': 'Roboto',
   *   '--background-color': '#fff'
   * };
   *
   * this.setPerComponentAndOnRoot(themeActive, perComponentStyles, onRootStyles);
   *
   * // Resultado:
   * // Gera e aplica os seguintes estilos no DOM
   * // html[class*="-light-AA"]:root {
   * //   --font-family: 'Roboto';
   * //   --background-color: '#fff';
   * //   po-listbox [hidden] {
   * //     display: flex !important;
   * //   }
   * // }
   *
   */
  setPerComponentAndOnRoot(active, perComponent, onRoot) {
    const perComponentStyles = perComponent ? this.generatePerComponentStyles(perComponent) : "";
    const onRootStyles = onRoot ? this.generateAdditionalStyles(onRoot) : "";
    let selector = "html";
    const typeSelector = active?.type !== void 0 ? `-${PoThemeTypeEnum[active.type]}` : "";
    const accessibilitySelector = active?.a11y !== void 0 ? `-${PoThemeA11yEnum[active.a11y]}` : "";
    if (typeSelector && accessibilitySelector) {
      selector += `[class*="${typeSelector}${accessibilitySelector}"]`;
    } else if (!typeSelector && accessibilitySelector) {
      selector += `[class$="${accessibilitySelector}"]`;
    } else if (typeSelector) {
      selector += `[class*="${typeSelector}"]`;
    }
    const styleCss = `
      ${selector}:root {
        ${perComponentStyles}
        ${onRootStyles}
      }
    `;
    let styleElement = this.document.head.querySelector("#baseStyle");
    if (!styleElement) {
      styleElement = this.renderer.createElement("style");
      styleElement.id = "baseStyle";
      this.renderer.appendChild(styleElement, this.renderer.createText(styleCss));
      this.renderer.appendChild(this.document.head, styleElement);
    } else {
      if (!styleElement.textContent.includes(styleCss.trim())) {
        this.renderer.appendChild(styleElement, this.renderer.createText(styleCss));
      }
    }
  }
  /**
   * @docsPrivate
   *
   * Gera estilos adicionais com base nos tokens de tema fornecidos, excluindo os tokens de cor.
   * @param theme Os tokens de tema contendo os estilos adicionais a serem gerados.
   * @returns Uma string contendo os estilos adicionais formatados.
   */
  generateAdditionalStyles(theme) {
    return Object.entries(theme).filter(([key]) => !["color", "perComponent", "onRoot"].includes(key)).map(([key, value]) => `${key}: ${value};`).join(" ");
  }
  /**
   * @docsPrivate
   *
   * Aplica os estilos de tema ao documento.
   * @param styleCss Os estilos CSS a serem aplicados.
   */
  applyThemeStyles(styleCss) {
    const styleElement = this.createStyleElement(styleCss, "theme");
    const existingStyleElement = document.head.querySelector("#theme");
    if (existingStyleElement) {
      this.renderer.removeChild(document.head, existingStyleElement);
    }
    this.renderer.appendChild(document.head, styleElement);
  }
  changeThemeType(theme, persistPreference = true) {
    this.cleanThemeActive(persistPreference);
    if (persistPreference) {
      this.setThemeLocal(theme);
    }
    document.getElementsByTagName("html")[0].classList.add(...[`${theme.name}-${PoThemeTypeEnum[this.getActiveTypeFromTheme(theme.active)]}-${PoThemeA11yEnum[this.getActiveA11yFromTheme(theme.active)]}`]);
  }
  /**
   * Persiste e define o tema do aplicativo com base nos dados armazenados.
   *
   * Este método recupera os dados do tema armazenados e os aplica ao aplicativo.
   *
   * @returns {PoTheme} Recupera o tema armazenado.
   */
  persistThemeActive() {
    const _theme = this.getThemeActive();
    this.setTheme(_theme, this.getActiveTypeFromTheme(_theme.active), this.getActiveA11yFromTheme(_theme.active));
    return _theme;
  }
  formatTheme(themeConfig, themeType, a11yLevel) {
    themeConfig.name = themeConfig.name.toLowerCase().replace(/[^a-zA-Z ]/g, "").replace(/\s+/g, "-");
    themeConfig.active = {
      type: themeType,
      a11y: a11yLevel
    };
  }
  applyTheme(theme) {
    const _localTheme = this.getThemeActive();
    if (!theme) {
      if (_localTheme) {
        this.persistThemeActive();
        return _localTheme;
      }
      return void 0;
    }
    const _type = this.getActiveTypeFromTheme(theme.active);
    const _accessibility = this.getActiveA11yFromTheme(theme.active);
    if (_localTheme && JSON.stringify(_localTheme) === JSON.stringify(theme)) {
      this.persistThemeActive();
      return _localTheme;
    }
    this.formatTheme(theme, _type, _accessibility);
    this.setTheme(theme, _type, _accessibility);
    return theme;
  }
  /**
   * Altera o tipo do tema armazenado e aplica os novos estilos ao documento.
   *
   * Este método altera o tipo do tema armazenado ativo (light/dark)
   *
   * @param {PoThemeTypeEnum} themeType O tipo de tema a ser aplicado, light ou dark.
   */
  changeCurrentThemeType(type) {
    const _theme = this.getThemeActive();
    typeof _theme.active === "object" ? _theme.active.type = type : _theme.active = type;
    this.changeThemeType(_theme);
  }
  /**
   * Método remove o tema armazenado e limpa todos os estilos de tema
   * aplicados ao documento.
   *
   * @param {boolean} [persistPreference=true] - (Opcional) Define se a preferência de tema não deve ser mantida no localStorage para persistência. `true` para remover, `false` para manter.
   */
  cleanThemeActive(persistPreference = true) {
    const themeSuffixes = ["-light-", "-dark-"];
    const htmlElement = document.getElementsByTagName("html")[0];
    Array.from(htmlElement.classList).forEach((className) => {
      if (themeSuffixes.some((suffix) => className.includes(suffix))) {
        htmlElement.classList.remove(className);
      }
    });
    if (persistPreference) {
      localStorage.removeItem("totvs-theme");
    }
  }
  getActiveTypeFromTheme(active) {
    return typeof active === "object" ? active.type : active;
  }
  getActiveA11yFromTheme(active) {
    return typeof active === "object" ? active.a11y : PoThemeA11yEnum.AAA;
  }
  /**
   * @docsPrivate
   *
   * Este método define um dados do tema e o armazena.
   * @param theme Os tokens de tema contendo os estilos adicionais a serem gerados.
   */
  setThemeLocal(theme) {
    if (theme) {
      localStorage.setItem("totvs-theme", JSON.stringify(theme));
      this.theme = theme;
    }
  }
  /**
   * Retorna o tema ativo como um observable.
   * @returns {PoTheme} Tema ativo.
   */
  getThemeActive() {
    try {
      const themeData = JSON.parse(localStorage.getItem("totvs-theme"));
      if (themeData && JSON.stringify(themeData) !== JSON.stringify(this.theme)) {
        this.theme = themeData;
      }
    } catch (error) {
      console.error("Erro ao obter o tema do armazenamento local:", error);
    }
    return this.theme;
  }
  /**
   * @docsPrivate
   *
   * Gera estilos CSS com base nos tokens de cores fornecidos.
   * @param css Os tokens de cor a serem usados para gerar os estilos.
   * @param id id do style a ser aplicado.
   * @returns Uma string contendo os estilos CSS gerados.
   */
  createStyleElement(css, id) {
    const styleElement = this.renderer.createElement("style");
    styleElement.id = id;
    this.renderer.appendChild(styleElement, this.renderer.createText(css));
    return styleElement;
  }
  /**
   * @docsPrivate
   *
   * Gera estilos CSS com base nos tokens de cores fornecidos.
   * @param themeColor Os tokens de cor a serem usados para gerar os estilos.
   * @returns Uma string contendo os estilos CSS gerados.
   */
  generateThemeStyles(themeColor) {
    const selectBgIconStyle = this.getSelectBgIconsStyle(themeColor);
    return [Object.entries(themeColor).flatMap(([type, values]) => Object.entries(values).flatMap(([tonality, tonalityValues]) => {
      if (type === "action") {
        return [`--color-${type}-${tonality}: ${tonalityValues};`];
      } else {
        return Object.entries(tonalityValues).map(([level, colorValue]) => `--color-${type}-${tonality}-${level}: ${colorValue};`);
      }
    })).join(""), selectBgIconStyle].join("");
  }
  /**
   * @docsPrivate
   *
   * Gera estilos CSS com base nos tokens per Component fornecidos.
   * @param themePerComponent Os tokens de cor a serem usados para gerar os estilos.
   * @returns Uma string contendo os estilos CSS gerados.
   */
  generatePerComponentStyles(themePerComponent) {
    return Object.entries(themePerComponent).flatMap(([type, values]) => Object.entries(values).flatMap(([level, colorValue]) => [`${type} {${level}: ${colorValue};};`])).join("");
  }
  /**
   * Define o tema atual como o tema "PoUI Padrão".
   *
   * @param {PoThemeTypeEnum} type O tipo de Tema a ser aplicado, light / dark.
   */
  setDefaultTheme(type) {
    this.setTheme(poThemeDefault, type);
  }
  /**
   * @docsPrivate
   *
   * Retorna o estilo CSS para o fundo dos ícones do componente po-select, com base nas cores do tema.
   *
   * @param {PoThemeColor} themeColor - Objeto contendo as cores do tema.
   * @returns {string} - Estilo CSS para o fundo dos ícones do po-select.
   */
  getSelectBgIconsStyle(themeColor) {
    let selectBgIcon = "";
    if (themeColor?.brand?.["01"]?.dark) {
      const selector = this.iconNameLib === "AnimaliaIcon" ? "po-select .po-select-phosphor" : "po-select";
      selectBgIcon += `${selector} { --background-image: url(${this.getSelectBgIcon(themeColor.neutral.dark[70])}); };`;
    }
    if (themeColor?.feedback?.negative?.base) {
      if (this.iconNameLib === "PoIcon") {
        selectBgIcon += `po-select.ng-dirty.ng-invalid select { --background-image: url(${this.getSelectBgIcon(themeColor.feedback.negative.base)}); };`;
      }
      if (this.iconNameLib === "AnimaliaIcon") {
        selectBgIcon += `po-select.ng-dirty.ng-invalid select.po-select-phosphor { background-image: url(${this.getSelectBgIcon(themeColor.feedback.negative.base)}); };`;
      }
    }
    if (themeColor?.neutral?.light?.["30"]) {
      if (this.iconNameLib === "PoIcon") {
        selectBgIcon += `select:disabled { background-image: url(${this.getSelectBgIcon(themeColor.neutral.light["30"])}); };`;
      }
      if (this.iconNameLib === "AnimaliaIcon") {
        selectBgIcon += `po-select select.po-select-phosphor:disabled { background-image: url(${this.getSelectBgIcon(themeColor.neutral.light["30"])}); };`;
      }
    }
    return selectBgIcon;
  }
  /**
   * @docsPrivate
   *
   * Retorna a imagem SVG utilizada como fundo do po-select.
   *
   * @param {string} color Cor da Imagem - Utilizada no atributo 'fill'.
   * @returns {string} Imagem SVG utilizada no po-select.
   */
  getSelectBgIcon(color) {
    let svg;
    if (this.iconNameLib === "PoIcon") {
      svg = `"data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' `;
      svg = svg.concat(`xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' `);
      svg = svg.concat(`d='M18.707 8.29301C18.316 7.90201 17.684 7.90201 17.293 8.29301L12 13.586L6.70701 `);
      svg = svg.concat(`8.29301C6.31601 7.90201 5.68401 7.90201 5.29301 8.29301C4.90201 8.68401 4.90201 `);
      svg = svg.concat(`9.31601 5.29301 9.70701L11.293 15.707C11.488 15.902 11.744 16 12 16C12.256 16 12.512 `);
      svg = svg.concat(`15.902 12.707 15.707L18.707 9.70701C19.098 9.31601 19.098 8.68401 18.707 8.29301Z' `);
      svg = svg.concat(`fill='${color.replace("#", "%23")}'/%3E%3C/svg%3E%0A");`);
      return svg;
    }
    svg = `"data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 256 256' fill='${color.replace("#", "%23")}' `;
    svg = svg.concat(`xmlns='http://www.w3.org/2000/svg'%3E%3Cpath `);
    svg = svg.concat(`d='M213.66,101.66l-80,80a8,8,0,0,1-11.32,0l-80-80A8,8,0,0,1,53.66,90.34L128,164.69l74.34-74.35a8,8,0,0,1,11.32,11.32Z'`);
    svg = svg.concat(`%3E%3C/path%3E%3C/svg%3E");`);
    return svg;
  }
  /**
   * Define o tipo (light/dark) quando um tema está sendo aplicado.
   *
   * @param {PoTheme} theme - Objeto contendo as definições de tema a serem aplicadas no componente.
   * @param {PoThemeTypeEnum} [themeType=PoThemeTypeEnum.light] - (Opcional) Tipo de tema a ser aplicado, podendo ser 'light' (claro) ou 'dark' (escuro). Por padrão, o tema claro é aplicado.
   */
  setThemeType(theme, themeType = PoThemeTypeEnum.light) {
    const _accessibility = typeof theme.active === "object" ? theme.active.a11y : PoThemeA11yEnum.AAA;
    this.setTheme(theme, themeType, _accessibility);
  }
  /**
   *  Define o tipo (light/dark) para um tema já ativo.
   *
   * @param {PoThemeTypeEnum} [themeType=PoThemeTypeEnum.light] - (Opcional) Tipo de tema a ser aplicado, podendo ser 'light' (claro) ou 'dark' (escuro). Por padrão, o tema claro é aplicado.
   */
  setCurrentThemeType(themeType = PoThemeTypeEnum.light) {
    const _theme = this.getThemeActive();
    this.setThemeType(_theme, themeType);
  }
  /**
   * Define o nivel de acessibilidade quando um tema está sendo aplicado.
   *
   * @param {PoTheme} theme - Objeto contendo as definições de tema a serem aplicadas no componente.
   * @param {PoThemeA11yEnum} [a11y=PoThemeA11yEnum.AAA] - (Opcional) Nível de acessibilidade a ser aplicado ao tema, como AA ou AAA. Se não for informado, por padrão a acessibilidade será AAA.
   */
  setThemeA11y(theme, a11y = PoThemeA11yEnum.AAA) {
    const _type = (typeof theme.active === "object" ? theme.active.type : theme.active) || 0;
    this.setTheme(theme, _type, a11y);
  }
  /**
   * Define o nivel de acessibilidade para um tema já ativo.
   *
   * @param {PoThemeA11yEnum} [a11y=PoThemeA11yEnum.AAA] - (Opcional) Nível de acessibilidade a ser aplicado ao tema, como AA ou AAA. Se não for informado, por padrão a acessibilidade será AAA.
   */
  setCurrentThemeA11y(a11y = PoThemeA11yEnum.AAA) {
    const _theme = this.getThemeActive();
    this.setThemeA11y(_theme, a11y);
  }
  static ɵfac = function PoThemeService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoThemeService)(ɵɵinject(DOCUMENT), ɵɵinject(RendererFactory2), ɵɵinject(ICONS_DICTIONARY, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoThemeService,
    factory: _PoThemeService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoThemeService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: RendererFactory2
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ICONS_DICTIONARY]
    }]
  }], null);
})();
var PoThemeModule = class _PoThemeModule {
  static ɵfac = function PoThemeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoThemeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoThemeModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoThemeService]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoThemeModule, [{
    type: NgModule,
    args: [{
      providers: [PoThemeService],
      bootstrap: []
    }]
  }], null, null);
})();
var PoServicesModule = class _PoServicesModule {
  static ɵfac = function PoServicesModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoServicesModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoServicesModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [PoActiveOverlayModule, PoColorPaletteModule, PoComponentInjectorModule, PoControlPositionModule, PoDateTimeModule, PoDialogModule, PoLanguageModule, PoMediaQueryModule, PoNotificationModule, PoThemeModule, PoActiveOverlayModule, PoColorPaletteModule, PoComponentInjectorModule, PoControlPositionModule, PoDateTimeModule, PoDialogModule, PoMediaQueryModule, PoNotificationModule, PoThemeModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoServicesModule, [{
    type: NgModule,
    args: [{
      declarations: [PoI18nPipe],
      imports: [PoActiveOverlayModule, PoColorPaletteModule, PoComponentInjectorModule, PoControlPositionModule, PoDateTimeModule, PoDialogModule, PoLanguageModule, PoMediaQueryModule, PoNotificationModule, PoThemeModule],
      exports: [PoActiveOverlayModule, PoColorPaletteModule, PoComponentInjectorModule, PoControlPositionModule, PoDateTimeModule, PoDialogModule, PoI18nPipe, PoMediaQueryModule, PoNotificationModule, PoThemeModule],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoServicesModule, {
    declarations: [PoI18nPipe],
    imports: [PoActiveOverlayModule, PoColorPaletteModule, PoComponentInjectorModule, PoControlPositionModule, PoDateTimeModule, PoDialogModule, PoLanguageModule, PoMediaQueryModule, PoNotificationModule, PoThemeModule],
    exports: [PoActiveOverlayModule, PoColorPaletteModule, PoComponentInjectorModule, PoControlPositionModule, PoDateTimeModule, PoDialogModule, PoI18nPipe, PoMediaQueryModule, PoNotificationModule, PoThemeModule]
  });
})();
var PO_POPOVER_DEFAULT_POSITION = "right";
var PO_POPOVER_DEFAULT_TRIGGER = "click";
var PO_POPOVER_TRIGGERS = ["click", "hover"];
var PoPopoverBaseComponent = class _PoPopoverBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Define que o popover será inserido no body da página em vez do elemento definido em `p-target`. Essa opção pode
   * ser necessária em cenários com containers que possuem scroll ou overflow escondido, garantindo o posicionamento
   * correto do conteúdo próximo ao elemento.
   *
   * @default `false`
   */
  appendBox = false;
  /**
   * @description
   *
   * ElementRef do componente de origem responsável por abrir o popover.
   * Para utilizar o po-popover deve-se colocar uma variável no componente que vai disparar o evento
   * de abertura, exemplo:
   *
   * ```
   * <po-button
   *   p-label="Open Popover">
   * </po-button>
   *
   * <po-popover
   *   [p-target]="poButton"
   *   [p-title]="PO Popover">
   * </po-popover>
   * ```
   *
   * Também deve-se criar um ViewChild para cada popover, passando como referência o elemento do
   * HTML que irá disparar o evento. Exemplo:
   *
   * ```
   * @ViewChild(PoButtonComponent, {read: ElementRef}) poButton: PoButtonComponent;
   * ```
   *
   * Pode-se tambem informar diretamente o HTMLElement, para não ter que utilizar o ViewChild.
   * Para utilizar o po-popover deve-se colocar uma variável no componente que vai disparar o evento
   * de abertura, exemplo:
   *
   * ```
   * <button #target>
   *   Abrir popover
   * </button>
   *
   * <po-popover
   *     [p-target]="target"
   *     p-trigger="click" >
   * </po-popover>
   * ```
   *
   *
   *
   */
  target;
  /** Título do popover. */
  title;
  /** Evento disparado ao fechar o popover. */
  closePopover = new EventEmitter();
  // Controla se o popover fica oculto ou visível, por padrão é oculto.
  isHidden = true;
  clickoutListener;
  mouseEnterListener;
  mouseLeaveListener;
  resizeListener;
  _hideArrow = false;
  _position = PO_POPOVER_DEFAULT_POSITION;
  _trigger = PO_POPOVER_DEFAULT_TRIGGER;
  /**
   * @optional
   *
   * @description
   *
   * Desabilita a seta do componente *popover*.
   *
   * @default `false`
   */
  set hideArrow(value) {
    this._hideArrow = convertToBoolean(value);
  }
  get hideArrow() {
    return this._hideArrow;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a posição que o po-popover abrirá em relação ao componente alvo. Sugere-se que seja
   * usada a orientação "right" (direita), porém o mesmo é flexível e será rotacionado
   * automaticamente para se adequar a tela, caso necessário.
   *
   * Posições válidas:
   * - `right`: Posiciona o po-popover no lado direito do componente alvo.
   * - `right-bottom`: Posiciona o po-popover no lado direito inferior do componente alvo.
   * - `right-top`: Posiciona o po-popover no lado direito superior do componente alvo.
   * - `bottom`: Posiciona o po-popover abaixo do componente alvo.
   * - `bottom-left`: Posiciona o po-popover abaixo e à esquerda do componente alvo.
   * - `bottom-right`: Posiciona o po-popover abaixo e à direita do componente alvo.
   * - `left`: Posiciona o po-popover no lado esquerdo do componente alvo.
   * - `left-top`: Posiciona o po-popover no lado esquerdo superior do componente alvo.
   * - `left-bottom`: Posiciona o po-popover no lado esquerdo inferior do componente alvo.
   * - `top`: Posiciona o po-popover acima do componente alvo.
   * - `top-right`: Posiciona o po-popover acima e à direita do componente alvo.
   * - `top-left`: Posiciona o po-popover acima e à esquerda do componente alvo.
   *
   *
   * @default right
   */
  set position(value) {
    this._position = PO_CONTROL_POSITIONS.includes(value) ? value : PO_POPOVER_DEFAULT_POSITION;
  }
  get position() {
    return this._position;
  }
  /**
   * @description
   *
   * Define o evento que abrirá o po-popover.
   *
   * Valores válidos:
   *  - `click`: Abre ao clicar no componente alvo.
   *  - `hover`: Abre ao passar o mouse sobre o componente alvo.
   *
   * @default click
   * @optional
   */
  set trigger(value) {
    this._trigger = PO_POPOVER_TRIGGERS.includes(value) ? value : PO_POPOVER_DEFAULT_TRIGGER;
  }
  get trigger() {
    return this._trigger;
  }
  static ɵfac = function PoPopoverBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPopoverBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoPopoverBaseComponent,
    inputs: {
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      target: [0, "p-target", "target"],
      title: [0, "p-title", "title"],
      hideArrow: [0, "p-hide-arrow", "hideArrow"],
      position: [0, "p-position", "position"],
      trigger: [0, "p-trigger", "trigger"]
    },
    outputs: {
      closePopover: "p-close"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopoverBaseComponent, [{
    type: Directive
  }], null, {
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    target: [{
      type: Input,
      args: ["p-target"]
    }],
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    closePopover: [{
      type: Output,
      args: ["p-close"]
    }],
    hideArrow: [{
      type: Input,
      args: ["p-hide-arrow"]
    }],
    position: [{
      type: Input,
      args: ["p-position"]
    }],
    trigger: [{
      type: Input,
      args: ["p-trigger"]
    }]
  });
})();
var _c0$14 = ["popoverElement"];
var _c1$q = ["*"];
function PoPopoverComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoPopoverComponent_ng_template_1_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMapInterpolate1("po-popover-arrow po-arrow-", ctx_r0.arrowDirection, "");
  }
}
function PoPopoverComponent_ng_template_1_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
function PoPopoverComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5, 3);
    ɵɵtemplate(2, PoPopoverComponent_ng_template_1_div_2_Template, 1, 3, "div", 6);
    ɵɵelementStart(3, "div", 7);
    ɵɵtemplate(4, PoPopoverComponent_ng_template_1_span_4_Template, 2, 1, "span", 8);
    ɵɵprojection(5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("hidden", ctx_r0.isHidden);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.hideArrow);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.title);
  }
}
function PoPopoverComponent_ng_template_3_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoPopoverComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoPopoverComponent_ng_template_3_ng_container_0_Template, 1, 0, "ng-container", 10);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopoverContent_r2 = ɵɵreference(2);
    ɵɵproperty("ngTemplateOutlet", sharedPopoverContent_r2);
  }
}
function PoPopoverComponent_ng_template_5_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoPopoverComponent_ng_template_5_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoPopoverComponent_ng_template_5_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 10);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const sharedPopoverContent_r2 = ɵɵreference(2);
    ɵɵproperty("ngTemplateOutlet", sharedPopoverContent_r2);
  }
}
function PoPopoverComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoPopoverComponent_ng_template_5_ng_template_0_Template, 1, 1, "ng-template", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("cdkConnectedOverlayOrigin", ctx_r0.target)("cdkConnectedOverlayOpen", true);
  }
}
var PoPopoverComponent = class _PoPopoverComponent extends PoPopoverBaseComponent {
  renderer;
  poControlPosition;
  popoverElement;
  arrowDirection = "left";
  timeoutResize;
  targetElement;
  eventListenerFunction;
  constructor(renderer, poControlPosition) {
    super();
    this.renderer = renderer;
    this.poControlPosition = poControlPosition;
  }
  ngAfterViewInit() {
    this.targetElement = this.target instanceof ElementRef ? this.target.nativeElement : this.target;
    this.initEventListenerFunction();
    this.setElementsControlPosition();
    this.setRendererListenInit();
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  close() {
    this.isHidden = true;
    this.closePopover.emit();
  }
  debounceResize() {
    clearTimeout(this.timeoutResize);
    this.timeoutResize = setTimeout(() => {
      this.setPopoverPosition();
    }, 200);
  }
  open() {
    this.addScrollEventListener();
    this.isHidden = false;
    this.setOpacity(0);
    setTimeout(() => {
      this.setElementsControlPosition();
      this.setPopoverPosition();
      this.setOpacity(1);
    });
  }
  setOpacity(value) {
    this.popoverElement.nativeElement.style.opacity = value;
  }
  setPopoverPosition() {
    this.poControlPosition.adjustPosition(this.position);
    this.arrowDirection = this.poControlPosition.getArrowDirection();
  }
  setRendererListenInit() {
    this.resizeListener = this.renderer.listen("window", "resize", (event) => {
      if (!this.isHidden) {
        this.debounceResize();
      }
    });
    if (this.trigger === "hover") {
      this.mouseEnterListener = this.renderer.listen(this.targetElement, "mouseenter", (event) => {
        this.open();
      });
      this.mouseLeaveListener = this.renderer.listen(this.targetElement, "mouseleave", (event) => {
        this.close();
      });
    } else {
      this.clickoutListener = this.renderer.listen("document", "click", (event) => {
        this.togglePopup(event);
      });
    }
  }
  togglePopup(event) {
    if (!this.isHidden && !this.popoverElement.nativeElement.contains(event.target) && !this.targetElement.contains(event.target)) {
      this.close();
    } else if (this.targetElement.contains(event.target)) {
      this.popoverElement.nativeElement.hidden ? this.open() : this.close();
    }
  }
  addScrollEventListener() {
    window.addEventListener("scroll", this.eventListenerFunction, true);
  }
  initEventListenerFunction() {
    this.eventListenerFunction = () => {
      this.setPopoverPosition();
    };
  }
  removeListeners() {
    if (this.clickoutListener) {
      this.clickoutListener();
    }
    if (this.mouseEnterListener) {
      this.mouseEnterListener();
    }
    if (this.mouseLeaveListener) {
      this.mouseLeaveListener();
    }
    this.resizeListener();
    window.removeEventListener("scroll", this.eventListenerFunction, true);
  }
  setElementsControlPosition() {
    const popoverOffset = 8;
    this.poControlPosition.setElements(this.popoverElement.nativeElement, popoverOffset, this.target);
  }
  static ɵfac = function PoPopoverComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPopoverComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoControlPositionService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPopoverComponent,
    selectors: [["po-popover"]],
    viewQuery: function PoPopoverComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$14, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popoverElement = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoControlPositionService]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c1$q,
    decls: 7,
    vars: 3,
    consts: [["sharedPopoverContent", ""], ["popoverDefault", ""], ["popoverCDK", ""], ["popoverElement", ""], [4, "ngIf", "ngIfThen", "ngIfElse"], [1, "po-popover", 3, "hidden"], [3, "class", 4, "ngIf"], [1, "po-popover-content"], ["class", "po-popover-title", 4, "ngIf"], [1, "po-popover-title"], [4, "ngTemplateOutlet"], ["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen"]],
    template: function PoPopoverComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, PoPopoverComponent_ng_container_0_Template, 1, 0, "ng-container", 4)(1, PoPopoverComponent_ng_template_1_Template, 6, 3, "ng-template", null, 0, ɵɵtemplateRefExtractor)(3, PoPopoverComponent_ng_template_3_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor)(5, PoPopoverComponent_ng_template_5_Template, 1, 2, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const popoverDefault_r3 = ɵɵreference(4);
        const popoverCDK_r4 = ɵɵreference(6);
        ɵɵproperty("ngIf", ctx.appendBox)("ngIfThen", popoverCDK_r4)("ngIfElse", popoverDefault_r3);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, CdkConnectedOverlay],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopoverComponent, [{
    type: Component,
    args: [{
      selector: "po-popover",
      providers: [PoControlPositionService],
      standalone: false,
      template: '<ng-container *ngIf="appendBox; then popoverCDK; else popoverDefault"> </ng-container>\n\n<ng-template #sharedPopoverContent>\n  <div [hidden]="isHidden" class="po-popover" #popoverElement>\n    <div *ngIf="!hideArrow" class="po-popover-arrow po-arrow-{{ arrowDirection }}"></div>\n\n    <div class="po-popover-content">\n      <span *ngIf="title" class="po-popover-title">{{ title }}</span>\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #popoverDefault>\n  <ng-container *ngTemplateOutlet="sharedPopoverContent"></ng-container>\n</ng-template>\n\n<ng-template #popoverCDK>\n  <ng-template cdkConnectedOverlay [cdkConnectedOverlayOrigin]="target" [cdkConnectedOverlayOpen]="true">\n    <ng-container *ngTemplateOutlet="sharedPopoverContent"></ng-container>\n  </ng-template>\n</ng-template>\n'
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: PoControlPositionService
  }], {
    popoverElement: [{
      type: ViewChild,
      args: ["popoverElement", {
        read: ElementRef,
        static: false
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPopoverComponent, {
    className: "PoPopoverComponent",
    filePath: "lib/components/po-popover/po-popover.component.ts",
    lineNumber: 42
  });
})();
var PoPopoverModule = class _PoPopoverModule {
  static ɵfac = function PoPopoverModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPopoverModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoPopoverModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, OverlayModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopoverModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, OverlayModule],
      declarations: [PoPopoverComponent],
      exports: [PoPopoverComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoPopoverModule, {
    declarations: [PoPopoverComponent],
    imports: [CommonModule, OverlayModule],
    exports: [PoPopoverComponent]
  });
})();
var PoTimePipe = class _PoTimePipe {
  transform(time, format) {
    const hourRegex = /^(([0-1][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9][\.]?([0-9]{1,6})?$/g;
    if (isTypeof(time, "string") && hourRegex.test(time)) {
      const amountOfF = format ? format.lastIndexOf("f") - format.indexOf("f") + 1 : 0;
      const miliseconds = this.addDotMiliseconds(time.substring(9, 9 + amountOfF), amountOfF);
      const formatMiliseconds = this.getFormatMiliseconds(amountOfF);
      return this.formatValue(time, format, formatMiliseconds, miliseconds);
    }
    return null;
  }
  addDotMiliseconds(miliseconds, amountOfF) {
    if (miliseconds && amountOfF) {
      miliseconds = "." + miliseconds;
    }
    return miliseconds;
  }
  formatValue(time, format, formatMiliseconds, miliseconds) {
    if (time && format) {
      const hour = time.substring(0, 2);
      const minutes = time.substring(3, 5);
      const seconds = time.substring(6, 8);
      format = format.replace("HH", hour);
      format = format.replace("mm", minutes);
      format = format.replace("ss", seconds);
      format = format.replace(`.${formatMiliseconds}`, miliseconds);
      return format;
    } else {
      return time;
    }
  }
  getFormatMiliseconds(amountOfF) {
    let formatMiliseconds = "";
    for (let i = 0; i < amountOfF; i++) {
      formatMiliseconds += "f";
    }
    return formatMiliseconds;
  }
  static ɵfac = function PoTimePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTimePipe)();
  };
  static ɵpipe = ɵɵdefinePipe({
    name: "po_time",
    type: _PoTimePipe,
    pure: true,
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTimePipe, [{
    type: Pipe,
    args: [{
      name: "po_time",
      standalone: false
    }]
  }], null, null);
})();
var PoTimeModule = class _PoTimeModule {
  static ɵfac = function PoTimeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTimeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoTimeModule
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTimeModule, [{
    type: NgModule,
    args: [{
      declarations: [PoTimePipe],
      imports: [],
      exports: [PoTimePipe],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTimeModule, {
    declarations: [PoTimePipe],
    exports: [PoTimePipe]
  });
})();
var PoPageSlideBaseComponent = class _PoPageSlideBaseComponent {
  /**
   * @description
   *
   * Título da página.
   */
  title;
  /**
   * @description
   *
   * Subtítulo da página.
   */
  subtitle;
  /**
   * @optional
   *
   * @description
   *
   * Oculta o botão de encerramento da página.
   *
   * Esta opção só é possível se a propriedade `p-click-out` estiver habilitada.
   *
   * @default `false`
   */
  hideClose = false;
  /**
   * @optional
   *
   * @description
   *
   * Define se permite o encerramento da página ao clicar fora da mesma.
   *
   * @default `false`
   */
  clickOut = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite a expansão dinâmica da largura do `po-page-slide` quando `p-size` for `auto` (automático).
   * Propriedade necessária para correto funcionamento da `po-table` dentro do `po-page-slide`
   *
   * @default `false`
   */
  flexibleWidth = false;
  /**
   * @optional
   *
   * @description
   * Evento executado ao fechar o page slide.
   */
  closePageSlide = new EventEmitter();
  // Controla se a página está ou não oculta, por padrão é oculto.
  hidden = true;
  _size = "md";
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho da página.
   *
   * Valores válidos:
   *  - `sm` (pequeno)
   *  - `md` (médio)
   *  - `lg` (grande)
   *  - `xl` (extra-grande)
   *  - `auto` (automático)
   *
   * > Todas as opções de tamanho, exceto `auto`, possuem uma largura máxima de **768px**.
   *
   * @default `md`
   */
  set size(value) {
    const sizes = ["sm", "md", "lg", "xl", "auto"];
    this._size = sizes.indexOf(value) > -1 ? value : "md";
  }
  get size() {
    return this._size;
  }
  /**
   * Ativa a visualização da página.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo
   * ser utilizado o `ViewChild` da seguinte forma:
   *
   * ```typescript
   * import { PoPageSlideComponent } from '@po/ng-components';
   *
   * ...
   *
   * @ViewChild(PoPageSlideComponent, { static: true }) pageSlide: PoPageSlideComponent;
   *
   * public openPage() {
   *   this.pageSlide.open();
   * }
   * ```
   */
  open() {
    if (this.hideClose && !this.clickOut) {
      this.hideClose = false;
    }
    this.hidden = false;
  }
  /**
   * Encerra a visualização da página.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo
   * ser utilizado o `ViewChild` da seguinte forma:
   *
   * ```typescript
   * import { PoPageSlideComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoPageSlideComponent, { static: true }) pageSlide: PoPageSlideComponent;
   *
   * public closePage() {
   *   this.pageSlide.close();
   * }
   * ```
   */
  close() {
    this.hidden = true;
    this.closePageSlide.emit();
  }
  static ɵfac = function PoPageSlideBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageSlideBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoPageSlideBaseComponent,
    inputs: {
      title: [0, "p-title", "title"],
      subtitle: [0, "p-subtitle", "subtitle"],
      hideClose: [2, "p-hide-close", "hideClose", convertToBoolean],
      clickOut: [2, "p-click-out", "clickOut", convertToBoolean],
      flexibleWidth: [2, "p-flexible-width", "flexibleWidth", convertToBoolean],
      size: [0, "p-size", "size"]
    },
    outputs: {
      closePageSlide: "p-close"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageSlideBaseComponent, [{
    type: Directive
  }], null, {
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    subtitle: [{
      type: Input,
      args: ["p-subtitle"]
    }],
    hideClose: [{
      type: Input,
      args: [{
        alias: "p-hide-close",
        transform: convertToBoolean
      }]
    }],
    clickOut: [{
      type: Input,
      args: [{
        alias: "p-click-out",
        transform: convertToBoolean
      }]
    }],
    flexibleWidth: [{
      type: Input,
      args: [{
        alias: "p-flexible-width",
        transform: convertToBoolean
      }]
    }],
    closePageSlide: [{
      type: Output,
      args: ["p-close"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }]
  });
})();
var _c0$13 = ["*"];
var PoPageSlideFooterComponent = class _PoPageSlideFooterComponent {
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o alinhamento padrão, à direita, dos botões de ações que ficam no rodapé da [`PoPageSlide`](/documentation/po-page-slide).
   *
   * > Caso a propriedade esteja habilitada, o alinhamento deverá ser a esquerda e pode ser personalizado.
   *
   * @default false
   */
  disabledAlign = false;
  static ɵfac = function PoPageSlideFooterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageSlideFooterComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPageSlideFooterComponent,
    selectors: [["po-page-slide-footer"]],
    inputs: {
      disabledAlign: [0, "p-disabled-align", "disabledAlign"]
    },
    standalone: false,
    ngContentSelectors: _c0$13,
    decls: 2,
    vars: 2,
    consts: [[1, "po-page-slide-footer"]],
    template: function PoPageSlideFooterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0);
        ɵɵprojection(1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("po-page-slide-footer-align-right", !ctx.disabledAlign);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageSlideFooterComponent, [{
    type: Component,
    args: [{
      selector: "po-page-slide-footer",
      standalone: false,
      template: '<div class="po-page-slide-footer" [class.po-page-slide-footer-align-right]="!disabledAlign">\n  <ng-content></ng-content>\n</div>\n'
    }]
  }], null, {
    disabledAlign: [{
      type: Input,
      args: ["p-disabled-align"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageSlideFooterComponent, {
    className: "PoPageSlideFooterComponent",
    filePath: "lib/components/po-page/po-page-slide/po-page-slide-footer/po-page-slide-footer.component.ts",
    lineNumber: 24
  });
})();
var _c0$12 = ["pageContent"];
var _c1$p = ["*", [["po-page-slide-footer"]]];
var _c2$d = ["*", "po-page-slide-footer"];
var _c3$9 = (a0) => ({
  "width": a0
});
function PoPageSlideComponent_div_0_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.subtitle);
  }
}
function PoPageSlideComponent_div_0_po_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 13);
    ɵɵlistener("p-click", function PoPageSlideComponent_div_0_po_button_10_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-aria-label", ctx_r1.buttonAriaLabel);
  }
}
function PoPageSlideComponent_div_0_div_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 14);
    ɵɵelement(1, "po-divider");
    ɵɵprojection(2, 1);
    ɵɵelementEnd();
  }
}
function PoPageSlideComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 2);
    ɵɵlistener("keydown.esc", function PoPageSlideComponent_div_0_Template_div_keydown_esc_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelementStart(1, "div", 3);
    ɵɵlistener("mousedown", function PoPageSlideComponent_div_0_Template_div_mousedown_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClickOut($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "div", 4)(3, "div", 5, 0)(5, "div", 6)(6, "div", 7)(7, "span");
    ɵɵtext(8);
    ɵɵelementEnd();
    ɵɵtemplate(9, PoPageSlideComponent_div_0_div_9_Template, 2, 1, "div", 8);
    ɵɵelementEnd();
    ɵɵtemplate(10, PoPageSlideComponent_div_0_po_button_10_Template, 1, 1, "po-button", 9);
    ɵɵelementEnd();
    ɵɵelementStart(11, "div", 10);
    ɵɵprojection(12);
    ɵɵelementEnd();
    ɵɵtemplate(13, PoPageSlideComponent_div_0_div_13_Template, 3, 0, "div", 11);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("@fade", ctx_r1.fadeParams);
    ɵɵadvance(2);
    ɵɵclassMapInterpolate1("po-page-slide-container po-page-slide-right po-page-slide-", ctx_r1.size, "");
    ɵɵproperty("@slide", ctx_r1.slideParams)("ngStyle", ɵɵpureFunction1(10, _c3$9, ctx_r1.flexibleWidth ? "" : ctx_r1.size === "auto" ? "auto" : ""));
    ɵɵadvance(6);
    ɵɵtextInterpolate(ctx_r1.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.subtitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hideClose);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r1.pageSlideFooter);
  }
}
var poPageSlideLiteralsDefault = {
  en: {
    close: "Close"
  },
  es: {
    close: "Cerrar"
  },
  pt: {
    close: "Fechar"
  },
  ru: {
    close: "Закрывать"
  }
};
var PoPageSlideComponent = class _PoPageSlideComponent extends PoPageSlideBaseComponent {
  poActiveOverlayService;
  languageService;
  _pageContent;
  firstElement;
  id = uuid();
  loadingCompleted = new ReplaySubject();
  sourceElement;
  buttonAriaLabel;
  duration = "70ms";
  timing = "700ms Cubic-Bezier(0.35, 0, 0.1, 1)";
  focusEvent;
  pageSlideFooter;
  set pageContent(pageContent) {
    if (pageContent) {
      this._pageContent = pageContent;
      this.loadingCompleted.next();
    }
  }
  get pageContent() {
    return this._pageContent;
  }
  constructor(poActiveOverlayService, languageService) {
    super();
    this.poActiveOverlayService = poActiveOverlayService;
    this.languageService = languageService;
    this.setTimeFromCSS();
    this.buttonAriaLabel = this.getTextDefault();
  }
  open() {
    this.sourceElement = document.activeElement;
    super.open();
    this.loadingCompleted.pipe(take(1)).pipe(delay(0)).subscribe(this.handleFocus.bind(this));
  }
  close() {
    this.poActiveOverlayService.activeOverlay.pop();
    super.close();
    this.removeEventListeners();
    this.sourceElement.focus();
  }
  onClickOut(event) {
    if (this.clickOut && !this.pageContent.nativeElement.contains(event.target)) {
      this.close();
    }
  }
  setTimeFromCSS() {
    const rootStyles = getComputedStyle(document.documentElement);
    this.duration = rootStyles.getPropertyValue("--transition-duration").trim();
    this.timing = rootStyles.getPropertyValue("--transition-timing").trim();
  }
  getTextDefault() {
    const language = this.languageService.getShortLanguage();
    return poPageSlideLiteralsDefault[language].close;
  }
  handleFocus() {
    this.poActiveOverlayService.activeOverlay.push(this.id);
    this.loadFirstElement();
    this.initFocus();
    document.addEventListener("focus", this.focusEvent, true);
  }
  initFocus() {
    this.focusEvent = (event) => {
      if (!this.pageContent.nativeElement.contains(event.target) && this.poActiveOverlayService.activeOverlay[this.poActiveOverlayService.activeOverlay.length - 1] === this.id) {
        event.stopPropagation();
        this.firstElement.focus();
      }
    };
    if (this.hideClose) {
      this.firstElement.focus();
    } else {
      const elements = getFocusableElements(this.pageContent.nativeElement);
      const element = elements[0] || this.pageContent.nativeElement;
      element.focus();
    }
  }
  loadFirstElement() {
    this.firstElement = getFocusableElements(this.pageContent.nativeElement)[0] || this.pageContent.nativeElement;
  }
  removeEventListeners() {
    document.removeEventListener("focus", this.focusEvent, true);
    this.loadingCompleted.complete();
  }
  get fadeParams() {
    return {
      value: true,
      params: {
        duration: this.duration || "70ms"
      }
    };
  }
  get slideParams() {
    return {
      value: true,
      params: {
        timing: this.timing || "700ms cubic-bezier(0.35, 0, 0.1, 1)"
      }
    };
  }
  static ɵfac = function PoPageSlideComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageSlideComponent)(ɵɵdirectiveInject(PoActiveOverlayService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPageSlideComponent,
    selectors: [["po-page-slide"]],
    contentQueries: function PoPageSlideComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PoPageSlideFooterComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageSlideFooter = _t.first);
      }
    },
    viewQuery: function PoPageSlideComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$12, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageContent = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c2$d,
    decls: 1,
    vars: 1,
    consts: [["pageContent", ""], ["class", "po-page-slide", "tabindex", "0", 3, "keydown.esc", 4, "ngIf"], ["tabindex", "0", 1, "po-page-slide", 3, "keydown.esc"], [1, "po-page-slide-overlay", 3, "mousedown"], [3, "ngStyle"], ["tabindex", "-1", 1, "po-page-slide-content"], [1, "po-page-slide-header"], [1, "po-page-slide-title"], ["class", "po-page-slide-subtitle", 4, "ngIf"], ["p-icon", "ICON_CLOSE", "p-kind", "tertiary", 3, "p-aria-label", "p-click", 4, "ngIf"], [1, "po-page-slide-body"], ["class", "po-page-slide-footer-content", 4, "ngIf"], [1, "po-page-slide-subtitle"], ["p-icon", "ICON_CLOSE", "p-kind", "tertiary", 3, "p-click", "p-aria-label"], [1, "po-page-slide-footer-content"]],
    template: function PoPageSlideComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c1$p);
        ɵɵtemplate(0, PoPageSlideComponent_div_0_Template, 14, 12, "div", 1);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.hidden);
      }
    },
    dependencies: [NgIf, NgStyle, PoButtonComponent, PoDividerComponent],
    encapsulation: 2,
    data: {
      animation: [trigger("fade", [transition(":enter", [style({
        opacity: 0
      }), group([animate(`{{duration}}`, style({
        opacity: 1
      })), query("@slide", animateChild())])]), transition(":leave", group([query("@slide", animateChild()), animate("150ms", style({
        opacity: 0
      }))]))]), trigger("slide", [transition(":enter", [style({
        transform: "translateX(50px)"
      }), animate(`{{timing }}`, style({
        transform: "none"
      }))]), transition(":leave", [animate("150ms", style({
        transform: "translateX(50px)"
      }))])])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageSlideComponent, [{
    type: Component,
    args: [{
      selector: "po-page-slide",
      providers: [],
      animations: [trigger("fade", [transition(":enter", [style({
        opacity: 0
      }), group([animate(`{{duration}}`, style({
        opacity: 1
      })), query("@slide", animateChild())])]), transition(":leave", group([query("@slide", animateChild()), animate("150ms", style({
        opacity: 0
      }))]))]), trigger("slide", [transition(":enter", [style({
        transform: "translateX(50px)"
      }), animate(`{{timing }}`, style({
        transform: "none"
      }))]), transition(":leave", [animate("150ms", style({
        transform: "translateX(50px)"
      }))])])],
      standalone: false,
      template: `<div class="po-page-slide" tabindex="0" (keydown.esc)="close()" *ngIf="!hidden" [@fade]="fadeParams">
  <div class="po-page-slide-overlay" (mousedown)="onClickOut($event)"></div>
  <div
    class="po-page-slide-container po-page-slide-right po-page-slide-{{ size }}"
    [@slide]="slideParams"
    [ngStyle]="{ 'width': flexibleWidth ? '' : size === 'auto' ? 'auto' : '' }"
  >
    <div class="po-page-slide-content" tabindex="-1" #pageContent>
      <div class="po-page-slide-header">
        <div class="po-page-slide-title">
          <span>{{ title }}</span>
          <div class="po-page-slide-subtitle" *ngIf="subtitle">{{ subtitle }}</div>
        </div>
        <po-button
          *ngIf="!hideClose"
          p-icon="ICON_CLOSE"
          p-kind="tertiary"
          (p-click)="close()"
          [p-aria-label]="buttonAriaLabel"
        >
        </po-button>
      </div>
      <div class="po-page-slide-body">
        <ng-content></ng-content>
      </div>

      <div class="po-page-slide-footer-content" *ngIf="pageSlideFooter">
        <po-divider></po-divider>
        <ng-content select="po-page-slide-footer"></ng-content>
      </div>
    </div>
  </div>
</div>
`
    }]
  }], () => [{
    type: PoActiveOverlayService
  }, {
    type: PoLanguageService
  }], {
    pageSlideFooter: [{
      type: ContentChild,
      args: [PoPageSlideFooterComponent]
    }],
    pageContent: [{
      type: ViewChild,
      args: ["pageContent", {
        read: ElementRef
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageSlideComponent, {
    className: "PoPageSlideComponent",
    filePath: "lib/components/po-page/po-page-slide/po-page-slide.component.ts",
    lineNumber: 71
  });
})();
var PoPageSlideModule = class _PoPageSlideModule {
  static ɵfac = function PoPageSlideModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageSlideModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoPageSlideModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, PoButtonModule, PoDividerModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageSlideModule, [{
    type: NgModule,
    args: [{
      declarations: [PoPageSlideComponent, PoPageSlideFooterComponent],
      exports: [PoPageSlideComponent, PoPageSlideFooterComponent],
      imports: [CommonModule, FormsModule, PoButtonModule, PoDividerModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoPageSlideModule, {
    declarations: [PoPageSlideComponent, PoPageSlideFooterComponent],
    imports: [CommonModule, FormsModule, PoButtonModule, PoDividerModule],
    exports: [PoPageSlideComponent, PoPageSlideFooterComponent]
  });
})();
var _c0$11 = (a0, a1) => ({
  "po-clickable": a0,
  "po-table-icon-disabled": a1
});
var PoTableIconComponent = class _PoTableIconComponent {
  /** Define se o ícone é clicável. */
  clickable;
  /** Cor do ícone. */
  color;
  /** Desabilitado. */
  disabled;
  /** Classe css do ícone. */
  icon;
  /** Texto do tooltip. */
  iconTooltip;
  /** Output click. */
  click = new EventEmitter();
  tooltip;
  get allowTooltip() {
    return !this.disabled && this.iconTooltip;
  }
  onClick(event) {
    if (this.clickable) {
      this.click.emit(event);
    }
  }
  tooltipMouseEnter() {
    if (this.allowTooltip) {
      this.tooltip = this.iconTooltip;
    }
  }
  tooltipMouseLeave() {
    this.tooltip = void 0;
  }
  static ɵfac = function PoTableIconComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableIconComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTableIconComponent,
    selectors: [["po-table-icon"]],
    inputs: {
      clickable: [0, "p-clickable", "clickable"],
      color: [0, "p-color", "color"],
      disabled: [0, "p-disabled", "disabled"],
      icon: [0, "p-icon", "icon"],
      iconTooltip: [0, "p-icon-tooltip", "iconTooltip"]
    },
    outputs: {
      click: "p-click"
    },
    standalone: false,
    decls: 1,
    vars: 10,
    consts: [[3, "click", "mouseenter", "mouseleave", "ngClass", "p-icon", "p-tooltip", "p-append-in-body"]],
    template: function PoTableIconComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "po-icon", 0);
        ɵɵlistener("click", function PoTableIconComponent_Template_po_icon_click_0_listener($event) {
          return ctx.onClick($event);
        })("mouseenter", function PoTableIconComponent_Template_po_icon_mouseenter_0_listener() {
          return ctx.tooltipMouseEnter();
        })("mouseleave", function PoTableIconComponent_Template_po_icon_mouseleave_0_listener() {
          return ctx.tooltipMouseLeave();
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMapInterpolate1("po-table-icon-content ", ctx.disabled ? "" : ctx.color, "");
        ɵɵproperty("ngClass", ɵɵpureFunction2(7, _c0$11, ctx.clickable, ctx.disabled))("p-icon", ctx.icon)("p-tooltip", ctx.tooltip)("p-append-in-body", true);
      }
    },
    dependencies: [NgClass, PoTooltipDirective, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableIconComponent, [{
    type: Component,
    args: [{
      selector: "po-table-icon",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<po-icon
  class="po-table-icon-content {{ disabled ? '' : color }}"
  [ngClass]="{ 'po-clickable': clickable, 'po-table-icon-disabled': disabled }"
  [p-icon]="icon"
  [p-tooltip]="tooltip"
  [p-append-in-body]="true"
  (click)="onClick($event)"
  (mouseenter)="tooltipMouseEnter()"
  (mouseleave)="tooltipMouseLeave()"
></po-icon>
`
    }]
  }], null, {
    clickable: [{
      type: Input,
      args: ["p-clickable"]
    }],
    color: [{
      type: Input,
      args: ["p-color"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }],
    iconTooltip: [{
      type: Input,
      args: ["p-icon-tooltip"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableIconComponent, {
    className: "PoTableIconComponent",
    filePath: "lib/components/po-table/po-table-icon/po-table-icon.component.ts",
    lineNumber: 16
  });
})();
function PoTableColumnIconComponent_po_table_icon_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-table-icon", 1);
    ɵɵlistener("p-click", function PoTableColumnIconComponent_po_table_icon_0_Template_po_table_icon_p_click_0_listener($event) {
      const column_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.click(column_r2, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-clickable", ctx_r2.isClickable(column_r2))("p-color", ctx_r2.getColor(column_r2))("p-disabled", ctx_r2.isDisabled(column_r2))("p-icon", ctx_r2.getIcon(column_r2))("p-icon-tooltip", column_r2.tooltip);
  }
}
var PoTableColumnIconComponent = class _PoTableColumnIconComponent {
  /** Definição da coluna que utiliza os icones. */
  column;
  /** Dados da linha da tabela. */
  row;
  _icons = [];
  /** Lista de colunas com ícones. */
  set icons(icons) {
    this._icons = this.convertToColumnIcon(icons);
  }
  get icons() {
    return this._icons;
  }
  click(columnIcon, event) {
    const isAbleAction = !this.isDisabled(columnIcon);
    if (isAbleAction) {
      if (columnIcon.action) {
        columnIcon.action(this.row, columnIcon);
      } else if (this.column.action) {
        this.column.action(this.row, columnIcon);
      }
      event.stopPropagation();
    }
  }
  getColor(column) {
    const color = typeof column.color === "function" ? column.color(this.row, column) : column.color;
    if (color) {
      return `po-text-${color}`;
    }
  }
  getIcon(column) {
    return column.icon || column.value;
  }
  isClickable(columnIcon) {
    return !!(!this.isDisabled(columnIcon) && (columnIcon.action || this.column.action));
  }
  isDisabled(column) {
    return column.disabled ? column.disabled(this.row) : false;
  }
  trackByFunction(index) {
    return index;
  }
  convertToColumnIcon(rowIcons) {
    if (Array.isArray(rowIcons)) {
      return rowIcons.map((rowIcon) => typeof rowIcon === "string" ? {
        value: rowIcon
      } : rowIcon);
    }
    if (typeof rowIcons === "string") {
      return [{
        value: rowIcons
      }];
    }
    return [];
  }
  static ɵfac = function PoTableColumnIconComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableColumnIconComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTableColumnIconComponent,
    selectors: [["po-table-column-icon"]],
    inputs: {
      column: [0, "p-column", "column"],
      row: [0, "p-row", "row"],
      icons: [0, "p-icons", "icons"]
    },
    standalone: false,
    decls: 1,
    vars: 2,
    consts: [[3, "p-clickable", "p-color", "p-disabled", "p-icon", "p-icon-tooltip", "p-click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-click", "p-clickable", "p-color", "p-disabled", "p-icon", "p-icon-tooltip"]],
    template: function PoTableColumnIconComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoTableColumnIconComponent_po_table_icon_0_Template, 1, 5, "po-table-icon", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.icons)("ngForTrackBy", ctx.trackByFunction);
      }
    },
    dependencies: [NgForOf, PoTableIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnIconComponent, [{
    type: Component,
    args: [{
      selector: "po-table-column-icon",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<po-table-icon\n  *ngFor="let column of icons; trackBy: trackByFunction"\n  [p-clickable]="isClickable(column)"\n  [p-color]="getColor(column)"\n  [p-disabled]="isDisabled(column)"\n  [p-icon]="getIcon(column)"\n  [p-icon-tooltip]="column.tooltip"\n  (p-click)="click(column, $event)"\n>\n</po-table-icon>\n'
    }]
  }], null, {
    column: [{
      type: Input,
      args: ["p-column"]
    }],
    row: [{
      type: Input,
      args: ["p-row"]
    }],
    icons: [{
      type: Input,
      args: ["p-icons"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableColumnIconComponent, {
    className: "PoTableColumnIconComponent",
    filePath: "lib/components/po-table/po-table-column-icon/po-table-column-icon.component.ts",
    lineNumber: 19
  });
})();
function PoTableColumnLabelComponent_po_tag_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-tag", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-color", ctx_r0.value == null ? null : ctx_r0.value.color)("p-value", ctx_r0.value == null ? null : ctx_r0.value.label)("p-text-color", ctx_r0.value == null ? null : ctx_r0.value.textColor)("p-icon", ctx_r0.value == null ? null : ctx_r0.value.icon)("p-type", ctx_r0.value == null ? null : ctx_r0.value.type);
  }
}
var PoTableColumnLabelComponent = class _PoTableColumnLabelComponent {
  value;
  ngOnInit() {
    this.checkValueHasLabel();
  }
  checkValueHasLabel() {
    return this.value?.label?.trim() ? true : false;
  }
  static ɵfac = function PoTableColumnLabelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableColumnLabelComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTableColumnLabelComponent,
    selectors: [["po-table-column-label"]],
    inputs: {
      value: [0, "p-value", "value"]
    },
    standalone: false,
    decls: 1,
    vars: 1,
    consts: [[3, "p-color", "p-value", "p-text-color", "p-icon", "p-type", 4, "ngIf"], [3, "p-color", "p-value", "p-text-color", "p-icon", "p-type"]],
    template: function PoTableColumnLabelComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoTableColumnLabelComponent_po_tag_0_Template, 1, 5, "po-tag", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.checkValueHasLabel());
      }
    },
    dependencies: [NgIf, PoTagComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnLabelComponent, [{
    type: Component,
    args: [{
      selector: "po-table-column-label",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<po-tag\n  *ngIf="checkValueHasLabel()"\n  [p-color]="value?.color"\n  [p-value]="value?.label"\n  [p-text-color]="value?.textColor"\n  [p-icon]="value?.icon"\n  [p-type]="value?.type"\n>\n</po-tag>\n'
    }]
  }], null, {
    value: [{
      type: Input,
      args: ["p-value"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableColumnLabelComponent, {
    className: "PoTableColumnLabelComponent",
    filePath: "lib/components/po-table/po-table-column-label/po-table-column-label.component.ts",
    lineNumber: 19
  });
})();
var _c0$10 = (a0) => ({
  "po-table-link-disabled": a0
});
function PoTableColumnLinkComponent_po_link_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-link", 4);
    ɵɵlistener("p-action", function PoTableColumnLinkComponent_po_link_2_Template_po_link_p_action_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.action == null ? null : ctx_r1.action(ctx_r1.value, ctx_r1.row));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-label", ctx_r1.value)("p-open-new-tab", ctx_r1.openNewTab);
  }
}
function PoTableColumnLinkComponent_po_link_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-link", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-label", ctx_r1.value)("p-open-new-tab", ctx_r1.openNewTab)("p-url", ctx_r1.link);
  }
}
function PoTableColumnLinkComponent_po_link_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-link", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-label", ctx_r1.value)("p-open-new-tab", ctx_r1.openNewTab)("p-url", ctx_r1.link);
  }
}
var PoTableColumnLinkComponent = class _PoTableColumnLinkComponent {
  action;
  disabled;
  link;
  openNewTab = false;
  row;
  value;
  get type() {
    if (this.action) {
      return "action";
    }
    return isExternalLink(this.link) ? "externalLink" : "internalLink";
  }
  static ɵfac = function PoTableColumnLinkComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableColumnLinkComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTableColumnLinkComponent,
    selectors: [["po-table-column-link"]],
    inputs: {
      action: [0, "p-action", "action"],
      disabled: [0, "p-disabled", "disabled"],
      link: [0, "p-link", "link"],
      openNewTab: [0, "p-open-new-tab", "openNewTab"],
      row: [0, "p-row", "row"],
      value: [0, "p-value", "value"]
    },
    standalone: false,
    decls: 5,
    vars: 7,
    consts: [[1, "po-table-link", 3, "ngClass"], [3, "ngSwitch"], [3, "p-label", "p-open-new-tab", "p-action", 4, "ngSwitchCase"], [3, "p-label", "p-open-new-tab", "p-url", 4, "ngSwitchCase"], [3, "p-action", "p-label", "p-open-new-tab"], [3, "p-label", "p-open-new-tab", "p-url"]],
    template: function PoTableColumnLinkComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵelementContainerStart(1, 1);
        ɵɵtemplate(2, PoTableColumnLinkComponent_po_link_2_Template, 1, 2, "po-link", 2)(3, PoTableColumnLinkComponent_po_link_3_Template, 1, 3, "po-link", 3)(4, PoTableColumnLinkComponent_po_link_4_Template, 1, 3, "po-link", 3);
        ɵɵelementContainerEnd();
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngClass", ɵɵpureFunction1(5, _c0$10, ctx.disabled));
        ɵɵadvance();
        ɵɵproperty("ngSwitch", ctx.type);
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", "action");
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", "externalLink");
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", "internalLink");
      }
    },
    dependencies: [NgClass, NgSwitch, NgSwitchCase, PoLinkComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnLinkComponent, [{
    type: Component,
    args: [{
      selector: "po-table-column-link",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<div class="po-table-link" [ngClass]="{ 'po-table-link-disabled': disabled }">
  <ng-container [ngSwitch]="type">
    <po-link
      *ngSwitchCase="'action'"
      [p-label]="value"
      [p-open-new-tab]="openNewTab"
      (p-action)="action?.(value, row)"
    ></po-link>
    <po-link *ngSwitchCase="'externalLink'" [p-label]="value" [p-open-new-tab]="openNewTab" [p-url]="link"></po-link>
    <po-link *ngSwitchCase="'internalLink'" [p-label]="value" [p-open-new-tab]="openNewTab" [p-url]="link"></po-link>
  </ng-container>
</div>
`
    }]
  }], null, {
    action: [{
      type: Input,
      args: ["p-action"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    link: [{
      type: Input,
      args: ["p-link"]
    }],
    openNewTab: [{
      type: Input,
      args: ["p-open-new-tab"]
    }],
    row: [{
      type: Input,
      args: ["p-row"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableColumnLinkComponent, {
    className: "PoTableColumnLinkComponent",
    filePath: "lib/components/po-table/po-table-column-link/po-table-column-link.component.ts",
    lineNumber: 18
  });
})();
var PoSwitchLabelPosition;
(function(PoSwitchLabelPosition2) {
  PoSwitchLabelPosition2[PoSwitchLabelPosition2["Right"] = 0] = "Right";
  PoSwitchLabelPosition2[PoSwitchLabelPosition2["Left"] = 1] = "Left";
})(PoSwitchLabelPosition || (PoSwitchLabelPosition = {}));
var _c0$$ = ["switchContainer"];
function PoSwitchComponent_po_icon_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 10);
  }
}
function PoSwitchComponent_po_label_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-label", 11);
    ɵɵlistener("click", function PoSwitchComponent_po_label_8_Template_po_label_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.eventClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r2.disabled)("p-label", ctx_r2.value === true ? ctx_r2.labelOn : ctx_r2.labelOff);
  }
}
var PoSwitchComponent = class _PoSwitchComponent extends PoFieldModel {
  changeDetector;
  switchContainer;
  id = `po-switch[${uuid()}]`;
  // Parâmetro interno, não documentar
  value = false;
  _labelOff = "false";
  _labelOn = "true";
  _labelPosition = PoSwitchLabelPosition.Right;
  _formatModel = false;
  /**
   * @optional
   *
   * @description
   *
   * Indica se o `model` receberá o valor formatado pelas propriedades `p-label-on` e `p-label-off` ou
   * apenas o valor puro (sem formatação).
   *
   * > Por padrão será atribuído `false`.
   * @default `false`
   */
  set formatModel(format) {
    this._formatModel = format || false;
  }
  get formatModel() {
    return this._formatModel;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica se o status do `model` será escondido visualmente ao lado do switch.
   *
   * > Por padrão será atribuído `false`.
   * @default `false`
   */
  hideLabelStatus = false;
  /**
   * @optional
   *
   * @description
   *
   * Posição de exibição do rótulo que fica ao lado do switch.
   *
   * > Por padrão exibe à direita.
   */
  set labelPosition(position) {
    this._labelPosition = position in PoSwitchLabelPosition ? parseInt(position, 10) : PoSwitchLabelPosition.Right;
  }
  get labelPosition() {
    return this._labelPosition;
  }
  /**
   * Texto exibido quando o valor do componente for `false`.
   *
   * @default `false`
   */
  set labelOff(label) {
    this._labelOff = label || "false";
  }
  get labelOff() {
    return this._labelOff;
  }
  /**
   * Texto exibido quando o valor do componente for `true`.
   *
   * @default `true`
   */
  set labelOn(label) {
    this._labelOn = label || "true";
  }
  get labelOn() {
    return this._labelOn;
  }
  constructor(changeDetector) {
    super();
    this.changeDetector = changeDetector;
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoSwitchComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoSwitchComponent, { static: true }) switch: PoSwitchComponent;
   *
   * focusSwitch() {
   *   this.switch.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.switchContainer.nativeElement.focus();
    }
  }
  onBlur() {
    this.onTouched?.();
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
  }
  getLabelPosition() {
    switch (this.labelPosition) {
      case PoSwitchLabelPosition.Left:
        return "left";
      case PoSwitchLabelPosition.Right:
        return "right";
      default:
        return "right";
    }
  }
  onKeyDown(event) {
    const isFieldFocused = document.activeElement === this.switchContainer.nativeElement;
    if (event.which === PoKeyCodeEnum.space || event.keyCode === PoKeyCodeEnum.space) {
      event.preventDefault();
      this.eventClick();
    }
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  changeValue(value) {
    if (this.value !== value) {
      this.value = value;
      if (this.formatModel) {
        if (this.value) {
          this.updateModel(this.labelOn);
        } else {
          this.updateModel(this.labelOff);
        }
      } else {
        this.updateModel(value);
      }
      this.emitChange(this.value);
    }
  }
  eventClick() {
    if (!this.disabled) {
      this.changeValue(!this.value);
    }
  }
  onWriteValue(value) {
    if (value !== this.value) {
      if (this.formatModel && !!value) {
        this.value = value.toLowerCase() === this.labelOn.toLowerCase();
      } else {
        this.value = !!value;
      }
      this.changeDetector.markForCheck();
    }
  }
  static ɵfac = function PoSwitchComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSwitchComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoSwitchComponent,
    selectors: [["po-switch"]],
    viewQuery: function PoSwitchComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$$, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.switchContainer = _t.first);
      }
    },
    inputs: {
      value: [2, "p-value", "value", convertToBoolean],
      formatModel: [2, "p-format-model", "formatModel", convertToBoolean],
      hideLabelStatus: [2, "p-hide-label-status", "hideLabelStatus", convertToBoolean],
      labelPosition: [0, "p-label-position", "labelPosition"],
      labelOff: [0, "p-label-off", "labelOff"],
      labelOn: [0, "p-label-on", "labelOn"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoSwitchComponent),
      multi: true
    }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature],
    decls: 10,
    vars: 18,
    consts: [["switchContainer", ""], [3, "p-disabled", "p-id", "p-label"], [1, "po-field-container-content"], [1, "po-switch"], ["role", "switch", 1, "po-switch-container", 3, "blur", "click", "keydown", "id", "tabindex"], [1, "po-switch-track"], [1, "po-switch-toggle"], ["class", "po-switch-icon", "p-icon", "ICON_OK", 4, "ngIf"], ["class", "po-switch-label", 3, "p-disabled", "p-label", "click", 4, "ngIf"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-show-additional-help", "p-show-additional-help-icon"], ["p-icon", "ICON_OK", 1, "po-switch-icon"], [1, "po-switch-label", 3, "click", "p-disabled", "p-label"]],
    template: function PoSwitchComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2)(2, "div", 3)(3, "div", 4, 0);
        ɵɵlistener("blur", function PoSwitchComponent_Template_div_blur_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        })("click", function PoSwitchComponent_Template_div_click_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventClick());
        })("keydown", function PoSwitchComponent_Template_div_keydown_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementStart(5, "div", 5)(6, "div", 6);
        ɵɵtemplate(7, PoSwitchComponent_po_icon_7_Template, 1, 0, "po-icon", 7);
        ɵɵelementEnd()()();
        ɵɵtemplate(8, PoSwitchComponent_po_label_8_Template, 1, 2, "po-label", 8);
        ɵɵelementEnd()();
        ɵɵelementStart(9, "po-field-container-bottom", 9);
        ɵɵlistener("p-additional-help", function PoSwitchComponent_Template_po_field_container_bottom_p_additional_help_9_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.emitAdditionalHelp());
        });
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label);
        ɵɵadvance();
        ɵɵattribute("name", ctx.name);
        ɵɵadvance();
        ɵɵattribute("data-label-position", ctx.getLabelPosition());
        ɵɵadvance();
        ɵɵproperty("id", ctx.id)("tabindex", ctx.disabled ? -1 : 0);
        ɵɵattribute("aria-checked", ctx.value)("aria-disabled", ctx.disabled);
        ɵɵadvance(3);
        ɵɵattribute("aria-label", ctx.value === true ? ctx.labelOn : ctx.labelOff);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.value === true);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.hideLabelStatus);
        ɵɵadvance();
        ɵɵproperty("p-additional-help-tooltip", ctx.getAdditionalHelpTooltip())("p-append-in-body", ctx.appendBox)("p-help", ctx.help)("p-disabled", ctx.disabled)("p-show-additional-help", ctx.displayAdditionalHelp)("p-show-additional-help-icon", ctx.showAdditionalHelpIcon());
      }
    },
    dependencies: [NgIf, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoLabelComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSwitchComponent, [{
    type: Component,
    args: [{
      selector: "po-switch",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoSwitchComponent),
        multi: true
      }],
      standalone: false,
      template: '<po-field-container [p-disabled]="disabled" [p-id]="id" [p-label]="label">\n  <div class="po-field-container-content" [attr.name]="name">\n    <div class="po-switch" [attr.data-label-position]="getLabelPosition()">\n      <div\n        #switchContainer\n        class="po-switch-container"\n        role="switch"\n        [attr.aria-checked]="value"\n        [attr.aria-disabled]="disabled"\n        [id]="id"\n        [tabindex]="disabled ? -1 : 0"\n        (blur)="onBlur()"\n        (click)="eventClick()"\n        (keydown)="onKeyDown($event)"\n      >\n        <div class="po-switch-track">\n          <div class="po-switch-toggle" [attr.aria-label]="value === true ? labelOn : labelOff">\n            <po-icon *ngIf="value === true" class="po-switch-icon" p-icon="ICON_OK"></po-icon>\n          </div>\n        </div>\n      </div>\n\n      <po-label\n        *ngIf="!hideLabelStatus"\n        class="po-switch-label"\n        [p-disabled]="disabled"\n        [p-label]="value === true ? labelOn : labelOff"\n        (click)="eventClick()"\n      >\n      </po-label>\n    </div>\n  </div>\n\n  <po-field-container-bottom\n    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"\n    [p-append-in-body]="appendBox"\n    [p-help]="help"\n    [p-disabled]="disabled"\n    [p-show-additional-help]="displayAdditionalHelp"\n    [p-show-additional-help-icon]="showAdditionalHelpIcon()"\n    (p-additional-help)="emitAdditionalHelp()"\n  ></po-field-container-bottom>\n</po-field-container>\n'
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    switchContainer: [{
      type: ViewChild,
      args: ["switchContainer", {
        static: true
      }]
    }],
    value: [{
      type: Input,
      args: [{
        alias: "p-value",
        transform: convertToBoolean
      }]
    }],
    formatModel: [{
      type: Input,
      args: [{
        alias: "p-format-model",
        transform: convertToBoolean
      }]
    }],
    hideLabelStatus: [{
      type: Input,
      args: [{
        alias: "p-hide-label-status",
        transform: convertToBoolean
      }]
    }],
    labelPosition: [{
      type: Input,
      args: ["p-label-position"]
    }],
    labelOff: [{
      type: Input,
      args: ["p-label-off"]
    }],
    labelOn: [{
      type: Input,
      args: ["p-label-on"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSwitchComponent, {
    className: "PoSwitchComponent",
    filePath: "lib/components/po-field/po-switch/po-switch.component.ts",
    lineNumber: 106
  });
})();
var _c0$_ = (a0) => ({
  $implicit: a0
});
function PoTableListManagerComponent_section_0_ng_container_3_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableListManagerComponent_section_0_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "li", 8);
    ɵɵtemplate(2, PoTableListManagerComponent_section_0_ng_container_3_ng_container_1_ng_container_2_Template, 1, 0, "ng-container", 9);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const option_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    const listItemsManagerDefault_r3 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵclassProp("po-checkbox-group-item-disabled", option_r1.disabled || ctx_r1.disabled);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", listItemsManagerDefault_r3)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c0$_, option_r1));
  }
}
function PoTableListManagerComponent_section_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableListManagerComponent_section_0_ng_container_3_ng_container_1_Template, 3, 6, "ng-container", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const option_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isFixed(option_r1));
  }
}
function PoTableListManagerComponent_section_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "section", 4)(1, "p", 5);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, PoTableListManagerComponent_section_0_ng_container_3_Template, 2, 1, "ng-container", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.literals.fixedColumns);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.checkboxGroupOptionsView)("ngForTrackBy", ctx_r1.trackByFn);
  }
}
function PoTableListManagerComponent_ng_container_4_ng_container_1_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableListManagerComponent_ng_container_4_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableListManagerComponent_ng_container_4_ng_container_1_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const option_r4 = ɵɵnextContext(2).$implicit;
    ɵɵnextContext();
    const listItemsManagerDefault_r3 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", listItemsManagerDefault_r3)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c0$_, option_r4));
  }
}
function PoTableListManagerComponent_ng_container_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "li", 8);
    ɵɵtemplate(2, PoTableListManagerComponent_ng_container_4_ng_container_1_ng_container_2_Template, 2, 4, "ng-container", 7);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const option_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-checkbox-group-item-disabled", option_r4.disabled || ctx_r1.disabled);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isFixed(option_r4));
  }
}
function PoTableListManagerComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableListManagerComponent_ng_container_4_ng_container_1_Template, 3, 3, "ng-container", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const option_r4 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isFixed(option_r4));
  }
}
function PoTableListManagerComponent_ng_template_5_po_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 18);
    ɵɵlistener("p-click", function PoTableListManagerComponent_ng_template_5_po_button_6_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r7);
      const option_r6 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitFixed(option_r6));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r6 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    const templateIconNotFixed_r8 = ɵɵreference(8);
    const templateIconFixed_r9 = ɵɵreference(10);
    ɵɵproperty("p-icon", ctx_r1.isFixed(option_r6) ? templateIconFixed_r9 : templateIconNotFixed_r8)("p-disabled", !option_r6.visible || ctx_r1.checksIfHasFiveFixed(option_r6));
  }
}
function PoTableListManagerComponent_ng_template_5_po_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 18);
    ɵɵlistener("p-click", function PoTableListManagerComponent_ng_template_5_po_button_7_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r10);
      const option_r6 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitFixed(option_r6));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r6 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-icon", ctx_r1.isFixed(option_r6) ? "ICON_PUSH_PIN_SLASH" : "ICON_PUSH_PIN")("p-disabled", !option_r6.visible || ctx_r1.checksIfHasFiveFixed(option_r6));
  }
}
function PoTableListManagerComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10)(1, "div", 11)(2, "po-switch", 12);
    ɵɵlistener("p-change", function PoTableListManagerComponent_ng_template_5_Template_po_switch_p_change_2_listener() {
      const option_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clickSwitch(option_r6));
    })("keydown", function PoTableListManagerComponent_ng_template_5_Template_po_switch_keydown_2_listener($event) {
      const option_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onKeyDown($event, option_r6));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 13);
    ɵɵtext(4);
    ɵɵelementEnd()();
    ɵɵelementStart(5, "div", 14);
    ɵɵtemplate(6, PoTableListManagerComponent_ng_template_5_po_button_6_Template, 1, 2, "po-button", 15)(7, PoTableListManagerComponent_ng_template_5_po_button_7_Template, 1, 2, "po-button", 15);
    ɵɵelementStart(8, "po-button", 16);
    ɵɵlistener("p-click", function PoTableListManagerComponent_ng_template_5_Template_po_button_p_click_8_listener() {
      const option_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitChangePosition(option_r6, "up"));
    });
    ɵɵelementEnd();
    ɵɵelementStart(9, "po-button", 17);
    ɵɵlistener("p-click", function PoTableListManagerComponent_ng_template_5_Template_po_button_p_click_9_listener() {
      const option_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitChangePosition(option_r6, "down"));
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const option_r6 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("p-disabled", option_r6.disabled || ctx_r1.disabled || ctx_r1.isFixed(option_r6))("p-value", ctx_r1.checkedOptions[option_r6.value])("p-hide-label-status", true);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", option_r6.label, " ");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r1.hideActionFixedColumns && ctx_r1.iconNameLib === "PoIcon");
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hideActionFixedColumns && ctx_r1.iconNameLib === "AnimaliaIcon");
    ɵɵadvance();
    ɵɵproperty("p-tooltip", ctx_r1.literals.up)("p-disabled", ctx_r1.verifyArrowDisabled(option_r6, "up") || ctx_r1.isFixed(option_r6));
    ɵɵadvance();
    ɵɵproperty("p-tooltip", ctx_r1.literals.down)("p-disabled", ctx_r1.verifyArrowDisabled(option_r6, "down") || ctx_r1.isFixed(option_r6));
  }
}
function PoTableListManagerComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 19)(1, "g", 20);
    ɵɵelement(2, "path", 21);
    ɵɵelementEnd();
    ɵɵelementStart(3, "defs")(4, "clipPath", 22);
    ɵɵelement(5, "rect", 23);
    ɵɵelementEnd()()();
  }
}
function PoTableListManagerComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 19)(1, "g", 24);
    ɵɵelement(2, "path", 25);
    ɵɵelementEnd();
    ɵɵelementStart(3, "defs")(4, "clipPath", 26);
    ɵɵelement(5, "rect", 27);
    ɵɵelementEnd()()();
  }
}
var poTableListManagerLiterals = {
  en: {
    up: "up",
    down: "down",
    otherColumns: "Other columns",
    fixedColumns: "Fixed"
  },
  es: {
    up: "arriba",
    down: "abajo",
    otherColumns: "Otras columnas",
    fixedColumns: "Fijado"
  },
  pt: {
    up: "acima",
    down: "abaixo",
    otherColumns: "Outras colunas",
    fixedColumns: "Fixo"
  },
  ru: {
    up: "вверх",
    down: "вниз",
    otherColumns: "Другие столбцы",
    fixedColumns: "зафиксированный"
  }
};
var PoTableListManagerComponent = class _PoTableListManagerComponent extends PoCheckboxGroupComponent {
  _iconToken;
  changePosition = new EventEmitter();
  changeColumnFixed = new EventEmitter();
  columnsManager;
  hideActionFixedColumns = false;
  literals;
  get iconNameLib() {
    return this._iconToken.NAME_LIB;
  }
  constructor(languageService, changeDetector, value) {
    super(changeDetector);
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues(__spreadValues({}, poTableListManagerLiterals[poLocaleDefault]), poTableListManagerLiterals[language]);
    this._iconToken = value ?? AnimaliaIconDictionary;
  }
  emitChangePosition(option, direction) {
    if (!this.isFixed(option)) {
      const infoPosition = {
        option,
        direction
      };
      const hasDisabled = this.verifyArrowDisabled(option, direction);
      if (!hasDisabled) {
        this.changePosition.emit(infoPosition);
      }
    }
  }
  verifyArrowDisabled(option, direction) {
    const index = this.columnsManager.findIndex((el) => el.property === option.value);
    const existsDetail = this.columnsManager.some(function(el) {
      return el.property === "detail";
    });
    const valueSubtraction = existsDetail ? 2 : 1;
    if (index === 0 && direction === "up") {
      return true;
    }
    if (index !== 0 && direction === "up" && this.columnsManager[index - 1].fixed) {
      return true;
    }
    if (index === this.columnsManager.length - valueSubtraction && direction === "down") {
      return true;
    }
    return false;
  }
  emitFixed(option) {
    if (option.visible) {
      const index = this.columnsManager.findIndex((el) => el.property === option.value);
      if (this.columnsManager[index].fixed === null || this.columnsManager[index].fixed === void 0 || this.columnsManager[index].fixed === false) {
        this.columnsManager[index].fixed = true;
        option.fixed = true;
      } else {
        this.columnsManager[index].fixed = false;
        option.fixed = false;
      }
      this.changeColumnFixed.emit(option);
    }
  }
  isFixed(option) {
    const index = this.columnsManager.findIndex((el) => el.property === option.value);
    if (this.columnsManager[index].fixed === true) {
      return true;
    }
    return false;
  }
  existedFixedItem() {
    return this.columnsManager.some((option) => option["fixed"] === true);
  }
  checksIfHasFiveFixed(option) {
    const isMoreThanFive = this.columnsManager.filter((item) => item.fixed === true).length > 4;
    const isNotFixed = !this.isFixed(option);
    return isMoreThanFive && isNotFixed;
  }
  clickSwitch(option) {
    this.checkOption(option);
  }
  static ɵfac = function PoTableListManagerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableListManagerComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ICONS_DICTIONARY, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTableListManagerComponent,
    selectors: [["po-table-list-manager"]],
    inputs: {
      columnsManager: [0, "p-columns-manager", "columnsManager"],
      hideActionFixedColumns: [2, "p-hide-action-fixed-columns", "hideActionFixedColumns", convertToBoolean]
    },
    outputs: {
      changePosition: "p-change-position",
      changeColumnFixed: "p-change-fixed"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoTableListManagerComponent),
      multi: true
    }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature],
    decls: 11,
    vars: 4,
    consts: [["listItemsManagerDefault", ""], ["templateIconNotFixed", ""], ["templateIconFixed", ""], ["class", "po-table-list-manager-section", 4, "ngIf"], [1, "po-table-list-manager-section"], [1, "po-table-list-manager-title-group-items"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], [1, "po-table-list-manager-container"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "po-table-list-manager-item"], [1, "po-table-list-manager-item-switch"], ["name", "switch", 3, "p-change", "keydown", "p-disabled", "p-value", "p-hide-label-status"], [1, "po-table-list-manager-item-text"], [1, "po-table-list-manager-item-buttons"], [3, "p-icon", "p-disabled", "p-click", 4, "ngIf"], ["p-tooltip-position", "left", "p-icon", "ICON_ARROW_UP", 3, "p-click", "p-tooltip", "p-disabled"], ["p-tooltip-position", "top", "p-icon", "ICON_ARROW_DOWN", 3, "p-click", "p-tooltip", "p-disabled"], [3, "p-click", "p-icon", "p-disabled"], ["xmlns", "http://www.w3.org/2000/svg", "width", "24", "height", "24", "viewBox", "0 0 24 24", "fill", "none"], ["clip-path", "url(#clip0_12562_15948)"], ["d", "M13.7143 5.71429V10C13.7143 10.96 14.0314 11.8514 14.5714 12.5714H9.42857C9.98571 11.8343 10.2857 10.9429 10.2857 10V5.71429H13.7143ZM16.2857 4H7.71429C7.24286 4 6.85714 4.38571 6.85714 4.85714C6.85714 5.32857 7.24286 5.71429 7.71429 5.71429H8.57143V10C8.57143 11.4229 7.42286 12.5714 6 12.5714V14.2857H11.1171V20.2857L11.9743 21.1429L12.8314 20.2857V14.2857H18V12.5714C16.5771 12.5714 15.4286 11.4229 15.4286 10V5.71429H16.2857C16.7571 5.71429 17.1429 5.32857 17.1429 4.85714C17.1429 4.38571 16.7571 4 16.2857 4Z", "fill", "black"], ["id", "clip0_12562_15948"], ["width", "24", "height", "24", "fill", "white"], ["clip-path", "url(#clip0_12562_17487)"], ["d", "M16.2857 4H7.71429C7.24286 4 6.85714 4.38571 6.85714 4.85714C6.85714 5.32857 7.24286 5.71429 7.71429 5.71429H8.57143V10C8.57143 11.4229 7.42286 12.5714 6 12.5714V14.2857H11.1171V20.2857L11.9743 21.1429L12.8314 20.2857V14.2857H18V12.5714C16.5771 12.5714 15.4286 11.4229 15.4286 10V5.71429H16.2857C16.7571 5.71429 17.1429 5.32857 17.1429 4.85714C17.1429 4.38571 16.7571 4 16.2857 4Z", "fill", "#B4B4C0"], ["id", "clip0_12562_17487"], ["width", "24", "height", "24", "fill", "black"]],
    template: function PoTableListManagerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoTableListManagerComponent_section_0_Template, 4, 3, "section", 3);
        ɵɵelementStart(1, "section", 4)(2, "p", 5);
        ɵɵtext(3);
        ɵɵelementEnd();
        ɵɵtemplate(4, PoTableListManagerComponent_ng_container_4_Template, 2, 1, "ng-container", 6);
        ɵɵelementEnd();
        ɵɵtemplate(5, PoTableListManagerComponent_ng_template_5_Template, 10, 10, "ng-template", null, 0, ɵɵtemplateRefExtractor)(7, PoTableListManagerComponent_ng_template_7_Template, 6, 0, "ng-template", null, 1, ɵɵtemplateRefExtractor)(9, PoTableListManagerComponent_ng_template_9_Template, 6, 0, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.existedFixedItem());
        ɵɵadvance(3);
        ɵɵtextInterpolate(ctx.literals.otherColumns);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.checkboxGroupOptionsView)("ngForTrackBy", ctx.trackByFn);
      }
    },
    dependencies: [NgForOf, NgIf, NgTemplateOutlet, PoButtonComponent, PoTooltipDirective, PoSwitchComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableListManagerComponent, [{
    type: Component,
    args: [{
      selector: "po-table-list-manager",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoTableListManagerComponent),
        multi: true
      }],
      standalone: false,
      template: `<section class="po-table-list-manager-section" *ngIf="existedFixedItem()">
  <p class="po-table-list-manager-title-group-items">{{ literals.fixedColumns }}</p>
  <ng-container *ngFor="let option of checkboxGroupOptionsView; trackBy: trackByFn">
    <ng-container *ngIf="isFixed(option)">
      <li class="po-table-list-manager-container" [class.po-checkbox-group-item-disabled]="option.disabled || disabled">
        <ng-container *ngTemplateOutlet="listItemsManagerDefault; context: { $implicit: option }"></ng-container>
      </li>
    </ng-container>
  </ng-container>
</section>

<section class="po-table-list-manager-section">
  <p class="po-table-list-manager-title-group-items">{{ literals.otherColumns }}</p>
  <ng-container *ngFor="let option of checkboxGroupOptionsView; trackBy: trackByFn">
    <ng-container *ngIf="!isFixed(option)">
      <li class="po-table-list-manager-container" [class.po-checkbox-group-item-disabled]="option.disabled || disabled">
        <ng-container *ngIf="!isFixed(option)">
          <ng-container *ngTemplateOutlet="listItemsManagerDefault; context: { $implicit: option }"></ng-container>
        </ng-container>
      </li>
    </ng-container>
  </ng-container>
</section>

<ng-template #listItemsManagerDefault let-option>
  <div class="po-table-list-manager-item">
    <div class="po-table-list-manager-item-switch">
      <po-switch
        name="switch"
        (p-change)="clickSwitch(option)"
        (keydown)="onKeyDown($event, option)"
        [p-disabled]="option.disabled || disabled || isFixed(option)"
        [p-value]="checkedOptions[option.value]"
        [p-hide-label-status]="true"
      >
      </po-switch>
      <span class="po-table-list-manager-item-text">
        {{ option.label }}
      </span>
    </div>

    <div class="po-table-list-manager-item-buttons">
      <po-button
        *ngIf="!hideActionFixedColumns && iconNameLib === 'PoIcon'"
        [p-icon]="isFixed(option) ? templateIconFixed : templateIconNotFixed"
        (p-click)="emitFixed(option)"
        [p-disabled]="!option.visible || checksIfHasFiveFixed(option)"
      >
      </po-button>

      <po-button
        *ngIf="!hideActionFixedColumns && iconNameLib === 'AnimaliaIcon'"
        [p-icon]="isFixed(option) ? 'ICON_PUSH_PIN_SLASH' : 'ICON_PUSH_PIN'"
        (p-click)="emitFixed(option)"
        [p-disabled]="!option.visible || checksIfHasFiveFixed(option)"
      >
      </po-button>

      <po-button
        [p-tooltip]="literals.up"
        p-tooltip-position="left"
        p-icon="ICON_ARROW_UP"
        [p-disabled]="verifyArrowDisabled(option, 'up') || isFixed(option)"
        (p-click)="emitChangePosition(option, 'up')"
      >
      </po-button>

      <po-button
        [p-tooltip]="literals.down"
        p-tooltip-position="top"
        p-icon="ICON_ARROW_DOWN"
        [p-disabled]="verifyArrowDisabled(option, 'down') || isFixed(option)"
        (p-click)="emitChangePosition(option, 'down')"
      >
      </po-button>
    </div>
  </div>
</ng-template>

<ng-template #templateIconNotFixed>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
    <g clip-path="url(#clip0_12562_15948)">
      <path
        d="M13.7143 5.71429V10C13.7143 10.96 14.0314 11.8514 14.5714 12.5714H9.42857C9.98571 11.8343 10.2857 10.9429 10.2857 10V5.71429H13.7143ZM16.2857 4H7.71429C7.24286 4 6.85714 4.38571 6.85714 4.85714C6.85714 5.32857 7.24286 5.71429 7.71429 5.71429H8.57143V10C8.57143 11.4229 7.42286 12.5714 6 12.5714V14.2857H11.1171V20.2857L11.9743 21.1429L12.8314 20.2857V14.2857H18V12.5714C16.5771 12.5714 15.4286 11.4229 15.4286 10V5.71429H16.2857C16.7571 5.71429 17.1429 5.32857 17.1429 4.85714C17.1429 4.38571 16.7571 4 16.2857 4Z"
        fill="black"
      />
    </g>
    <defs>
      <clipPath id="clip0_12562_15948">
        <rect width="24" height="24" fill="white" />
      </clipPath>
    </defs>
  </svg>
</ng-template>

<ng-template #templateIconFixed>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
    <g clip-path="url(#clip0_12562_17487)">
      <path
        d="M16.2857 4H7.71429C7.24286 4 6.85714 4.38571 6.85714 4.85714C6.85714 5.32857 7.24286 5.71429 7.71429 5.71429H8.57143V10C8.57143 11.4229 7.42286 12.5714 6 12.5714V14.2857H11.1171V20.2857L11.9743 21.1429L12.8314 20.2857V14.2857H18V12.5714C16.5771 12.5714 15.4286 11.4229 15.4286 10V5.71429H16.2857C16.7571 5.71429 17.1429 5.32857 17.1429 4.85714C17.1429 4.38571 16.7571 4 16.2857 4Z"
        fill="#B4B4C0"
      />
    </g>
    <defs>
      <clipPath id="clip0_12562_17487">
        <rect width="24" height="24" fill="black" />
      </clipPath>
    </defs>
  </svg>
</ng-template>
`
    }]
  }], () => [{
    type: PoLanguageService
  }, {
    type: ChangeDetectorRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ICONS_DICTIONARY]
    }]
  }], {
    changePosition: [{
      type: Output,
      args: ["p-change-position"]
    }],
    changeColumnFixed: [{
      type: Output,
      args: ["p-change-fixed"]
    }],
    columnsManager: [{
      type: Input,
      args: ["p-columns-manager"]
    }],
    hideActionFixedColumns: [{
      type: Input,
      args: [{
        alias: "p-hide-action-fixed-columns",
        transform: convertToBoolean
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableListManagerComponent, {
    className: "PoTableListManagerComponent",
    filePath: "lib/components/po-table/po-table-list-manager/po-table-list-manager.component.ts",
    lineNumber: 52
  });
})();
var _c0$Z = ["pageSlideColumnsManager"];
var PoTableColumnManagerMaxColumnsDefault = 99999;
var poTableColumnManagerLiteralsDefault = {
  en: {
    columnsManager: "Columns manager",
    restoreDefault: "Restore default"
  },
  es: {
    columnsManager: "Gerente de columna",
    restoreDefault: "Restaurar por defecto"
  },
  pt: {
    columnsManager: "Gerenciador de colunas",
    restoreDefault: "Restaurar padrão"
  },
  ru: {
    columnsManager: "менеджер колонок",
    restoreDefault: "сброс настроек"
  }
};
var PoTableColumnManagerComponent = class _PoTableColumnManagerComponent {
  renderer;
  popover;
  pageSlideColumnsManager;
  columns = [];
  target;
  colunsDefault;
  lastVisibleColumnsSelected = [];
  visibleColumnsChange = new EventEmitter();
  // Evento disparado ao fechar o popover do gerenciador de colunas após alterar as colunas visíveis.
  // O po-table envia como parâmetro um array de string com as colunas visíveis atualizadas. Por exemplo: ["idCard", "name", "hireStatus", "age"].
  changeVisibleColumns = new EventEmitter();
  initialColumns = new EventEmitter();
  hideActionFixedColumns = false;
  literals;
  columnsOptions = [];
  visibleColumns = [];
  columnUpdate;
  _maxColumns = PoTableColumnManagerMaxColumnsDefault;
  defaultColumns = [];
  resizeListener;
  restoreDefaultEvent;
  lastEmittedValue;
  minColumns = 1;
  set maxColumns(value) {
    this._maxColumns = convertToInt(value, PoTableColumnManagerMaxColumnsDefault);
  }
  get maxColumns() {
    return this._maxColumns;
  }
  constructor(renderer, languageService) {
    this.renderer = renderer;
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues(__spreadValues({}, poTableColumnManagerLiteralsDefault[poLocaleDefault]), poTableColumnManagerLiteralsDefault[language]);
  }
  ngOnChanges(changes) {
    const {
      columns,
      maxColumns,
      target,
      lastVisibleColumnsSelected
    } = changes;
    if (target && target.firstChange) {
      this.initializeListeners();
    }
    if (columns) {
      this.onChangeColumns(columns);
    }
    if (maxColumns) {
      this.updateValues(this.columns);
    }
    if (lastVisibleColumnsSelected?.currentValue) {
      this.pageSlideColumnsManager.open();
    }
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  // aqui chegam os eventos do checkbox e do close do popover que também é disparado no resize
  checkChanges(event = [], emit = false) {
    this.verifyToEmitChange(event);
    if (emit) {
      this.verifyToEmitVisibleColumns();
    }
  }
  restore() {
    this.restoreDefaultEvent = true;
    this.defaultColumns = this.removePropertyFixed(this.defaultColumns);
    const defaultColumns = this.getVisibleColumns(this.defaultColumns);
    this.initialColumns.emit(this.getVisibleColumns(this.colunsDefault));
    this.checkChanges(defaultColumns, this.restoreDefaultEvent);
  }
  changePosition({
    option,
    direction
  }) {
    const indexColumn = this.columns.findIndex((el) => el.property === option.value);
    const newColumn = [...this.columns];
    this.changePositionColumn(newColumn, indexColumn, direction);
    this.columns = newColumn;
    this.visibleColumnsChange.emit(this.columns);
  }
  emitColumnFixed(option) {
    const newColumn = [...this.columns];
    if (option) {
      newColumn.forEach((itemColumn) => {
        if (itemColumn.property === option.value) {
          itemColumn.fixed = option.fixed;
        }
      });
      const amountOfFixed = newColumn.filter((itemFixed) => itemFixed.fixed === true).length;
      const indexColumn = newColumn.findIndex((el) => el.property === option.value);
      const item = newColumn.splice(indexColumn, 1)[0];
      if (option.fixed) {
        newColumn.splice(amountOfFixed - 1, 0, item);
      }
      if (option.fixed === false) {
        newColumn.splice(amountOfFixed, 0, item);
      }
      this.columns = [...newColumn];
    }
    this.visibleColumnsChange.emit(newColumn);
  }
  changePositionColumn(array, index, direction) {
    if (direction === "up") {
      array.splice(index, 0, array.splice(index - 1, 1)[0]);
    }
    if (direction === "down") {
      array.splice(index, 0, array.splice(index + 1, 1)[0]);
    }
  }
  verifyToEmitChange(event) {
    const newColumns = [...event];
    if (newColumns.length >= 1 && this.allowsChangeVisibleColumns()) {
      this.emitChangesToSelectedColumns(newColumns);
    }
    if (newColumns.length === 1) {
      const columnsOptions = this.mapTableColumnsToCheckboxOptions(this.columnUpdate);
      this.columnsOptions = this.disabledLastColumn(columnsOptions);
    }
  }
  emitChangesToSelectedColumns(newColumns) {
    this.visibleColumns = [...newColumns];
    const visibleTableColumns = this.getVisibleTableColumns(this.visibleColumns);
    this.visibleColumnsChange.emit(visibleTableColumns);
  }
  allowsChangeVisibleColumns() {
    const visibleTableColumns = this.getVisibleTableColumns(this.visibleColumns);
    return this.stringify(visibleTableColumns) !== this.stringify(this.columns);
  }
  verifyToEmitVisibleColumns() {
    if (this.restoreDefaultEvent) {
      this.verifyRestoreValues();
    } else {
      this.verifyOnClose();
    }
  }
  verifyRestoreValues() {
    const defaultColumns = [...this.defaultColumns];
    const defaultVisibleColumns = this.getVisibleColumns(defaultColumns);
    if (this.allowsChangeSelectedColumns(defaultVisibleColumns)) {
      this.visibleColumnsChange.emit(this.defaultColumns);
    }
    this.restoreDefaultEvent = false;
  }
  allowsChangeSelectedColumns(defaultVisibleColumns) {
    const visibleColumns = this.getVisibleColumns(this.columns);
    return !this.isEqualArrays(defaultVisibleColumns, visibleColumns);
  }
  verifyOnClose() {
    if (this.allowsEmission()) {
      this.emitVisibleColumns();
    }
  }
  emitVisibleColumns() {
    this.lastEmittedValue = [...this.visibleColumns];
    this.changeVisibleColumns.emit(this.visibleColumns);
  }
  allowsEmission() {
    const updatedVisibleColumns = this.visibleColumns ? [...this.visibleColumns] : [];
    const lastEmittedValue = this.lastEmittedValue ? [...this.lastEmittedValue] : [];
    const lastVisibleColumnsSelected = this.lastVisibleColumnsSelected ? [...this.lastVisibleColumnsSelected] : [];
    const lastVisibleColumns = this.getVisibleColumns(lastVisibleColumnsSelected);
    return this.isUpdate(updatedVisibleColumns, lastEmittedValue) || this.isFirstTime(updatedVisibleColumns, lastVisibleColumns);
  }
  isFirstTime(updatedVisibleColumns, lastVisibleColumns) {
    return !this.lastEmittedValue && !this.isEqualArrays(updatedVisibleColumns, lastVisibleColumns);
  }
  isUpdate(updatedVisibleColumns, lastEmittedValue) {
    return this.lastEmittedValue && !this.isEqualArrays(updatedVisibleColumns, lastEmittedValue);
  }
  isEqualArrays(first, second) {
    const one = first ? [...first] : [];
    const two = second ? [...second] : [];
    const firstSort = one.slice();
    const secondSort = two.slice();
    const firstString = JSON.stringify(firstSort);
    const secondString = JSON.stringify(secondSort);
    return firstString === secondString;
  }
  // desabilitará as colunas, que não estiverem selecionadas, após exeder o numero maximo de colunas.
  disableColumnsOptions(columns = []) {
    return columns.map((column) => __spreadProps(__spreadValues({}, column), {
      disabled: this.isDisableColumn(column.value)
    }));
  }
  getColumnTitleLabel(column) {
    return column.label || capitalizeFirstLetter(column.property);
  }
  /** Retorna um Array de column.property das colunas que são visiveis. */
  getVisibleColumns(columns) {
    let visibleColumns = [];
    columns.forEach((column) => {
      if (this.isVisibleColumn(column, visibleColumns)) {
        visibleColumns = [...visibleColumns, column.property];
      }
    });
    return visibleColumns;
  }
  isVisibleColumn(column, visibleColumns) {
    return column.visible !== false && visibleColumns.length < this.maxColumns && column.type !== "detail";
  }
  /** Retorna um Array PoTableColumn a partir das colunas visiveis no gerenciador de colunas. */
  getVisibleTableColumns(visibleColumns) {
    const columns = this.columns ? [...this.columns] : [];
    return columns.map((column) => __spreadProps(__spreadValues({}, column), {
      visible: visibleColumns.includes(column.property) || column.type === "detail"
    }));
  }
  initializeListeners() {
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      if (this.popover && !this.popover.isHidden) {
        this.popover.close();
      }
    });
  }
  isDisableColumn(property) {
    return this.visibleColumns.length >= this.maxColumns ? !this.visibleColumns.includes(property) : false;
  }
  mapTableColumnsToCheckboxOptions(columns = []) {
    const tableColumns = [...columns];
    const columnsOptions = [];
    tableColumns.forEach((column) => {
      if (column.type !== "detail") {
        columnsOptions.push({
          value: column.property,
          label: this.getColumnTitleLabel(column),
          disabled: this.isDisableColumn(column.property),
          visible: column.visible
        });
      }
    });
    return columnsOptions;
  }
  disabledLastColumn(columns) {
    return columns.map((column) => __spreadProps(__spreadValues({}, column), {
      disabled: column.type !== "detail" && column.visible ? true : false
    }));
  }
  onChangeColumns(columns) {
    const {
      currentValue = [],
      previousValue = []
    } = columns;
    this.columnUpdate = columns.currentValue;
    if (!this.lastVisibleColumnsSelected && this.stringify(this.defaultColumns) !== this.stringify(currentValue)) {
      this.defaultColumns = [...currentValue];
    }
    if (this.stringify(previousValue) !== this.stringify(currentValue)) {
      this.updateValues(currentValue);
    }
  }
  updateValues(currentValue) {
    const visibleColumns = this.getVisibleColumns(currentValue);
    this.visibleColumns = [...visibleColumns];
    const columnsOptions = this.mapTableColumnsToCheckboxOptions(currentValue);
    this.columnsOptions = this.disableColumnsOptions(columnsOptions);
    this.checkChanges(visibleColumns, false);
  }
  removeListeners() {
    if (this.resizeListener) {
      this.resizeListener();
    }
  }
  stringify(columns) {
    return JSON.stringify(columns, (key, value) => {
      if (key !== "icon" && key !== "searchService") {
        return value;
      }
    });
  }
  removePropertyFixed(arr) {
    return arr.map((obj) => {
      if (obj.hasOwnProperty("fixed")) {
        obj.fixed = false;
      }
      return obj;
    });
  }
  static ɵfac = function PoTableColumnManagerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableColumnManagerComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTableColumnManagerComponent,
    selectors: [["po-table-column-manager"]],
    viewQuery: function PoTableColumnManagerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoPopoverComponent, 5);
        ɵɵviewQuery(_c0$Z, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popover = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageSlideColumnsManager = _t.first);
      }
    },
    inputs: {
      columns: [0, "p-columns", "columns"],
      target: [0, "p-target", "target"],
      colunsDefault: [0, "p-columns-default", "colunsDefault"],
      lastVisibleColumnsSelected: [0, "p-last-visible-columns-selected", "lastVisibleColumnsSelected"],
      hideActionFixedColumns: [2, "p-hide-action-fixed-columns", "hideActionFixedColumns", convertToBoolean],
      maxColumns: [0, "p-max-columns", "maxColumns"]
    },
    outputs: {
      visibleColumnsChange: "p-visible-columns-change",
      changeVisibleColumns: "p-change-visible-columns",
      initialColumns: "p-initial-columns"
    },
    standalone: false,
    features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature],
    decls: 7,
    vars: 7,
    consts: [["pageSlideColumnsManager", ""], ["p-size", "auto", 3, "p-close", "p-title", "p-click-out"], [1, "po-table-column-manager-body"], ["name", "visibleColumns", "p-columns", "1", 3, "ngModelChange", "p-change", "p-change-position", "p-change-fixed", "ngModel", "p-options", "p-hide-action-fixed-columns", "p-columns-manager"], [1, "po-table-column-manager-footer"], ["p-kind", "tertiary", 1, "po-table-column-manager-footer-restore", 3, "p-click", "p-label"]],
    template: function PoTableColumnManagerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-page-slide", 1, 0);
        ɵɵlistener("p-close", function PoTableColumnManagerComponent_Template_po_page_slide_p_close_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.checkChanges([], true));
        });
        ɵɵelementStart(2, "div")(3, "div", 2)(4, "po-table-list-manager", 3);
        ɵɵtwoWayListener("ngModelChange", function PoTableColumnManagerComponent_Template_po_table_list_manager_ngModelChange_4_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.visibleColumns, $event) || (ctx.visibleColumns = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("p-change", function PoTableColumnManagerComponent_Template_po_table_list_manager_p_change_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.checkChanges($event, false));
        })("p-change-position", function PoTableColumnManagerComponent_Template_po_table_list_manager_p_change_position_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.changePosition($event));
        })("p-change-fixed", function PoTableColumnManagerComponent_Template_po_table_list_manager_p_change_fixed_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.emitColumnFixed($event));
        });
        ɵɵelementEnd()();
        ɵɵelementStart(5, "div", 4)(6, "po-button", 5);
        ɵɵlistener("p-click", function PoTableColumnManagerComponent_Template_po_button_p_click_6_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.restore());
        });
        ɵɵelementEnd()()()();
      }
      if (rf & 2) {
        ɵɵproperty("p-title", ctx.literals.columnsManager)("p-click-out", true);
        ɵɵadvance(4);
        ɵɵtwoWayProperty("ngModel", ctx.visibleColumns);
        ɵɵproperty("p-options", ctx.columnsOptions)("p-hide-action-fixed-columns", ctx.hideActionFixedColumns)("p-columns-manager", ctx.columns);
        ɵɵadvance(2);
        ɵɵproperty("p-label", ctx.literals.restoreDefault);
      }
    },
    dependencies: [NgControlStatus, NgModel, PoButtonComponent, PoPageSlideComponent, PoTableListManagerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnManagerComponent, [{
    type: Component,
    args: [{
      selector: "po-table-column-manager",
      standalone: false,
      template: '<po-page-slide\n  #pageSlideColumnsManager\n  p-size="auto"\n  [p-title]="literals.columnsManager"\n  [p-click-out]="true"\n  (p-close)="checkChanges([], true)"\n>\n  <div>\n    <div class="po-table-column-manager-body">\n      <po-table-list-manager\n        name="visibleColumns"\n        [(ngModel)]="visibleColumns"\n        p-columns="1"\n        [p-options]="columnsOptions"\n        [p-hide-action-fixed-columns]="hideActionFixedColumns"\n        (p-change)="checkChanges($event, false)"\n        (p-change-position)="changePosition($event)"\n        (p-change-fixed)="emitColumnFixed($event)"\n        [p-columns-manager]="columns"\n      >\n      </po-table-list-manager>\n    </div>\n\n    <div class="po-table-column-manager-footer">\n      <po-button\n        class="po-table-column-manager-footer-restore"\n        p-kind="tertiary"\n        [p-label]="literals.restoreDefault"\n        (p-click)="restore()"\n      >\n      </po-button>\n    </div>\n  </div>\n</po-page-slide>\n'
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: PoLanguageService
  }], {
    popover: [{
      type: ViewChild,
      args: [PoPopoverComponent]
    }],
    pageSlideColumnsManager: [{
      type: ViewChild,
      args: ["pageSlideColumnsManager"]
    }],
    columns: [{
      type: Input,
      args: ["p-columns"]
    }],
    target: [{
      type: Input,
      args: ["p-target"]
    }],
    colunsDefault: [{
      type: Input,
      args: ["p-columns-default"]
    }],
    lastVisibleColumnsSelected: [{
      type: Input,
      args: ["p-last-visible-columns-selected"]
    }],
    visibleColumnsChange: [{
      type: Output,
      args: ["p-visible-columns-change"]
    }],
    changeVisibleColumns: [{
      type: Output,
      args: ["p-change-visible-columns"]
    }],
    initialColumns: [{
      type: Output,
      args: ["p-initial-columns"]
    }],
    hideActionFixedColumns: [{
      type: Input,
      args: [{
        alias: "p-hide-action-fixed-columns",
        transform: convertToBoolean
      }]
    }],
    maxColumns: [{
      type: Input,
      args: ["p-max-columns"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableColumnManagerComponent, {
    className: "PoTableColumnManagerComponent",
    filePath: "lib/components/po-table/po-table-column-manager/po-table-column-manager.component.ts",
    lineNumber: 51
  });
})();
var PoNotificationBaseService = class {
  // Array responsável por guardar a instância de po-toaster's superiores.
  stackTop = [];
  // Array responsável por guardar a instância de po-toaster's inferiores.
  stackBottom = [];
  // Duração da notificação ativa.
  defaultDuration = 9e3;
  /**
   * Emite uma notificação de sucesso.
   *
   * @param {PoNotification | string} notification Objeto com os dados da notificação ou somente a string com a mensagem da notificação.
   */
  success(notification) {
    this.createToaster(this.buildToaster(notification, PoToasterType.Success));
  }
  /**
   * Emite uma notificação de atenção.
   *
   * @param {PoNotification | string} notification Objeto com os dados da notificação ou somente a string com a mensagem da notificação
   */
  warning(notification) {
    this.createToaster(this.buildToaster(notification, PoToasterType.Warning));
  }
  /**
   * Emite uma notificação de erro.
   *
   * @param {PoNotification | string} notification Objeto com os dados da notificação ou somente a string com a mensagem da notificação
   */
  error(notification) {
    this.createToaster(this.buildToaster(notification, PoToasterType.Error));
  }
  /**
   * Emite uma notificação de informação.
   *
   * @param {PoNotification | string} notification Objeto com os dados da notificação ou somente a string com a mensagem da notificação
   */
  information(notification) {
    this.createToaster(this.buildToaster(notification, PoToasterType.Information));
  }
  /**
   * Define em milissegundos a duração padrão para as notificações.
   *
   * > Padrão 9 segundos.
   *
   * @param {number} defaultDuration Duração em milisegundos
   */
  setDefaultDuration(defaultDuration) {
    this.defaultDuration = defaultDuration;
  }
  /**
   * @docsPrivate
   *
   * Cria um objeto do tipo PoToaster de acordo o tipo.
   *
   * @param {PoNotification | string} notification Objeto PoNotification com os dados da notificação
   */
  buildToaster(notification, type) {
    let index = 0;
    let orientation;
    if (notification.orientation === void 0 || notification.orientation === PoToasterOrientation.Bottom) {
      index = this.stackBottom.length;
      orientation = PoToasterOrientation.Bottom;
    } else {
      index = this.stackTop.length;
      orientation = PoToasterOrientation.Top;
    }
    const toaster = {
      componentRef: void 0,
      message: notification.message || notification,
      type,
      orientation,
      action: notification.action,
      actionLabel: notification.actionLabel,
      position: index,
      mode: notification.mode || PoToasterMode.Alert,
      showClose: notification.showClose || true,
      supportMessage: notification.supportMessage,
      duration: notification.duration || this.defaultDuration
    };
    if (notification.action) {
      toaster.action = (param) => {
        notification.action();
        this.destroyToaster(param.componentRef);
      };
    }
    return toaster;
  }
};
var PoNotificationMaxLength = 5;
var PoNotificationFadeTime = 200;
var PoNotificationService = class _PoNotificationService extends PoNotificationBaseService {
  poComponentInjector;
  constructor(poComponentInjector) {
    super();
    this.poComponentInjector = poComponentInjector;
  }
  createToaster(toaster) {
    const componentRef = this.poComponentInjector.createComponentInApplication(PoToasterComponent);
    toaster.componentRef = componentRef;
    componentRef.changeDetectorRef.detectChanges();
    componentRef.instance.configToaster(toaster);
    const stack = toaster.orientation === PoToasterOrientation.Top ? this.stackTop : this.stackBottom;
    stack.push(componentRef);
    this.verifyLimitToaster(stack);
    this.observableOnClose(componentRef);
    if (!(toaster.action && toaster.actionLabel || toaster.type === PoToasterType.Error)) {
      timer(toaster.duration).pipe(takeWhile(() => componentRef.instance.alive)).subscribe(() => {
        this.destroyToaster(componentRef);
      });
    }
  }
  destroyToaster(toaster) {
    let stack;
    if (toaster.instance.orientation === PoToasterOrientation.Top) {
      stack = this.stackTop;
    } else {
      stack = this.stackBottom;
    }
    toaster.instance.setFadeOut();
    const index = stack.indexOf(toaster);
    stack.splice(index, 1);
    setTimeout(() => {
      this.poComponentInjector.destroyComponentInApplication(toaster);
      for (let count = 0; count < stack.length; count++) {
        stack[count].instance.changePosition(count);
      }
    }, PoNotificationFadeTime);
  }
  observableOnClose(componentRef) {
    componentRef.instance.observableOnClose.subscribe(() => {
      this.destroyToaster(componentRef);
    });
  }
  verifyLimitToaster(stack) {
    if (stack.length > PoNotificationMaxLength) {
      this.destroyToaster(stack[0]);
    }
  }
  static ɵfac = function PoNotificationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNotificationService)(ɵɵinject(PoComponentInjectorService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoNotificationService,
    factory: _PoNotificationService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNotificationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PoComponentInjectorService
  }], null);
})();
var PoTableRowTemplateArrowDirection;
(function(PoTableRowTemplateArrowDirection2) {
  PoTableRowTemplateArrowDirection2["Left"] = "LEFT";
  PoTableRowTemplateArrowDirection2["Right"] = "RIGHT";
})(PoTableRowTemplateArrowDirection || (PoTableRowTemplateArrowDirection = {}));
var PoSearchFilterMode;
(function(PoSearchFilterMode2) {
  PoSearchFilterMode2[PoSearchFilterMode2["startsWith"] = 0] = "startsWith";
  PoSearchFilterMode2[PoSearchFilterMode2["contains"] = 1] = "contains";
  PoSearchFilterMode2[PoSearchFilterMode2["endsWith"] = 2] = "endsWith";
})(PoSearchFilterMode || (PoSearchFilterMode = {}));
var PoTableColumnSortType;
(function(PoTableColumnSortType2) {
  PoTableColumnSortType2["Ascending"] = "ascending";
  PoTableColumnSortType2["Descending"] = "descending";
})(PoTableColumnSortType || (PoTableColumnSortType = {}));
var PoTableColumnSpacing;
(function(PoTableColumnSpacing2) {
  PoTableColumnSpacing2["Small"] = "small";
  PoTableColumnSpacing2["Medium"] = "medium";
  PoTableColumnSpacing2["Large"] = "large";
})(PoTableColumnSpacing || (PoTableColumnSpacing = {}));
var PoTableService = class _PoTableService {
  http;
  headers = new HttpHeaders({
    "X-PO-No-Message": "true"
  });
  url;
  urlDelete;
  constructor(http) {
    this.http = http;
  }
  getFilteredItems(filteredParams) {
    const params = this.validateParams(filteredParams);
    return this.http.get(this.url, {
      headers: this.headers,
      params
    });
  }
  deleteItem(paramDelete, paramResponse) {
    const params = {
      [paramDelete]: paramResponse
    };
    return this.http.delete(this.urlDelete, {
      headers: this.headers,
      params
    });
  }
  setUrl(url, method) {
    if (method === "GET") {
      this.url = url;
    } else {
      this.urlDelete = url;
    }
  }
  scrollListener(componentListner) {
    return fromEvent(componentListner, "scroll").pipe(debounceTime(100));
  }
  validateParams(params) {
    return isTypeof(params, "object") && !Array.isArray(params) ? params : void 0;
  }
  static ɵfac = function PoTableService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoTableService,
    factory: _PoTableService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableService, [{
    type: Injectable
  }], () => [{
    type: HttpClient
  }], null);
})();
var poTableContainer = ["border", "shadow"];
var poTableContainerDefault = "border";
var poTableParamDeleteApi = "id";
var poTableLiteralsDefault = {
  en: {
    noColumns: "Columns are not defined",
    noData: "No data found",
    noItem: "No selected item",
    oneItem: "1 selected item",
    multipleItems: "selected items",
    noVisibleColumn: "No visible column",
    loadingData: "Loading",
    loadMoreData: "Load more data",
    seeCompleteSubtitle: "See complete subtitle",
    completeSubtitle: "Complete subtitle",
    columnsManager: "Columns manager",
    bodyDelete: "Do you really want to delete this item?",
    cancel: "Cancel",
    delete: "Delete",
    deleteSuccessful: "Items removed successfully",
    deleteApiError: "An unexpected error occurred, please try again later"
  },
  es: {
    noColumns: "Columnas no definidas",
    noData: "Datos no encontrados",
    noItem: "Ningún elemento seleccionado",
    oneItem: "1 elemento seleccionado",
    multipleItems: "elementos seleccionados",
    noVisibleColumn: "Sin columnas visibles",
    loadingData: "Cargando datos",
    loadMoreData: "Cargar más resultados",
    seeCompleteSubtitle: "Ver subtitulo completo",
    completeSubtitle: "Subtitulo completo",
    columnsManager: "Gerente de columna",
    bodyDelete: "¿Realmente desea eliminar este elemento?",
    cancel: "Cancelar",
    delete: "Borrar",
    deleteSuccessful: "Elementos eliminados con éxito",
    deleteApiError: "Ocurrió un error inesperado, inténtalo de nuevo más tarde"
  },
  pt: {
    noColumns: "Nenhuma definição de colunas",
    noData: "Nenhum dado encontrado",
    noVisibleColumn: "Nenhuma coluna visível",
    noItem: "Nenhum item selecionado",
    oneItem: "1 item selecionado",
    multipleItems: "itens selecionados",
    loadingData: "Carregando",
    loadMoreData: "Carregar mais resultados",
    seeCompleteSubtitle: "Ver legenda completa",
    completeSubtitle: "Legenda completa",
    columnsManager: "Gerenciador de colunas",
    bodyDelete: "Deseja realmente excluir esse item?",
    cancel: "Cancelar",
    delete: "Excluir",
    deleteSuccessful: "Itens removidos com sucesso",
    deleteApiError: "Ocorreu um erro inesperado, tente novamente mais tarde!"
  },
  ru: {
    noColumns: "Нет определения столбца",
    noData: "Данные не найдены",
    noItem: "Нет выбранного элемента",
    oneItem: "1 элемент выбран",
    multipleItems: "выбранные элементы",
    noVisibleColumn: "нет видимых столбцов",
    loadingData: "Загрузка",
    loadMoreData: "Загрузка",
    seeCompleteSubtitle: "Посмотреть полный субтитр",
    completeSubtitle: "Полный заголовок",
    columnsManager: "менеджер колонок",
    bodyDelete: "Вы действительно хотите удалить этот элемент?",
    cancel: "Отмена",
    delete: "Удалить",
    deleteSuccessful: "Элементы успешно удалены",
    deleteApiError: "Произошла непредвиденная ошибка, повторите попытку позже"
  }
};
var PoTableBaseComponent = class _PoTableBaseComponent {
  poDate;
  poTableService;
  /**
   * @optional
   *
   * @description
   *
   * Permite que o gerenciador de colunas, responsável pela definição de quais colunas serão exibidas, seja escondido.
   *
   * @default `false`
   */
  hideColumnsManager = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite que as ações em lote, responsável por excluir e exibir a quantidade de itens, sejam escondidas.
   *
   * @default `true`
   */
  hideBatchActions = true;
  /**
   * @optional
   *
   * @description
   *
   * Habilita ou desabilita a quebra automática de texto. Quando ativada, o texto que excede
   * o espaço disponível é transferido para a próxima linha em pontos apropriados para uma
   * leitura clara.
   *
   * > Incompatível com `virtual-scroll`, que requer altura fixa nas linhas.
   *
   * @default `false`
   */
  textWrap = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite que as ações para fixar uma coluna da tabela sejam escondidas.
   *
   * @default `false`
   */
  set hideActionFixedColumns(hide) {
    if (hide) {
      this.columns = this.removePropertyFixed(this.columns);
    }
    this._hideActionFixedColumns = hide;
  }
  get hideActionFixedColumns() {
    return this._hideActionFixedColumns;
  }
  /**
   * @optional
   *
   * @description
   *
   * Permite que o campo de pesquisa seja escondido.
   *
   * @default `true`
   */
  hideTableSearch = true;
  /**
   * @optional
   *
   * @description
   *
   * Permite fechar um detalhe ou row template automaticamente, ao abrir outro item.
   *
   * @default `false`
   */
  autoCollapse = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite que seja adicionado o estado de carregamento no botão "Carregar mais resultados".
   *
   * @default `false`
   */
  loadingShowMore = false;
  /**
   * @optional
   *
   * @description
   *
   * Habilita em todas as colunas a opção de ordenação de dados. Caso a coluna seja do tipo 'data' ou 'dateTime' a
   * mesma deve respeitar os tipos de entrada definidos para que sejam ordenadas.
   *
   * @default `false`
   */
  sort = false;
  /**
   * @description
   *
   * Se verdadeiro, torna habilitado o botão "Carregar mais resultados".
   *
   * @default `false`
   */
  showMoreDisabled = false;
  /**
   * @description
   *
   * Habilita ou desabilita o estilo listrado da tabela (`striped`).
   * > Recomendado para tabelas com maior número de dados, facilitando a sua visualização na tabela.
   *
   * @default `false`
   */
  striped = false;
  /**
   * @description
   *
   * Esconde o *checkbox* para seleção de todas as linhas.
   *
   * > Sempre receberá *true* caso a seleção de apenas uma linha esteja ativa.
   *
   * @default `false`
   */
  hideSelectAll = false;
  /**
   * @description
   *
   * Define que somente uma linha da tabela pode ser selecionada.
   *
   * > Esta definição não se aplica aos itens filhos, os mesmos possuem comportamento independente do item pai.
   */
  singleSelect = false;
  /**
   * @description
   *
   * Permite selecionar um item da tabela clicando na linha.
   *
   * > Caso haja necessidade de selecionar o item apenas via radio ou checkbox, deve-se definir esta propriedade como `false`.
   *
   * @default `true`
   */
  selectableEntireLine = true;
  /**
   * @optional
   *
   * @description
   *
   * Define que a coluna de ações ficará no lado direito da tabela.
   *
   * @default `false`
   */
  actionRight = false;
  /**
   * @optional
   *
   * @description
   *
   * Define uma quantidade máxima de colunas que serão exibidas na tabela.
   *
   * Quando chegar no valor informado, as colunas que não estiverem selecionadas ficarão
   * desabilitadas e caso houver mais colunas visíveis do que o permitido, as excedentes
   * serão ignoradas por ordem de posição.
   */
  maxColumns;
  /**
   * @optional
   *
   * @description
   *
   * Define o modo de pesquisa utilizado no campo de busca, quando habilitado.
   * Valores definidos no enum: PoSearchFilterMode
   * > Obs: A pesquisa é realizada exclusivamente nos dados locais, ou seja, aqueles que foram
   * > renderizados na tabela.
   *
   * @default `startsWith`
   */
  filterType = PoSearchFilterMode.startsWith;
  /**
   * @optional
   *
   * @description
   * Evento executado quando todas as linhas são selecionadas por meio do *checkbox* que seleciona todas as linhas.
   */
  allSelected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento executado quando a seleção das linhas é desmarcada por meio do *checkbox* que seleciona todas as linhas.
   */
  allUnselected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado ao colapsar uma linha do `po-table`.
   *
   * > Como parâmetro o componente envia o item colapsado.
   */
  collapsed = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado ao expandir uma linha do `po-table`.
   *
   * > Como parâmetro o componente envia o item expandido.
   */
  expanded = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado após o método de exclusão ser finalizado.
   *
   * ```
   *<po-table
   *  (p-delete-items)="items = $event"
   * >
   *</po-table>
   * ```
   *
   *
   * > Como parâmetro o componente envia a lista atualizada, sem os itens excluídos.
   */
  eventDelete = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado ao selecionar uma linha do `po-table`.
   */
  selected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Recebe uma ação de clique para o botão "Carregar mais resultados", caso nenhuma ação for definida o mesmo
   * não é visível.
   *
   * Recebe um objeto `{ column, type }` onde:
   *
   * - column (`PoTableColumn`): objeto da coluna que está ordenada.
   * - type (`PoTableColumnSortType`): tipo da ordenação.
   */
  showMore = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado ao ordenar colunas da tabela.
   *
   * Recebe um objeto `{ column, type }` onde:
   *
   * - column (`PoTableColumn`): objeto da coluna que foi clicada/ordenada.
   * - type (`PoTableColumnSortType`): tipo da ordenação.
   */
  sortBy = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento executado ao desmarcar a seleção de uma linha do `po-table`.
   */
  unselected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado ao fechar o page slide do gerenciador de colunas após alterar as colunas visíveis.
   *
   * O componente envia como parâmetro um array de string com as colunas visíveis atualizadas.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  changeVisibleColumns = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no botão de restaurar padrão no gerenciador de colunas.
   *
   * O componente envia como parâmetro um array de string com as colunas configuradas inicialmente.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  columnRestoreManager = new EventEmitter();
  allColumnsWidthPixels;
  columnMasterDetail;
  hasMainColumns = false;
  mainColumns = [];
  selectAll = false;
  sortedColumn = {
    property: null,
    ascending: true
  };
  subtitleColumns = [];
  page = 1;
  pageSize = 10;
  hasService = false;
  initialColumns;
  showBatchActions = false;
  itemsSelected = [];
  paramsFilter = {};
  filteredItems = [];
  initialized = false;
  fixedLayout = false;
  initialVisibleColumns = false;
  _spacing = PoTableColumnSpacing.Medium;
  _filteredColumns;
  _actions = [];
  _columns = [];
  _container;
  _paramDelete = poTableParamDeleteApi;
  _height;
  _hideDetail = false;
  _items;
  _literals;
  _loading = false;
  _selectable;
  language = poLocaleDefault;
  _serviceApi;
  _serviceDeleteApi;
  poTableServiceSubscription;
  sortStore;
  _infiniteScrollDistance = 100;
  _infiniteScroll = false;
  _draggable = false;
  _hideActionFixedColumns = false;
  _virtualScroll = true;
  constructor(poDate, languageService, poTableService) {
    this.poDate = poDate;
    this.poTableService = poTableService;
    this.language = languageService.getShortLanguage();
  }
  /**
   * @description
   *
   * Lista de itens da tabela.
   * > Se falso, será inicializado como um *array* vazio.
   */
  set items(items) {
    if (this.height) {
      this._items = Array.isArray(items) ? [...items] : [];
    } else {
      this._items = Array.isArray(items) ? items : [];
    }
    if (!this.hasItems) {
      this.selectAll = false;
    } else if (!this.hasColumns) {
      this.columns = this.getDefaultColumns(items[0]);
    }
    this.filteredItems = this.height ? [...this.items] : this.items;
    setTimeout(() => this.checkInfiniteScroll());
  }
  get items() {
    return this._items;
  }
  /**
   * @optional
   *
   * @description
   *
   * Lista das colunas da tabela, deve receber um *array* de objetos que implementam a interface `PoTableColumn`.
   * Por padrão receberá como valor a primeira coluna da lista de itens da tabela.
   * > Caso não encontre valor, a mensagem 'Nenhuma definição de colunas' será exibida.
   *
   */
  set columns(columns) {
    const hasColumnsWithVisible = columns?.find((column) => column.visible === true);
    if (this.initialColumns === void 0) {
      this.initialColumns = columns;
    }
    this._columns = columns || [];
    if (hasColumnsWithVisible && !this.initialVisibleColumns) {
      this.initialVisibleColumns = true;
    }
    if (this._columns.length) {
      this.setColumnLink();
    } else if (this.hasItems) {
      this._columns = this.getDefaultColumns(this.items[0]);
    }
    this.onChangeColumns();
  }
  get columns() {
    return this._columns;
  }
  /**
   * @optional
   *
   * @description
   *
   * Adiciona um contorno arredondado ao `po-table`, as opções são:
   * - `border`: com bordas/linhas.
   * - `shadow`: com sombras.
   *
   * @default `border`
   */
  set container(value) {
    this._container = poTableContainer.includes(value) ? value : poTableContainerDefault;
  }
  get container() {
    return this._container;
  }
  /**
   * @optional
   *
   * @description
   *
   * Adiciona o parâmetro a ser enviado para a requisição de DELETE.
   *
   * É necessário a utilização da propriedade `p-service-delete` em conjunto.
   *
   * @default `id`
   */
  set paramDeleteApi(value) {
    this._paramDelete = value && typeof value === "string" ? value : poTableParamDeleteApi;
  }
  get paramDeleteApi() {
    return this._paramDelete;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a altura da tabela em *pixels* e fixa o cabeçalho.
   *
   * Ao utilizar essa propriedade será inserido o `virtual-scroll` na tabela melhorando a performance.
   */
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita a visualização da lista de detalhes de cada linha da coluna.
   *
   * @default `false`
   */
  set hideDetail(hideDetail) {
    this._hideDetail = hideDetail != null && hideDetail.toString() === "" ? true : convertToBoolean(hideDetail);
  }
  get hideDetail() {
    return this._hideDetail;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-table`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoTableLiterals = {
   *    noColumns: 'Nenhuma definição de colunas',
   *    noData: 'Nenhum dado encontrado',
   *    noVisibleColumn: 'Nenhuma coluna visível',
   *    noItem: 'Nenhum item selecionado',
   *    oneItem: '1 item selecionado',
   *    multipleItems: 'itens selecionados',
   *    loadingData: 'Carregando',
   *    loadMoreData: 'Carregar mais resultados',
   *    seeCompleteSubtitle: 'Ver legenda completa',
   *    completeSubtitle: 'Legenda completa',
   *    columnsManager: 'Gerenciador de colunas',
   *    bodyDelete: 'Deseja realmente excluir esse item?',
   *    cancel: 'Cancelar',
   *    delete: 'Excluir',
   *    deleteSuccessful: 'Itens removidos com sucesso',
   *    deleteApiError: 'Ocorreu um erro inesperado, tente novamente mais tarde!',
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoTableLiterals = {
   *    noData: 'Sem dados'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-table
   *   [p-literals]="customLiterals">
   * </po-table>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poTableLiteralsDefault[poLocaleDefault]), poTableLiteralsDefault[this.language]), value);
    } else {
      this._literals = poTableLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poTableLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Bloqueia a interação do usuário com os dados da _table_.
   *
   * @default `false`
   */
  set loading(loading) {
    this._loading = convertToBoolean(loading);
  }
  get loading() {
    return this._loading;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma lista de ações.
   *
   * Quando houver apenas uma ação definida ela será exibida diretamente na coluna, caso contrário, o componente
   * se encarrega de agrupá-las exibindo o ícone [**an an-dots-three**](https://po-ui.io/icons) que listará as ações ao ser clicado.
   *
   * **A coluna de ações não será exibida quando:**
   *  - a lista conter valores inválidos ou indefinidos.
   *  - tenha uma única ação e a mesma não for visível.
   */
  set actions(actions) {
    this._actions = actions;
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Permite a seleção de linhas na tabela e, caso a propriedade `p-single-select` esteja definida será possível
   * selecionar apenas uma única linha.
   *
   * **Importante:**
   *  - As linhas de detalhe definidas em `PoTableDetail` possuem comportamento independente da linha mestre;
   *  - Cada linha possui por padrão a propriedade dinâmica `$selected`, na qual é possível validar se a linha
   * está selecionada, por exemplo: `item.$selected` ou `item['$selected']`.
   *
   * @default `false`
   */
  set selectable(value) {
    this._selectable = value === "" ? true : convertToBoolean(value);
  }
  get selectable() {
    return this._selectable;
  }
  /**
   * @optional
   *
   * @description
   *
   * Se verdadeiro, ativa a funcionalidade de scroll infinito para a tabela e o botão "Carregar Mais" deixará de ser exibido. Ao chegar no fim da tabela
   * executará a função `p-show-more`.
   *
   * **Regras de utilização:**
   *  - O scroll infinito só funciona para tabelas que utilizam a propriedade `p-height` e que possuem o scroll já na carga inicial dos dados.
   *
   * @default `false`
   */
  set infiniteScroll(value) {
    this._infiniteScroll = convertToBoolean(value && this.height > 0);
  }
  get infiniteScroll() {
    return this._infiniteScroll;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o percentual necessário para disparar o evento `p-show-more`, que é responsável por carregar mais dados na tabela. Caso o valor informado seja maior que 100 ou menor
   * que 0, o valor padrão será 100%
   *
   * **Exemplos:**
   *  - p-infinite-scroll-distance = 80: Quando atingir 80%  do scroll da tabela, o `p-show-more` será disparado.
   */
  set infiniteScrollDistance(value) {
    this._infiniteScrollDistance = value > 100 || value < 0 ? 100 : value;
  }
  get infiniteScrollDistance() {
    return this._infiniteScrollDistance;
  }
  /**
   * @optional
   *
   * @description
   *
   * URL da API responsável por retornar os registros.
   *
   * Ao realizar a busca de mais registros via paginação (Carregar mais resultados), será enviado os parâmetros `page` e `pageSize`, conforme abaixo:
   *
   * ```
   * url + ?page=1&pageSize=10
   * ```
   *
   * Caso utilizar ordenação, a coluna ordenada será enviada através do parâmetro `order`, por exemplo:
   * - Coluna decrescente:
   * ```
   *  url + ?page=1&pageSize=10&order=-name
   * ```
   *
   * - Coluna ascendente:
   * ```
   *  url + ?page=1&pageSize=10&order=name
   * ```
   *
   * > Esta URL deve retornar e receber os dados no padrão de [API do PO UI](https://po-ui.io/guides/api).
   */
  set serviceApi(service) {
    this._serviceApi = service;
    this.setService(this.serviceApi, "GET");
    this.hasService = !!service;
    this.showMoreDisabled = !this.hasService;
    this.page = 1;
    this.initializeData();
  }
  get serviceApi() {
    return this._serviceApi;
  }
  /**
   * @optional
   *
   * @description
   *
   * URL da API responsável por excluir os registros.
   *
   * Ao selecionar o botão de excluir itens, essa url será executada utilizando o parâmetro enviado na propriedade `p-param-delete-api`.
   * Caso ela não seja utilizada, o parâmetro padrão a ser enviado será `id`.
   *
   * > Esta URL deve retornar e receber os dados no padrão de [API do PO UI](https://po-ui.io/guides/api).
   */
  set serviceDeleteApi(service) {
    this._serviceDeleteApi = service;
    this.setService(this.serviceDeleteApi, "DELETE");
  }
  get serviceDeleteApi() {
    return this._serviceDeleteApi;
  }
  /**
   * @optional
   *
   * @description
   *
   * Responsável por aplicar espaçamento nas colunas.
   *
   * Deve receber um dos valores do enum `PoTableColumnSpacing`.
   *
   * @default `medium`
   */
  set spacing(value) {
    if (value === "small" || value === "medium" || value === "large") {
      this._spacing = value;
    } else {
      this._spacing = PoTableColumnSpacing.Medium;
    }
  }
  get spacing() {
    return this._spacing;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define as colunas que serão filtradas no campo de pesquisa.
   * Aceita um array de strings, representando as colunas específicas que serão consideradas na filtragem.
   *
   */
  set filteredColumns(values) {
    this._filteredColumns = values;
  }
  get filteredColumns() {
    return this._filteredColumns;
  }
  get hasColumns() {
    return this.columns && this.columns.length > 0;
  }
  get hasItems() {
    return !!(this.items && this.items.length);
  }
  get nameColumnDetail() {
    return this.columnMasterDetail ? this.columnMasterDetail.property : null;
  }
  get validColumns() {
    const typesValid = ["string", "number", "boolean", "date", "time", "dateTime", "currency", "subtitle", "link", "label", "icon", "cellTemplate", "columnTemplate"];
    return this.columns.filter((col) => !col.type || typesValid.includes(col.type));
  }
  get visibleActions() {
    return this.actions !== void 0 && this.actions && this.actions.filter((action) => action && action.visible !== false);
  }
  getFilteredColumns() {
    this.filteredColumns = this.columns.filter((column) => column.visible !== false).map((column) => column.property || column.label);
  }
  get sortType() {
    return this.sortedColumn.ascending ? PoTableColumnSortType.Ascending : PoTableColumnSortType.Descending;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita o modo drag and drop para as colunas da tabela.
   *
   * @default `false`
   */
  set draggable(draggable) {
    this._draggable = draggable || false;
  }
  get draggable() {
    return this._draggable;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita o `virtual-scroll` na tabela para melhorar a performance com grandes volumes de dados.
   * Requer altura (`p-height`) para funcionar corretamente.
   *
   * > Incompatível com `p-text-wrap` e `master-detail`, pois o `virtual-scroll` exige altura fixa nas linhas.
   *
   * @default `true`
   */
  set virtualScroll(value) {
    this._virtualScroll = convertToBoolean(value && this.height > 0);
  }
  get virtualScroll() {
    return this._virtualScroll;
  }
  ngOnDestroy() {
    this.poTableServiceSubscription?.unsubscribe();
  }
  ngOnChanges(changes) {
    if (this.singleSelect || this.hideSelectAll) {
      this.selectAll = false;
      this.hideSelectAll = true;
    }
    if (changes.height) {
      this.calculateHeightTableContainer(this.height);
    }
    if ((changes.height || changes.items) && this.initialized) {
      this.changeHeaderWidth();
    }
    this.changeSizeLoading();
  }
  selectAllRows() {
    if (!this.hideSelectAll) {
      this.selectAll = !this.selectAll;
      this.items.forEach((item) => {
        item.$selected = this.selectAll;
        if (item[this.nameColumnDetail]) {
          const childItems = item[this.nameColumnDetail];
          childItems.forEach((childItem) => childItem.$selected = this.selectAll);
        }
      });
      this.emitSelectAllEvents(this.selectAll, [...this.items]);
      this.setSelectedList();
    }
  }
  selectRow(row) {
    row.$selected = !row.$selected;
    this.emitSelectEvents(row);
    this.configAfterSelectRow(this.items, row);
    if (row[this.nameColumnDetail] && (row.$selected === true || row.$selected === false)) {
      const childItems = row[this.nameColumnDetail];
      childItems.forEach((item) => item.$selected = row.$selected);
    }
    this.setSelectedList();
  }
  hasSelectableRow() {
    return this.selectable && this.selectableEntireLine;
  }
  selectDetailRow(event) {
    const {
      item,
      parentRow
    } = event;
    this.emitSelectEvents(item);
    this.updateParentRowSelection(parentRow);
  }
  updateParentRowSelection(parentRow) {
    const old = parentRow.$selected || null;
    const childItems = parentRow[this.nameColumnDetail];
    if (childItems.every((item) => item.$selected)) {
      parentRow.$selected = true;
    } else if (childItems.every((item) => !item.$selected)) {
      parentRow.$selected = false;
    } else {
      parentRow.$selected = null;
    }
    if (old != parentRow.$selected && !(old == null && parentRow.$selected === false)) {
      this.emitSelectEvents(parentRow);
    }
    this.configAfterSelectRow(this.items, parentRow);
    this.setSelectedList();
  }
  setSelectedList() {
    this.itemsSelected = [];
    this.items.forEach((item) => {
      if (item.$selected) {
        this.itemsSelected.push(item);
      }
    });
  }
  getClassColor(row, column) {
    return column.color ? `po-text-${this.getColumnColor(row, column)}` : "";
  }
  toggleDetail(row) {
    const rowShowDetail = row.$showDetail;
    if (this.autoCollapse) {
      this.collapseAllItems(this.items);
    }
    this.setShowDetail(row, !rowShowDetail);
    this.emitExpandEvents(row);
  }
  toggleRowAction(row) {
    const toggleShowAction = row.$showAction;
    this.items.forEach((item) => {
      if (item.$showAction) {
        item.$showAction = false;
      }
    });
    row.$showAction = !toggleShowAction;
  }
  sortColumn(column) {
    if (!this.sort || column.type === "detail" || column.sortable === false) {
      return;
    }
    this.sortedColumn.ascending = this.sortedColumn.property === column ? !this.sortedColumn.ascending : true;
    this.sortArray(column, this.sortedColumn.ascending);
    this.sortBy.emit({
      column,
      type: this.sortType
    });
    if (this.hasService && this.sort) {
      this.sortStore = {
        column,
        type: this.sortType
      };
    }
    this.sortedColumn.property = column;
  }
  onShowMore() {
    const sort = this.sortedColumn.property ? {
      column: this.sortedColumn.property,
      type: this.sortType
    } : void 0;
    if (this.hasService) {
      this.page++;
      this.loading = true;
      this.loadingShowMore = true;
      this.poTableServiceSubscription = this.getFilteredItems().subscribe((data) => {
        this.items = [...this.items, ...data.items];
        this.showMoreDisabled = !data.hasNext;
        this.loading = false;
        this.loadingShowMore = false;
      });
    }
    this.showMore.emit(sort);
  }
  getFilteredItems(queryParams) {
    const filteredParams = this.getFilteredParams(queryParams);
    return this.poTableService.getFilteredItems(filteredParams);
  }
  setTableResponseProperties(data) {
    this.items = data.items || [];
    this.showMoreDisabled = !data.hasNext;
    this.loading = false;
  }
  initializeData(params) {
    if (this.hasService) {
      this.loading = true;
      this.paramsFilter = params;
      this.getFilteredItems(params).subscribe((data) => {
        this.setTableResponseProperties(data);
      });
    }
  }
  sortArray(column, ascending, item) {
    let itemsList;
    if (item) {
      itemsList = this.height ? [...item] : item;
    } else {
      itemsList = this.height ? [...this.filteredItems] : this.filteredItems;
    }
    itemsList.sort((leftSide, rightSide) => sortValues(leftSide[column.property], rightSide[column.property], ascending));
    this.filteredItems = itemsList;
  }
  getDefaultColumns(item) {
    const keys = Object.keys(item);
    return keys.filter((key) => typeof item[key] !== "object").map((key) => ({
      label: capitalizeFirstLetter(key),
      property: key
    }));
  }
  setShowDetail(rowIdentifier, isShowDetail) {
    const isRowIndex = typeof rowIdentifier === "number" && this.items[rowIdentifier];
    const row = isRowIndex ? this.items[rowIdentifier] : rowIdentifier;
    row.$showDetail = isShowDetail;
  }
  collapseAllItems(items) {
    for (const item of items) {
      if (item.$showDetail) {
        this.setShowDetail(item, false);
        this.emitExpandEvents(item);
      }
    }
  }
  configAfterSelectRow(rows, row) {
    if (this.singleSelect) {
      this.unselectOtherRows(rows, row);
    } else if (!this.hideSelectAll) {
      this.selectAll = this.isEverySelected(rows);
    }
  }
  emitExpandEvents(row) {
    row.$showDetail ? this.expanded.emit(row) : this.collapsed.emit(row);
  }
  emitSelectAllEvents(selectAll, rows) {
    selectAll ? this.allSelected.emit(rows) : this.allUnselected.emit(rows);
  }
  emitSelectEvents(row) {
    row.$selected ? this.selected.emit(row) : this.unselected.emit(row);
  }
  getColumnColor(row, column) {
    const columnColor = column.color;
    return isTypeof(columnColor, "function") ? columnColor(row, column.property) : columnColor;
  }
  // Retorna a coluna da lista de colunas que é do tipo detail
  getColumnMasterDetail() {
    return this.columns.find((col) => col.type === "detail");
  }
  // Colunas que são inseridas no <head> da tabela
  getMainColumns() {
    return this.validColumns.filter((col) => col.visible !== false);
  }
  // Retorna as colunas com status
  getSubtitleColumns() {
    return this.columns.filter((col) => col.type === "subtitle");
  }
  isEverySelected(items) {
    const someCheckedOrIndeterminate = (item) => item.$selected || item.$selected === null;
    const everyChecked = (item) => item.$selected;
    if (items.every(everyChecked)) {
      return true;
    }
    if (items.some(someCheckedOrIndeterminate)) {
      return null;
    }
    return false;
  }
  onChangeColumns() {
    this.setMainColumns();
    this.setColumnMasterDetail();
    this.setSubtitleColumns();
    this.getFilteredColumns();
  }
  setColumnLink() {
    this.columns.forEach((column) => {
      if (column["type"] === "link" && !column["link"]) {
        column["link"] = "link";
      }
    });
  }
  setColumnMasterDetail() {
    this.columnMasterDetail = this.getColumnMasterDetail();
  }
  setMainColumns() {
    this.mainColumns = this.getMainColumns();
    this.hasMainColumns = !!this.mainColumns.length;
    this.allColumnsWidthPixels = this.verifyWidthColumnsPixels();
  }
  setSubtitleColumns() {
    this.subtitleColumns = this.getSubtitleColumns();
  }
  unselectOtherRows(rows, row) {
    rows.forEach((item) => {
      if (item !== row) {
        item.$selected = false;
      }
    });
  }
  verifyWidthColumnsPixels() {
    return this.hasMainColumns ? this.mainColumns.every((column) => column.width && column.width.includes("px")) : false;
  }
  setService(service, method) {
    if (service && isTypeof(service, "string")) {
      this.poTableService.setUrl(service, method);
    }
  }
  getFilteredParams(queryParams) {
    const {
      page,
      pageSize,
      sortStore
    } = this;
    const filteredParams = {};
    const order = this.getOrderParam(sortStore);
    const params = __spreadValues({
      page,
      pageSize,
      order
    }, queryParams);
    for (const key in params) {
      if (params.hasOwnProperty(key) && params[key] !== void 0) {
        filteredParams[key] = params[key];
      }
    }
    return filteredParams;
  }
  getOrderParam(sort = {
    type: void 0
  }) {
    const {
      column,
      type
    } = sort;
    if (!column) {
      return;
    }
    if (type === PoTableColumnSortType.Descending) {
      return `-${column.property}`;
    }
    return `${column.property}`;
  }
  removePropertyFixed(arr) {
    return arr.map((obj) => {
      if (obj.hasOwnProperty("fixed")) {
        obj.fixed = false;
      }
      return obj;
    });
  }
  static ɵfac = function PoTableBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableBaseComponent)(ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(PoTableService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTableBaseComponent,
    inputs: {
      hideColumnsManager: [2, "p-hide-columns-manager", "hideColumnsManager", convertToBoolean],
      hideBatchActions: [2, "p-hide-batch-actions", "hideBatchActions", convertToBoolean],
      textWrap: [2, "p-text-wrap", "textWrap", convertToBoolean],
      hideActionFixedColumns: [0, "p-hide-action-fixed-columns", "hideActionFixedColumns"],
      hideTableSearch: [2, "p-hide-table-search", "hideTableSearch", convertToBoolean],
      autoCollapse: [2, "p-auto-collapse", "autoCollapse", convertToBoolean],
      loadingShowMore: [2, "p-loading-show-more", "loadingShowMore", convertToBoolean],
      sort: [2, "p-sort", "sort", convertToBoolean],
      showMoreDisabled: [2, "p-show-more-disabled", "showMoreDisabled", convertToBoolean],
      striped: [2, "p-striped", "striped", convertToBoolean],
      hideSelectAll: [2, "p-hide-select-all", "hideSelectAll", convertToBoolean],
      singleSelect: [2, "p-single-select", "singleSelect", convertToBoolean],
      selectableEntireLine: [2, "p-selectable-entire-line", "selectableEntireLine", convertToBoolean],
      actionRight: [2, "p-actions-right", "actionRight", convertToBoolean],
      maxColumns: [0, "p-max-columns", "maxColumns"],
      filterType: [0, "p-filter-type", "filterType"],
      items: [0, "p-items", "items"],
      columns: [0, "p-columns", "columns"],
      container: [0, "p-container", "container"],
      paramDeleteApi: [0, "p-param-delete-api", "paramDeleteApi"],
      height: [0, "p-height", "height"],
      hideDetail: [0, "p-hide-detail", "hideDetail"],
      literals: [0, "p-literals", "literals"],
      loading: [0, "p-loading", "loading"],
      actions: [0, "p-actions", "actions"],
      selectable: [0, "p-selectable", "selectable"],
      infiniteScroll: [0, "p-infinite-scroll", "infiniteScroll"],
      infiniteScrollDistance: [0, "p-infinite-scroll-distance", "infiniteScrollDistance"],
      serviceApi: [0, "p-service-api", "serviceApi"],
      serviceDeleteApi: [0, "p-service-delete", "serviceDeleteApi"],
      spacing: [0, "p-spacing", "spacing"],
      filteredColumns: [0, "p-filtered-columns", "filteredColumns"],
      draggable: [0, "p-draggable", "draggable"],
      virtualScroll: [0, "p-virtual-scroll", "virtualScroll"]
    },
    outputs: {
      allSelected: "p-all-selected",
      allUnselected: "p-all-unselected",
      collapsed: "p-collapsed",
      expanded: "p-expanded",
      eventDelete: "p-delete-items",
      selected: "p-selected",
      showMore: "p-show-more",
      sortBy: "p-sort-by",
      unselected: "p-unselected",
      changeVisibleColumns: "p-change-visible-columns",
      columnRestoreManager: "p-restore-column-manager"
    },
    features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoDateService
  }, {
    type: PoLanguageService
  }, {
    type: PoTableService
  }], {
    hideColumnsManager: [{
      type: Input,
      args: [{
        alias: "p-hide-columns-manager",
        transform: convertToBoolean
      }]
    }],
    hideBatchActions: [{
      type: Input,
      args: [{
        alias: "p-hide-batch-actions",
        transform: convertToBoolean
      }]
    }],
    textWrap: [{
      type: Input,
      args: [{
        alias: "p-text-wrap",
        transform: convertToBoolean
      }]
    }],
    hideActionFixedColumns: [{
      type: Input,
      args: ["p-hide-action-fixed-columns"]
    }],
    hideTableSearch: [{
      type: Input,
      args: [{
        alias: "p-hide-table-search",
        transform: convertToBoolean
      }]
    }],
    autoCollapse: [{
      type: Input,
      args: [{
        alias: "p-auto-collapse",
        transform: convertToBoolean
      }]
    }],
    loadingShowMore: [{
      type: Input,
      args: [{
        alias: "p-loading-show-more",
        transform: convertToBoolean
      }]
    }],
    sort: [{
      type: Input,
      args: [{
        alias: "p-sort",
        transform: convertToBoolean
      }]
    }],
    showMoreDisabled: [{
      type: Input,
      args: [{
        alias: "p-show-more-disabled",
        transform: convertToBoolean
      }]
    }],
    striped: [{
      type: Input,
      args: [{
        alias: "p-striped",
        transform: convertToBoolean
      }]
    }],
    hideSelectAll: [{
      type: Input,
      args: [{
        alias: "p-hide-select-all",
        transform: convertToBoolean
      }]
    }],
    singleSelect: [{
      type: Input,
      args: [{
        alias: "p-single-select",
        transform: convertToBoolean
      }]
    }],
    selectableEntireLine: [{
      type: Input,
      args: [{
        alias: "p-selectable-entire-line",
        transform: convertToBoolean
      }]
    }],
    actionRight: [{
      type: Input,
      args: [{
        alias: "p-actions-right",
        transform: convertToBoolean
      }]
    }],
    maxColumns: [{
      type: Input,
      args: ["p-max-columns"]
    }],
    filterType: [{
      type: Input,
      args: ["p-filter-type"]
    }],
    allSelected: [{
      type: Output,
      args: ["p-all-selected"]
    }],
    allUnselected: [{
      type: Output,
      args: ["p-all-unselected"]
    }],
    collapsed: [{
      type: Output,
      args: ["p-collapsed"]
    }],
    expanded: [{
      type: Output,
      args: ["p-expanded"]
    }],
    eventDelete: [{
      type: Output,
      args: ["p-delete-items"]
    }],
    selected: [{
      type: Output,
      args: ["p-selected"]
    }],
    showMore: [{
      type: Output,
      args: ["p-show-more"]
    }],
    sortBy: [{
      type: Output,
      args: ["p-sort-by"]
    }],
    unselected: [{
      type: Output,
      args: ["p-unselected"]
    }],
    changeVisibleColumns: [{
      type: Output,
      args: ["p-change-visible-columns"]
    }],
    columnRestoreManager: [{
      type: Output,
      args: ["p-restore-column-manager"]
    }],
    items: [{
      type: Input,
      args: ["p-items"]
    }],
    columns: [{
      type: Input,
      args: ["p-columns"]
    }],
    container: [{
      type: Input,
      args: ["p-container"]
    }],
    paramDeleteApi: [{
      type: Input,
      args: ["p-param-delete-api"]
    }],
    height: [{
      type: Input,
      args: ["p-height"]
    }],
    hideDetail: [{
      type: Input,
      args: ["p-hide-detail"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    loading: [{
      type: Input,
      args: ["p-loading"]
    }],
    actions: [{
      type: Input,
      args: ["p-actions"]
    }],
    selectable: [{
      type: Input,
      args: ["p-selectable"]
    }],
    infiniteScroll: [{
      type: Input,
      args: ["p-infinite-scroll"]
    }],
    infiniteScrollDistance: [{
      type: Input,
      args: ["p-infinite-scroll-distance"]
    }],
    serviceApi: [{
      type: Input,
      args: ["p-service-api"]
    }],
    serviceDeleteApi: [{
      type: Input,
      args: ["p-service-delete"]
    }],
    spacing: [{
      type: Input,
      args: ["p-spacing"]
    }],
    filteredColumns: [{
      type: Input,
      args: ["p-filtered-columns"]
    }],
    draggable: [{
      type: Input,
      args: ["p-draggable"]
    }],
    virtualScroll: [{
      type: Input,
      args: ["p-virtual-scroll"]
    }]
  });
})();
var PoTableCellTemplateDirective = class _PoTableCellTemplateDirective {
  templateRef;
  // Necessário manter templateRef para o funcionamento do cell template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoTableCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTableCellTemplateDirective,
    selectors: [["", "p-table-cell-template", ""]],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-table-cell-template]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var PoTableColumnTemplateDirective = class _PoTableColumnTemplateDirective {
  templateRef;
  /**
   * @optional
   *
   * @description
   *
   * Variável responsável por armazenar a property da coluna da tabela que será adicionado o template.
   *
   * Caso não seja informada esta propriedade, serão apresentados normalmente os dados da coluna.
   */
  targetProperty;
  // Necessário manter templateRef para o funcionamento do column template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoTableColumnTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableColumnTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTableColumnTemplateDirective,
    selectors: [["", "p-table-column-template", ""]],
    inputs: {
      targetProperty: [0, "p-property", "targetProperty"]
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-table-column-template]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], {
    targetProperty: [{
      type: Input,
      args: ["p-property"]
    }]
  });
})();
var PoTableRowTemplateDirective = class _PoTableRowTemplateDirective {
  templateRef;
  /**
   * @optional
   *
   * @description
   *
   * Função que deve retornar um valor booleano, informando se apresentará o template da linha.
   * Serão passados o objeto da linha e o indice da mesma por parâmetro, para que seja possível
   * tomar uma decisão a partir do objeto da linha corrente.
   *
   * Caso não ser utilizado esta propriedade, serão apresentados todos os detalhes das linhas.
   *
   * @default `true`
   */
  poTableRowTemplateShow;
  _tableRowTemplateArrowDirection = PoTableRowTemplateArrowDirection.Left;
  /**
   * @optional
   *
   * @description
   *
   * Propriedade responsável por informar a posição do colapse que abrirá os detalhes da linha.
   *
   * @default `'LEFT'`
   */
  set tableRowTemplateArrowDirection(value) {
    value = value?.toUpperCase();
    this._tableRowTemplateArrowDirection = Object.values(PoTableRowTemplateArrowDirection).includes(value) ? value : PoTableRowTemplateArrowDirection.Left;
  }
  get tableRowTemplateArrowDirection() {
    return this._tableRowTemplateArrowDirection;
  }
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoTableRowTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableRowTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTableRowTemplateDirective,
    selectors: [["", "p-table-row-template", ""]],
    inputs: {
      poTableRowTemplateShow: [0, "p-table-row-template-show", "poTableRowTemplateShow"],
      tableRowTemplateArrowDirection: [0, "p-table-row-template-arrow-direction", "tableRowTemplateArrowDirection"]
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableRowTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-table-row-template]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], {
    poTableRowTemplateShow: [{
      type: Input,
      args: ["p-table-row-template-show"]
    }],
    tableRowTemplateArrowDirection: [{
      type: Input,
      args: ["p-table-row-template-arrow-direction"]
    }]
  });
})();
var _c0$Y = ["noColumnsHeader"];
var _c1$o = ["popup"];
var _c2$c = ["tableFooter"];
var _c3$8 = ["tableWrapper"];
var _c4$3 = ["tableTemplate"];
var _c5$1 = ["tableVirtualScroll"];
var _c6 = ["tableScrollable"];
var _c7 = ["columnManager"];
var _c8 = ["columnBatchActions"];
var _c9 = ["columnActionLeft"];
var _c10 = ["filterInput"];
var _c11 = ["poSearchInput"];
var _c12 = ["columnManagerTarget"];
var _c13 = ["columnManagerTargetFixed"];
var _c14 = ["actionsIconElement"];
var _c15 = ["actionsElement"];
var _c16 = (a0, a1, a2, a3, a4) => ({
  "po-table-interactive": a0,
  "po-table-selectable": a1,
  "po-table-striped": a2,
  "po-table-data-fixed-columns": a3,
  "po-table-text-wrap-enabled": a4
});
var _c17 = (a0, a1) => ({
  "no-hover": a0,
  "po-table-column-drag": a1
});
var _c18 = (a0) => ({
  "po-table-header-sorted": a0
});
var _c19 = (a0) => ({
  "width": a0
});
var _c20 = (a0) => ({
  $implicit: a0
});
var _c21 = (a0, a1) => ({
  row: a0,
  rowIndex: a1
});
var _c22 = (a0, a1) => ({
  row: a0,
  column: a1
});
var _c23 = (a0, a1) => ({
  $implicit: a0,
  rowIndex: a1
});
function PoTableComponent_div_1_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r1.literals.noItem);
  }
}
function PoTableComponent_div_1_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r1.literals.oneItem);
  }
}
function PoTableComponent_div_1_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate2("", ctx_r1.itemsSelected.length, " ", ctx_r1.literals.multipleItems, "");
  }
}
function PoTableComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 38, 12)(2, "div", 39)(3, "strong");
    ɵɵtemplate(4, PoTableComponent_div_1_ng_template_4_Template, 1, 1, "ng-template", 40)(5, PoTableComponent_div_1_ng_template_5_Template, 1, 1, "ng-template", 41)(6, PoTableComponent_div_1_ng_template_6_Template, 1, 2, "ng-template", 42);
    ɵɵelementEnd()();
    ɵɵelementStart(7, "div", 43)(8, "po-button", 44);
    ɵɵlistener("p-click", function PoTableComponent_div_1_Template_po_button_p_click_8_listener() {
      ɵɵrestoreView(_r1);
      ɵɵnextContext();
      const modalDelete_r3 = ɵɵreference(30);
      return ɵɵresetView(modalDelete_r3.open());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngPlural", ctx_r1.itemsSelected.length);
    ɵɵadvance(6);
    ɵɵproperty("p-danger", true)("p-disabled", ctx_r1.itemsSelected.length > 1 && ctx_r1.serviceDeleteApi !== void 0)("p-label", ctx_r1.literals.delete);
  }
}
function PoTableComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 45, 13)(2, "po-button", 46, 14);
    ɵɵlistener("p-click", function PoTableComponent_div_2_Template_po_button_p_click_2_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onOpenColumnManager());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("p-aria-label", ctx_r1.literals.columnsManager)("p-tooltip", ctx_r1.literals.columnsManager);
  }
}
function PoTableComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 47)(1, "po-search", 48);
    ɵɵlistener("p-filtered-items-change", function PoTableComponent_div_3_Template_po_search_p_filtered_items_change_1_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onFilteredItemsChange($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-items", ctx_r1.items)("p-filter-keys", ctx_r1.filteredColumns)("p-filter-type", ctx_r1.filterType);
  }
}
function PoTableComponent_po_container_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_po_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-container", 49);
    ɵɵtemplate(1, PoTableComponent_po_container_4_ng_container_1_Template, 1, 0, "ng-container", 50);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const tableContainerTemplate_r6 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tableContainerTemplate_r6);
  }
}
function PoTableComponent_ng_template_5_po_loading_overlay_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-loading-overlay", 57);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-text", ctx_r1.literals.loadingData)("p-size", ctx_r1.sizeLoading);
  }
}
function PoTableComponent_ng_template_5_div_5_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_5_div_5_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, PoTableComponent_ng_template_5_div_5_div_3_ng_container_1_Template, 1, 0, "ng-container", 50);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(3);
    const tableVirtualScrollTemplate_r7 = ɵɵreference(11);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tableVirtualScrollTemplate_r7);
  }
}
function PoTableComponent_ng_template_5_div_5_div_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_5_div_5_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 60);
    ɵɵtemplate(1, PoTableComponent_ng_template_5_div_5_div_4_ng_container_1_Template, 1, 0, "ng-container", 50);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    const tableTemplate_r8 = ɵɵreference(9);
    ɵɵstyleProp("height", ctx_r1.heightTableContainer, "px");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tableTemplate_r8);
  }
}
function PoTableComponent_ng_template_5_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 58)(1, "div", null, 16);
    ɵɵtemplate(3, PoTableComponent_ng_template_5_div_5_div_3_Template, 2, 1, "div", 55)(4, PoTableComponent_ng_template_5_div_5_div_4_Template, 2, 3, "div", 59);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("height", ctx_r1.heightTableContainer, "px");
    ɵɵadvance();
    ɵɵclassProp("po-table-container-fixed-inner", ctx_r1.virtualScroll);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.virtualScroll);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.virtualScroll);
  }
}
function PoTableComponent_ng_template_5_div_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_5_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, PoTableComponent_ng_template_5_div_6_ng_container_1_Template, 1, 0, "ng-container", 50);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const tableTemplate_r8 = ɵɵreference(9);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tableTemplate_r8);
  }
}
function PoTableComponent_ng_template_5_div_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "po-table-subtitle-footer", 63);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r9 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("p-literals", ctx_r1.literals)("p-subtitles", column_r9.subtitles);
  }
}
function PoTableComponent_ng_template_5_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 61);
    ɵɵtemplate(1, PoTableComponent_ng_template_5_div_7_ng_container_1_Template, 2, 2, "ng-container", 62);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.subtitleColumns)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function PoTableComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, PoTableComponent_ng_template_5_po_loading_overlay_1_Template, 1, 2, "po-loading-overlay", 51);
    ɵɵelementStart(2, "div", 52)(3, "div", 53, 15);
    ɵɵtemplate(5, PoTableComponent_ng_template_5_div_5_Template, 5, 6, "div", 54)(6, PoTableComponent_ng_template_5_div_6_Template, 2, 1, "div", 55);
    ɵɵelementEnd()()();
    ɵɵtemplate(7, PoTableComponent_ng_template_5_div_7_Template, 2, 2, "div", 56);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-table-container-sticky", ctx_r1.loading);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.loading);
    ɵɵadvance(2);
    ɵɵstyleProp("opacity", ctx_r1.tableOpacity);
    ɵɵclassProp("po-table-header-fixed-columns-pixels", ctx_r1.allColumnsWidthPixels);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasFooter);
  }
}
function PoTableComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 64, 17)(2, "po-button", 65);
    ɵɵlistener("p-click", function PoTableComponent_div_7_Template_po_button_p_click_2_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onShowMore());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-invisible", ctx_r1.showMore.observers.length === 0 && !ctx_r1.hasService);
    ɵɵadvance(2);
    ɵɵproperty("p-disabled", ctx_r1.showMoreDisabled)("p-label", ctx_r1.literals.loadMoreData)("p-loading", ctx_r1.loadingShowMore);
  }
}
function PoTableComponent_ng_template_8_th_4_po_checkbox_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox", 77);
    ɵɵlistener("p-change", function PoTableComponent_ng_template_8_th_4_po_checkbox_2_Template_po_checkbox_p_change_0_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.selectAllRows());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-checkboxValue", ctx_r1.selectAll === null ? "mixed" : ctx_r1.selectAll);
  }
}
function PoTableComponent_ng_template_8_th_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 75)(1, "div");
    ɵɵtemplate(2, PoTableComponent_ng_template_8_th_4_po_checkbox_2_Template, 1, 1, "po-checkbox", 76);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("pointer-events", ctx_r1.hideSelectAll ? "none" : "auto");
    ɵɵadvance();
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r1.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hideSelectAll);
  }
}
function PoTableComponent_ng_template_8_th_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 78);
  }
}
function PoTableComponent_ng_template_8_th_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", null, 21);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("po-table-header-master-detail", !ctx_r1.isSingleAction)("po-table-header-single-action", ctx_r1.isSingleAction);
  }
}
function PoTableComponent_ng_template_8_th_7_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_th_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 79, 22);
    ɵɵtemplate(2, PoTableComponent_ng_template_8_th_7_ng_container_2_Template, 1, 0, "ng-container", 72);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    const noColumnsWithHeight_r13 = ɵɵreference(23);
    const noColumnsWithoutHeight_r14 = ɵɵreference(25);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.height)("ngIfThen", noColumnsWithHeight_r13)("ngIfElse", noColumnsWithoutHeight_r14);
  }
}
function PoTableComponent_ng_template_8_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_ng_template_9_th_0_ng_container_4_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 86);
  }
}
function PoTableComponent_ng_template_8_ng_template_9_th_0_ng_container_4__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 87);
    ɵɵelement(1, "circle", 88)(2, "circle", 89)(3, "circle", 90)(4, "circle", 91)(5, "circle", 92)(6, "circle", 93);
    ɵɵelementEnd();
  }
}
function PoTableComponent_ng_template_8_ng_template_9_th_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_template_9_th_0_ng_container_4_po_icon_1_Template, 1, 0, "po-icon", 84)(2, PoTableComponent_ng_template_8_ng_template_9_th_0_ng_container_4__svg_svg_2_Template, 7, 0, "svg", 85);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.iconNameLib === "AnimaliaIcon");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.iconNameLib === "PoIcon");
  }
}
function PoTableComponent_ng_template_8_ng_template_9_th_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_ng_template_9_th_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 81);
    ɵɵpipe(1, "titlecase");
    ɵɵpipe(2, "lowercase");
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_template_9_th_0_Template_th_click_0_listener() {
      const column_r16 = ɵɵrestoreView(_r15).$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.sortColumn(column_r16));
    });
    ɵɵelementStart(3, "div", 82);
    ɵɵtemplate(4, PoTableComponent_ng_template_8_ng_template_9_th_0_ng_container_4_Template, 3, 2, "ng-container", 55)(5, PoTableComponent_ng_template_8_ng_template_9_th_0_ng_container_5_Template, 1, 0, "ng-container", 83);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r16 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    const contentHeaderTemplate_r17 = ɵɵreference(21);
    ɵɵstyleProp("width", column_r16.width)("max-width", column_r16.width)("min-width", column_r16.width);
    ɵɵclassProp("po-clickable", ctx_r1.sort && column_r16.sortable !== false || ctx_r1.hasService)("po-table-header-subtitle", column_r16.type === "subtitle")("po-table-column-drag-box", ctx_r1.isDraggable);
    ɵɵproperty("ngClass", ɵɵpureFunction1(30, _c18, ctx_r1.sort && ctx_r1.JSON.stringify(ctx_r1.sortedColumn == null ? null : ctx_r1.sortedColumn.property) === ctx_r1.JSON.stringify(column_r16) && (ctx_r1.sortedColumn.ascending || !ctx_r1.sortedColumn.ascending)))("ngStyle", ɵɵpureFunction1(32, _c19, ctx_r1.height > 0 && !ctx_r1.virtualScroll ? !ctx_r1.hasItems ? "100%" : ctx_r1.applyFixedColumns() ? column_r16.width : "auto" : ""))("cdkDragDisabled", column_r16.fixed ? "true" : "false")("pFrozenColumn", column_r16.fixed);
    ɵɵattribute("data-po-table-column-name", ɵɵpipeBind1(2, 28, column_r16.label || ɵɵpipeBind1(1, 26, column_r16.property)));
    ɵɵadvance(3);
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r1.height)("po-table-header-flex-right", column_r16.type === "currency" || column_r16.type === "number")("po-table-header-flex-center", column_r16.type === "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isDraggable && !column_r16.fixed);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", contentHeaderTemplate_r17)("ngTemplateOutletContext", ɵɵpureFunction1(34, _c20, column_r16));
  }
}
function PoTableComponent_ng_template_8_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_8_ng_template_9_th_0_Template, 6, 36, "th", 80);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngForOf", ctx_r1.mainColumns)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function PoTableComponent_ng_template_8_ng_template_11_th_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_ng_template_11_th_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 95);
    ɵɵpipe(1, "titlecase");
    ɵɵpipe(2, "lowercase");
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_template_11_th_0_Template_th_click_0_listener() {
      const column_r19 = ɵɵrestoreView(_r18).$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.sortColumn(column_r19));
    });
    ɵɵelementStart(3, "div", 82);
    ɵɵtemplate(4, PoTableComponent_ng_template_8_ng_template_11_th_0_ng_container_4_Template, 1, 0, "ng-container", 83);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r19 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    const contentHeaderTemplate_r17 = ɵɵreference(21);
    ɵɵstyleProp("width", column_r19.width)("max-width", column_r19.width)("min-width", column_r19.width);
    ɵɵclassProp("po-clickable", ctx_r1.sort && column_r19.sortable !== false || ctx_r1.hasService)("po-table-header-subtitle", column_r19.type === "subtitle");
    ɵɵproperty("ngClass", ɵɵpureFunction1(26, _c18, ctx_r1.sort && ctx_r1.JSON.stringify(ctx_r1.sortedColumn == null ? null : ctx_r1.sortedColumn.property) === ctx_r1.JSON.stringify(column_r19) && (ctx_r1.sortedColumn.ascending || !ctx_r1.sortedColumn.ascending)))("ngStyle", ɵɵpureFunction1(28, _c19, ctx_r1.height > 0 && !ctx_r1.virtualScroll ? !ctx_r1.hasItems ? "100%" : ctx_r1.applyFixedColumns() ? column_r19.width : "auto" : ""))("pFrozenColumn", column_r19.fixed);
    ɵɵattribute("data-po-table-column-name", ɵɵpipeBind1(2, 24, column_r19.label || ɵɵpipeBind1(1, 22, column_r19.property)));
    ɵɵadvance(3);
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r1.height)("po-table-header-flex-right", column_r19.type === "currency" || column_r19.type === "number")("po-table-header-flex-center", column_r19.type === "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", contentHeaderTemplate_r17)("ngTemplateOutletContext", ɵɵpureFunction1(30, _c20, column_r19));
  }
}
function PoTableComponent_ng_template_8_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_8_ng_template_11_th_0_Template, 5, 32, "th", 94);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngForOf", ctx_r1.mainColumns)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function PoTableComponent_ng_template_8_th_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 78);
  }
}
function PoTableComponent_ng_template_8_th_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("po-table-header-single-action", ctx_r1.isSingleAction)("po-table-header-actions", !ctx_r1.isSingleAction);
  }
}
function PoTableComponent_ng_template_8_tbody_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tbody", 96)(1, "tr", 97)(2, "td", 98)(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("colSpan", ctx_r1.columnCount);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.literals.noData, " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 75);
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_2_ng_container_1_Template, 1, 0, "ng-container", 83);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    const inputRadio_r21 = ɵɵreference(17);
    const inputCheckbox_r22 = ɵɵreference(19);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.singleSelect ? inputRadio_r21 : inputCheckbox_r22)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c20, row_r20));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_3_ng_template_1_Template(rf, ctx) {
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 104);
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_3_Template_td_click_0_listener() {
      ɵɵrestoreView(_r23);
      const row_r20 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.toggleDetail(row_r20));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_3_ng_template_1_Template, 0, 0, "ng-template", 105);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r23 = ɵɵnextContext();
    const row_r20 = ctx_r23.$implicit;
    const rowIndex_r25 = ctx_r23.index;
    ɵɵnextContext(3);
    const poTableColumnDetail_r26 = ɵɵreference(15);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", poTableColumnDetail_r26)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c21, row_r20, rowIndex_r25));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_4_ng_template_0_Template(rf, ctx) {
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_8_ng_container_16_tbody_1_4_ng_template_0_Template, 0, 0, "ng-template", 105);
  }
  if (rf & 2) {
    const ctx_r23 = ɵɵnextContext();
    const row_r20 = ctx_r23.$implicit;
    const rowIndex_r25 = ctx_r23.index;
    ɵɵnextContext(3);
    const ActionsColumnTemplate_r27 = ɵɵreference(27);
    ɵɵproperty("ngTemplateOutlet", ActionsColumnTemplate_r27)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c21, row_r20, rowIndex_r25));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_2_ng_container_1_Template, 1, 0, "ng-container", 83);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.getTemplate(column_r29))("ngTemplateOutletContext", ɵɵpureFunction1(2, _c20, ctx_r1.getCellData(row_r20, column_r29)));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_3_ng_container_1_Template, 1, 0, "ng-container", 83);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.tableCellTemplate == null ? null : ctx_r1.tableCellTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c22, row_r20, column_r29));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.getBooleanLabel(ctx_r1.getCellData(row_r20, column_r29), column_r29), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "currency");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind4(2, 1, ctx_r1.getCellData(row_r20, column_r29), column_r29.format, "symbol", "1.2-2"), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r1.getCellData(row_r20, column_r29), column_r29.format || "dd/MM/yyyy"), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "po_time");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r1.getCellData(row_r20, column_r29), column_r29.format || "HH:mm:ss.ffffff"), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r1.getCellData(row_r20, column_r29), column_r29.format || "dd/MM/yyyy HH:mm:ss"), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.formatNumber(ctx_r1.getCellData(row_r20, column_r29), column_r29.format), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_po_table_column_link_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r30 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-table-column-link", 112);
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_po_table_column_link_10_Template_po_table_column_link_click_0_listener($event) {
      ɵɵrestoreView(_r30);
      const column_r29 = ɵɵnextContext().$implicit;
      const row_r20 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onClickLink($event, row_r20, column_r29));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-action", column_r29.action)("p-disabled", ctx_r1.checkDisabled(row_r20, column_r29))("p-link", row_r20[column_r29.link])("p-row", row_r20)("p-value", ctx_r1.getCellData(row_r20, column_r29));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_po_table_column_icon_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-table-column-icon", 113);
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-column", column_r29)("p-icons", ctx_r1.getColumnIcons(row_r20, column_r29))("p-row", row_r20);
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵelement(1, "po-table-subtitle-circle", 114);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("p-subtitle", ctx_r1.getSubtitleColumn(row_r20, column_r29));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵelement(1, "po-table-column-label", 115);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("p-value", ctx_r1.getColumnLabel(row_r20, column_r29));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r29 = ɵɵnextContext().$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getCellData(row_r20, column_r29));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r28 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 106);
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_Template_td_click_0_listener() {
      ɵɵrestoreView(_r28);
      const row_r20 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.hasSelectableRow() ? ctx_r1.selectRow(row_r20) : "javascript:;");
    });
    ɵɵelementStart(1, "div", 107);
    ɵɵlistener("mouseenter", function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_Template_div_mouseenter_1_listener($event) {
      const column_r29 = ɵɵrestoreView(_r28).$implicit;
      const row_r20 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.tooltipMouseEnter($event, column_r29, row_r20));
    })("mouseleave", function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_Template_div_mouseleave_1_listener() {
      ɵɵrestoreView(_r28);
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.tooltipMouseLeave());
    });
    ɵɵtemplate(2, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_2_Template, 2, 4, "span", 108)(3, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_3_Template, 2, 5, "span", 108)(4, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_4_Template, 2, 1, "span", 108)(5, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_5_Template, 3, 6, "span", 108)(6, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_6_Template, 3, 4, "span", 108)(7, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_7_Template, 3, 4, "span", 108)(8, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_8_Template, 3, 4, "span", 108)(9, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_9_Template, 2, 1, "span", 108)(10, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_po_table_column_link_10_Template, 1, 5, "po-table-column-link", 109)(11, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_po_table_column_icon_11_Template, 1, 3, "po-table-column-icon", 110)(12, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_12_Template, 2, 1, "span", 108)(13, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_13_Template, 2, 1, "span", 108)(14, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_span_14_Template, 2, 1, "span", 111);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r29 = ctx.$implicit;
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("width", column_r29.width)("max-width", column_r29.width)("min-width", column_r29.width);
    ɵɵclassProp("po-table-column", column_r29.type !== "icon")("po-table-column-right", column_r29.type === "currency" || column_r29.type === "number")("po-table-column-center", column_r29.type === "subtitle")("po-table-column-icons", column_r29.type === "icon");
    ɵɵproperty("pFrozenColumn", column_r29.fixed)("ngClass", ctx_r1.getClassColor(row_r20, column_r29));
    ɵɵadvance();
    ɵɵproperty("ngSwitch", column_r29.type)("p-tooltip", ctx_r1.tooltipText)("p-append-in-body", true);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "columnTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "cellTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "boolean");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "currency");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "date");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "time");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "dateTime");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "number");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "link");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "icon");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "label");
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_6_ng_template_1_Template(rf, ctx) {
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r31 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 104);
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_6_Template_td_click_0_listener() {
      ɵɵrestoreView(_r31);
      const row_r20 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.toggleDetail(row_r20));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_6_ng_template_1_Template, 0, 0, "ng-template", 105);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r23 = ɵɵnextContext();
    const row_r20 = ctx_r23.$implicit;
    const rowIndex_r25 = ctx_r23.index;
    ɵɵnextContext(3);
    const poTableColumnDetail_r26 = ɵɵreference(15);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", poTableColumnDetail_r26)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c21, row_r20, rowIndex_r25));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_7_ng_template_0_Template(rf, ctx) {
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_8_ng_container_16_tbody_1_7_ng_template_0_Template, 0, 0, "ng-template", 105);
  }
  if (rf & 2) {
    const ctx_r23 = ɵɵnextContext();
    const row_r20 = ctx_r23.$implicit;
    const rowIndex_r25 = ctx_r23.index;
    ɵɵnextContext(3);
    const ActionsColumnTemplate_r27 = ɵɵreference(27);
    ɵɵproperty("ngTemplateOutlet", ActionsColumnTemplate_r27)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c21, row_r20, rowIndex_r25));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_tr_8_ng_template_2_Template(rf, ctx) {
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_tr_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr")(1, "td", 116);
    ɵɵtemplate(2, PoTableComponent_ng_template_8_ng_container_16_tbody_1_tr_8_ng_template_2_Template, 0, 0, "ng-template", 105);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r23 = ɵɵnextContext();
    const row_r20 = ctx_r23.$implicit;
    const rowIndex_r25 = ctx_r23.index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("colSpan", ctx_r1.columnCountForMasterDetail);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.tableRowTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(3, _c23, row_r20, rowIndex_r25));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_tr_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r32 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr")(1, "td", 117)(2, "po-table-detail", 118);
    ɵɵlistener("p-select-row", function PoTableComponent_ng_template_8_ng_container_16_tbody_1_tr_9_Template_po_table_detail_p_select_row_2_listener($event) {
      ɵɵrestoreView(_r32);
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.selectDetailRow($event));
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const row_r20 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("colSpan", ctx_r1.columnCountForMasterDetail);
    ɵɵadvance();
    ɵɵproperty("p-selectable", ctx_r1.selectable && !ctx_r1.detailHideSelect)("p-detail", ctx_r1.columnMasterDetail.detail)("p-items", row_r20[ctx_r1.nameColumnDetail])("p-parent-row", row_r20);
  }
}
function PoTableComponent_ng_template_8_ng_container_16_tbody_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tbody", 96)(1, "tr", 100);
    ɵɵtemplate(2, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_2_Template, 2, 4, "td", 101)(3, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_3_Template, 2, 5, "td", 102)(4, PoTableComponent_ng_template_8_ng_container_16_tbody_1_4_Template, 1, 5, null, 55)(5, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_5_Template, 15, 31, "td", 103)(6, PoTableComponent_ng_template_8_ng_container_16_tbody_1_td_6_Template, 2, 5, "td", 102)(7, PoTableComponent_ng_template_8_ng_container_16_tbody_1_7_Template, 1, 5, null, 55);
    ɵɵelementEnd();
    ɵɵtemplate(8, PoTableComponent_ng_template_8_ng_container_16_tbody_1_tr_8_Template, 3, 6, "tr", 55)(9, PoTableComponent_ng_template_8_ng_container_16_tbody_1_tr_9_Template, 3, 5, "tr", 55);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r20 = ctx.$implicit;
    const rowIndex_r25 = ctx.index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵclassProp("po-table-row-active", row_r20.$selected || row_r20.$selected === null && ctx_r1.selectable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.selectable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.columnMasterDetail && !ctx_r1.hideDetail && !ctx_r1.hasRowTemplate || ctx_r1.hasRowTemplate && !ctx_r1.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.actionRight && (ctx_r1.visibleActions.length > 1 || ctx_r1.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.mainColumns)("ngForTrackBy", ctx_r1.trackBy);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.actionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasMainColumns && ctx_r1.hasRowTemplate && row_r20.$showDetail && ctx_r1.isShowRowTemplate(row_r20, rowIndex_r25));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasMainColumns && ctx_r1.isShowMasterDetail(row_r20));
  }
}
function PoTableComponent_ng_template_8_ng_container_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_16_tbody_1_Template, 10, 11, "tbody", 99);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.filteredItems)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function PoTableComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "table", 66, 18)(2, "thead")(3, "tr", 67);
    ɵɵlistener("cdkDropListDropped", function PoTableComponent_ng_template_8_Template_tr_cdkDropListDropped_3_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.drop($event));
    });
    ɵɵtemplate(4, PoTableComponent_ng_template_8_th_4_Template, 3, 5, "th", 68)(5, PoTableComponent_ng_template_8_th_5_Template, 1, 0, "th", 69)(6, PoTableComponent_ng_template_8_th_6_Template, 2, 4, "th", 70)(7, PoTableComponent_ng_template_8_th_7_Template, 3, 3, "th", 71)(8, PoTableComponent_ng_template_8_ng_container_8_Template, 1, 0, "ng-container", 72)(9, PoTableComponent_ng_template_8_ng_template_9_Template, 1, 2, "ng-template", null, 19, ɵɵtemplateRefExtractor)(11, PoTableComponent_ng_template_8_ng_template_11_Template, 1, 2, "ng-template", null, 20, ɵɵtemplateRefExtractor)(13, PoTableComponent_ng_template_8_th_13_Template, 1, 0, "th", 69)(14, PoTableComponent_ng_template_8_th_14_Template, 1, 4, "th", 73);
    ɵɵelementEnd()();
    ɵɵtemplate(15, PoTableComponent_ng_template_8_tbody_15_Template, 5, 2, "tbody", 74)(16, PoTableComponent_ng_template_8_ng_container_16_Template, 2, 2, "ng-container", 55);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tableDefaultThDragDrop_r33 = ɵɵreference(10);
    const tableDefaultThDefault_r34 = ɵɵreference(12);
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction5(18, _c16, ctx_r1.selectable || ctx_r1.sort, ctx_r1.selectable, ctx_r1.striped, ctx_r1.applyFixedColumns(), ctx_r1.textWrap));
    ɵɵattribute("p-spacing", ctx_r1.spacing);
    ɵɵadvance(2);
    ɵɵclassProp("po-table-header-sticky", ctx_r1.height > 0 && !ctx_r1.virtualScroll);
    ɵɵadvance();
    ɵɵclassProp("po-table-header", !ctx_r1.height);
    ɵɵproperty("ngClass", !ctx_r1.height ? ɵɵpureFunction2(24, _c17, ctx_r1.hideSelectAll, ctx_r1.isDraggable) : "");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasSelectableColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", (ctx_r1.hasMasterDetailColumn || ctx_r1.hasRowTemplate) && ctx_r1.hasMainColumns && !ctx_r1.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.actionRight && (ctx_r1.visibleActions.length > 1 || ctx_r1.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hasMainColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isDraggable || ctx_r1.hasSomeFixed())("ngIfThen", tableDefaultThDragDrop_r33)("ngIfElse", tableDefaultThDefault_r34);
    ɵɵadvance(5);
    ɵɵproperty("ngIf", ctx_r1.hasRowTemplateWithArrowDirectionRight && (ctx_r1.hasVisibleActions || ctx_r1.hideColumnsManager) && ctx_r1.hasMainColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasVisibleActions && ctx_r1.actionRight && (ctx_r1.visibleActions.length > 1 || ctx_r1.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hasItems || !ctx_r1.hasMainColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasMainColumns);
  }
}
function PoTableComponent_ng_template_10_th_5_po_checkbox_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r36 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox", 77);
    ɵɵlistener("p-change", function PoTableComponent_ng_template_10_th_5_po_checkbox_2_Template_po_checkbox_p_change_0_listener() {
      ɵɵrestoreView(_r36);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.selectAllRows());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-checkboxValue", ctx_r1.selectAll === null ? "mixed" : ctx_r1.selectAll);
  }
}
function PoTableComponent_ng_template_10_th_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 75)(1, "div");
    ɵɵtemplate(2, PoTableComponent_ng_template_10_th_5_po_checkbox_2_Template, 1, 1, "po-checkbox", 76);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("pointer-events", ctx_r1.hideSelectAll ? "none" : "auto");
    ɵɵadvance();
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r1.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hideSelectAll);
  }
}
function PoTableComponent_ng_template_10_th_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 78);
  }
}
function PoTableComponent_ng_template_10_th_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", null, 21);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("po-table-header-master-detail", !ctx_r1.isSingleAction)("po-table-header-single-action", ctx_r1.isSingleAction);
  }
}
function PoTableComponent_ng_template_10_th_8_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_th_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 79, 22);
    ɵɵtemplate(2, PoTableComponent_ng_template_10_th_8_ng_container_2_Template, 1, 0, "ng-container", 72);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    const noColumnsWithHeight_r13 = ɵɵreference(23);
    const noColumnsWithoutHeight_r14 = ɵɵreference(25);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.height)("ngIfThen", noColumnsWithHeight_r13)("ngIfElse", noColumnsWithoutHeight_r14);
  }
}
function PoTableComponent_ng_template_10_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_4_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 86);
  }
}
function PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_4__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 87);
    ɵɵelement(1, "circle", 88)(2, "circle", 89)(3, "circle", 90)(4, "circle", 91)(5, "circle", 92)(6, "circle", 93);
    ɵɵelementEnd();
  }
}
function PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_4_po_icon_1_Template, 1, 0, "po-icon", 84)(2, PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_4__svg_svg_2_Template, 7, 0, "svg", 85);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.iconNameLib === "AnimaliaIcon");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.iconNameLib === "PoIcon");
  }
}
function PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_ng_template_10_th_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r37 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 81);
    ɵɵpipe(1, "titlecase");
    ɵɵpipe(2, "lowercase");
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_template_10_th_0_Template_th_click_0_listener() {
      const column_r38 = ɵɵrestoreView(_r37).$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.sortColumn(column_r38));
    });
    ɵɵelementStart(3, "div", 82);
    ɵɵtemplate(4, PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_4_Template, 3, 2, "ng-container", 55)(5, PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_5_Template, 1, 0, "ng-container", 83);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r38 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    const contentHeaderTemplate_r17 = ɵɵreference(21);
    ɵɵstyleProp("width", column_r38.width)("max-width", column_r38.width)("min-width", column_r38.width);
    ɵɵclassProp("po-clickable", ctx_r1.sort && column_r38.sortable !== false || ctx_r1.hasService)("po-table-header-subtitle", column_r38.type === "subtitle")("po-table-column-drag-box", ctx_r1.isDraggable);
    ɵɵproperty("ngClass", ɵɵpureFunction1(30, _c18, ctx_r1.sort && ctx_r1.JSON.stringify(ctx_r1.sortedColumn == null ? null : ctx_r1.sortedColumn.property) === ctx_r1.JSON.stringify(column_r38) && (ctx_r1.sortedColumn.ascending || !ctx_r1.sortedColumn.ascending)))("ngStyle", ɵɵpureFunction1(32, _c19, !ctx_r1.hasItems ? "100%" : ctx_r1.applyFixedColumns() ? column_r38.width : "auto"))("cdkDragDisabled", column_r38.fixed ? "true" : "false")("pFrozenColumn", column_r38.fixed);
    ɵɵattribute("data-po-table-column-name", ɵɵpipeBind1(2, 28, column_r38.label || ɵɵpipeBind1(1, 26, column_r38.property)));
    ɵɵadvance(3);
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r1.height)("po-table-header-flex-right", column_r38.type === "currency" || column_r38.type === "number")("po-table-header-flex-center", column_r38.type === "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isDraggable && !column_r38.fixed);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", contentHeaderTemplate_r17)("ngTemplateOutletContext", ɵɵpureFunction1(34, _c20, column_r38));
  }
}
function PoTableComponent_ng_template_10_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_10_ng_template_10_th_0_Template, 6, 36, "th", 80);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngForOf", ctx_r1.mainColumns)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function PoTableComponent_ng_template_10_ng_template_12_th_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_ng_template_12_th_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r39 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 123);
    ɵɵpipe(1, "titlecase");
    ɵɵpipe(2, "lowercase");
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_template_12_th_0_Template_th_click_0_listener() {
      const column_r40 = ɵɵrestoreView(_r39).$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.sortColumn(column_r40));
    });
    ɵɵelementStart(3, "div", 82);
    ɵɵtemplate(4, PoTableComponent_ng_template_10_ng_template_12_th_0_ng_container_4_Template, 1, 0, "ng-container", 83);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r40 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    const contentHeaderTemplate_r17 = ɵɵreference(21);
    ɵɵstyleProp("width", column_r40.width)("max-width", column_r40.width)("min-width", column_r40.width);
    ɵɵclassProp("po-clickable", ctx_r1.sort && column_r40.sortable !== false || ctx_r1.hasService)("po-table-header-subtitle", column_r40.type === "subtitle");
    ɵɵproperty("ngClass", ɵɵpureFunction1(26, _c18, ctx_r1.sort && ctx_r1.JSON.stringify(ctx_r1.sortedColumn == null ? null : ctx_r1.sortedColumn.property) === ctx_r1.JSON.stringify(column_r40) && (ctx_r1.sortedColumn.ascending || !ctx_r1.sortedColumn.ascending)))("ngStyle", ɵɵpureFunction1(28, _c19, !ctx_r1.hasItems ? "100%" : ctx_r1.applyFixedColumns() ? column_r40.width : "auto"))("pFrozenColumn", column_r40.fixed);
    ɵɵattribute("data-po-table-column-name", ɵɵpipeBind1(2, 24, column_r40.label || ɵɵpipeBind1(1, 22, column_r40.property)));
    ɵɵadvance(3);
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r1.height)("po-table-header-flex-right", column_r40.type === "currency" || column_r40.type === "number")("po-table-header-flex-center", column_r40.type === "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", contentHeaderTemplate_r17)("ngTemplateOutletContext", ɵɵpureFunction1(30, _c20, column_r40));
  }
}
function PoTableComponent_ng_template_10_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_10_ng_template_12_th_0_Template, 5, 32, "th", 122);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngForOf", ctx_r1.mainColumns)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function PoTableComponent_ng_template_10_th_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 78);
  }
}
function PoTableComponent_ng_template_10_th_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("po-table-header-single-action", ctx_r1.isSingleAction)("po-table-header-actions", !ctx_r1.isSingleAction);
  }
}
function PoTableComponent_ng_template_10_tbody_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tbody", 96)(1, "tr", 97)(2, "td", 98)(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("colSpan", ctx_r1.columnCount);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.literals.noData, " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 75);
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_2_ng_container_1_Template, 1, 0, "ng-container", 83);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    const inputRadio_r21 = ɵɵreference(17);
    const inputCheckbox_r22 = ɵɵreference(19);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.singleSelect ? inputRadio_r21 : inputCheckbox_r22)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c20, row_r41));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_3_ng_template_1_Template(rf, ctx) {
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r42 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 104);
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_3_Template_td_click_0_listener() {
      ɵɵrestoreView(_r42);
      const row_r41 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.toggleDetail(row_r41));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_3_ng_template_1_Template, 0, 0, "ng-template", 105);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r42 = ɵɵnextContext();
    const row_r41 = ctx_r42.$implicit;
    const rowIndex_r44 = ctx_r42.index;
    ɵɵnextContext(3);
    const poTableColumnDetail_r26 = ɵɵreference(15);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", poTableColumnDetail_r26)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c21, row_r41, rowIndex_r44));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_4_ng_template_0_Template(rf, ctx) {
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_10_ng_container_17_tbody_1_4_ng_template_0_Template, 0, 0, "ng-template", 105);
  }
  if (rf & 2) {
    const ctx_r42 = ɵɵnextContext();
    const row_r41 = ctx_r42.$implicit;
    const rowIndex_r44 = ctx_r42.index;
    ɵɵnextContext(3);
    const ActionsColumnTemplate_r27 = ɵɵreference(27);
    ɵɵproperty("ngTemplateOutlet", ActionsColumnTemplate_r27)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c21, row_r41, rowIndex_r44));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_2_ng_container_1_Template, 1, 0, "ng-container", 83);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.getTemplate(column_r46))("ngTemplateOutletContext", ɵɵpureFunction1(2, _c20, ctx_r1.getCellData(row_r41, column_r46)));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_3_ng_container_1_Template, 1, 0, "ng-container", 83);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.tableCellTemplate == null ? null : ctx_r1.tableCellTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c22, row_r41, column_r46));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.getBooleanLabel(ctx_r1.getCellData(row_r41, column_r46), column_r46), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "currency");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind4(2, 1, ctx_r1.getCellData(row_r41, column_r46), column_r46.format, "symbol", "1.2-2"), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r1.getCellData(row_r41, column_r46), column_r46.format || "dd/MM/yyyy"), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "po_time");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r1.getCellData(row_r41, column_r46), column_r46.format || "HH:mm:ss.ffffff"), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r1.getCellData(row_r41, column_r46), column_r46.format || "dd/MM/yyyy HH:mm:ss"), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.formatNumber(ctx_r1.getCellData(row_r41, column_r46), column_r46.format), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_po_table_column_link_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r47 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-table-column-link", 112);
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_po_table_column_link_10_Template_po_table_column_link_click_0_listener($event) {
      ɵɵrestoreView(_r47);
      const column_r46 = ɵɵnextContext().$implicit;
      const row_r41 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.onClickLink($event, row_r41, column_r46));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-action", column_r46.action)("p-disabled", ctx_r1.checkDisabled(row_r41, column_r46))("p-link", row_r41[column_r46.link])("p-row", row_r41)("p-value", ctx_r1.getCellData(row_r41, column_r46));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_po_table_column_icon_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-table-column-icon", 113);
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-column", column_r46)("p-icons", ctx_r1.getColumnIcons(row_r41, column_r46))("p-row", row_r41);
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵelement(1, "po-table-subtitle-circle", 114);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("p-subtitle", ctx_r1.getSubtitleColumn(row_r41, column_r46));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵelement(1, "po-table-column-label", 115);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("p-value", ctx_r1.getColumnLabel(row_r41, column_r46));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r46 = ɵɵnextContext().$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getCellData(row_r41, column_r46));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r45 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 126);
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_Template_td_click_0_listener() {
      ɵɵrestoreView(_r45);
      const row_r41 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.hasSelectableRow() ? ctx_r1.selectRow(row_r41) : "javascript:;");
    });
    ɵɵelementStart(1, "div", 107);
    ɵɵlistener("mouseenter", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_Template_div_mouseenter_1_listener($event) {
      const column_r46 = ɵɵrestoreView(_r45).$implicit;
      const row_r41 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.tooltipMouseEnter($event, column_r46, row_r41));
    })("mouseleave", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_Template_div_mouseleave_1_listener() {
      ɵɵrestoreView(_r45);
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.tooltipMouseLeave());
    });
    ɵɵtemplate(2, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_2_Template, 2, 4, "span", 108)(3, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_3_Template, 2, 5, "span", 108)(4, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_4_Template, 2, 1, "span", 108)(5, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_5_Template, 3, 6, "span", 108)(6, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_6_Template, 3, 4, "span", 108)(7, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_7_Template, 3, 4, "span", 108)(8, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_8_Template, 3, 4, "span", 108)(9, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_9_Template, 2, 1, "span", 108)(10, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_po_table_column_link_10_Template, 1, 5, "po-table-column-link", 109)(11, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_po_table_column_icon_11_Template, 1, 3, "po-table-column-icon", 110)(12, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_12_Template, 2, 1, "span", 108)(13, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_13_Template, 2, 1, "span", 108)(14, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_span_14_Template, 2, 1, "span", 111);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r46 = ctx.$implicit;
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("width", column_r46.width)("max-width", column_r46.width)("min-width", column_r46.width);
    ɵɵclassProp("po-table-column", column_r46.type !== "icon")("po-table-column-right", column_r46.type === "currency" || column_r46.type === "number")("po-table-column-center", column_r46.type === "subtitle")("po-table-column-icons", column_r46.type === "icon");
    ɵɵproperty("ngClass", ctx_r1.getClassColor(row_r41, column_r46))("pFrozenColumn", column_r46.fixed);
    ɵɵadvance();
    ɵɵproperty("ngSwitch", column_r46.type)("p-tooltip", ctx_r1.tooltipText)("p-append-in-body", true);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "columnTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "cellTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "boolean");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "currency");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "date");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "time");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "dateTime");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "number");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "link");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "icon");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "label");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_ng_template_1_Template(rf, ctx) {
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r48 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 104);
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_Template_td_click_0_listener() {
      ɵɵrestoreView(_r48);
      const row_r41 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.toggleDetail(row_r41));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_ng_template_1_Template, 0, 0, "ng-template", 105);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r42 = ɵɵnextContext();
    const row_r41 = ctx_r42.$implicit;
    const rowIndex_r44 = ctx_r42.index;
    ɵɵnextContext(3);
    const poTableColumnDetail_r26 = ɵɵreference(15);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", poTableColumnDetail_r26)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c21, row_r41, rowIndex_r44));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_7_ng_template_0_Template(rf, ctx) {
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_10_ng_container_17_tbody_1_7_ng_template_0_Template, 0, 0, "ng-template", 105);
  }
  if (rf & 2) {
    const ctx_r42 = ɵɵnextContext();
    const row_r41 = ctx_r42.$implicit;
    const rowIndex_r44 = ctx_r42.index;
    ɵɵnextContext(3);
    const ActionsColumnTemplate_r27 = ɵɵreference(27);
    ɵɵproperty("ngTemplateOutlet", ActionsColumnTemplate_r27)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c21, row_r41, rowIndex_r44));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_8_ng_template_2_Template(rf, ctx) {
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr")(1, "td", 116);
    ɵɵtemplate(2, PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_8_ng_template_2_Template, 0, 0, "ng-template", 105);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r42 = ɵɵnextContext();
    const row_r41 = ctx_r42.$implicit;
    const rowIndex_r44 = ctx_r42.index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("colSpan", ctx_r1.columnCountForMasterDetail);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.tableRowTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(3, _c23, row_r41, rowIndex_r44));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r49 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr")(1, "td", 117)(2, "po-table-detail", 118);
    ɵɵlistener("p-select-row", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_9_Template_po_table_detail_p_select_row_2_listener($event) {
      ɵɵrestoreView(_r49);
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.selectDetailRow($event));
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const row_r41 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("colSpan", ctx_r1.columnCountForMasterDetail);
    ɵɵadvance();
    ɵɵproperty("p-selectable", ctx_r1.selectable && !ctx_r1.detailHideSelect)("p-detail", ctx_r1.columnMasterDetail.detail)("p-items", row_r41[ctx_r1.nameColumnDetail])("p-parent-row", row_r41);
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tbody", 96)(1, "tr", 100);
    ɵɵtemplate(2, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_2_Template, 2, 4, "td", 101)(3, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_3_Template, 2, 5, "td", 102)(4, PoTableComponent_ng_template_10_ng_container_17_tbody_1_4_Template, 1, 5, null, 55)(5, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_Template, 15, 31, "td", 125)(6, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_Template, 2, 5, "td", 102)(7, PoTableComponent_ng_template_10_ng_container_17_tbody_1_7_Template, 1, 5, null, 55);
    ɵɵelementEnd();
    ɵɵtemplate(8, PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_8_Template, 3, 6, "tr", 55)(9, PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_9_Template, 3, 5, "tr", 55);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r41 = ctx.$implicit;
    const rowIndex_r44 = ctx.index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵclassProp("po-table-row-active", row_r41.$selected || row_r41.$selected === null && ctx_r1.selectable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.selectable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.columnMasterDetail && !ctx_r1.hideDetail && !ctx_r1.hasRowTemplate || ctx_r1.hasRowTemplate && !ctx_r1.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.actionRight && (ctx_r1.visibleActions.length > 1 || ctx_r1.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.mainColumns)("ngForTrackBy", ctx_r1.trackBy);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.actionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasMainColumns && ctx_r1.hasRowTemplate && row_r41.$showDetail && ctx_r1.isShowRowTemplate(row_r41, rowIndex_r44));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasMainColumns && ctx_r1.isShowMasterDetail(row_r41));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_Template, 10, 11, "tbody", 124);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("cdkVirtualForOf", ctx_r1.filteredItems)("cdkVirtualForTrackBy", ctx_r1.trackBy);
  }
}
function PoTableComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r35 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cdk-virtual-scroll-viewport", 119, 23)(2, "table", 66)(3, "thead", 120)(4, "tr", 121);
    ɵɵlistener("cdkDropListDropped", function PoTableComponent_ng_template_10_Template_tr_cdkDropListDropped_4_listener($event) {
      ɵɵrestoreView(_r35);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.drop($event));
    });
    ɵɵtemplate(5, PoTableComponent_ng_template_10_th_5_Template, 3, 5, "th", 68)(6, PoTableComponent_ng_template_10_th_6_Template, 1, 0, "th", 69)(7, PoTableComponent_ng_template_10_th_7_Template, 2, 4, "th", 70)(8, PoTableComponent_ng_template_10_th_8_Template, 3, 3, "th", 71)(9, PoTableComponent_ng_template_10_ng_container_9_Template, 1, 0, "ng-container", 72)(10, PoTableComponent_ng_template_10_ng_template_10_Template, 1, 2, "ng-template", null, 24, ɵɵtemplateRefExtractor)(12, PoTableComponent_ng_template_10_ng_template_12_Template, 1, 2, "ng-template", null, 25, ɵɵtemplateRefExtractor)(14, PoTableComponent_ng_template_10_th_14_Template, 1, 0, "th", 69)(15, PoTableComponent_ng_template_10_th_15_Template, 1, 4, "th", 73);
    ɵɵelementEnd()();
    ɵɵtemplate(16, PoTableComponent_ng_template_10_tbody_16_Template, 5, 2, "tbody", 74)(17, PoTableComponent_ng_template_10_ng_container_17_Template, 2, 2, "ng-container", 55);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const tableVirtualScrollThDragDrop_r50 = ɵɵreference(11);
    const tableVirtualScrollThDefault_r51 = ɵɵreference(13);
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r1.heightTableContainer, "px");
    ɵɵproperty("itemSize", ctx_r1.itemSize)("minBufferPx", ctx_r1.heightTableContainer < 100 ? 100 : ctx_r1.heightTableContainer)("maxBufferPx", ctx_r1.heightTableContainer < 200 ? 200 : ctx_r1.heightTableContainer);
    ɵɵadvance(2);
    ɵɵproperty("ngClass", ɵɵpureFunction5(22, _c16, ctx_r1.selectable || ctx_r1.sort, ctx_r1.selectable, ctx_r1.striped, ctx_r1.applyFixedColumns(), ctx_r1.textWrap));
    ɵɵattribute("p-spacing", ctx_r1.spacing);
    ɵɵadvance();
    ɵɵstyleProp("top", ctx_r1.inverseOfTranslation);
    ɵɵadvance();
    ɵɵclassProp("po-table-header", !ctx_r1.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasSelectableColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", (ctx_r1.hasMasterDetailColumn || ctx_r1.hasRowTemplate) && ctx_r1.hasMainColumns && !ctx_r1.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.actionRight && (ctx_r1.visibleActions.length > 1 || ctx_r1.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hasMainColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isDraggable || ctx_r1.hasSomeFixed())("ngIfThen", tableVirtualScrollThDragDrop_r50)("ngIfElse", tableVirtualScrollThDefault_r51);
    ɵɵadvance(5);
    ɵɵproperty("ngIf", ctx_r1.hasRowTemplateWithArrowDirectionRight && ctx_r1.hasMainColumns && (ctx_r1.hasVisibleActions || ctx_r1.hideColumnsManager));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasVisibleActions && ctx_r1.actionRight && (ctx_r1.visibleActions.length > 1 || ctx_r1.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hasItems || !ctx_r1.hasMainColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasMainColumns);
  }
}
function PoTableComponent_ng_template_14_po_icon_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 128);
  }
  if (rf & 2) {
    const row_r52 = ɵɵnextContext().row;
    ɵɵproperty("p-icon", row_r52.$showDetail ? "ICON_ARROW_UP" : "ICON_ARROW_DOWN");
  }
}
function PoTableComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_14_po_icon_0_Template, 1, 1, "po-icon", 127);
  }
  if (rf & 2) {
    const row_r52 = ctx.row;
    const rowIndex_r53 = ctx.rowIndex;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.containsMasterDetail(row_r52) && !ctx_r1.hasRowTemplate || ctx_r1.isShowRowTemplate(row_r52, rowIndex_r53) && ctx_r1.hasRowTemplate);
  }
}
function PoTableComponent_ng_template_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r54 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-radio", 129);
    ɵɵlistener("p-change-selected", function PoTableComponent_ng_template_16_Template_po_radio_p_change_selected_0_listener() {
      const row_r55 = ɵɵrestoreView(_r54).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectRow(row_r55));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r55 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.idRadio)("p-checked", row_r55.$selected);
  }
}
function PoTableComponent_ng_template_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r56 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox", 130);
    ɵɵlistener("p-change", function PoTableComponent_ng_template_18_Template_po_checkbox_p_change_0_listener() {
      const row_r57 = ɵɵrestoreView(_r56).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectable ? ctx_r1.selectRow(row_r57) : "javascript:;");
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r57 = ctx.$implicit;
    ɵɵproperty("p-checkboxValue", row_r57.$selected === null ? "mixed" : row_r57.$selected);
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_1_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 135);
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_1__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 136);
    ɵɵelement(1, "path", 137);
    ɵɵelementEnd();
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableComponent_ng_template_20_span_4_ng_container_1_po_icon_1_Template, 1, 0, "po-icon", 133)(2, PoTableComponent_ng_template_20_span_4_ng_container_1__svg_svg_2_Template, 2, 0, "svg", 134);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.iconNameLib === "AnimaliaIcon");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.iconNameLib === "PoIcon");
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_2_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 139);
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_2__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 136);
    ɵɵelement(1, "path", 140);
    ɵɵelementEnd();
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableComponent_ng_template_20_span_4_ng_container_2_po_icon_1_Template, 1, 0, "po-icon", 138)(2, PoTableComponent_ng_template_20_span_4_ng_container_2__svg_svg_2_Template, 2, 0, "svg", 134);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.iconNameLib === "AnimaliaIcon");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.iconNameLib === "PoIcon");
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_3_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 142);
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_3__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 136);
    ɵɵelement(1, "path", 143);
    ɵɵelementEnd();
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableComponent_ng_template_20_span_4_ng_container_3_po_icon_1_Template, 1, 0, "po-icon", 141)(2, PoTableComponent_ng_template_20_span_4_ng_container_3__svg_svg_2_Template, 2, 0, "svg", 134);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.iconNameLib === "AnimaliaIcon");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.iconNameLib === "PoIcon");
  }
}
function PoTableComponent_ng_template_20_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, PoTableComponent_ng_template_20_span_4_ng_container_1_Template, 3, 2, "ng-container", 55)(2, PoTableComponent_ng_template_20_span_4_ng_container_2_Template, 3, 2, "ng-container", 55)(3, PoTableComponent_ng_template_20_span_4_ng_container_3_Template, 3, 2, "ng-container", 55);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r59 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-table-header-icon-unselected", ctx_r1.JSON.stringify(ctx_r1.sortedColumn == null ? null : ctx_r1.sortedColumn.property) !== ctx_r1.JSON.stringify(column_r59))("po-table-header-icon-descending", ctx_r1.JSON.stringify(ctx_r1.sortedColumn == null ? null : ctx_r1.sortedColumn.property) === ctx_r1.JSON.stringify(column_r59) && ctx_r1.sortedColumn.ascending)("po-table-header-icon-ascending", ctx_r1.JSON.stringify(ctx_r1.sortedColumn == null ? null : ctx_r1.sortedColumn.property) === ctx_r1.JSON.stringify(column_r59) && !ctx_r1.sortedColumn.ascending);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.JSON.stringify(ctx_r1.sortedColumn == null ? null : ctx_r1.sortedColumn.property) !== ctx_r1.JSON.stringify(column_r59));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.JSON.stringify(ctx_r1.sortedColumn == null ? null : ctx_r1.sortedColumn.property) === ctx_r1.JSON.stringify(column_r59) && ctx_r1.sortedColumn.ascending);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.JSON.stringify(ctx_r1.sortedColumn == null ? null : ctx_r1.sortedColumn.property) === ctx_r1.JSON.stringify(column_r59) && !ctx_r1.sortedColumn.ascending);
  }
}
function PoTableComponent_ng_template_20_Template(rf, ctx) {
  if (rf & 1) {
    const _r58 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 131, 26);
    ɵɵlistener("mouseenter", function PoTableComponent_ng_template_20_Template_span_mouseenter_0_listener($event) {
      ɵɵrestoreView(_r58);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.tooltipMouseEnter($event));
    })("mouseleave", function PoTableComponent_ng_template_20_Template_span_mouseleave_0_listener() {
      ɵɵrestoreView(_r58);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.tooltipMouseLeave());
    });
    ɵɵtext(2);
    ɵɵpipe(3, "titlecase");
    ɵɵelementEnd();
    ɵɵtemplate(4, PoTableComponent_ng_template_20_span_4_Template, 4, 9, "span", 132);
  }
  if (rf & 2) {
    const column_r59 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-tooltip", ctx_r1.tooltipText)("p-append-in-body", true);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", column_r59.label || ɵɵpipeBind1(3, 4, column_r59.property), " ");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.sort && column_r59.sortable !== false);
  }
}
function PoTableComponent_ng_template_22_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 144);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r1.headerWidth, "px");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.hasValidColumns ? ctx_r1.literals.noVisibleColumn : ctx_r1.literals.noColumns, " ");
  }
}
function PoTableComponent_ng_template_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r1.hasValidColumns ? ctx_r1.literals.noVisibleColumn : ctx_r1.literals.noColumns, "\n");
  }
}
function PoTableComponent_ng_template_26_td_0_div_1_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 151);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("p-icon", ctx_r1.firstAction.icon);
  }
}
function PoTableComponent_ng_template_26_td_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r60 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 149);
    ɵɵlistener("click", function PoTableComponent_ng_template_26_td_0_div_1_Template_div_click_0_listener() {
      ɵɵrestoreView(_r60);
      const row_r61 = ɵɵnextContext(2).row;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.executeTableAction(row_r61, ctx_r1.firstAction));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_26_td_0_div_1_po_icon_1_Template, 1, 1, "po-icon", 150);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r61 = ɵɵnextContext(2).row;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-table-action-disabled", ctx_r1.firstAction.disabled ? ctx_r1.validateTableAction(row_r61, ctx_r1.firstAction) : false);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.firstAction.icon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.firstAction.label, " ");
  }
}
function PoTableComponent_ng_template_26_td_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 147);
    ɵɵtemplate(1, PoTableComponent_ng_template_26_td_0_div_1_Template, 3, 4, "div", 148);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("width", ctx_r1.height && ctx_r1.actionRight ? ctx_r1.getWidthColumnManager() : "", "px")("max-width", ctx_r1.height && !ctx_r1.actionRight ? ctx_r1.getColumnWidthActionsLeft() : "", "px")("width", ctx_r1.height && !ctx_r1.actionRight ? ctx_r1.getColumnWidthActionsLeft() : "", "px");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.firstAction.visible !== false);
  }
}
function PoTableComponent_ng_template_26_td_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r62 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 152)(1, "div", 153, 27);
    ɵɵlistener("click", function PoTableComponent_ng_template_26_td_1_Template_div_click_1_listener() {
      ɵɵrestoreView(_r62);
      const popupTarget_r63 = ɵɵreference(2);
      const row_r61 = ɵɵnextContext().row;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.togglePopup(row_r61, popupTarget_r63));
    });
    ɵɵelement(3, "po-icon", 154);
    ɵɵelementEnd()();
  }
}
function PoTableComponent_ng_template_26_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_26_td_0_Template, 2, 7, "td", 145)(1, PoTableComponent_ng_template_26_td_1_Template, 4, 0, "td", 146);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.isSingleAction);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.visibleActions.length > 1);
  }
}
function PoTableComponent_po_table_column_manager_28_Template(rf, ctx) {
  if (rf & 1) {
    const _r64 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-table-column-manager", 155);
    ɵɵlistener("p-visible-columns-change", function PoTableComponent_po_table_column_manager_28_Template_po_table_column_manager_p_visible_columns_change_0_listener($event) {
      ɵɵrestoreView(_r64);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onVisibleColumnsChange($event));
    })("p-change-visible-columns", function PoTableComponent_po_table_column_manager_28_Template_po_table_column_manager_p_change_visible_columns_0_listener($event) {
      ɵɵrestoreView(_r64);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onChangeVisibleColumns($event));
    })("p-initial-columns", function PoTableComponent_po_table_column_manager_28_Template_po_table_column_manager_p_initial_columns_0_listener($event) {
      ɵɵrestoreView(_r64);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onColumnRestoreManager($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-columns", ctx_r1.columns)("p-max-columns", ctx_r1.maxColumns)("p-target", ctx_r1.columnManagerTarget)("p-last-visible-columns-selected", ctx_r1.lastVisibleColumnsSelected)("p-hide-action-fixed-columns", ctx_r1.hideActionFixedColumns)("p-columns-default", ctx_r1.initialColumns);
  }
}
var PoTableComponent = class _PoTableComponent extends PoTableBaseComponent {
  changeDetector;
  decimalPipe;
  defaultService;
  tableRowTemplate;
  tableCellTemplate;
  tableColumnTemplates;
  noColumnsHeader;
  poPopupComponent;
  modalDelete;
  tableFooterElement;
  tableWrapperElement;
  tableTemplate;
  tableVirtualScroll;
  tableScrollable;
  columnManager;
  columnBatchActions;
  columnActionLeft;
  actionsIconElement;
  actionsElement;
  filterInput;
  poSearchInput;
  viewPort;
  poNotification = inject(PoNotificationService);
  heightTableContainer;
  heightTableVirtual;
  popupTarget;
  tableOpacity = 0;
  tooltipText;
  itemSize = 48;
  lastVisibleColumnsSelected;
  tagColor;
  idRadio;
  inputFieldValue = "";
  JSON;
  newOrderColumns;
  sizeLoading = "sm";
  headerWidth;
  close = {
    action: () => {
      this.modalDelete.close();
    },
    label: this.literals.cancel,
    danger: true
  };
  confirm = {
    action: () => {
      this.deleteItems();
    },
    label: this.literals.delete
  };
  _columnManagerTarget;
  _columnManagerTargetFixed;
  _iconToken;
  differ;
  footerHeight;
  headerHeight;
  timeoutResize;
  visibleElement = false;
  scrollEvent$;
  subscriptionScrollEvent;
  subscriptionService = new Subscription();
  clickListener;
  resizeListener;
  set columnManagerTarget(value) {
    this._columnManagerTarget = value;
    this.changeDetector.detectChanges();
  }
  get columnManagerTarget() {
    return this._columnManagerTarget;
  }
  set columnManagerTargetFixed(value) {
    this._columnManagerTargetFixed = value;
    this.changeDetector.detectChanges();
  }
  get columnManagerTargetFixed() {
    return this._columnManagerTargetFixed;
  }
  get iconNameLib() {
    return this._iconToken.NAME_LIB;
  }
  constructor(poDate, differs, renderer, poLanguageService, changeDetector, decimalPipe, defaultService, value) {
    super(poDate, poLanguageService, defaultService);
    this.changeDetector = changeDetector;
    this.decimalPipe = decimalPipe;
    this.defaultService = defaultService;
    this.JSON = JSON;
    this.differ = differs.find([]).create(null);
    this.clickListener = renderer.listen("document", "click", () => {
    });
    this.resizeListener = renderer.listen("window", "resize", (event) => {
      this.debounceResize();
    });
    this._iconToken = value ?? AnimaliaIconDictionary;
  }
  get hasRowTemplateWithArrowDirectionRight() {
    return this.tableRowTemplate?.tableRowTemplateArrowDirection === PoTableRowTemplateArrowDirection.Right;
  }
  get columnCount() {
    const columnCount = this.mainColumns.length + (this.actions.length > 0 ? 1 : 0) + (this.selectable ? 1 : 0) + (!this.hideDetail && this.columnMasterDetail !== void 0 ? 1 : 0) + this.countExtraColumns();
    return columnCount || 1;
  }
  get columnCountForMasterDetail() {
    return this.mainColumns.length + 1 + (this.actions.length > 0 ? 1 : 0) + (this.selectable ? 1 : 0);
  }
  get detailHideSelect() {
    const masterDetail = this.columnMasterDetail;
    return masterDetail && masterDetail.detail ? masterDetail.detail.hideSelect : false;
  }
  get hasVisibleActions() {
    return !!this.visibleActions.length;
  }
  get firstAction() {
    return this.visibleActions && this.visibleActions[0];
  }
  get hasFooter() {
    return this.hasItems && this.hasVisibleSubtitleColumns;
  }
  get hasMasterDetailColumn() {
    return this.hasMainColumns && this.hasItems && !this.hideDetail && !!(this.columnMasterDetail || this.hasRowTemplate);
  }
  get hasRowTemplate() {
    return !!this.tableRowTemplate;
  }
  get hasSelectableColumn() {
    return this.selectable && this.hasItems && this.hasMainColumns;
  }
  get hasValidColumns() {
    return !!this.validColumns.length;
  }
  get hasVisibleSubtitleColumns() {
    return this.subtitleColumns.some((column) => column.visible !== false);
  }
  get isSingleAction() {
    return this.visibleActions.length === 1;
  }
  get isDraggable() {
    return this.draggable;
  }
  get inverseOfTranslation() {
    if (!this.viewPort || !this.viewPort["_renderedContentOffset"]) {
      return "-0px";
    }
    const offset = this.viewPort["_renderedContentOffset"];
    return `-${offset}px`;
  }
  ngOnInit() {
    this.idRadio = `po-radio-${uuid()}`;
  }
  changeHeaderWidth() {
    if (this.noColumnsHeader) {
      this.headerWidth = this.noColumnsHeader?.nativeElement.offsetWidth;
    }
    this.changeDetector.detectChanges();
  }
  ngAfterViewInit() {
    this.initialized = true;
    this.changeHeaderWidth();
    this.changeSizeLoading();
    this.applyFixedColumns();
  }
  showMoreInfiniteScroll({
    target
  }) {
    const scrollPosition = target.offsetHeight + target.scrollTop;
    if (!this.showMoreDisabled && scrollPosition >= target.scrollHeight * (this.infiniteScrollDistance / 110)) {
      this.onShowMore();
    }
  }
  ngDoCheck() {
    this.applyFixedColumns();
    this.checkChangesItems();
    this.verifyCalculateHeightTableContainer();
    if (this.tableWrapperElement?.nativeElement.offsetWidth && !this.visibleElement && this.initialized) {
      this.debounceResize();
      this.checkInfiniteScroll();
      this.visibleElement = true;
    }
  }
  ngOnDestroy() {
    this.removeListeners();
    this.subscriptionService?.unsubscribe();
  }
  /**
   * Método responsável por realizar busca no serviço de dados podendo informar filtros e com o retorno, atualiza a tabela.
   *
   * Caso não seja informado parâmetro, nada será adicionado ao GET, conforme abaixo:
   * ```
   * url + ?page=1&pageSize=10
   * ```
   * > Obs: os parâmetros `page` e `pageSize` sempre serão chamados independente de ser enviados outros parâmetros.
   *
   * Caso sejam informados os parâmetros `{ name: 'JOHN', age: '23' }`, todos serão adicionados ao GET, conforme abaixo:
   * ```
   * url + ?page=1&pageSize=10&name=JOHN&age=23
   * ```
   *
   * @param { { key: value } } queryParams Formato do objeto a ser enviado.
   * > Pode ser utilizada qualquer string como key, e qualquer string ou number como value.
   */
  applyFilters(queryParams) {
    this.page = 1;
    this.initializeData(queryParams);
  }
  /**
   * Verifica se columns possuem a propriedade width.
   */
  applyFixedColumns() {
    return !this.columns.some((column) => !column.width);
  }
  /**
   * Método que colapsa uma linha com detalhe quando executada.
   *
   * @param { number } rowIndex Índice da linha que será colapsada.
   * > Ao reordenar os dados da tabela, o valor contido neste índice será alterado conforme a ordenação.
   */
  collapse(rowIndex) {
    this.setShowDetail(rowIndex, false);
  }
  /**
   * Método que expande uma linha com detalhe quando executada.
   *
   * @param { number } rowIndex Índice da linha que será expandida.
   * > Ao reordenar os dados da tabela, o valor contido neste índice será alterado conforme a ordenação.
   */
  expand(rowIndex) {
    this.setShowDetail(rowIndex, true);
  }
  /**
   * Retorna as linhas do `po-table` que estão selecionadas.
   */
  getSelectedRows() {
    return this.items.filter((item) => item.$selected);
  }
  /**
   * Retorna as linhas do `po-table` que não estão selecionadas.
   */
  getUnselectedRows() {
    return this.items.filter((item) => !item.$selected);
  }
  /**
   * Desmarca as linhas que estão selecionadas.
   */
  unselectRows() {
    const columnDetail = this.nameColumnDetail;
    this.items.forEach((item) => {
      const detailItems = columnDetail ? item[columnDetail] : null;
      if (Array.isArray(detailItems)) {
        detailItems.forEach((detailItem) => {
          detailItem.$selected = false;
        });
      }
      item.$selected = false;
    });
    this.selectAll = false;
  }
  checkDisabled(row, column) {
    return column.disabled ? column.disabled(row) : false;
  }
  containsMasterDetail(row) {
    return row[this.nameColumnDetail] && row[this.nameColumnDetail].length;
  }
  executeTableAction(row, tableAction) {
    if (!row.disabled && !this.validateTableAction(row, tableAction)) {
      tableAction.action(row);
      this.toggleRowAction(row);
    }
  }
  /**
   * Desmarca uma linha que está selecionada.
   */
  unselectRowItem(itemfn) {
    this.toggleSelect(itemfn, false);
    if (this.items.every((item) => !item.$selected)) {
      this.selectAll = false;
    } else {
      this.selectAll = null;
    }
  }
  /**
   * Seleciona uma linha do 'po-table'.
   */
  selectRowItem(itemfn) {
    this.toggleSelect(itemfn, true);
    if (this.items.every((item) => item.$selected)) {
      this.selectAll = true;
    } else {
      this.selectAll = null;
    }
  }
  /**
   * Método responsável pela exclusão de itens em lote.
   * Caso a tabela esteja executando a propriedade `p-service-delete`, será necessário excluir 1 item por vez.
   *
   * Ao utilizar `p-service-delete` mas sem a propriedade `p-service-api`, será responsabilidade do usuário o tratamento
   * após a requisição DELETE ser executada.
   *
   * Caso a tabela utilize `p-height` e esteja sem serviço, é necessário a reatribuição dos itens utilizando o evento `(p-delete-items)`, por exemplo:
   *
   * ```
   *<po-table
   *  (p-delete-items)="items = $event"
   * >
   *</po-table>
   * ```
   */
  deleteItems() {
    const newItems = [...this.items];
    const newItemsFiltered = [...newItems].filter((item) => !item.$selected);
    if (!this.serviceDeleteApi) {
      this.deleteItemsLocal(newItems, newItemsFiltered);
    } else {
      this.deleteItemsService(newItemsFiltered);
    }
  }
  formatNumber(value, format) {
    if (!format) {
      return value;
    }
    return this.decimalPipe.transform(value, format);
  }
  getCellData(row, column) {
    const arrayProperty = column.property.split(".");
    if (arrayProperty.length > 1) {
      const nestedProperties = arrayProperty;
      let value = row;
      for (const property of nestedProperties) {
        value = value[property] || value[property] === 0 ? value[property] : "";
      }
      return value;
    } else {
      return row[column.property];
    }
  }
  getBooleanLabel(rowValue, columnBoolean) {
    if (rowValue || rowValue === false || rowValue === 0) {
      rowValue = convertToBoolean(rowValue);
      if (columnBoolean.boolean) {
        return rowValue ? columnBoolean.boolean.trueLabel || "Sim" : columnBoolean.boolean.falseLabel || "Não";
      } else {
        return rowValue ? "Sim" : "Não";
      }
    }
    return rowValue;
  }
  getColumnIcons(row, column) {
    const rowIcons = this.getCellData(row, column);
    if (column.icons) {
      if (Array.isArray(rowIcons)) {
        return this.mergeCustomIcons(rowIcons, column.icons);
      } else {
        return this.findCustomIcon(rowIcons, column);
      }
    }
    return rowIcons;
  }
  getColumnLabel(row, columnLabel) {
    return columnLabel.labels.find((labelItem) => this.getCellData(row, columnLabel) === labelItem.value);
  }
  getSubtitleColumn(row, subtitleColumn) {
    return subtitleColumn.subtitles.find((subtitleItem) => this.getCellData(row, subtitleColumn) === subtitleItem.value);
  }
  isShowMasterDetail(row) {
    return !this.hideDetail && this.nameColumnDetail && row.$showDetail && this.containsMasterDetail(row) && !this.hasRowTemplate;
  }
  isShowRowTemplate(row, index) {
    if (this.tableRowTemplate && this.tableRowTemplate.poTableRowTemplateShow) {
      return this.tableRowTemplate.poTableRowTemplateShow(row, index);
    }
    return true;
  }
  onClickLink(event, row, column) {
    if (!this.checkDisabled(row, column)) {
      event.stopPropagation();
    }
  }
  onChangeVisibleColumns(columns) {
    this.changeVisibleColumns.emit(columns);
  }
  onColumnRestoreManager(value) {
    this.columnRestoreManager.emit(value);
  }
  onVisibleColumnsChange(columns) {
    this.columns = columns;
    this.changeDetector.detectChanges();
  }
  tooltipMouseEnter(event, column, row) {
    this.tooltipText = void 0;
    if (event.target.offsetWidth < event.target.scrollWidth && event.target.innerText.trim()) {
      return this.tooltipText = event.target.innerText;
    }
    if (column) {
      this.checkingIfColumnHasTooltip(column, row);
    }
  }
  tooltipMouseLeave() {
    this.tooltipText = void 0;
  }
  togglePopup(row, targetRef) {
    this.popupTarget = targetRef;
    this.changeDetector.detectChanges();
    this.poPopupComponent.toggle(row);
  }
  trackBy(index) {
    return index;
  }
  validateTableAction(row, tableAction) {
    if (typeof tableAction.disabled === "function") {
      return tableAction.disabled(row);
    } else {
      return tableAction.disabled;
    }
  }
  onOpenColumnManager() {
    this.lastVisibleColumnsSelected = [...this.columns];
  }
  onFilteredItemsChange(items) {
    if (this.sortedColumn.property) {
      this.sortArray(this.sortedColumn.property, this.sortedColumn.ascending, items);
    } else {
      this.filteredItems = items;
    }
  }
  /**
   * Método que remove um item da tabela.
   *
   * @param { number | { key: value } } item Índice da linha ou o item que será removido.
   * > Ao remover o item, a linha que o representa será excluída da tabela.
   */
  removeItem(item) {
    if (item instanceof Object) {
      this.items = this.items.filter((filterItem) => filterItem !== item);
    } else if (typeof item === "number") {
      const index = item;
      this.items.splice(index, 1);
    }
  }
  /**
   * Método que atualiza um item da tabela.
   *
   * @param { number | { key: value } } item Índice da linha ou o item que será atualizado.
   * @param { { key: value } } updatedItem Item que foi atualizado.
   * > Ao atualizar o item, a informação será alterada na tabela.
   */
  updateItem(item, updatedItem) {
    if (typeof item === "number") {
      this.items.splice(item, 1, updatedItem);
    } else {
      const index = this.items.findIndex((indexItem) => indexItem === item);
      this.items.splice(index, 1, updatedItem);
    }
  }
  drop(event) {
    if (!this.mainColumns[event.currentIndex].fixed) {
      moveItemInArray(this.mainColumns, event.previousIndex, event.currentIndex);
      if (this.hideColumnsManager === false) {
        this.newOrderColumns = this.mainColumns;
        const detail = this.columns.filter((item) => item.property === "detail")[0];
        if (detail !== void 0) {
          this.newOrderColumns.push(detail);
        }
        this.columns.map((item, index) => {
          if (!item.visible) {
            this.newOrderColumns.splice(index, 0, item);
          }
        });
        this.columns = this.newOrderColumns;
        this.onVisibleColumnsChange(this.newOrderColumns);
      }
    }
  }
  getTemplate(column) {
    const template = this.tableColumnTemplates?.find((tableColumnTemplate) => tableColumnTemplate.targetProperty === column.property);
    if (!this.initialized) return null;
    if (template) {
      return template.templateRef;
    } else {
      console.warn(`Não foi possível encontrar o template para a coluna: ${column.property}, por gentileza informe a propriedade [p-property]`);
      return null;
    }
  }
  getWidthColumnManager() {
    return this.columnManager?.nativeElement.offsetWidth;
  }
  getColumnWidthActionsLeft() {
    return this.columnActionLeft?.nativeElement.offsetWidth;
  }
  hasSomeFixed() {
    return this.columns.some((item) => item.fixed === true);
  }
  calculateHeightTableContainer(height) {
    const value = parseFloat(height);
    this.heightTableContainer = value ? value - this.getHeightTableFooter() : void 0;
    this.heightTableVirtual = this.heightTableContainer ? this.heightTableContainer - this.itemSize : void 0;
    this.setTableOpacity(1);
    this.changeDetector.detectChanges();
  }
  verifyCalculateHeightTableContainer() {
    if (this.height && this.verifyChangeHeightInFooter()) {
      this.footerHeight = this.getHeightTableFooter();
      this.calculateHeightTableContainer(this.height);
    }
  }
  checkInfiniteScroll() {
    if (this.hasInfiniteScroll()) {
      let scrollHeight = 0;
      if (this.virtualScroll) {
        scrollHeight = this.tableVirtualScroll.nativeElement.scrollHeight;
      } else {
        scrollHeight = this.tableScrollable.nativeElement.scrollHeight;
      }
      if (scrollHeight >= this.height) {
        this.includeInfiniteScroll();
      } else {
        this.infiniteScroll = false;
      }
    }
    this.changeDetector.detectChanges();
  }
  changesAfterDelete(newItemsFiltered) {
    this.selectAll = false;
    this.setSelectedList();
    this.modalDelete.close();
    this.poNotification.success(this.literals.deleteSuccessful);
    this.eventDelete.emit(newItemsFiltered);
  }
  changeSizeLoading() {
    const tableHeight = this.tableWrapperElement?.nativeElement?.offsetHeight;
    if (tableHeight <= 150) {
      this.sizeLoading = "sm";
    } else if (tableHeight > 150 && tableHeight < 260) {
      this.sizeLoading = "md";
    } else {
      this.sizeLoading = "lg";
    }
    this.changeDetector.detectChanges();
  }
  checkChangesItems() {
    const changesItems = this.differ.diff(this.items);
    if (changesItems && this.selectAll) {
      this.selectAll = null;
    }
    if (changesItems && !this.hasColumns && this.hasItems) {
      this.columns = this.getDefaultColumns(this.items[0]);
    }
  }
  checkingIfColumnHasTooltip(column, row) {
    if (column.type === "link" && column.tooltip && !this.checkDisabled(row, column)) {
      return this.tooltipText = column.tooltip;
    }
    if (column.type === "label") {
      const columnLabel = this.getColumnLabel(row, column);
      return this.tooltipText = columnLabel?.tooltip;
    }
  }
  countExtraColumns() {
    let extraColumns = 0;
    if (!this.columnMasterDetail && this.hasItems) {
      if ((this.hasMasterDetailColumn || this.hasRowTemplate) && this.hasMainColumns && !this.hasRowTemplateWithArrowDirectionRight) {
        extraColumns++;
      }
      if (this.hasRowTemplateWithArrowDirectionRight && this.hasMainColumns && (this.hasVisibleActions || this.hideColumnsManager)) {
        extraColumns++;
      }
    }
    return extraColumns;
  }
  debounceResize() {
    clearTimeout(this.timeoutResize);
    this.timeoutResize = setTimeout(() => {
      this.setTableOpacity(1);
    });
  }
  deleteItemsLocal(newItems, newItemsFiltered) {
    if (this.height) {
      this.items = newItemsFiltered;
    } else {
      let index = this.items.length - 1;
      newItems.slice().reverse().forEach((item) => {
        if (item.$selected) {
          this.removeItem(index);
        }
        index--;
      });
    }
    this.changesAfterDelete(newItemsFiltered);
    this.onFilteredItemsChange(newItemsFiltered);
  }
  deleteItemsService(newItemsFiltered) {
    this.subscriptionService.add(this.defaultService.deleteItem(this.paramDeleteApi, this.itemsSelected[0][this.paramDeleteApi]).subscribe({
      next: (value) => {
        if (this.hasService) {
          const filteredParams = __spreadProps(__spreadValues({}, this.paramsFilter), {
            pageSize: newItemsFiltered.length + 1,
            page: 1
          });
          this.loading = true;
          this.subscriptionService.add(this.defaultService.getFilteredItems(filteredParams).subscribe((items) => {
            this.setTableResponseProperties(items);
          }));
        }
        this.items = newItemsFiltered;
        this.changesAfterDelete(newItemsFiltered);
      },
      error: (error) => {
        this.poNotification.error(this.literals.deleteApiError);
        this.modalDelete.close();
        this.eventDelete.emit(this.items);
      }
    }));
  }
  findCustomIcon(rowIcons, column) {
    const customIcon = column.icons.find((icon) => rowIcons === icon.value);
    return customIcon ? [customIcon] : void 0;
  }
  getHeightTableFooter() {
    return this.tableFooterElement ? this.tableFooterElement.nativeElement.offsetHeight : 0;
  }
  hasInfiniteScroll() {
    let scrollHeight = 0;
    if (this.virtualScroll && this.tableVirtualScroll) {
      scrollHeight = this.tableVirtualScroll.nativeElement.scrollHeight;
    }
    if (!this.virtualScroll && this.tableScrollable) {
      scrollHeight = this.tableScrollable.nativeElement.scrollHeight;
    }
    return this.infiniteScroll && this.hasItems && !this.subscriptionScrollEvent && this.height > 0 && scrollHeight > 0;
  }
  includeInfiniteScroll() {
    let element = null;
    if (this.virtualScroll) {
      element = this.tableVirtualScroll?.nativeElement;
    } else {
      element = this.tableScrollable.nativeElement.closest(".po-table-container-overflow");
    }
    if (element) {
      this.scrollEvent$ = this.defaultService.scrollListener(element);
      this.subscriptionScrollEvent = this.scrollEvent$.subscribe((event) => this.showMoreInfiniteScroll(event));
    }
    this.changeDetector.detectChanges();
  }
  mergeCustomIcons(rowIcons, customIcons) {
    const mergedIcons = [];
    rowIcons.forEach((columnValue) => {
      const foundCustomIcon = customIcons.find((customIcon) => columnValue === customIcon.icon || columnValue === customIcon.value);
      foundCustomIcon ? mergedIcons.push(foundCustomIcon) : mergedIcons.push(columnValue);
    });
    return mergedIcons;
  }
  removeListeners() {
    if (this.resizeListener) {
      this.resizeListener();
    }
    if (this.clickListener) {
      this.clickListener();
    }
    if (this.subscriptionScrollEvent) {
      this.subscriptionScrollEvent.unsubscribe();
    }
  }
  setTableOpacity(value) {
    this.tableOpacity = value;
  }
  verifyChangeHeightInFooter() {
    return this.footerHeight !== this.getHeightTableFooter();
  }
  toggleSelect(compare, selectValue) {
    if (typeof compare !== "function") {
      this.items.forEach((item) => {
        if (item === compare) {
          item.$selected = selectValue;
        }
      });
    } else {
      this.items.forEach((item) => {
        if (compare(item)) {
          item.$selected = selectValue;
        }
      });
    }
  }
  static ɵfac = function PoTableComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableComponent)(ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DecimalPipe), ɵɵdirectiveInject(PoTableService), ɵɵdirectiveInject(ICONS_DICTIONARY, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTableComponent,
    selectors: [["po-table"]],
    contentQueries: function PoTableComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PoTableRowTemplateDirective, 7);
        ɵɵcontentQuery(dirIndex, PoTableCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PoTableColumnTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableRowTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableCellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableColumnTemplates = _t);
      }
    },
    viewQuery: function PoTableComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$Y, 5, ElementRef);
        ɵɵviewQuery(_c1$o, 5);
        ɵɵviewQuery(PoModalComponent, 7);
        ɵɵviewQuery(_c2$c, 5, ElementRef);
        ɵɵviewQuery(_c3$8, 5, ElementRef);
        ɵɵviewQuery(_c4$3, 5, ElementRef);
        ɵɵviewQuery(_c5$1, 5, ElementRef);
        ɵɵviewQuery(_c6, 5, ElementRef);
        ɵɵviewQuery(_c7, 5, ElementRef);
        ɵɵviewQuery(_c8, 5, ElementRef);
        ɵɵviewQuery(_c9, 5, ElementRef);
        ɵɵviewQuery(_c10, 5);
        ɵɵviewQuery(_c11, 7, ElementRef);
        ɵɵviewQuery(CdkVirtualScrollViewport, 5);
        ɵɵviewQuery(_c12, 5);
        ɵɵviewQuery(_c13, 5);
        ɵɵviewQuery(_c14, 5, ElementRef);
        ɵɵviewQuery(_c15, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noColumnsHeader = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPopupComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalDelete = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableFooterElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableWrapperElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableVirtualScroll = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableScrollable = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnManager = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnBatchActions = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnActionLeft = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poSearchInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewPort = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnManagerTarget = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnManagerTargetFixed = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionsIconElement = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionsElement = _t);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoDateService, PoTableService]), ɵɵInheritDefinitionFeature],
    decls: 33,
    vars: 14,
    consts: [["tableContainerTemplate", ""], ["tableTemplate", ""], ["tableVirtualScrollTemplate", ""], ["popup", ""], ["poTableColumnDetail", ""], ["inputRadio", ""], ["inputCheckbox", ""], ["contentHeaderTemplate", ""], ["noColumnsWithHeight", ""], ["noColumnsWithoutHeight", ""], ["ActionsColumnTemplate", ""], ["modalDelete", ""], ["columnBatchActions", ""], ["columnManager", ""], ["columnManagerTarget", ""], ["tableWrapper", ""], ["poTableTbody", ""], ["tableFooter", ""], ["tableScrollable", ""], ["tableDefaultThDragDrop", ""], ["tableDefaultThDefault", ""], ["columnActionLeft", ""], ["noColumnsHeader", ""], ["tableVirtualScroll", ""], ["tableVirtualScrollThDragDrop", ""], ["tableVirtualScrollThDefault", ""], ["columnHeader", ""], ["popupTarget", ""], [1, "po-table-actions"], ["class", "po-table-actions-batch-actions", 4, "ngIf"], ["class", "po-table-actions-column-manager", 4, "ngIf"], ["class", "po-table-search", 4, "ngIf"], ["p-no-padding", "", 4, "ngIf", "ngIfElse"], ["class", "po-row po-table-footer-show-more", 3, "po-invisible", 4, "ngIf"], [3, "p-actions", "p-target"], [3, "p-columns", "p-max-columns", "p-target", "p-last-visible-columns-selected", "p-hide-action-fixed-columns", "p-columns-default", "p-visible-columns-change", "p-change-visible-columns", "p-initial-columns", 4, "ngIf"], [3, "p-title", "p-primary-action", "p-secondary-action", "p-click-out"], [1, "po-font-text-large"], [1, "po-table-actions-batch-actions"], [1, "po-table-actions-batch-actions__label", 3, "ngPlural"], ["ngPluralCase", "=0"], ["ngPluralCase", "=1"], ["ngPluralCase", "other"], [1, "po-table-actions-batch-actions__buttons"], ["p-icon", "ICON_DELETE", 3, "p-click", "p-danger", "p-disabled", "p-label"], [1, "po-table-actions-column-manager"], ["p-icon", "ICON_SETTINGS", "p-kind", "tertiary", "p-tooltip-position", "left", 3, "p-click", "p-aria-label", "p-tooltip"], [1, "po-table-search"], [3, "p-filtered-items-change", "p-items", "p-filter-keys", "p-filter-type"], ["p-no-padding", ""], [4, "ngTemplateOutlet"], [3, "p-text", "p-size", 4, "ngIf"], [1, "po-table-main-container"], [1, "po-table-wrapper"], ["class", "po-table-container", 3, "height", 4, "ngIf"], [4, "ngIf"], ["class", "po-table-footer", 4, "ngIf"], [3, "p-text", "p-size"], [1, "po-table-container"], ["class", "po-table-container-overflow", 3, "height", 4, "ngIf"], [1, "po-table-container-overflow"], [1, "po-table-footer"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-literals", "p-subtitles"], [1, "po-row", "po-table-footer-show-more"], [1, "po-offset-xl-4", "po-offset-lg-4", "po-offset-md-3", "po-lg-4", "po-md-6", 3, "p-click", "p-disabled", "p-label", "p-loading"], [1, "po-table", 3, "ngClass"], ["cdkDropList", "", "cdkDropListOrientation", "horizontal", 3, "cdkDropListDropped", "ngClass"], ["class", "po-table-column-selectable", 3, "pointer-events", 4, "ngIf"], ["class", "po-table-header-column po-table-header-master-detail", 4, "ngIf"], [3, "po-table-header-master-detail", "po-table-header-single-action", 4, "ngIf"], ["class", "po-table-header-column po-text-center", 4, "ngIf"], [4, "ngIf", "ngIfThen", "ngIfElse"], [3, "po-table-header-single-action", "po-table-header-actions", 4, "ngIf"], ["class", "po-table-group-row", 4, "ngIf"], [1, "po-table-column-selectable"], ["name", "selectAll", 3, "p-checkboxValue", "p-change", 4, "ngIf"], ["name", "selectAll", 3, "p-change", "p-checkboxValue"], [1, "po-table-header-column", "po-table-header-master-detail"], [1, "po-table-header-column", "po-text-center"], ["class", "po-table-header-ellipsis p-element po-frozen-column", "cdkDrag", "", "cdkDragLockAxis", "x", 3, "width", "max-width", "min-width", "po-clickable", "ngClass", "ngStyle", "po-table-header-subtitle", "po-table-column-drag-box", "cdkDragDisabled", "pFrozenColumn", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["cdkDrag", "", "cdkDragLockAxis", "x", 1, "po-table-header-ellipsis", "p-element", "po-frozen-column", 3, "click", "ngClass", "ngStyle", "cdkDragDisabled", "pFrozenColumn"], [1, "po-table-header-flex"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["cdkDragHandle", "", "p-icon", "ICON_DRAG", 4, "ngIf"], ["cdkDragHandle", "", "width", "16", "height", "16", "viewBox", "0 0 24 24", "fill", "none", "xmlns", "http://www.w3.org/2000/svg", 4, "ngIf"], ["cdkDragHandle", "", "p-icon", "ICON_DRAG"], ["cdkDragHandle", "", "width", "16", "height", "16", "viewBox", "0 0 24 24", "fill", "none", "xmlns", "http://www.w3.org/2000/svg"], ["cx", "9", "cy", "6", "r", "2", "fill", "black"], ["cx", "15", "cy", "6", "r", "2", "fill", "black"], ["cx", "9", "cy", "12", "r", "2", "fill", "black"], ["cx", "15", "cy", "12", "r", "2", "fill", "black"], ["cx", "9", "cy", "18", "r", "2", "fill", "black"], ["cx", "15", "cy", "18", "r", "2", "fill", "black"], ["class", "po-table-header-ellipsis p-element po-frozen-column", 3, "width", "max-width", "min-width", "po-clickable", "ngClass", "ngStyle", "po-table-header-subtitle", "pFrozenColumn", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-table-header-ellipsis", "p-element", "po-frozen-column", 3, "click", "ngClass", "ngStyle", "pFrozenColumn"], [1, "po-table-group-row"], [1, "po-table-row", "po-table-row-no-data"], [1, "po-table-no-data", "po-text-center", 3, "colSpan"], ["class", "po-table-group-row", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-table-row"], ["class", "po-table-column-selectable", 4, "ngIf"], ["class", "po-table-column-detail-toggle", 3, "click", 4, "ngIf"], ["class", "p-element po-frozen-column", 3, "width", "max-width", "min-width", "po-table-column", "po-table-column-right", "po-table-column-center", "po-table-column-icons", "pFrozenColumn", "ngClass", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-table-column-detail-toggle", 3, "click"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "p-element", "po-frozen-column", 3, "click", "pFrozenColumn", "ngClass"], [1, "po-table-column-cell", "po-table-body-ellipsis", "notranslate", 3, "mouseenter", "mouseleave", "ngSwitch", "p-tooltip", "p-append-in-body"], [4, "ngSwitchCase"], [3, "p-action", "p-disabled", "p-link", "p-row", "p-value", "click", 4, "ngSwitchCase"], [3, "p-column", "p-icons", "p-row", 4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "click", "p-action", "p-disabled", "p-link", "p-row", "p-value"], [3, "p-column", "p-icons", "p-row"], [3, "p-subtitle"], [3, "p-value"], [1, "po-table-row-template-container", 3, "colSpan"], [1, "po-table-column-detail", 3, "colSpan"], [3, "p-select-row", "p-selectable", "p-detail", "p-items", "p-parent-row"], [3, "itemSize", "minBufferPx", "maxBufferPx"], [1, "po-table-header-sticky"], ["cdkDropList", "", "cdkDropListOrientation", "horizontal", 3, "cdkDropListDropped"], ["class", "po-table-header-ellipsis p-element po-frozen-column example-box", 3, "width", "max-width", "min-width", "po-clickable", "ngClass", "ngStyle", "po-table-header-subtitle", "pFrozenColumn", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-table-header-ellipsis", "p-element", "po-frozen-column", "example-box", 3, "click", "ngClass", "ngStyle", "pFrozenColumn"], ["class", "po-table-group-row", 4, "cdkVirtualFor", "cdkVirtualForOf", "cdkVirtualForTrackBy"], ["class", "p-element po-frozen-column", 3, "width", "max-width", "min-width", "po-table-column", "po-table-column-right", "po-table-column-center", "po-table-column-icons", "ngClass", "pFrozenColumn", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "p-element", "po-frozen-column", 3, "click", "ngClass", "pFrozenColumn"], ["class", "po-clickable", 3, "p-icon", 4, "ngIf"], [1, "po-clickable", 3, "p-icon"], [3, "p-change-selected", "name", "p-checked"], ["name", "checkbox", 3, "p-change", "p-checkboxValue"], [1, "po-table-header-ellipsis", 3, "mouseenter", "mouseleave", "p-tooltip", "p-append-in-body"], [3, "po-table-header-icon-unselected", "po-table-header-icon-descending", "po-table-header-icon-ascending", 4, "ngIf"], ["p-icon", "ICON_SORT", 4, "ngIf"], ["width", "16", "height", "16", "viewBox", "0 0 24 24", "fill", "none", "xmlns", "http://www.w3.org/2000/svg", 4, "ngIf"], ["p-icon", "ICON_SORT"], ["width", "16", "height", "16", "viewBox", "0 0 24 24", "fill", "none", "xmlns", "http://www.w3.org/2000/svg"], ["fill-rule", "evenodd", "clip-rule", "evenodd", "d", "M18.2929 15.2929L17 16.5858L17 10C17 9.44772 16.5523 9 16 9C15.4477 9 15 9.44772 15 10L15 16.5858L13.7071 15.2929C13.3166 14.9024 12.6834 14.9024 12.2929 15.2929C11.9024 15.6834 11.9024 16.3166 12.2929 16.7071L15.2929 19.7071C15.6834 20.0976 16.3166 20.0976 16.7071 19.7071L19.7071 16.7071C20.0976 16.3166 20.0976 15.6834 19.7071 15.2929C19.3166 14.9024 18.6834 14.9024 18.2929 15.2929ZM5.70716 8.7071L7.00006 7.4142L7.00003 14C7.00002 14.5523 7.44774 15 8.00002 15C8.55231 15 9.00002 14.5523 9.00003 14L9.00006 7.41418L10.2929 8.70707C10.6835 9.09759 11.3166 9.09758 11.7072 8.70706C12.0977 8.31653 12.0977 7.68336 11.7072 7.29284L8.70718 4.29286C8.31665 3.90234 7.68349 3.90235 7.29296 4.29287L4.29295 7.29289C3.90242 7.68342 3.90242 8.31658 4.29294 8.70711C4.68347 9.09763 5.31663 9.09762 5.70716 8.7071Z", "fill", "#1D1D30"], ["p-icon", "ICON_SORT_ASC", 4, "ngIf"], ["p-icon", "ICON_SORT_ASC"], ["fill-rule", "evenodd", "clip-rule", "evenodd", "d", "M11 9.41421L9.70711 10.7071C9.31658 11.0976 8.68342 11.0976 8.29289 10.7071C7.90237 10.3166 7.90237 9.68342 8.29289 9.29289L11.2929 6.29289C11.6834 5.90237 12.3166 5.90237 12.7071 6.29289L15.7071 9.29289C16.0976 9.68342 16.0976 10.3166 15.7071 10.7071C15.3166 11.0976 14.6834 11.0976 14.2929 10.7071L13 9.41421V16C13 16.5523 12.5523 17 12 17C11.4477 17 11 16.5523 11 16V9.41421Z", "fill", "black"], ["cdkDragHandle", "", "p-icon", "ICON_SORT_DESC", 4, "ngIf"], ["cdkDragHandle", "", "p-icon", "ICON_SORT_DESC"], ["fill-rule", "evenodd", "clip-rule", "evenodd", "d", "M9.70711 13.2929L11 14.5858V7C11 6.44772 11.4477 6 12 6C12.5523 6 13 6.44772 13 7V14.5858L14.2929 13.2929C14.6834 12.9024 15.3166 12.9024 15.7071 13.2929C16.0976 13.6834 16.0976 14.3166 15.7071 14.7071L12.7071 17.7071C12.3166 18.0976 11.6834 18.0976 11.2929 17.7071L8.29289 14.7071C7.90237 14.3166 7.90237 13.6834 8.29289 13.2929C8.68342 12.9024 9.31658 12.9024 9.70711 13.2929Z", "fill", "black"], [1, "po-table-header-fixed-inner"], ["class", "po-table-column po-table-column-single-action", 3, "width", "max-width", 4, "ngIf"], ["class", "po-table-column-actions", 4, "ngIf"], [1, "po-table-column", "po-table-column-single-action"], ["class", "po-table-single-action po-clickable", 3, "po-table-action-disabled", "click", 4, "ngIf"], [1, "po-table-single-action", "po-clickable", 3, "click"], ["class", "po-table-single-action-content", 3, "p-icon", 4, "ngIf"], [1, "po-table-single-action-content", 3, "p-icon"], [1, "po-table-column-actions"], [1, "po-clickable", 3, "click"], ["p-icon", "ICON_MORE"], [3, "p-visible-columns-change", "p-change-visible-columns", "p-initial-columns", "p-columns", "p-max-columns", "p-target", "p-last-visible-columns-selected", "p-hide-action-fixed-columns", "p-columns-default"]],
    template: function PoTableComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 28);
        ɵɵtemplate(1, PoTableComponent_div_1_Template, 9, 4, "div", 29)(2, PoTableComponent_div_2_Template, 4, 2, "div", 30)(3, PoTableComponent_div_3_Template, 2, 3, "div", 31);
        ɵɵelementEnd();
        ɵɵtemplate(4, PoTableComponent_po_container_4_Template, 2, 1, "po-container", 32)(5, PoTableComponent_ng_template_5_Template, 8, 10, "ng-template", null, 0, ɵɵtemplateRefExtractor)(7, PoTableComponent_div_7_Template, 3, 5, "div", 33)(8, PoTableComponent_ng_template_8_Template, 17, 27, "ng-template", null, 1, ɵɵtemplateRefExtractor)(10, PoTableComponent_ng_template_10_Template, 18, 28, "ng-template", null, 2, ɵɵtemplateRefExtractor);
        ɵɵelement(12, "po-popup", 34, 3);
        ɵɵtemplate(14, PoTableComponent_ng_template_14_Template, 1, 1, "ng-template", null, 4, ɵɵtemplateRefExtractor)(16, PoTableComponent_ng_template_16_Template, 1, 2, "ng-template", null, 5, ɵɵtemplateRefExtractor)(18, PoTableComponent_ng_template_18_Template, 1, 1, "ng-template", null, 6, ɵɵtemplateRefExtractor)(20, PoTableComponent_ng_template_20_Template, 5, 6, "ng-template", null, 7, ɵɵtemplateRefExtractor)(22, PoTableComponent_ng_template_22_Template, 2, 3, "ng-template", null, 8, ɵɵtemplateRefExtractor)(24, PoTableComponent_ng_template_24_Template, 1, 1, "ng-template", null, 9, ɵɵtemplateRefExtractor)(26, PoTableComponent_ng_template_26_Template, 2, 2, "ng-template", null, 10, ɵɵtemplateRefExtractor)(28, PoTableComponent_po_table_column_manager_28_Template, 1, 6, "po-table-column-manager", 35);
        ɵɵelementStart(29, "po-modal", 36, 11)(31, "p", 37);
        ɵɵtext(32);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        const tableContainerTemplate_r6 = ɵɵreference(6);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasValidColumns && ctx.itemsSelected.length > 0 && !ctx.hideBatchActions);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasValidColumns && !ctx.hideColumnsManager);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.hideTableSearch && ctx.hasValidColumns);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.container)("ngIfElse", tableContainerTemplate_r6);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", !ctx.infiniteScroll);
        ɵɵadvance(5);
        ɵɵproperty("p-actions", ctx.actions)("p-target", ctx.popupTarget);
        ɵɵadvance(16);
        ɵɵproperty("ngIf", !ctx.hideColumnsManager);
        ɵɵadvance();
        ɵɵproperty("p-title", ctx.literals.delete)("p-primary-action", ctx.confirm)("p-secondary-action", ctx.close)("p-click-out", true);
        ɵɵadvance(3);
        ɵɵtextInterpolate(ctx.literals.bodyDelete);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableComponent, [{
    type: Component,
    args: [{
      selector: "po-table",
      providers: [PoDateService, PoTableService],
      standalone: false,
      template: `<div class="po-table-actions">
  <div
    #columnBatchActions
    *ngIf="hasValidColumns && itemsSelected.length > 0 && !hideBatchActions"
    class="po-table-actions-batch-actions"
  >
    <div [ngPlural]="itemsSelected.length" class="po-table-actions-batch-actions__label">
      <strong>
        <ng-template ngPluralCase="=0">{{ literals.noItem }}</ng-template>
        <ng-template ngPluralCase="=1">{{ literals.oneItem }}</ng-template>
        <ng-template ngPluralCase="other">{{ itemsSelected.length }} {{ literals.multipleItems }}</ng-template>
      </strong>
    </div>

    <div class="po-table-actions-batch-actions__buttons">
      <po-button
        p-icon="ICON_DELETE"
        [p-danger]="true"
        [p-disabled]="itemsSelected.length > 1 && serviceDeleteApi !== undefined"
        [p-label]="literals.delete"
        (p-click)="modalDelete.open()"
      ></po-button>
    </div>
  </div>

  <div #columnManager *ngIf="hasValidColumns && !hideColumnsManager" class="po-table-actions-column-manager">
    <po-button
      #columnManagerTarget
      p-icon="ICON_SETTINGS"
      p-kind="tertiary"
      p-tooltip-position="left"
      [p-aria-label]="literals.columnsManager"
      [p-tooltip]="literals.columnsManager"
      (p-click)="onOpenColumnManager()"
    ></po-button>
  </div>

  <div *ngIf="!hideTableSearch && hasValidColumns" class="po-table-search">
    <po-search
      [p-items]="items"
      [p-filter-keys]="filteredColumns"
      [p-filter-type]="filterType"
      (p-filtered-items-change)="onFilteredItemsChange($event)"
    >
    </po-search>
  </div>
</div>
<po-container *ngIf="container; else tableContainerTemplate" p-no-padding>
  <ng-container *ngTemplateOutlet="tableContainerTemplate"></ng-container>
</po-container>

<ng-template #tableContainerTemplate>
  <div [class.po-table-container-sticky]="loading">
    <po-loading-overlay *ngIf="loading" [p-text]="literals.loadingData" [p-size]="sizeLoading"></po-loading-overlay>
    <div class="po-table-main-container">
      <div
        #tableWrapper
        class="po-table-wrapper"
        [class.po-table-header-fixed-columns-pixels]="allColumnsWidthPixels"
        [style.opacity]="tableOpacity"
      >
        <div *ngIf="height" class="po-table-container" [style.height.px]="heightTableContainer">
          <div #poTableTbody [class.po-table-container-fixed-inner]="virtualScroll">
            <div *ngIf="virtualScroll">
              <ng-container *ngTemplateOutlet="tableVirtualScrollTemplate"></ng-container>
            </div>
            <div *ngIf="!virtualScroll" class="po-table-container-overflow" [style.height.px]="heightTableContainer">
              <ng-container *ngTemplateOutlet="tableTemplate"></ng-container>
            </div>
          </div>
        </div>

        <div *ngIf="!height">
          <ng-container *ngTemplateOutlet="tableTemplate"></ng-container>
        </div>
      </div>
    </div>
  </div>

  <div class="po-table-footer" *ngIf="hasFooter">
    <ng-container *ngFor="let column of subtitleColumns; trackBy: trackBy">
      <po-table-subtitle-footer [p-literals]="literals" [p-subtitles]="column.subtitles"> </po-table-subtitle-footer>
    </ng-container>
  </div>
</ng-template>

<!-- Show More Button -->
<div
  *ngIf="!infiniteScroll"
  class="po-row po-table-footer-show-more"
  [class.po-invisible]="showMore.observers.length === 0 && !hasService"
  #tableFooter
>
  <po-button
    class="po-offset-xl-4 po-offset-lg-4 po-offset-md-3 po-lg-4 po-md-6"
    [p-disabled]="showMoreDisabled"
    [p-label]="literals.loadMoreData"
    [p-loading]="loadingShowMore"
    (p-click)="onShowMore()"
  >
  </po-button>
</div>

<!-- Table default-->
<ng-template #tableTemplate>
  <table
    #tableScrollable
    class="po-table"
    [ngClass]="{
      'po-table-interactive': selectable || sort,
      'po-table-selectable': selectable,
      'po-table-striped': striped,
      'po-table-data-fixed-columns': applyFixedColumns(),
      'po-table-text-wrap-enabled': textWrap
    }"
    [attr.p-spacing]="spacing"
  >
    <thead [class.po-table-header-sticky]="height > 0 && !virtualScroll">
      <tr
        [ngClass]="!height ? { 'no-hover': hideSelectAll, 'po-table-column-drag': this.isDraggable } : ''"
        [class.po-table-header]="!height"
        cdkDropList
        cdkDropListOrientation="horizontal"
        (cdkDropListDropped)="drop($event)"
      >
        <th
          *ngIf="hasSelectableColumn"
          [style.pointer-events]="hideSelectAll ? 'none' : 'auto'"
          class="po-table-column-selectable"
        >
          <div [class.po-table-header-fixed-inner]="height">
            <po-checkbox
              name="selectAll"
              *ngIf="!hideSelectAll"
              (p-change)="selectAllRows()"
              [p-checkboxValue]="selectAll === null ? 'mixed' : selectAll"
            ></po-checkbox>
          </div>
        </th>

        <th
          *ngIf="(hasMasterDetailColumn || hasRowTemplate) && hasMainColumns && !hasRowTemplateWithArrowDirectionRight"
          class="po-table-header-column po-table-header-master-detail"
        ></th>

        <!-- Coluna criada para caso as ações fiquem no lado esquerdo -->
        <th
          #columnActionLeft
          *ngIf="!actionRight && (visibleActions.length > 1 || isSingleAction)"
          [class.po-table-header-master-detail]="!isSingleAction"
          [class.po-table-header-single-action]="isSingleAction"
        ></th>

        <th *ngIf="!hasMainColumns" #noColumnsHeader class="po-table-header-column po-text-center">
          <ng-container *ngIf="height; then noColumnsWithHeight; else noColumnsWithoutHeight"> </ng-container>
        </th>

        <ng-container
          *ngIf="this.isDraggable || hasSomeFixed(); then tableDefaultThDragDrop; else tableDefaultThDefault"
        >
        </ng-container>
        <ng-template #tableDefaultThDragDrop>
          <th
            *ngFor="let column of mainColumns; let i = index; trackBy: trackBy"
            class="po-table-header-ellipsis p-element po-frozen-column"
            [style.width]="column.width"
            [style.max-width]="column.width"
            [style.min-width]="column.width"
            [attr.data-po-table-column-name]="column.label || (column.property | titlecase) | lowercase"
            [class.po-clickable]="(sort && column.sortable !== false) || hasService"
            [ngClass]="{
              'po-table-header-sorted':
                sort &&
                JSON.stringify(sortedColumn?.property) === JSON.stringify(column) &&
                (sortedColumn.ascending || !sortedColumn.ascending)
            }"
            [ngStyle]="{
              'width':
                height > 0 && !virtualScroll ? (!hasItems ? '100%' : applyFixedColumns() ? column.width : 'auto') : ''
            }"
            [class.po-table-header-subtitle]="column.type === 'subtitle'"
            [class.po-table-column-drag-box]="this.isDraggable"
            (click)="sortColumn(column)"
            cdkDrag
            cdkDragLockAxis="x"
            [cdkDragDisabled]="column.fixed ? 'true' : 'false'"
            [pFrozenColumn]="column.fixed"
          >
            <div
              class="po-table-header-flex"
              [class.po-table-header-fixed-inner]="height"
              [class.po-table-header-flex-right]="column.type === 'currency' || column.type === 'number'"
              [class.po-table-header-flex-center]="column.type === 'subtitle'"
            >
              <ng-container *ngIf="this.isDraggable && !column.fixed">
                <po-icon cdkDragHandle *ngIf="iconNameLib === 'AnimaliaIcon'" p-icon="ICON_DRAG"></po-icon>
                <svg
                  *ngIf="iconNameLib === 'PoIcon'"
                  cdkDragHandle
                  width="16"
                  height="16"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <circle cx="9" cy="6" r="2" fill="black" />
                  <circle cx="15" cy="6" r="2" fill="black" />
                  <circle cx="9" cy="12" r="2" fill="black" />
                  <circle cx="15" cy="12" r="2" fill="black" />
                  <circle cx="9" cy="18" r="2" fill="black" />
                  <circle cx="15" cy="18" r="2" fill="black" />
                </svg>
              </ng-container>
              <ng-container *ngTemplateOutlet="contentHeaderTemplate; context: { $implicit: column }"> </ng-container>
            </div>
          </th>
        </ng-template>
        <ng-template #tableDefaultThDefault>
          <th
            *ngFor="let column of mainColumns; let i = index; trackBy: trackBy"
            class="po-table-header-ellipsis p-element po-frozen-column"
            [style.width]="column.width"
            [style.max-width]="column.width"
            [style.min-width]="column.width"
            [attr.data-po-table-column-name]="column.label || (column.property | titlecase) | lowercase"
            [class.po-clickable]="(sort && column.sortable !== false) || hasService"
            [ngClass]="{
              'po-table-header-sorted':
                sort &&
                JSON.stringify(sortedColumn?.property) === JSON.stringify(column) &&
                (sortedColumn.ascending || !sortedColumn.ascending)
            }"
            [ngStyle]="{
              'width':
                height > 0 && !virtualScroll ? (!hasItems ? '100%' : applyFixedColumns() ? column.width : 'auto') : ''
            }"
            [class.po-table-header-subtitle]="column.type === 'subtitle'"
            (click)="sortColumn(column)"
            [pFrozenColumn]="column.fixed"
          >
            <div
              class="po-table-header-flex"
              [class.po-table-header-fixed-inner]="height"
              [class.po-table-header-flex-right]="column.type === 'currency' || column.type === 'number'"
              [class.po-table-header-flex-center]="column.type === 'subtitle'"
            >
              <ng-container *ngTemplateOutlet="contentHeaderTemplate; context: { $implicit: column }"> </ng-container>
            </div>
          </th>
        </ng-template>

        <th
          *ngIf="hasRowTemplateWithArrowDirectionRight && (hasVisibleActions || hideColumnsManager) && hasMainColumns"
          class="po-table-header-column po-table-header-master-detail"
        ></th>

        <th
          *ngIf="hasVisibleActions && actionRight && (visibleActions.length > 1 || isSingleAction)"
          [class.po-table-header-single-action]="isSingleAction"
          [class.po-table-header-actions]="!isSingleAction"
        ></th>
      </tr>
    </thead>

    <tbody class="po-table-group-row" *ngIf="!hasItems || !hasMainColumns">
      <tr class="po-table-row po-table-row-no-data">
        <td [colSpan]="columnCount" class="po-table-no-data po-text-center">
          <span> {{ literals.noData }} </span>
        </td>
      </tr>
    </tbody>

    <ng-container *ngIf="hasMainColumns">
      <tbody class="po-table-group-row" *ngFor="let row of filteredItems; let rowIndex = index; trackBy: trackBy">
        <tr class="po-table-row" [class.po-table-row-active]="row.$selected || (row.$selected === null && selectable)">
          <td *ngIf="selectable" class="po-table-column-selectable">
            <ng-container *ngTemplateOutlet="singleSelect ? inputRadio : inputCheckbox; context: { $implicit: row }">
            </ng-container>
          </td>

          <!-- Valida se a origem do detail é pelo input do po-table ou pela diretiva -->
          <td
            *ngIf="
              (columnMasterDetail && !hideDetail && !hasRowTemplate) ||
              (hasRowTemplate && !hasRowTemplateWithArrowDirectionRight)
            "
            class="po-table-column-detail-toggle"
            (click)="toggleDetail(row)"
          >
            <ng-template
              [ngTemplateOutlet]="poTableColumnDetail"
              [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
            >
            </ng-template>
          </td>

          <!-- Coluna com as ações na esquerda (padrão)-->
          <ng-template
            *ngIf="!actionRight && (visibleActions.length > 1 || isSingleAction)"
            [ngTemplateOutlet]="ActionsColumnTemplate"
            [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
          >
          </ng-template>

          <td
            *ngFor="let column of mainColumns; let columnIndex = index; trackBy: trackBy"
            [style.width]="column.width"
            [style.max-width]="column.width"
            [style.min-width]="column.width"
            [class.po-table-column]="column.type !== 'icon'"
            [class.po-table-column-right]="column.type === 'currency' || column.type === 'number'"
            [class.po-table-column-center]="column.type === 'subtitle'"
            [class.po-table-column-icons]="column.type === 'icon'"
            [pFrozenColumn]="column.fixed"
            class="p-element po-frozen-column"
            [ngClass]="getClassColor(row, column)"
            (click)="hasSelectableRow() ? selectRow(row) : 'javascript:;'"
          >
            <div
              class="po-table-column-cell po-table-body-ellipsis notranslate"
              [ngSwitch]="column.type"
              [p-tooltip]="tooltipText"
              [p-append-in-body]="true"
              (mouseenter)="tooltipMouseEnter($event, column, row)"
              (mouseleave)="tooltipMouseLeave()"
            >
              <span *ngSwitchCase="'columnTemplate'">
                <ng-container *ngTemplateOutlet="getTemplate(column); context: { $implicit: getCellData(row, column) }">
                </ng-container>
              </span>

              <span *ngSwitchCase="'cellTemplate'">
                <ng-container *ngTemplateOutlet="tableCellTemplate?.templateRef; context: { row: row, column: column }">
                </ng-container>
              </span>

              <span *ngSwitchCase="'boolean'">
                {{ getBooleanLabel(getCellData(row, column), column) }}
              </span>

              <span *ngSwitchCase="'currency'">
                {{ getCellData(row, column) | currency: column.format : 'symbol' : '1.2-2' }}
              </span>

              <span *ngSwitchCase="'date'">
                {{ getCellData(row, column) | date: column.format || 'dd/MM/yyyy' }}
              </span>

              <span *ngSwitchCase="'time'">
                {{ getCellData(row, column) | po_time: column.format || 'HH:mm:ss.ffffff' }}
              </span>

              <span *ngSwitchCase="'dateTime'">
                {{ getCellData(row, column) | date: column.format || 'dd/MM/yyyy HH:mm:ss' }}
              </span>

              <span *ngSwitchCase="'number'">
                {{ formatNumber(getCellData(row, column), column.format) }}
              </span>

              <po-table-column-link
                *ngSwitchCase="'link'"
                [p-action]="column.action"
                [p-disabled]="checkDisabled(row, column)"
                [p-link]="row[column.link]"
                [p-row]="row"
                [p-value]="getCellData(row, column)"
                (click)="onClickLink($event, row, column)"
              >
              </po-table-column-link>

              <po-table-column-icon
                *ngSwitchCase="'icon'"
                [p-column]="column"
                [p-icons]="getColumnIcons(row, column)"
                [p-row]="row"
              >
              </po-table-column-icon>

              <span *ngSwitchCase="'subtitle'">
                <po-table-subtitle-circle [p-subtitle]="getSubtitleColumn(row, column)"></po-table-subtitle-circle>
              </span>
              <span *ngSwitchCase="'label'">
                <po-table-column-label [p-value]="getColumnLabel(row, column)"> </po-table-column-label>
              </span>
              <span *ngSwitchDefault>{{ getCellData(row, column) }}</span>
            </div>
          </td>

          <td
            *ngIf="hasRowTemplateWithArrowDirectionRight"
            class="po-table-column-detail-toggle"
            (click)="toggleDetail(row)"
          >
            <ng-template
              [ngTemplateOutlet]="poTableColumnDetail"
              [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
            >
            </ng-template>
          </td>

          <!-- Coluna de açoes na direita -->
          <ng-template
            *ngIf="actionRight"
            [ngTemplateOutlet]="ActionsColumnTemplate"
            [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
          >
          </ng-template>
        </tr>

        <tr *ngIf="hasMainColumns && hasRowTemplate && row.$showDetail && isShowRowTemplate(row, rowIndex)">
          <td class="po-table-row-template-container" [colSpan]="columnCountForMasterDetail">
            <ng-template
              [ngTemplateOutlet]="tableRowTemplate.templateRef"
              [ngTemplateOutletContext]="{ $implicit: row, rowIndex: rowIndex }"
            >
            </ng-template>
          </td>
        </tr>

        <tr *ngIf="hasMainColumns && isShowMasterDetail(row)">
          <td class="po-table-column-detail" [colSpan]="columnCountForMasterDetail">
            <po-table-detail
              [p-selectable]="selectable && !detailHideSelect"
              [p-detail]="columnMasterDetail.detail"
              [p-items]="row[nameColumnDetail]"
              [p-parent-row]="row"
              (p-select-row)="selectDetailRow($event)"
            >
            </po-table-detail>
          </td>
        </tr>
      </tbody>
    </ng-container>
  </table>
</ng-template>

<!-- Table with virtual scroll -->
<ng-template #tableVirtualScrollTemplate>
  <cdk-virtual-scroll-viewport
    #tableVirtualScroll
    [itemSize]="itemSize"
    [style.height.px]="heightTableContainer"
    [minBufferPx]="heightTableContainer < 100 ? 100 : heightTableContainer"
    [maxBufferPx]="heightTableContainer < 200 ? 200 : heightTableContainer"
  >
    <table
      class="po-table"
      [ngClass]="{
        'po-table-interactive': selectable || sort,
        'po-table-selectable': selectable,
        'po-table-striped': striped,
        'po-table-data-fixed-columns': applyFixedColumns(),
        'po-table-text-wrap-enabled': textWrap
      }"
      [attr.p-spacing]="spacing"
    >
      <thead class="po-table-header-sticky" [style.top]="inverseOfTranslation">
        <tr
          [class.po-table-header]="!height"
          cdkDropList
          cdkDropListOrientation="horizontal"
          (cdkDropListDropped)="drop($event)"
        >
          <th
            *ngIf="hasSelectableColumn"
            [style.pointer-events]="hideSelectAll ? 'none' : 'auto'"
            class="po-table-column-selectable"
          >
            <div [class.po-table-header-fixed-inner]="height">
              <po-checkbox
                name="selectAll"
                *ngIf="!hideSelectAll"
                (p-change)="selectAllRows()"
                [p-checkboxValue]="selectAll === null ? 'mixed' : selectAll"
              ></po-checkbox>
            </div>
          </th>

          <th
            *ngIf="
              (hasMasterDetailColumn || hasRowTemplate) && hasMainColumns && !hasRowTemplateWithArrowDirectionRight
            "
            class="po-table-header-column po-table-header-master-detail"
          ></th>

          <!-- Coluna criada para caso as ações fiquem no lado esquerdo -->
          <th
            #columnActionLeft
            *ngIf="!actionRight && (visibleActions.length > 1 || isSingleAction)"
            [class.po-table-header-master-detail]="!isSingleAction"
            [class.po-table-header-single-action]="isSingleAction"
          ></th>

          <th *ngIf="!hasMainColumns" #noColumnsHeader class="po-table-header-column po-text-center">
            <ng-container *ngIf="height; then noColumnsWithHeight; else noColumnsWithoutHeight"> </ng-container>
          </th>

          <ng-container
            *ngIf="
              this.isDraggable || hasSomeFixed();
              then tableVirtualScrollThDragDrop;
              else tableVirtualScrollThDefault
            "
          >
          </ng-container>
          <ng-template #tableVirtualScrollThDragDrop>
            <th
              *ngFor="let column of mainColumns; let i = index; trackBy: trackBy"
              class="po-table-header-ellipsis p-element po-frozen-column"
              [style.width]="column.width"
              [style.max-width]="column.width"
              [style.min-width]="column.width"
              [attr.data-po-table-column-name]="column.label || (column.property | titlecase) | lowercase"
              [class.po-clickable]="(sort && column.sortable !== false) || hasService"
              [ngClass]="{
                'po-table-header-sorted':
                  sort &&
                  JSON.stringify(sortedColumn?.property) === JSON.stringify(column) &&
                  (sortedColumn.ascending || !sortedColumn.ascending)
              }"
              [ngStyle]="{ 'width': !hasItems ? '100%' : applyFixedColumns() ? column.width : 'auto' }"
              [class.po-table-header-subtitle]="column.type === 'subtitle'"
              [class.po-table-column-drag-box]="this.isDraggable"
              (click)="sortColumn(column)"
              cdkDrag
              cdkDragLockAxis="x"
              [cdkDragDisabled]="column.fixed ? 'true' : 'false'"
              [pFrozenColumn]="column.fixed"
            >
              <div
                class="po-table-header-flex"
                [class.po-table-header-fixed-inner]="height"
                [class.po-table-header-flex-right]="column.type === 'currency' || column.type === 'number'"
                [class.po-table-header-flex-center]="column.type === 'subtitle'"
              >
                <ng-container *ngIf="this.isDraggable && !column.fixed">
                  <po-icon cdkDragHandle *ngIf="iconNameLib === 'AnimaliaIcon'" p-icon="ICON_DRAG"></po-icon>
                  <svg
                    *ngIf="iconNameLib === 'PoIcon'"
                    cdkDragHandle
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <circle cx="9" cy="6" r="2" fill="black" />
                    <circle cx="15" cy="6" r="2" fill="black" />
                    <circle cx="9" cy="12" r="2" fill="black" />
                    <circle cx="15" cy="12" r="2" fill="black" />
                    <circle cx="9" cy="18" r="2" fill="black" />
                    <circle cx="15" cy="18" r="2" fill="black" />
                  </svg>
                </ng-container>
                <ng-container *ngTemplateOutlet="contentHeaderTemplate; context: { $implicit: column }"> </ng-container>
              </div>
            </th>
          </ng-template>
          <ng-template #tableVirtualScrollThDefault>
            <th
              *ngFor="let column of mainColumns; let i = index; trackBy: trackBy"
              class="po-table-header-ellipsis p-element po-frozen-column example-box"
              [style.width]="column.width"
              [style.max-width]="column.width"
              [style.min-width]="column.width"
              [attr.data-po-table-column-name]="column.label || (column.property | titlecase) | lowercase"
              [class.po-clickable]="(sort && column.sortable !== false) || hasService"
              [ngClass]="{
                'po-table-header-sorted':
                  sort &&
                  JSON.stringify(sortedColumn?.property) === JSON.stringify(column) &&
                  (sortedColumn.ascending || !sortedColumn.ascending)
              }"
              [ngStyle]="{ 'width': !hasItems ? '100%' : applyFixedColumns() ? column.width : 'auto' }"
              [class.po-table-header-subtitle]="column.type === 'subtitle'"
              (click)="sortColumn(column)"
              [pFrozenColumn]="column.fixed"
            >
              <div
                class="po-table-header-flex"
                [class.po-table-header-fixed-inner]="height"
                [class.po-table-header-flex-right]="column.type === 'currency' || column.type === 'number'"
                [class.po-table-header-flex-center]="column.type === 'subtitle'"
              >
                <ng-container *ngTemplateOutlet="contentHeaderTemplate; context: { $implicit: column }"> </ng-container>
              </div>
            </th>
          </ng-template>

          <th
            *ngIf="hasRowTemplateWithArrowDirectionRight && hasMainColumns && (hasVisibleActions || hideColumnsManager)"
            class="po-table-header-column po-table-header-master-detail"
          ></th>

          <th
            *ngIf="hasVisibleActions && actionRight && (visibleActions.length > 1 || isSingleAction)"
            [class.po-table-header-single-action]="isSingleAction"
            [class.po-table-header-actions]="!isSingleAction"
          ></th>
        </tr>
      </thead>

      <tbody class="po-table-group-row" *ngIf="!hasItems || !hasMainColumns">
        <tr class="po-table-row po-table-row-no-data">
          <td [colSpan]="columnCount" class="po-table-no-data po-text-center">
            <span> {{ literals.noData }} </span>
          </td>
        </tr>
      </tbody>

      <ng-container *ngIf="hasMainColumns">
        <tbody
          class="po-table-group-row"
          *cdkVirtualFor="let row of filteredItems; let rowIndex = index; trackBy: trackBy"
        >
          <tr
            class="po-table-row"
            [class.po-table-row-active]="row.$selected || (row.$selected === null && selectable)"
          >
            <td *ngIf="selectable" class="po-table-column-selectable">
              <ng-container *ngTemplateOutlet="singleSelect ? inputRadio : inputCheckbox; context: { $implicit: row }">
              </ng-container>
            </td>

            <!-- Valida se a origem do detail é pelo input do po-table pela diretiva -->
            <td
              *ngIf="
                (columnMasterDetail && !hideDetail && !hasRowTemplate) ||
                (hasRowTemplate && !hasRowTemplateWithArrowDirectionRight)
              "
              class="po-table-column-detail-toggle"
              (click)="toggleDetail(row)"
            >
              <ng-template
                [ngTemplateOutlet]="poTableColumnDetail"
                [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
              >
              </ng-template>
            </td>

            <!-- Coluna com as ações na esquerda (padrão)-->
            <ng-template
              *ngIf="!actionRight && (visibleActions.length > 1 || isSingleAction)"
              [ngTemplateOutlet]="ActionsColumnTemplate"
              [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
            >
            </ng-template>

            <td
              *ngFor="let column of mainColumns; let columnIndex = index; trackBy: trackBy"
              [style.width]="column.width"
              [style.max-width]="column.width"
              [style.min-width]="column.width"
              [class.po-table-column]="column.type !== 'icon'"
              [class.po-table-column-right]="column.type === 'currency' || column.type === 'number'"
              [class.po-table-column-center]="column.type === 'subtitle'"
              [class.po-table-column-icons]="column.type === 'icon'"
              [ngClass]="getClassColor(row, column)"
              [pFrozenColumn]="column.fixed"
              class="p-element po-frozen-column"
              (click)="hasSelectableRow() ? selectRow(row) : 'javascript:;'"
            >
              <div
                class="po-table-column-cell po-table-body-ellipsis notranslate"
                [ngSwitch]="column.type"
                [p-tooltip]="tooltipText"
                [p-append-in-body]="true"
                (mouseenter)="tooltipMouseEnter($event, column, row)"
                (mouseleave)="tooltipMouseLeave()"
              >
                <span *ngSwitchCase="'columnTemplate'">
                  <ng-container
                    *ngTemplateOutlet="getTemplate(column); context: { $implicit: getCellData(row, column) }"
                  >
                  </ng-container>
                </span>

                <span *ngSwitchCase="'cellTemplate'">
                  <ng-container
                    *ngTemplateOutlet="tableCellTemplate?.templateRef; context: { row: row, column: column }"
                  >
                  </ng-container>
                </span>

                <span *ngSwitchCase="'boolean'">
                  {{ getBooleanLabel(getCellData(row, column), column) }}
                </span>

                <span *ngSwitchCase="'currency'">
                  {{ getCellData(row, column) | currency: column.format : 'symbol' : '1.2-2' }}
                </span>

                <span *ngSwitchCase="'date'">
                  {{ getCellData(row, column) | date: column.format || 'dd/MM/yyyy' }}
                </span>

                <span *ngSwitchCase="'time'">
                  {{ getCellData(row, column) | po_time: column.format || 'HH:mm:ss.ffffff' }}
                </span>

                <span *ngSwitchCase="'dateTime'">
                  {{ getCellData(row, column) | date: column.format || 'dd/MM/yyyy HH:mm:ss' }}
                </span>

                <span *ngSwitchCase="'number'">
                  {{ formatNumber(getCellData(row, column), column.format) }}
                </span>

                <po-table-column-link
                  *ngSwitchCase="'link'"
                  [p-action]="column.action"
                  [p-disabled]="checkDisabled(row, column)"
                  [p-link]="row[column.link]"
                  [p-row]="row"
                  [p-value]="getCellData(row, column)"
                  (click)="onClickLink($event, row, column)"
                >
                </po-table-column-link>

                <po-table-column-icon
                  *ngSwitchCase="'icon'"
                  [p-column]="column"
                  [p-icons]="getColumnIcons(row, column)"
                  [p-row]="row"
                >
                </po-table-column-icon>

                <span *ngSwitchCase="'subtitle'">
                  <po-table-subtitle-circle [p-subtitle]="getSubtitleColumn(row, column)"></po-table-subtitle-circle>
                </span>
                <span *ngSwitchCase="'label'">
                  <po-table-column-label [p-value]="getColumnLabel(row, column)"> </po-table-column-label>
                </span>
                <span *ngSwitchDefault>{{ getCellData(row, column) }}</span>
              </div>
            </td>

            <td
              *ngIf="hasRowTemplateWithArrowDirectionRight"
              class="po-table-column-detail-toggle"
              (click)="toggleDetail(row)"
            >
              <ng-template
                [ngTemplateOutlet]="poTableColumnDetail"
                [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
              >
              </ng-template>
            </td>

            <!-- Coluna de açoes na direita -->
            <ng-template
              *ngIf="actionRight"
              [ngTemplateOutlet]="ActionsColumnTemplate"
              [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
            >
            </ng-template>
          </tr>

          <tr *ngIf="hasMainColumns && hasRowTemplate && row.$showDetail && isShowRowTemplate(row, rowIndex)">
            <td class="po-table-row-template-container" [colSpan]="columnCountForMasterDetail">
              <ng-template
                [ngTemplateOutlet]="tableRowTemplate.templateRef"
                [ngTemplateOutletContext]="{ $implicit: row, rowIndex: rowIndex }"
              >
              </ng-template>
            </td>
          </tr>

          <tr *ngIf="hasMainColumns && isShowMasterDetail(row)">
            <td class="po-table-column-detail" [colSpan]="columnCountForMasterDetail">
              <po-table-detail
                [p-selectable]="selectable && !detailHideSelect"
                [p-detail]="columnMasterDetail.detail"
                [p-items]="row[nameColumnDetail]"
                [p-parent-row]="row"
                (p-select-row)="selectDetailRow($event)"
              >
              </po-table-detail>
            </td>
          </tr>
        </tbody>
      </ng-container>
    </table>
  </cdk-virtual-scroll-viewport>
</ng-template>

<po-popup #popup [p-actions]="actions" [p-target]="popupTarget"> </po-popup>

<ng-template #poTableColumnDetail let-row="row" let-rowIndex="rowIndex">
  <po-icon
    *ngIf="(containsMasterDetail(row) && !hasRowTemplate) || (isShowRowTemplate(row, rowIndex) && hasRowTemplate)"
    [p-icon]="row.$showDetail ? 'ICON_ARROW_UP' : 'ICON_ARROW_DOWN'"
    class="po-clickable"
  >
  </po-icon>
</ng-template>

<ng-template #inputRadio let-row>
  <po-radio [name]="idRadio" [p-checked]="row.$selected" (p-change-selected)="selectRow(row)"></po-radio>
</ng-template>

<ng-template #inputCheckbox let-row>
  <po-checkbox
    name="checkbox"
    (p-change)="selectable ? selectRow(row) : 'javascript:;'"
    [p-checkboxValue]="row.$selected === null ? 'mixed' : row.$selected"
  ></po-checkbox>
</ng-template>

<ng-template #contentHeaderTemplate let-column>
  <span
    #columnHeader
    class="po-table-header-ellipsis"
    [p-tooltip]="tooltipText"
    [p-append-in-body]="true"
    (mouseenter)="tooltipMouseEnter($event)"
    (mouseleave)="tooltipMouseLeave()"
  >
    {{ column.label || (column.property | titlecase) }}
  </span>

  <span
    *ngIf="sort && column.sortable !== false"
    [class.po-table-header-icon-unselected]="JSON.stringify(sortedColumn?.property) !== JSON.stringify(column)"
    [class.po-table-header-icon-descending]="
      JSON.stringify(sortedColumn?.property) === JSON.stringify(column) && sortedColumn.ascending
    "
    [class.po-table-header-icon-ascending]="
      JSON.stringify(sortedColumn?.property) === JSON.stringify(column) && !sortedColumn.ascending
    "
  >
    <ng-container *ngIf="JSON.stringify(sortedColumn?.property) !== JSON.stringify(column)">
      <po-icon *ngIf="iconNameLib === 'AnimaliaIcon'" p-icon="ICON_SORT"></po-icon>
      <svg
        *ngIf="iconNameLib === 'PoIcon'"
        width="16"
        height="16"
        viewBox="0 0 24 24"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M18.2929 15.2929L17 16.5858L17 10C17 9.44772 16.5523 9 16 9C15.4477 9 15 9.44772 15 10L15 16.5858L13.7071 15.2929C13.3166 14.9024 12.6834 14.9024 12.2929 15.2929C11.9024 15.6834 11.9024 16.3166 12.2929 16.7071L15.2929 19.7071C15.6834 20.0976 16.3166 20.0976 16.7071 19.7071L19.7071 16.7071C20.0976 16.3166 20.0976 15.6834 19.7071 15.2929C19.3166 14.9024 18.6834 14.9024 18.2929 15.2929ZM5.70716 8.7071L7.00006 7.4142L7.00003 14C7.00002 14.5523 7.44774 15 8.00002 15C8.55231 15 9.00002 14.5523 9.00003 14L9.00006 7.41418L10.2929 8.70707C10.6835 9.09759 11.3166 9.09758 11.7072 8.70706C12.0977 8.31653 12.0977 7.68336 11.7072 7.29284L8.70718 4.29286C8.31665 3.90234 7.68349 3.90235 7.29296 4.29287L4.29295 7.29289C3.90242 7.68342 3.90242 8.31658 4.29294 8.70711C4.68347 9.09763 5.31663 9.09762 5.70716 8.7071Z"
          fill="#1D1D30"
        />
      </svg>
    </ng-container>

    <ng-container *ngIf="JSON.stringify(sortedColumn?.property) === JSON.stringify(column) && sortedColumn.ascending">
      <po-icon *ngIf="iconNameLib === 'AnimaliaIcon'" p-icon="ICON_SORT_ASC"></po-icon>
      <svg
        *ngIf="iconNameLib === 'PoIcon'"
        width="16"
        height="16"
        viewBox="0 0 24 24"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M11 9.41421L9.70711 10.7071C9.31658 11.0976 8.68342 11.0976 8.29289 10.7071C7.90237 10.3166 7.90237 9.68342 8.29289 9.29289L11.2929 6.29289C11.6834 5.90237 12.3166 5.90237 12.7071 6.29289L15.7071 9.29289C16.0976 9.68342 16.0976 10.3166 15.7071 10.7071C15.3166 11.0976 14.6834 11.0976 14.2929 10.7071L13 9.41421V16C13 16.5523 12.5523 17 12 17C11.4477 17 11 16.5523 11 16V9.41421Z"
          fill="black"
        />
      </svg>
    </ng-container>

    <ng-container *ngIf="JSON.stringify(sortedColumn?.property) === JSON.stringify(column) && !sortedColumn.ascending">
      <po-icon cdkDragHandle *ngIf="iconNameLib === 'AnimaliaIcon'" p-icon="ICON_SORT_DESC"></po-icon>
      <svg
        *ngIf="iconNameLib === 'PoIcon'"
        width="16"
        height="16"
        viewBox="0 0 24 24"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M9.70711 13.2929L11 14.5858V7C11 6.44772 11.4477 6 12 6C12.5523 6 13 6.44772 13 7V14.5858L14.2929 13.2929C14.6834 12.9024 15.3166 12.9024 15.7071 13.2929C16.0976 13.6834 16.0976 14.3166 15.7071 14.7071L12.7071 17.7071C12.3166 18.0976 11.6834 18.0976 11.2929 17.7071L8.29289 14.7071C7.90237 14.3166 7.90237 13.6834 8.29289 13.2929C8.68342 12.9024 9.31658 12.9024 9.70711 13.2929Z"
          fill="black"
        />
      </svg>
    </ng-container>
  </span>
</ng-template>

<ng-template #noColumnsWithHeight>
  <div class="po-table-header-fixed-inner" [style.width.px]="headerWidth">
    {{ hasValidColumns ? literals.noVisibleColumn : literals.noColumns }}
  </div>
</ng-template>

<ng-template #noColumnsWithoutHeight>
  {{ hasValidColumns ? literals.noVisibleColumn : literals.noColumns }}
</ng-template>

<!-- Template de ações -->
<ng-template #ActionsColumnTemplate let-row="row" let-rowIndex="rowIndex">
  <td
    *ngIf="isSingleAction"
    class="po-table-column po-table-column-single-action"
    [style.width.px]="height && actionRight ? getWidthColumnManager() : ''"
    [style.max-width.px]="height && !actionRight ? getColumnWidthActionsLeft() : ''"
    [style.width.px]="height && !actionRight ? getColumnWidthActionsLeft() : ''"
  >
    <div
      *ngIf="firstAction.visible !== false"
      class="po-table-single-action po-clickable"
      [class.po-table-action-disabled]="firstAction.disabled ? validateTableAction(row, firstAction) : false"
      (click)="executeTableAction(row, firstAction)"
    >
      <po-icon *ngIf="firstAction.icon" class="po-table-single-action-content" [p-icon]="firstAction.icon"></po-icon>
      {{ firstAction.label }}
    </div>
  </td>

  <td *ngIf="visibleActions.length > 1" class="po-table-column-actions">
    <div #popupTarget class="po-clickable" (click)="togglePopup(row, popupTarget)">
      <po-icon p-icon="ICON_MORE"></po-icon>
    </div>
  </td>
</ng-template>

<po-table-column-manager
  *ngIf="!hideColumnsManager"
  [p-columns]="columns"
  [p-max-columns]="maxColumns"
  [p-target]="columnManagerTarget"
  [p-last-visible-columns-selected]="lastVisibleColumnsSelected"
  [p-hide-action-fixed-columns]="hideActionFixedColumns"
  (p-visible-columns-change)="onVisibleColumnsChange($event)"
  (p-change-visible-columns)="onChangeVisibleColumns($event)"
  [p-columns-default]="initialColumns"
  (p-initial-columns)="onColumnRestoreManager($event)"
>
</po-table-column-manager>

<po-modal
  #modalDelete
  [p-title]="literals.delete"
  [p-primary-action]="confirm"
  [p-secondary-action]="close"
  [p-click-out]="true"
>
  <p class="po-font-text-large">{{ literals.bodyDelete }}</p>
</po-modal>
`
    }]
  }], () => [{
    type: PoDateService
  }, {
    type: IterableDiffers
  }, {
    type: Renderer2
  }, {
    type: PoLanguageService
  }, {
    type: ChangeDetectorRef
  }, {
    type: DecimalPipe
  }, {
    type: PoTableService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ICONS_DICTIONARY]
    }]
  }], {
    tableRowTemplate: [{
      type: ContentChild,
      args: [PoTableRowTemplateDirective, {
        static: true
      }]
    }],
    tableCellTemplate: [{
      type: ContentChild,
      args: [PoTableCellTemplateDirective]
    }],
    tableColumnTemplates: [{
      type: ContentChildren,
      args: [PoTableColumnTemplateDirective]
    }],
    noColumnsHeader: [{
      type: ViewChild,
      args: ["noColumnsHeader", {
        read: ElementRef
      }]
    }],
    poPopupComponent: [{
      type: ViewChild,
      args: ["popup"]
    }],
    modalDelete: [{
      type: ViewChild,
      args: [PoModalComponent, {
        static: true
      }]
    }],
    tableFooterElement: [{
      type: ViewChild,
      args: ["tableFooter", {
        read: ElementRef,
        static: false
      }]
    }],
    tableWrapperElement: [{
      type: ViewChild,
      args: ["tableWrapper", {
        read: ElementRef,
        static: false
      }]
    }],
    tableTemplate: [{
      type: ViewChild,
      args: ["tableTemplate", {
        read: ElementRef,
        static: false
      }]
    }],
    tableVirtualScroll: [{
      type: ViewChild,
      args: ["tableVirtualScroll", {
        read: ElementRef,
        static: false
      }]
    }],
    tableScrollable: [{
      type: ViewChild,
      args: ["tableScrollable", {
        read: ElementRef,
        static: false
      }]
    }],
    columnManager: [{
      type: ViewChild,
      args: ["columnManager", {
        read: ElementRef,
        static: false
      }]
    }],
    columnBatchActions: [{
      type: ViewChild,
      args: ["columnBatchActions", {
        read: ElementRef,
        static: false
      }]
    }],
    columnActionLeft: [{
      type: ViewChild,
      args: ["columnActionLeft", {
        read: ElementRef,
        static: false
      }]
    }],
    actionsIconElement: [{
      type: ViewChildren,
      args: ["actionsIconElement", {
        read: ElementRef
      }]
    }],
    actionsElement: [{
      type: ViewChildren,
      args: ["actionsElement", {
        read: ElementRef
      }]
    }],
    filterInput: [{
      type: ViewChild,
      args: ["filterInput"]
    }],
    poSearchInput: [{
      type: ViewChild,
      args: ["poSearchInput", {
        read: ElementRef,
        static: true
      }]
    }],
    viewPort: [{
      type: ViewChild,
      args: [CdkVirtualScrollViewport, {
        static: false
      }]
    }],
    columnManagerTarget: [{
      type: ViewChild,
      args: ["columnManagerTarget"]
    }],
    columnManagerTargetFixed: [{
      type: ViewChild,
      args: ["columnManagerTargetFixed"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableComponent, {
    className: "PoTableComponent",
    filePath: "lib/components/po-table/po-table.component.ts",
    lineNumber: 107
  });
})();
function PoTableDetailComponent_thead_1_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 7);
  }
}
function PoTableDetailComponent_thead_1_th_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 8)(1, "div", 9);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const detail_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassProp("po-table-header-flex-right", detail_r1.type === "currency" || detail_r1.type === "number");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.getColumnTitleLabel(detail_r1), " ");
  }
}
function PoTableDetailComponent_thead_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "thead")(1, "tr");
    ɵɵtemplate(2, PoTableDetailComponent_thead_1_th_2_Template, 1, 0, "th", 4);
    ɵɵelement(3, "th", 5);
    ɵɵtemplate(4, PoTableDetailComponent_thead_1_th_4_Template, 3, 3, "th", 6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.isSelectable);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.detail.columns);
  }
}
function PoTableDetailComponent_tr_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "td", 13);
    ɵɵelementStart(2, "td", 14)(3, "po-checkbox", 15);
    ɵɵlistener("p-change", function PoTableDetailComponent_tr_3_ng_container_1_Template_po_checkbox_p_change_3_listener() {
      ɵɵrestoreView(_r3);
      const item_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onSelectRow(item_r4));
    });
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext().$implicit;
    ɵɵadvance(3);
    ɵɵproperty("p-checkboxValue", item_r4.$selected);
  }
}
function PoTableDetailComponent_tr_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 16);
  }
}
function PoTableDetailComponent_tr_3_td_4_strong_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "strong");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r6 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.getColumnTitleLabel(detail_r6), ": ");
  }
}
function PoTableDetailComponent_tr_3_td_4_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "currency");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r6 = ɵɵnextContext().$implicit;
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind4(2, 1, ctx_r1.getDetailData(item_r4, detail_r6), detail_r6.format, "symbol", "1.2-2"));
  }
}
function PoTableDetailComponent_tr_3_td_4_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r6 = ɵɵnextContext().$implicit;
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind2(2, 1, ctx_r1.getDetailData(item_r4, detail_r6), detail_r6.format || "dd/MM/yyyy"));
  }
}
function PoTableDetailComponent_tr_3_td_4_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "po_time");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r6 = ɵɵnextContext().$implicit;
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind2(2, 1, ctx_r1.getDetailData(item_r4, detail_r6), detail_r6.format || "HH:mm:ss.ffffff"));
  }
}
function PoTableDetailComponent_tr_3_td_4_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r6 = ɵɵnextContext().$implicit;
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r1.getDetailData(item_r4, detail_r6), detail_r6.format || "dd/MM/yyyy HH:mm:ss"), " ");
  }
}
function PoTableDetailComponent_tr_3_td_4_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r6 = ɵɵnextContext().$implicit;
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.formatNumberDetail(ctx_r1.getDetailData(item_r4, detail_r6), detail_r6.format));
  }
}
function PoTableDetailComponent_tr_3_td_4_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r6 = ɵɵnextContext().$implicit;
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getDetailData(item_r4, detail_r6));
  }
}
function PoTableDetailComponent_tr_3_td_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 17);
    ɵɵlistener("click", function PoTableDetailComponent_tr_3_td_4_Template_td_click_0_listener() {
      ɵɵrestoreView(_r5);
      const item_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.isSelectable ? ctx_r1.onSelectRow(item_r4) : "javascript:;");
    });
    ɵɵtemplate(1, PoTableDetailComponent_tr_3_td_4_strong_1_Template, 2, 1, "strong", 2);
    ɵɵelementContainerStart(2, 18);
    ɵɵtemplate(3, PoTableDetailComponent_tr_3_td_4_span_3_Template, 3, 6, "span", 19)(4, PoTableDetailComponent_tr_3_td_4_span_4_Template, 3, 4, "span", 19)(5, PoTableDetailComponent_tr_3_td_4_span_5_Template, 3, 4, "span", 19)(6, PoTableDetailComponent_tr_3_td_4_span_6_Template, 3, 4, "span", 19)(7, PoTableDetailComponent_tr_3_td_4_span_7_Template, 2, 1, "span", 19)(8, PoTableDetailComponent_tr_3_td_4_span_8_Template, 2, 1, "span", 20);
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r6 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("po-table-column-right", ctx_r1.typeHeaderTop && (detail_r6.type === "currency" || detail_r6.type === "number"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.typeHeaderInline);
    ɵɵadvance();
    ɵɵproperty("ngSwitch", detail_r6.type);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "currency");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "date");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "time");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "dateTime");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "number");
  }
}
function PoTableDetailComponent_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 10);
    ɵɵtemplate(1, PoTableDetailComponent_tr_3_ng_container_1_Template, 4, 1, "ng-container", 11)(2, PoTableDetailComponent_tr_3_ng_template_2_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(4, PoTableDetailComponent_tr_3_td_4_Template, 9, 9, "td", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const masterDetailSpace_r7 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-table-row-active", item_r4.$selected && ctx_r1.isSelectable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isSelectable)("ngIfElse", masterDetailSpace_r7);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r1.detailColumns);
  }
}
var PoTableDetailComponent = class _PoTableDetailComponent {
  decimalPipe;
  /**
   * Lista de itens do _detail_ da tabela.
   */
  items;
  /**
   * Linha do registro pai correspondente ao item de detalhe selecionado. Utilizado para gerenciar o estado de seleção do elemento pai,
   * permitindo que o mesmo seja atualizado para refletir a seleção de todos os filhos ou estado indeterminado.
   */
  parentRow;
  /**
   * Define se a tabela possui a opção de `selectable` habilitada.
   */
  isSelectable = false;
  /**
   * @optional
   *
   * @description
   *
   * Ação executada ao selecionar ou desmarcar a seleção de uma linha de detalhe do `po-table`.
   */
  selectRow = new EventEmitter();
  _detail;
  /**
   * Configuração da linha de detalhes.
   */
  set detail(value) {
    this._detail = this.returnPoTableDetailObject(value);
  }
  get detail() {
    return this._detail;
  }
  constructor(decimalPipe) {
    this.decimalPipe = decimalPipe;
  }
  get detailColumns() {
    return this.detail?.columns || [];
  }
  get typeHeaderInline() {
    return this.detail && !this.detail["typeHeader"] || this.detail["typeHeader"] === "inline";
  }
  get typeHeaderTop() {
    return this.detail && this.detail["typeHeader"] === "top";
  }
  formatNumberDetail(value, format) {
    if (!format) {
      return value;
    }
    return this.decimalPipe.transform(value, format);
  }
  getColumnTitleLabel(detail) {
    return detail.label || capitalizeFirstLetter(detail.property);
  }
  getDetailData(item, detail) {
    const arrayProperty = detail.property.split(".");
    if (arrayProperty.length > 1) {
      const nestedProperties = arrayProperty;
      let value = item;
      for (const property of nestedProperties) {
        value = value[property] || value[property] === 0 ? value[property] : "";
      }
      return value;
    } else {
      return item[detail.property];
    }
  }
  onSelectRow(item) {
    item.$selected = !item.$selected;
    this.selectRow.emit({
      item,
      parentRow: this.parentRow
    });
  }
  returnPoTableDetailObject(value) {
    if (value && isTypeof(value, "object")) {
      if (value.columns) {
        value.columns.forEach((column) => column.property = column.property || column.column);
      }
      if (Array.isArray(value)) {
        return {
          columns: value
        };
      }
      if (value.columns) {
        return value;
      }
    }
  }
  static ɵfac = function PoTableDetailComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableDetailComponent)(ɵɵdirectiveInject(DecimalPipe));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTableDetailComponent,
    selectors: [["po-table-detail"]],
    inputs: {
      items: [0, "p-items", "items"],
      parentRow: [0, "p-parent-row", "parentRow"],
      isSelectable: [0, "p-selectable", "isSelectable"],
      detail: [0, "p-detail", "detail"]
    },
    outputs: {
      selectRow: "p-select-row"
    },
    standalone: false,
    decls: 4,
    vars: 2,
    consts: [["masterDetailSpace", ""], [1, "po-table-master-detail"], [4, "ngIf"], ["class", "po-table-detail-row", 3, "po-table-row-active", 4, "ngFor", "ngForOf"], ["class", "po-table-header po-table-column-selectable", 4, "ngIf"], [1, "po-table-header", "po-table-header-column", "po-table-header-master-detail"], ["class", "po-table-header po-table-header-ellipsis", 4, "ngFor", "ngForOf"], [1, "po-table-header", "po-table-column-selectable"], [1, "po-table-header", "po-table-header-ellipsis"], [1, "po-table-header-flex"], [1, "po-table-detail-row"], [4, "ngIf", "ngIfElse"], ["class", "po-table-column-master-detail po-table-master-detail-label", 3, "po-table-column-right", "click", 4, "ngFor", "ngForOf"], [1, "po-table-column-master-detail-space-checkbox"], [1, "po-table-column", "po-table-column-selectable"], ["name", "checkbox", 3, "p-change", "p-checkboxValue"], [1, "po-table-column-master-detail-space"], [1, "po-table-column-master-detail", "po-table-master-detail-label", 3, "click"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"]],
    template: function PoTableDetailComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "table", 1);
        ɵɵtemplate(1, PoTableDetailComponent_thead_1_Template, 5, 2, "thead", 2);
        ɵɵelementStart(2, "tbody");
        ɵɵtemplate(3, PoTableDetailComponent_tr_3_Template, 5, 5, "tr", 3);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.typeHeaderTop);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ctx.items);
      }
    },
    dependencies: [NgForOf, NgIf, NgSwitch, NgSwitchCase, NgSwitchDefault, PoCheckboxComponent, CurrencyPipe, DatePipe, PoTimePipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableDetailComponent, [{
    type: Component,
    args: [{
      selector: "po-table-detail",
      standalone: false,
      template: `<table class="po-table-master-detail">
  <thead *ngIf="typeHeaderTop">
    <tr>
      <th class="po-table-header po-table-column-selectable" *ngIf="isSelectable"></th>
      <th class="po-table-header po-table-header-column po-table-header-master-detail"></th>
      <th class="po-table-header po-table-header-ellipsis" *ngFor="let detail of detail.columns">
        <div
          class="po-table-header-flex"
          [class.po-table-header-flex-right]="detail.type === 'currency' || detail.type === 'number'"
        >
          {{ getColumnTitleLabel(detail) }}
        </div>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr
      class="po-table-detail-row"
      [class.po-table-row-active]="item.$selected && isSelectable"
      *ngFor="let item of items"
    >
      <ng-container *ngIf="isSelectable; else masterDetailSpace">
        <td class="po-table-column-master-detail-space-checkbox"></td>
        <td class="po-table-column po-table-column-selectable">
          <po-checkbox name="checkbox" (p-change)="onSelectRow(item)" [p-checkboxValue]="item.$selected"></po-checkbox>
        </td>
      </ng-container>

      <ng-template #masterDetailSpace>
        <td class="po-table-column-master-detail-space"></td>
      </ng-template>

      <td
        class="po-table-column-master-detail po-table-master-detail-label"
        (click)="isSelectable ? onSelectRow(item) : 'javascript:;'"
        *ngFor="let detail of detailColumns"
        [class.po-table-column-right]="typeHeaderTop && (detail.type === 'currency' || detail.type === 'number')"
      >
        <strong *ngIf="typeHeaderInline"> {{ getColumnTitleLabel(detail) }}: </strong>

        <ng-container [ngSwitch]="detail.type">
          <span *ngSwitchCase="'currency'">{{
            getDetailData(item, detail) | currency: detail.format : 'symbol' : '1.2-2'
          }}</span>
          <span *ngSwitchCase="'date'">{{ getDetailData(item, detail) | date: detail.format || 'dd/MM/yyyy' }}</span>
          <span *ngSwitchCase="'time'">{{
            getDetailData(item, detail) | po_time: detail.format || 'HH:mm:ss.ffffff'
          }}</span>
          <span *ngSwitchCase="'dateTime'">
            {{ getDetailData(item, detail) | date: detail.format || 'dd/MM/yyyy HH:mm:ss' }}
          </span>
          <span *ngSwitchCase="'number'">{{ formatNumberDetail(getDetailData(item, detail), detail.format) }}</span>
          <span *ngSwitchDefault>{{ getDetailData(item, detail) }}</span>
        </ng-container>
      </td>
    </tr>
  </tbody>
</table>
`
    }]
  }], () => [{
    type: DecimalPipe
  }], {
    items: [{
      type: Input,
      args: ["p-items"]
    }],
    parentRow: [{
      type: Input,
      args: ["p-parent-row"]
    }],
    isSelectable: [{
      type: Input,
      args: ["p-selectable"]
    }],
    selectRow: [{
      type: Output,
      args: ["p-select-row"]
    }],
    detail: [{
      type: Input,
      args: ["p-detail"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableDetailComponent, {
    className: "PoTableDetailComponent",
    filePath: "lib/components/po-table/po-table-detail/po-table-detail.component.ts",
    lineNumber: 21
  });
})();
var PoTableSubtitleCircleComponent = class _PoTableSubtitleCircleComponent {
  poColorPaletteService;
  /** Esconde a tooltip. */
  hideTitle = false;
  _subtitle;
  /** Objeto com os dados da legenda. */
  set subtitle(subtitle) {
    if (subtitle) {
      subtitle.color = this.poColorPaletteService.getColor(subtitle);
    }
    this._subtitle = subtitle;
  }
  get subtitle() {
    return this._subtitle;
  }
  constructor(poColorPaletteService) {
    this.poColorPaletteService = poColorPaletteService;
  }
  static ɵfac = function PoTableSubtitleCircleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableSubtitleCircleComponent)(ɵɵdirectiveInject(PoColorPaletteService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTableSubtitleCircleComponent,
    selectors: [["po-table-subtitle-circle"]],
    inputs: {
      hideTitle: [0, "p-hide-title", "hideTitle"],
      subtitle: [0, "p-subtitle", "subtitle"]
    },
    standalone: false,
    decls: 2,
    vars: 5,
    consts: [[3, "title"]],
    template: function PoTableSubtitleCircleComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "span", 0);
        ɵɵtext(1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMapInterpolate1("po-table-subtitle-circle po-", ctx.subtitle == null ? null : ctx.subtitle.color, "");
        ɵɵproperty("title", ctx.hideTitle ? "" : ctx.subtitle == null ? null : ctx.subtitle.label);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx.subtitle == null ? null : ctx.subtitle.content, "\n");
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableSubtitleCircleComponent, [{
    type: Component,
    args: [{
      selector: "po-table-subtitle-circle",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<span [title]="hideTitle ? '' : subtitle?.label" class="po-table-subtitle-circle po-{{ subtitle?.color }}">
  {{ subtitle?.content }}
</span>
`
    }]
  }], () => [{
    type: PoColorPaletteService
  }], {
    hideTitle: [{
      type: Input,
      args: ["p-hide-title"]
    }],
    subtitle: [{
      type: Input,
      args: ["p-subtitle"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableSubtitleCircleComponent, {
    className: "PoTableSubtitleCircleComponent",
    filePath: "lib/components/po-table/po-table-subtitle-circle/po-table-subtitle-circle.component.ts",
    lineNumber: 19
  });
})();
function PoTableShowSubtitleComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵelement(1, "po-table-subtitle-circle", 7);
    ɵɵelementStart(2, "span", 8);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const subtitle_r3 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("p-subtitle", subtitle_r3);
    ɵɵadvance(2);
    ɵɵtextInterpolate(subtitle_r3.label);
  }
}
var PoTableShowSubtitleComponent = class _PoTableShowSubtitleComponent {
  /** Objeto com os dados da legenda. */
  subtitles;
  /** Propriedade que recebe as literais definidas no `po-table`. */
  literals;
  static ɵfac = function PoTableShowSubtitleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableShowSubtitleComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTableShowSubtitleComponent,
    selectors: [["po-table-show-subtitle"]],
    inputs: {
      subtitles: [0, "p-subtitles", "subtitles"],
      literals: [0, "p-literals", "literals"]
    },
    standalone: false,
    decls: 7,
    vars: 3,
    consts: [["modal", ""], [1, "po-table-footer-show-subtitle", 3, "click"], [1, "po-table-footer-show-subtitle-container"], [1, "po-table-show-subtitle"], ["p-size", "sm", 3, "p-title"], ["class", "po-table-subtitle-footer-modal po-row", 4, "ngFor", "ngForOf"], [1, "po-table-subtitle-footer-modal", "po-row"], ["p-hide-title", "true", 3, "p-subtitle"], [1, "po-table-subtitle-text"]],
    template: function PoTableShowSubtitleComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 1);
        ɵɵlistener("click", function PoTableShowSubtitleComponent_Template_div_click_0_listener() {
          ɵɵrestoreView(_r1);
          const modal_r2 = ɵɵreference(5);
          return ɵɵresetView(modal_r2.open());
        });
        ɵɵelementStart(1, "div", 2)(2, "span", 3);
        ɵɵtext(3);
        ɵɵelementEnd()()();
        ɵɵelementStart(4, "po-modal", 4, 0);
        ɵɵtemplate(6, PoTableShowSubtitleComponent_div_6_Template, 4, 2, "div", 5);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵtextInterpolate(ctx.literals.seeCompleteSubtitle);
        ɵɵadvance();
        ɵɵproperty("p-title", ctx.literals.completeSubtitle);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", ctx.subtitles);
      }
    },
    dependencies: [NgForOf, PoModalComponent, PoTableSubtitleCircleComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableShowSubtitleComponent, [{
    type: Component,
    args: [{
      selector: "po-table-show-subtitle",
      standalone: false,
      template: '<div class="po-table-footer-show-subtitle" (click)="modal.open()">\n  <div class="po-table-footer-show-subtitle-container">\n    <span class="po-table-show-subtitle">{{ literals.seeCompleteSubtitle }}</span>\n  </div>\n</div>\n\n<po-modal #modal p-size="sm" [p-title]="literals.completeSubtitle">\n  <div *ngFor="let subtitle of subtitles" class="po-table-subtitle-footer-modal po-row">\n    <po-table-subtitle-circle p-hide-title="true" [p-subtitle]="subtitle"> </po-table-subtitle-circle>\n    <span class="po-table-subtitle-text">{{ subtitle.label }}</span>\n  </div>\n</po-modal>\n'
    }]
  }], null, {
    subtitles: [{
      type: Input,
      args: ["p-subtitles"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableShowSubtitleComponent, {
    className: "PoTableShowSubtitleComponent",
    filePath: "lib/components/po-table/po-table-show-subtitle/po-table-show-subtitle.component.ts",
    lineNumber: 17
  });
})();
function PoTableSubtitleFooterComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵelement(1, "po-table-subtitle-circle", 4);
    ɵɵelementStart(2, "span", 5);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const subtitle_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("p-subtitle", subtitle_r1);
    ɵɵadvance(2);
    ɵɵtextInterpolate(subtitle_r1.label);
  }
}
function PoTableSubtitleFooterComponent_po_table_show_subtitle_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-table-show-subtitle", 6);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-literals", ctx_r1.literals)("p-subtitles", ctx_r1.subtitles);
  }
}
var PoTableSubtitleFooterComponent = class _PoTableSubtitleFooterComponent {
  element;
  renderer;
  /** Propriedade que recebe as literais definidas no `po-table`. */
  literals;
  /** Propriedade que recebe as legendas definidas no `PoTableSubtitleCircleComponent`. */
  subtitles;
  showSubtitle;
  resizeListener;
  isVisible;
  timeoutResize;
  constructor(element, renderer) {
    this.element = element;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    this.initializeResizeListener();
    this.debounceResize();
  }
  ngDoCheck() {
    if (!this.isVisible && this.getContainerSize() > 0) {
      this.toggleShowCompleteSubtitle();
      this.isVisible = true;
    }
  }
  ngOnDestroy() {
    this.removeResizeListener();
  }
  debounceResize() {
    clearTimeout(this.timeoutResize);
    this.timeoutResize = setTimeout(() => {
      this.toggleShowCompleteSubtitle();
    });
  }
  getContainerSize() {
    return this.element.nativeElement.querySelector(".po-table-subtitle-footer-container").offsetWidth;
  }
  getItemsSize() {
    const items = this.element.nativeElement.querySelectorAll(".po-table-subtitle-footer");
    return Array.from(items).map((item) => item["offsetWidth"]).reduce((a, b) => a + b, 16);
  }
  initializeResizeListener() {
    this.resizeListener = this.renderer.listen("window", "resize", (event) => {
      this.debounceResize();
    });
  }
  removeResizeListener() {
    this.resizeListener();
  }
  toggleShowCompleteSubtitle() {
    const containerSize = this.getContainerSize();
    const itemsSize = this.getItemsSize();
    this.showSubtitle = itemsSize > containerSize;
  }
  static ɵfac = function PoTableSubtitleFooterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableSubtitleFooterComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTableSubtitleFooterComponent,
    selectors: [["po-table-subtitle-footer"]],
    inputs: {
      literals: [0, "p-literals", "literals"],
      subtitles: [0, "p-subtitles", "subtitles"]
    },
    standalone: false,
    decls: 3,
    vars: 2,
    consts: [[1, "po-table-subtitle-footer-container"], ["class", "po-table-subtitle-footer", 4, "ngFor", "ngForOf"], [3, "p-literals", "p-subtitles", 4, "ngIf"], [1, "po-table-subtitle-footer"], ["p-hide-title", "true", 3, "p-subtitle"], [1, "po-table-subtitle-text"], [3, "p-literals", "p-subtitles"]],
    template: function PoTableSubtitleFooterComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoTableSubtitleFooterComponent_div_1_Template, 4, 2, "div", 1)(2, PoTableSubtitleFooterComponent_po_table_show_subtitle_2_Template, 1, 2, "po-table-show-subtitle", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.subtitles);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showSubtitle);
      }
    },
    dependencies: [NgForOf, NgIf, PoTableShowSubtitleComponent, PoTableSubtitleCircleComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableSubtitleFooterComponent, [{
    type: Component,
    args: [{
      selector: "po-table-subtitle-footer",
      standalone: false,
      template: '<div class="po-table-subtitle-footer-container">\n  <div *ngFor="let subtitle of subtitles" class="po-table-subtitle-footer">\n    <po-table-subtitle-circle p-hide-title="true" [p-subtitle]="subtitle"> </po-table-subtitle-circle>\n    <span class="po-table-subtitle-text">{{ subtitle.label }}</span>\n  </div>\n  <po-table-show-subtitle *ngIf="showSubtitle" [p-literals]="literals" [p-subtitles]="subtitles">\n  </po-table-show-subtitle>\n</div>\n'
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    subtitles: [{
      type: Input,
      args: ["p-subtitles"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableSubtitleFooterComponent, {
    className: "PoTableSubtitleFooterComponent",
    filePath: "lib/components/po-table/po-table-subtitle-footer/po-table-subtitle-footer.component.ts",
    lineNumber: 17
  });
})();
var PoSwitchModule = class _PoSwitchModule {
  static ɵfac = function PoSwitchModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSwitchModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoSwitchModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, PoFieldContainerModule, PoLabelModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSwitchModule, [{
    type: NgModule,
    args: [{
      declarations: [PoSwitchComponent],
      exports: [PoSwitchComponent],
      imports: [CommonModule, FormsModule, PoFieldContainerModule, PoLabelModule, PoIconModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoSwitchModule, {
    declarations: [PoSwitchComponent],
    imports: [CommonModule, FormsModule, PoFieldContainerModule, PoLabelModule, PoIconModule],
    exports: [PoSwitchComponent]
  });
})();
var PoTableColumnFrozenDirective = class _PoTableColumnFrozenDirective {
  el;
  renderer;
  _frozen = true;
  get frozen() {
    return this._frozen;
  }
  set frozen(val) {
    this._frozen = val;
    if (!val) {
      this.renderer.removeClass(this.el.nativeElement, "po-table-column-fixed");
    } else {
      this.updateStickyPosition();
    }
  }
  alignFrozen = "left";
  constructor(el, renderer) {
    this.el = el;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    setTimeout(() => {
      this.updateStickyPosition();
    }, 300);
  }
  ngOnChanges(changes) {
    if (changes.frozen.previousValue && !changes.frozen.currentValue) {
      setTimeout(() => {
        this.resizeColumns();
      }, 100);
    }
  }
  /* istanbul ignore next */
  updateStickyPosition() {
    if (this._frozen) {
      if (this.alignFrozen === "right") {
        let right = 0;
        const next = this.el.nativeElement.nextElementSibling;
        if (next) {
          right = this.getOuterWidth(next) + (parseFloat(next.style.right) || 0);
        }
        this.el.nativeElement.style.right = right + "px";
      } else {
        let left = 0;
        const prev = this.el.nativeElement.previousElementSibling;
        if (prev && !prev.classList.contains("po-table-column-selectable") && !prev.classList.contains("po-table-column-actions") && !prev.classList.contains("po-table-column-detail-toggle") && !prev.classList.contains("po-table-header-master-detail")) {
          left = this.getOuterWidth(prev) + (parseFloat(prev.style.left) || 0);
        }
        this.el.nativeElement.style.left = left - 1 + "px";
        this.renderer.addClass(this.el.nativeElement, "po-table-column-fixed");
      }
      const filterRow = this.el.nativeElement.parentElement.nextElementSibling;
      if (filterRow) {
        const index = this.index(this.el.nativeElement);
        if (filterRow.children && filterRow.children[index]) {
          filterRow.children[index].style.left = this.el.nativeElement.style.left;
          filterRow.children[index].style.right = this.el.nativeElement.style.right;
        }
      }
    }
  }
  /* istanbul ignore next */
  resizeColumns() {
    const currentElement = this.el.nativeElement;
    const prevElements = [];
    let prevElement = currentElement.previousElementSibling;
    while (prevElement && prevElement.classList.contains("po-table-column-fixed")) {
      prevElements.push(prevElement);
      prevElement = prevElement.previousElementSibling;
    }
    if (prevElements.length >= 2) {
      let leftAccumulator = 0;
      for (let i = prevElements.length - 1; i >= 0; i--) {
        const prevWidth = this.getOuterWidth(prevElements[i], true);
        prevElements[i].style.left = leftAccumulator - 1 + "px";
        leftAccumulator += prevWidth;
      }
    }
  }
  getOuterWidth(el, margin) {
    let width = el.offsetWidth;
    if (margin) {
      const style2 = getComputedStyle(el);
      width += parseFloat(style2.marginLeft) + parseFloat(style2.marginRight);
    }
    return width - 1;
  }
  index(element) {
    const children = element.parentNode.childNodes;
    let num = 0;
    for (let i = 0; i < children.length; i++) {
      if (children[i] === element) {
        return num;
      }
      if (children[i].nodeType === 1) {
        num++;
      }
    }
    return -1;
  }
  static ɵfac = function PoTableColumnFrozenDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableColumnFrozenDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTableColumnFrozenDirective,
    selectors: [["", "pFrozenColumn", ""]],
    hostAttrs: [1, "p-element"],
    hostVars: 2,
    hostBindings: function PoTableColumnFrozenDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("po-frozen-column", ctx.frozen);
      }
    },
    inputs: {
      frozen: [0, "pFrozenColumn", "frozen"],
      alignFrozen: "alignFrozen"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnFrozenDirective, [{
    type: Directive,
    args: [{
      selector: "[pFrozenColumn]",
      host: {
        class: "p-element",
        "[class.po-frozen-column]": "frozen"
      },
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    frozen: [{
      type: Input,
      args: ["pFrozenColumn"]
    }],
    alignFrozen: [{
      type: Input
    }]
  });
})();
var PoComboFilterMode;
(function(PoComboFilterMode2) {
  PoComboFilterMode2[PoComboFilterMode2["startsWith"] = 0] = "startsWith";
  PoComboFilterMode2[PoComboFilterMode2["contains"] = 1] = "contains";
  PoComboFilterMode2[PoComboFilterMode2["endsWith"] = 2] = "endsWith";
})(PoComboFilterMode || (PoComboFilterMode = {}));
var PoComboOptionTemplateDirective = class _PoComboOptionTemplateDirective {
  templateRef;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoComboOptionTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoComboOptionTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoComboOptionTemplateDirective,
    selectors: [["", "p-combo-option-template", ""]],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComboOptionTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-combo-option-template]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var poComboLiteralsDefault = {
  en: {
    noData: "No data found",
    chooseOption: "Choose an option",
    clear: "Clear"
  },
  es: {
    noData: "Datos no encontrados",
    chooseOption: "Elija una opción",
    clear: "limpia"
  },
  pt: {
    noData: "Nenhum dado encontrado",
    chooseOption: "Escolha uma opção",
    clear: "Apagar"
  },
  ru: {
    noData: "Данные не найдены",
    chooseOption: "Выберите опцию",
    clear: "чистый"
  }
};
var PO_COMBO_DEBOUNCE_TIME_DEFAULT = 400;
var PO_COMBO_FIELD_LABEL_DEFAULT = "label";
var PO_COMBO_FIELD_VALUE_DEFAULT = "value";
var PoComboBaseComponent = class _PoComboBaseComponent {
  changeDetector;
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Label no componente. */
  label;
  /** Texto de apoio para o campo. */
  help;
  /** Nome do componente. */
  name;
  /**
   * @optional
   *
   * @description
   * Nesta propriedade deve ser informada a URL do serviço em que será realizado o filtro para carregamento da lista de
   * itens no componente.
   * Caso haja a necessidade de customização, então pode ser informado um serviço implementando a interface PoComboFilter.
   *
   * Caso utilizado uma URL, o serviço deve ser retornado no padrão API TOTVS e utiliza as propriedades
   * `p-field-label` e `p-field-value` para a construção da lista de itens.
   *
   * Quando utilizada uma URL de serviço, então será concatenada nesta URL o valor que deseja-se filtrar da seguinte forma:
   * ```
   * url + ?filter=Peter
   * ```
   *
   * Se for definida a propriedade `p-filter-params`, a mesma também será concatenada. Por exemplo, para o
   * parâmetro `{ age: 23 }` a URL ficaria:
   *
   * ```
   * url + ?page=1&pageSize=20&age=23&filter=Peter
   * ```
   */
  filterService;
  /**
   * @optional
   *
   * @description
   *
   * Se verdadeiro ativa a funcionalidade de scroll infinito para o combo, Ao chegar ao fim da tabela executará nova busca dos dados conforme paginação.
   *
   * @default `false`
   */
  set infiniteScroll(value) {
    this._infiniteScroll = convertToBoolean(value);
  }
  get infiniteScroll() {
    return this._infiniteScroll;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o percentual necessário para disparar o evento `show-more`, que é responsável por carregar mais dados no combo. Caso o valor seja maior que 100 ou menor que 0, o valor padrão será 100%.
   *
   * **Exemplos**
   * - p-infinite-scroll-distance = 80: Quando atingir 80% do scroll do combo, o `show-more` será disparado.
   */
  set infiniteScrollDistance(value) {
    this._infiniteScrollDistance = value > 100 || value < 0 ? 100 : value;
  }
  get infiniteScrollDistance() {
    return this._infiniteScrollDistance;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o ícone que será exibido no início do campo.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](https://po-ui.io/icons). conforme exemplo abaixo:
   * ```
   * <po-combo p-icon="an an-user" p-label="PO combo"></po-combo>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-combo p-icon="fa fa-podcast" p-label="PO combo"></po-combo>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-combo [p-icon]="template" p-label="combo template ionic"></po-combo>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   */
  icon;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /** Se verdadeiro, o campo receberá um botão para ser limpo. */
  clean;
  /**
   * @optional
   *
   * @description
   *
   * Se verdadeiro, o evento `p-change` receberá como argumento o `PoComboOption` referente à opção selecionada.
   *
   * @default `false`
   */
  emitObjectValue = false;
  /**
   * @optional
   *
   * @description
   *
   * Se verdadeiro, desabilitará a busca de um item via TAB.
   *
   * @default `false`
   */
  disabledTabFilter = false;
  /**
   * @optional
   *
   * @description
   *
   * Define que o filtro no primeiro clique será removido.
   *
   * > Caso o combo tenha um valor padrão de inicialização, o primeiro clique
   * no componente retornará todos os itens da lista e não apenas o item inicialiazado.
   *
   * @default `false`
   */
  removeInitialFilter = false;
  /**
   * @optional
   *
   * @description
   *
   * Exibe a mensagem setada se o campo estiver vazio e for requerido.
   *
   * > Necessário que a propriedade `p-required` esteja habilitada.
   *
   */
  fieldErrorMessage;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   *
   * > Caso essa propriedade seja definida como `true`, a mensagem de erro será limitada a duas linhas
   * e um tooltip será exibido ao passar o mouse sobre a mensagem para mostrar o conteúdo completo.
   *
   * @default `false`
   */
  errorLimit = false;
  /**
   * @optional
   *
   * @description
   *
   * Deve ser informada uma função que será disparada quando houver alterações no ngModel. A função receberá como argumento o model modificado.
   *
   * > Pode-se optar pelo recebimento do objeto selecionado ao invés do model através da propriedade `p-emit-object-value`.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da tag form.
   *
   * Na versão 12.2.0 do Angular a verificação `strictTemplates` vem true como default. Portanto, para utilizar
   * two-way binding no componente deve se utilizar da seguinte forma:
   *
   * ```
   * <po-combo ... [ngModel]="comboModel" (ngModelChange)="comboModel = $event"> </po-combo>
   * ```
   *
   */
  ngModelChange = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Deve ser informada uma função que será disparada quando houver alterações no Search input. A função receberá como argumento o input modificado.
   *
   */
  inputChange = new EventEmitter();
  /**
   * @docsPrivate
   *
   * Determinar se o valor do compo deve retorna objeto do tipo {value: any, label: any}
   */
  controlValueWithLabel = false;
  cacheOptions = [];
  defaultService;
  firstInWriteValue = true;
  isFirstFilter = true;
  isFiltering = false;
  keyupSubscribe;
  onModelChange;
  previousSearchValue = "";
  selectedOption;
  selectedValue;
  selectedView;
  service;
  visibleOptions = [];
  page = 1;
  pageSize = 10;
  loading = false;
  displayAdditionalHelp = false;
  dynamicLabel = "label";
  dynamicValue = "value";
  shouldApplyFocus = false;
  hasValidatorRequired = false;
  cacheStaticOptions = [];
  comboOptionsList = [];
  onModelTouched = null;
  _changeOnEnter = false;
  _debounceTime = 400;
  _disabled = false;
  _disabledInitFilter = false;
  _fieldLabel = "label";
  _fieldValue = "value";
  _filterMinlength = 0;
  _filterMode = PoComboFilterMode.startsWith;
  _filterParams;
  _literals;
  _options = [];
  _placeholder = "";
  _required = false;
  _sort = false;
  language;
  _infiniteScrollDistance = 100;
  _infiniteScroll = false;
  // utilizado para fazer o controle de atualizar o model.
  // não deve forçar a atualização se o gatilho for o writeValue para não deixar o campo dirty.
  fromWriteValue = false;
  validatorChange;
  /** Mensagem apresentada enquanto o campo estiver vazio. */
  set placeholder(value) {
    this._placeholder = value || this.literals.chooseOption;
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * @optional
   *
   * @description
   * Esta propriedade define em quanto tempo (em milissegundos), aguarda para acionar o evento de filtro após cada pressionamento de tecla.
   * Será utilizada apenas quando houver serviço (`p-filter-service`).
   *
   * @default `400`
   */
  set debounceTime(value) {
    const parsedValue = parseInt(value, 10);
    this._debounceTime = !isNaN(parsedValue) && parsedValue > 0 ? parsedValue : PO_COMBO_DEBOUNCE_TIME_DEFAULT;
  }
  get debounceTime() {
    return this._debounceTime;
  }
  /**
   * @optional
   *
   * @description
   * Desabilita o filtro inicial no serviço, que é executado no primeiro clique no campo.
   *
   * @default `false`
   *
   */
  set disabledInitFilter(value) {
    this._disabledInitFilter = convertToBoolean(value);
  }
  get disabledInitFilter() {
    return this._disabledInitFilter;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo valor de cada item da lista.
   *
   * Necessário quando informar o serviço como URL e o mesmo não estiver retornando uma lista de objetos no padrão da interface
   * PoComboOption.
   *
   * @default `value`
   */
  set fieldValue(value) {
    if (!this.service && !this.filterService) {
      this.dynamicValue = value;
    }
    this._fieldValue = value || PO_COMBO_FIELD_VALUE_DEFAULT;
    if (isTypeof(this.filterService, "string") && this.service) {
      this.service.fieldValue = this._fieldValue;
    }
  }
  get fieldValue() {
    return this._fieldValue;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo texto de apresentação de cada item da lista.
   *
   * Necessário quando informar o serviço como URL e o mesmo não estiver retornando uma lista de objetos no padrão da interface
   * PoComboOption.
   *
   * @default `label`
   */
  set fieldLabel(value) {
    if (!this.service && !this.filterService) {
      this.dynamicLabel = value;
    }
    this._fieldLabel = value || PO_COMBO_FIELD_LABEL_DEFAULT;
    if (isTypeof(this.filterService, "string") && this.service) {
      this.service.fieldLabel = this._fieldLabel;
    }
  }
  get fieldLabel() {
    return this._fieldLabel;
  }
  /**
   * @optional
   *
   * @description
   * Valor mínimo de caracteres para realizar o filtro no serviço.
   *
   * @default `0`
   */
  set filterMinlength(value) {
    const parseValue = typeof value === "string" ? parseInt(value, 10) : value;
    this._filterMinlength = Number.isInteger(parseValue) ? parseValue : 0;
  }
  get filterMinlength() {
    return this._filterMinlength;
  }
  /**
   * @optional
   *
   * @description
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel(this.selectedValue);
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * @optional
   *
   * @description
   * Indica que o evento `p-change` só será disparado ao clicar ou pressionar a tecla "Enter" sobre uma opção selecionada.
   *
   * @default `false`
   */
  set changeOnEnter(changeOnEnter) {
    this._changeOnEnter = convertToBoolean(changeOnEnter);
  }
  get changeOnEnter() {
    return this._changeOnEnter;
  }
  /**
   * @optional
   *
   * @description
   * Indica que o campo será desabilitado.
   *
   * @default `false`
   */
  set disabled(disabled) {
    this._disabled = convertToBoolean(disabled);
    this.validateModel(this.selectedValue);
  }
  get disabled() {
    return this._disabled;
  }
  /** Indica que a lista definida na propriedade p-options será ordenada pela descrição. */
  set sort(sort) {
    this._sort = convertToBoolean(sort);
    this.comboListDefinitions();
  }
  get sort() {
    return this._sort;
  }
  /**
   * Nesta propriedade define a lista de opções do `po-combo`.
   *
   * > A lista pode ser definida utilizando um array com o valor representando o `value` e o `label` das seguintes formas:
   *
   * ```
   * <po-combo name="combo" p-label="PO Combo" [p-options]="[{value: 1, label: 'One'}, {value: 2, label: 'two'}]"> </po-combo>
   * ```
   *
   * ```
   * <po-combo name="combo" p-label="PO Combo" [p-options]="[{name: 'Roger', age: 28}, {name: 'Anne', age: 35}]" p-field-label="name" p-field-value="age"> </po-combo>
   * ```
   *
   * - Aconselha-se utilizar valores distintos no `label` e `value` dos itens.
   */
  set options(options) {
    this._options = Array.isArray(options) ? options : [];
    this.comboListDefinitions();
  }
  get options() {
    return this._options;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o modo de pesquisa utilizado no filtro da lista de seleção: `startsWith`, `contains` ou `endsWith`.
   *
   * > Quando utilizar a propriedade `p-filter-service` esta propriedade será ignorada.
   *
   * @default `startsWith`
   */
  set filterMode(filterMode) {
    this._filterMode = filterMode in PoComboFilterMode ? filterMode : PoComboFilterMode.startsWith;
    switch (this._filterMode.toString()) {
      case "startsWith":
        this._filterMode = PoComboFilterMode.startsWith;
        break;
      case "contains":
        this._filterMode = PoComboFilterMode.contains;
        break;
      case "endsWith":
        this._filterMode = PoComboFilterMode.endsWith;
        break;
    }
  }
  get filterMode() {
    return this._filterMode;
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor que será repassado como parâmetro para a URL ou aos métodos do serviço que implementam a interface *PoComboFilter*.
   *
   * > Caso a lista contenha agrupamentos, os mesmos só serão exibidos se houver no mínimo uma opção que corresponda à pesquisa.
   */
  set filterParams(filterParams) {
    this._filterParams = filterParams || filterParams === 0 || filterParams === false ? filterParams : void 0;
  }
  get filterParams() {
    return this._filterParams;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-combo`.
   *
   * Para utilizar basta passar a literal que deseja customizar:
   *
   * ```
   *  const customLiterals: PoComboLiterals = {
   *    noData: 'Nenhum valor'
   *  };
   * ```
   *
   * E para carregar a literal customizada, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-combo
   *   [p-literals]="customLiterals">
   * </po-combo>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poComboLiteralsDefault[poLocaleDefault]), poComboLiteralsDefault[this.language]), value);
    } else {
      this._literals = poComboLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poComboLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Define se o componente irá guardar o valor do model para evitar requisições repetidas.
   *
   * > Caso o valor seja `false`, o componente fará uma nova requisição mesmo que o valor procurado seja o mesmo do model.
   *
   * @default `true`
   */
  cache = true;
  /**
   * @optional
   *
   * @description
   *
   * Define que o `listbox` e/ou tooltip (`p-additional-help-tooltip` e/ou `p-error-limit`) serão incluídos no body da
   * página e não dentro do componente. Essa opção pode ser necessária em cenários com containers que possuem scroll ou
   * overflow escondido,garantindo o posicionamento correto de ambos próximo ao elemento.
   *
   * > O uso dessa propriedade pode acarretar na perda sequencial da tabulação da página. Quando utilizado com
   * `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  constructor(languageService, changeDetector) {
    this.changeDetector = changeDetector;
    this.language = languageService.getShortLanguage();
  }
  get isOptionGroupList() {
    return this._options.length && this._options[0].hasOwnProperty("options");
  }
  ngOnInit() {
    this.dynamicValue = this.checkIfService("value");
    this.dynamicLabel = this.checkIfService("label");
    this.updateComboList();
  }
  onInitService() {
    if (this.filterService) {
      this.setService(this.filterService);
      this.initInputObservable();
    }
  }
  setService(service) {
    if (service) {
      if (isTypeof(service, "object")) {
        this.service = service;
      } else {
        this.service = this.defaultService;
        this.service.configProperties(service, this.fieldLabel, this.fieldValue);
      }
    }
  }
  compareMethod(search, option, filterMode) {
    switch (filterMode) {
      case PoComboFilterMode.startsWith:
        return this.startsWith(search, option);
      case PoComboFilterMode.contains:
        return this.contains(search, option);
      case PoComboFilterMode.endsWith:
        return this.endsWith(search, option);
    }
  }
  startsWith(search, option) {
    return option[this.dynamicLabel].toLowerCase().startsWith(search.toLowerCase());
  }
  contains(search, option) {
    return option[this.dynamicLabel].toLowerCase().indexOf(search.toLowerCase()) > -1;
  }
  endsWith(search, option) {
    return option[this.dynamicLabel].toLowerCase().endsWith(search.toLowerCase());
  }
  getOptionFromValue(value, options) {
    return options ? options.find((option) => this.isEqual(option[this.dynamicValue], value)) : null;
  }
  getOptionFromLabel(label, options) {
    if (options) {
      return options.find((option) => option[this.dynamicLabel].toString().toLowerCase() === label.toString().toLowerCase());
    } else {
      return null;
    }
  }
  updateSelectedValue(option, isUpdateModel = true) {
    const optionLabel = option && option[this.dynamicLabel] || "";
    this.updateInternalVariables(option);
    if (this.changeOnEnter && isUpdateModel) {
      this.setInputValue(optionLabel);
    } else if (!this.changeOnEnter) {
      this.setInputValue(optionLabel);
    }
    if (isUpdateModel) {
      const optionValue = option?.[this.dynamicValue] !== void 0 ? option[this.dynamicValue] : void 0;
      this.updateModel(optionValue);
    }
  }
  callModelChange(value) {
    return this.onModelChange ? this.onModelChange(value) : this.ngModelChange.emit(value);
  }
  isEqual(value, inputValue) {
    if ((value || value === 0) && inputValue) {
      return value.toString() === inputValue.toString();
    }
    if (value === null && inputValue !== null || value === void 0 && inputValue !== void 0) {
      value = `${value}`;
    }
    return value === inputValue;
  }
  searchForLabel(search, options, filterMode) {
    if (search && options && options.length) {
      const newOptions = [];
      let addedOptionsGroupTitle = false;
      let optionsGroupTitle;
      options.forEach((option) => {
        if ("options" in option) {
          addedOptionsGroupTitle = false;
          return optionsGroupTitle = option;
        }
        if (option[this.dynamicLabel] && (this.compareMethod(search, option, filterMode) || this.service)) {
          if (this.isOptionGroupList && !addedOptionsGroupTitle) {
            newOptions.push(optionsGroupTitle);
            addedOptionsGroupTitle = true;
          }
          newOptions.push(option);
        }
      });
      this.selectedView = newOptions[this.isOptionGroupList ? 1 : 0];
      this.updateComboList(newOptions);
    } else {
      this.updateComboList();
    }
  }
  updateComboList(options) {
    const copyOptions = options || [...this.comboOptionsList];
    let newOptions;
    if (this.removeInitialFilter) {
      newOptions = copyOptions;
    } else {
      newOptions = !options && !this.infiniteScroll && this.selectedValue ? [__spreadValues({}, this.selectedOption)] : copyOptions;
    }
    this.visibleOptions = newOptions;
    if (!this.selectedView && this.visibleOptions.length) {
      this.selectedView = copyOptions.find((option) => option[this.dynamicValue] !== void 0);
    }
  }
  getNextOption(value, options, reverse = false) {
    const optionsList = reverse ? options.slice(0).reverse() : options.slice(0);
    let optionFound = null;
    let found = false;
    for (const option of optionsList) {
      if (option[this.dynamicValue] && !optionFound) {
        optionFound = option;
      }
      if (option[this.dynamicValue] && found) {
        return option;
      }
      if (this.isEqual(option[this.dynamicValue], value)) {
        found = true;
      }
    }
    return optionFound;
  }
  getIndexSelectedView() {
    for (let i = 0; i < this.visibleOptions.length; i++) {
      if (this.compareObjects(this.visibleOptions[i], this.selectedView)) {
        return i;
      }
    }
    return null;
  }
  compareObjects(obj1, obj2) {
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  }
  verifyValidOption() {
    const inputValue = this.getInputValue();
    const optionFound = this.getOptionFromLabel(inputValue, this.comboOptionsList);
    if (!this.service) {
      this.updateComboList([...this.cacheStaticOptions]);
    }
    if (optionFound && optionFound[this.dynamicValue] !== this.selectedValue) {
      this.updateSelectedValue(optionFound);
      this.previousSearchValue = optionFound[this.dynamicLabel];
    } else if (this.selectedValue && this.selectedOption && this.selectedOption[this.dynamicLabel] !== inputValue) {
      this.updateSelectedValueWithOldOption();
      this.previousSearchValue = this.selectedOption[this.dynamicLabel];
      return;
    } else if (inputValue && !optionFound) {
      const isInputValueDiffSelectedLabel = !!(this.selectedOption && this.selectedOption[this.dynamicLabel] !== inputValue);
      this.updateSelectedValue(null, isInputValueDiffSelectedLabel || this.changeOnEnter);
      this.previousSearchValue = "";
      return;
    }
  }
  // Recebe as alterações do model
  writeValue(value) {
    value = this.getValueWrite(value);
    this.fromWriteValue = true;
    if (validValue(value) && !this.service && this.comboOptionsList && this.comboOptionsList.length) {
      const option = this.getOptionFromValue(value, this.comboOptionsList);
      this.updateSelectedValue(option);
      this.comboOptionsList = this.comboOptionsList.map((option2) => {
        if (this.isEqual(option2[this.dynamicValue], value)) {
          return __spreadProps(__spreadValues({}, option2), {
            selected: true
          });
        }
        return option2;
      });
      this.updateComboList();
      this.removeInitialFilter = false;
      return;
    }
    if (value && this.service) {
      return this.getObjectByValue(value);
    } else {
      this.updateSelectedValue(null);
      this.updateComboList();
      this.updateHasNext();
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.onModelChange = fn;
  }
  registerOnTouched(fn) {
    this.onModelTouched = fn;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(abstractControl) {
    if (!this.hasValidatorRequired && this.fieldErrorMessage && abstractControl.hasValidator(Validators.required)) {
      this.hasValidatorRequired = true;
    }
    if (requiredFailed(this.required || this.hasValidatorRequired, this.disabled, abstractControl.value)) {
      this.changeDetector.markForCheck();
      return {
        required: {
          valid: false
        }
      };
    }
  }
  clear(value) {
    this.callModelChange(value);
    this.updateSelectedValue(null);
    this.updateComboList();
    this.initInputObservable();
    this.updateHasNext();
    if (this.service || this.filterService) {
      this.keyupSubscribe.unsubscribe();
    }
  }
  configAfterSetFilterService(service) {
    if (service) {
      this.comboOptionsList = [];
      this.unsubscribeKeyupObservable();
      this.onInitService();
    } else {
      this.service = void 0;
      this.comboOptionsList = this.cacheStaticOptions;
    }
    this.visibleOptions = [];
    this.isFirstFilter = true;
  }
  unsubscribeKeyupObservable() {
    if (this.keyupSubscribe) {
      this.keyupSubscribe.unsubscribe();
    }
  }
  validateModel(model) {
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  comboListDefinitions() {
    this.comboOptionsList = this.options.length > 0 ? this.listingComboOptions(this.options) : this.options;
    this.cacheStaticOptions = this.comboOptionsList;
    this.updateComboList();
  }
  checkIfService(dynamicValue) {
    if ((this.service || this.filterService) && dynamicValue === "label") {
      return PO_COMBO_FIELD_LABEL_DEFAULT;
    }
    if ((this.service || this.filterService) && dynamicValue === "value") {
      return PO_COMBO_FIELD_VALUE_DEFAULT;
    }
    if (!this.service && dynamicValue === "label") {
      return this.fieldLabel;
    }
    if (!this.service && dynamicValue === "value") {
      return this.fieldValue;
    }
  }
  compareOptions(dynamicLabel) {
    return function(optionA, optionB) {
      const labelA = optionA[dynamicLabel].toString().toLowerCase();
      const labelB = optionB[dynamicLabel].toString().toLowerCase();
      return labelA < labelB ? -1 : labelA > labelB ? 1 : 0;
    };
  }
  getValueUpdate(data, selectedOption) {
    const {
      [this.dynamicValue]: value,
      [this.dynamicLabel]: label
    } = selectedOption || {};
    if (this.controlValueWithLabel && value) {
      return {
        value,
        label
      };
    }
    return data;
  }
  getValueWrite(data) {
    if (this.controlValueWithLabel && data?.value) {
      return data?.value;
    }
    return data;
  }
  hasDuplicatedOption(options, currentOption, accumulatedGroupOptions) {
    if (accumulatedGroupOptions) {
      return accumulatedGroupOptions.some((option) => option[this.dynamicLabel] === currentOption);
    } else {
      return options.some((option) => option[this.dynamicValue] === currentOption);
    }
  }
  listingComboOptions(comboOptions) {
    const comboOptionsList = comboOptions.concat();
    const verifiedComboOptionsList = this.verifyComboOptions(comboOptionsList);
    this.sortOptions(verifiedComboOptionsList);
    if (this.isOptionGroupList && verifiedComboOptionsList.length > 0) {
      return this.verifyComboOptionsGroup(verifiedComboOptionsList);
    }
    return verifiedComboOptionsList;
  }
  sortOptions(comboOptionsList) {
    if (comboOptionsList.length > 0 && this.sort) {
      return comboOptionsList.sort(this.compareOptions(this.dynamicLabel));
    }
  }
  validateValue(currentOption, verifyingOptionsGroup = false) {
    const {
      options
    } = currentOption;
    if (this.isOptionGroupList) {
      return validValue(currentOption[this.dynamicLabel]) && options && options.length > 0 || verifyingOptionsGroup === true && validValue(currentOption[this.dynamicValue]);
    }
    return validValue(currentOption[this.dynamicValue]) && !options;
  }
  verifyComboOptions(comboOptions, verifyingOptionsGroup = false, accumulatedGroupOptions) {
    return comboOptions.reduce((accumulatedOptions, currentOption) => {
      if (!this.verifyIfHasLabel(currentOption) || this.hasDuplicatedOption(accumulatedOptions, currentOption[this.dynamicValue] || currentOption[this.dynamicLabel], accumulatedGroupOptions) || !this.validateValue(currentOption, verifyingOptionsGroup)) {
        return accumulatedOptions;
      }
      accumulatedOptions.push(currentOption);
      return accumulatedOptions;
    }, []);
  }
  verifyComboOptionsGroup(comboOptionsList) {
    return comboOptionsList.reduce((accumulatedGroupOptions, currentOption) => {
      const {
        options
      } = currentOption;
      const verifiedComboOptionsGroupList = this.verifyComboOptions(options, true, accumulatedGroupOptions);
      if (verifiedComboOptionsGroupList.length > 0) {
        this.sortOptions(verifiedComboOptionsGroupList);
        accumulatedGroupOptions.push({
          label: currentOption[this.dynamicLabel],
          options: true
        }, ...verifiedComboOptionsGroupList);
      }
      return accumulatedGroupOptions;
    }, []);
  }
  verifyIfHasLabel(currentOption = {}) {
    const {
      options
    } = currentOption;
    if (this.isOptionGroupList && options && !currentOption[this.dynamicLabel] || !currentOption[this.dynamicLabel] && !currentOption[this.dynamicValue] || !this.isOptionGroupList && options) {
      return false;
    }
    if (!currentOption[this.dynamicLabel]) {
      currentOption[this.dynamicLabel] = currentOption[this.dynamicValue].toString();
      return true;
    }
    return true;
  }
  updateInternalVariables(option) {
    if (option) {
      this.selectedView = option;
      this.selectedOption = option;
    } else {
      this.selectedView = void 0;
      this.selectedOption = void 0;
    }
  }
  updateModel(value) {
    if (value !== this.selectedValue) {
      if (!this.fromWriteValue) {
        this.callModelChange(this.getValueUpdate(value, this.selectedOption));
      }
      this.change.emit(this.emitObjectValue ? this.selectedOption : value);
    }
    this.selectedValue = value;
    this.fromWriteValue = false;
  }
  updateSelectedValueWithOldOption() {
    const oldOption = this.getOptionFromValue(this.selectedValue, this.comboOptionsList);
    if (oldOption && oldOption[this.dynamicLabel]) {
      return this.updateSelectedValue(oldOption);
    }
  }
  updateHasNext() {
    if (this.service && this.infiniteScroll) {
      this.defaultService.hasNext = true;
    }
  }
  static ɵfac = function PoComboBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoComboBaseComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoComboBaseComponent,
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      label: [0, "p-label", "label"],
      help: [0, "p-help", "help"],
      name: "name",
      filterService: [0, "p-filter-service", "filterService"],
      infiniteScroll: [0, "p-infinite-scroll", "infiniteScroll"],
      infiniteScrollDistance: [0, "p-infinite-scroll-distance", "infiniteScrollDistance"],
      icon: [0, "p-icon", "icon"],
      optional: [0, "p-optional", "optional"],
      clean: [2, "p-clean", "clean", convertToBoolean],
      emitObjectValue: [2, "p-emit-object-value", "emitObjectValue", convertToBoolean],
      disabledTabFilter: [2, "p-disabled-tab-filter", "disabledTabFilter", convertToBoolean],
      removeInitialFilter: [0, "p-remove-initial-filter", "removeInitialFilter"],
      fieldErrorMessage: [0, "p-field-error-message", "fieldErrorMessage"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      controlValueWithLabel: [2, "p-control-value-with-label", "controlValueWithLabel", convertToBoolean],
      placeholder: [0, "p-placeholder", "placeholder"],
      debounceTime: [0, "p-debounce-time", "debounceTime"],
      disabledInitFilter: [0, "p-disabled-init-filter", "disabledInitFilter"],
      fieldValue: [0, "p-field-value", "fieldValue"],
      fieldLabel: [0, "p-field-label", "fieldLabel"],
      filterMinlength: [0, "p-filter-minlength", "filterMinlength"],
      required: [0, "p-required", "required"],
      showRequired: [0, "p-show-required", "showRequired"],
      changeOnEnter: [0, "p-change-on-enter", "changeOnEnter"],
      disabled: [0, "p-disabled", "disabled"],
      sort: [0, "p-sort", "sort"],
      options: [0, "p-options", "options"],
      filterMode: [0, "p-filter-mode", "filterMode"],
      filterParams: [0, "p-filter-params", "filterParams"],
      literals: [0, "p-literals", "literals"],
      cache: [2, "p-cache", "cache", convertToBoolean],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      change: "p-change",
      keydown: "p-keydown",
      ngModelChange: "ngModelChange",
      inputChange: "p-input-change"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComboBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }, {
    type: ChangeDetectorRef
  }], {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    filterService: [{
      type: Input,
      args: ["p-filter-service"]
    }],
    infiniteScroll: [{
      type: Input,
      args: ["p-infinite-scroll"]
    }],
    infiniteScrollDistance: [{
      type: Input,
      args: ["p-infinite-scroll-distance"]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    clean: [{
      type: Input,
      args: [{
        alias: "p-clean",
        transform: convertToBoolean
      }]
    }],
    emitObjectValue: [{
      type: Input,
      args: [{
        alias: "p-emit-object-value",
        transform: convertToBoolean
      }]
    }],
    disabledTabFilter: [{
      type: Input,
      args: [{
        alias: "p-disabled-tab-filter",
        transform: convertToBoolean
      }]
    }],
    removeInitialFilter: [{
      type: Input,
      args: ["p-remove-initial-filter"]
    }],
    fieldErrorMessage: [{
      type: Input,
      args: ["p-field-error-message"]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    ngModelChange: [{
      type: Output,
      args: ["ngModelChange"]
    }],
    inputChange: [{
      type: Output,
      args: ["p-input-change"]
    }],
    controlValueWithLabel: [{
      type: Input,
      args: [{
        alias: "p-control-value-with-label",
        transform: convertToBoolean
      }]
    }],
    placeholder: [{
      type: Input,
      args: ["p-placeholder"]
    }],
    debounceTime: [{
      type: Input,
      args: ["p-debounce-time"]
    }],
    disabledInitFilter: [{
      type: Input,
      args: ["p-disabled-init-filter"]
    }],
    fieldValue: [{
      type: Input,
      args: ["p-field-value"]
    }],
    fieldLabel: [{
      type: Input,
      args: ["p-field-label"]
    }],
    filterMinlength: [{
      type: Input,
      args: ["p-filter-minlength"]
    }],
    required: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }],
    changeOnEnter: [{
      type: Input,
      args: ["p-change-on-enter"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    sort: [{
      type: Input,
      args: ["p-sort"]
    }],
    options: [{
      type: Input,
      args: ["p-options"]
    }],
    filterMode: [{
      type: Input,
      args: ["p-filter-mode"]
    }],
    filterParams: [{
      type: Input,
      args: ["p-filter-params"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    cache: [{
      type: Input,
      args: [{
        alias: "p-cache",
        transform: convertToBoolean
      }]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }]
  });
})();
var PoComboFilterService = class _PoComboFilterService {
  http;
  fieldLabel = "label";
  fieldValue = "value";
  hasNext = true;
  headers = new HttpHeaders({
    "X-PO-No-Message": "true"
  });
  _url;
  messages = [];
  get url() {
    return this._url;
  }
  constructor(http) {
    this.http = http;
  }
  getFilteredData(param, filterParams) {
    const params = this.prepareParams(param, filterParams);
    return this.http.get(`${this.url}`, {
      responseType: "json",
      params,
      headers: this.headers
    }).pipe(tap((res) => this.hasNext = res["hasNext"]), map((response) => this.parseToArrayComboOption(response.items)));
  }
  getObjectByValue(value, filterParams) {
    const filterParamsValidated = validateObjectType(filterParams);
    return this.http.get(`${this.url}/${value}`, {
      params: filterParamsValidated,
      headers: this.headers
    }).pipe(map((item) => this.parseToComboOption(item)));
  }
  configProperties(url, fieldLabel, fieldValue) {
    this._url = url;
    this.fieldLabel = fieldLabel;
    this.fieldValue = fieldValue;
  }
  scrollListener(componentListner) {
    return fromEvent(componentListner, "scroll").pipe(debounceTime(100));
  }
  prepareParams(param, filterParams) {
    const {
      page,
      pageSize,
      value
    } = param;
    const filterParamsValidated = validateObjectType(filterParams);
    return page ? __spreadProps(__spreadValues({}, filterParamsValidated), {
      page,
      pageSize,
      filter: value
    }) : __spreadProps(__spreadValues({}, filterParamsValidated), {
      filter: value
    });
  }
  parseToArrayComboOption(items) {
    if (items && items.length > 0) {
      const parsedOptions = items.map((item) => this.parseToComboOption(item));
      this.displayMessages();
      return parsedOptions;
    }
    return [];
  }
  parseToComboOption(item) {
    if (!item?.[this.fieldValue]) {
      this.addMessage(item, this.fieldValue);
      return {
        value: ""
      };
    }
    const label = item[this.fieldLabel];
    const value = item[this.fieldValue];
    return {
      label,
      value
    };
  }
  addMessage(item, property) {
    this.messages.push(`Cannot read property "${property}" of ${JSON.stringify(item)},
      see [p-field-value] property at https://po-ui.io/documentation/po-combo`);
  }
  displayMessages() {
    if (this.messages.length) {
      this.messages.forEach((message) => console.error(message));
      this.messages = [];
    }
  }
  static ɵfac = function PoComboFilterService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoComboFilterService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoComboFilterService,
    factory: _PoComboFilterService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComboFilterService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }], null);
})();
var _c0$X = ["outerContainer"];
var _c1$n = ["containerElement"];
var _c2$b = ["contentElement"];
var _c3$7 = ["iconArrow"];
var _c4$2 = ["inp"];
var _c5 = ["poListbox"];
function PoComboComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵelement(1, "po-icon", 21);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-field-icon-disabled", ctx_r1.disabled);
    ɵɵproperty("p-icon", ctx_r1.icon);
  }
}
function PoComboComponent_po_clean_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 22);
    ɵɵlistener("p-change-event", function PoComboComponent_po_clean_11_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clear($event));
    })("click", function PoComboComponent_po_clean_11_Template_po_clean_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      ctx_r1.clear(null);
      return ɵɵresetView($event.preventDefault());
    })("keydown.enter", function PoComboComponent_po_clean_11_Template_po_clean_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      ctx_r1.clearAndFocus();
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-element-ref", ctx_r1.inputEl);
    ɵɵattribute("aria-label", ctx_r1.literals.clean);
  }
}
function PoComboComponent_ng_container_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoComboComponent_ng_template_16_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoComboComponent_ng_template_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoComboComponent_ng_template_16_ng_container_0_Template, 1, 0, "ng-container", 23);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const dropdownListbox_r4 = ɵɵreference(22);
    ɵɵproperty("ngTemplateOutlet", dropdownListbox_r4);
  }
}
function PoComboComponent_ng_template_18_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoComboComponent_ng_template_18_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoComboComponent_ng_template_18_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 23);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const dropdownListbox_r4 = ɵɵreference(22);
    ɵɵproperty("ngTemplateOutlet", dropdownListbox_r4);
  }
}
function PoComboComponent_ng_template_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoComboComponent_ng_template_18_ng_template_0_Template, 1, 1, "ng-template", 24);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const trigger_r5 = ɵɵreference(5);
    ɵɵproperty("cdkConnectedOverlayOrigin", trigger_r5)("cdkConnectedOverlayOpen", true);
  }
}
function PoComboComponent_ng_template_21_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 25, 7)(2, "po-listbox", 26, 8);
    ɵɵlistener("p-selectcombo-item", function PoComboComponent_ng_template_21_Template_po_listbox_p_selectcombo_item_2_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onOptionClick($event, $event.event));
    })("p-update-infinite-scroll", function PoComboComponent_ng_template_21_Template_po_listbox_p_update_infinite_scroll_2_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.showMoreInfiniteScroll());
    })("p-close", function PoComboComponent_ng_template_21_Template_po_listbox_p_close_2_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onCloseCombo());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("hidden", !ctx_r1.comboOpen && !ctx_r1.isServerSearching);
    ɵɵadvance(2);
    ɵɵproperty("p-items", ctx_r1.visibleOptions)("p-field-value", ctx_r1.dynamicValue)("p-field-label", ctx_r1.dynamicLabel)("p-template", ctx_r1.comboOptionTemplate)("p-search-value", ctx_r1.getInputValue())("p-infinite-loading", ctx_r1.infiniteLoading)("p-infinite-scroll", ctx_r1.infiniteScroll)("p-filtering", ctx_r1.isFiltering)("p-cache", ctx_r1.cache)("p-filter-mode", ctx_r1.filterMode)("p-visible", ctx_r1.comboOpen)("p-is-searching", ctx_r1.isServerSearching)("p-should-mark-letter", ctx_r1.shouldMarkLetters)("p-compare-cache", ctx_r1.compareObjects(ctx_r1.cacheOptions, ctx_r1.visibleOptions))("p-combo-service", ctx_r1.service)("p-infinite-scroll-distance", ctx_r1.infiniteScrollDistance)("p-container-width", ctx_r1.containerWidth);
  }
}
var poComboContainerOffset = 8;
var poComboContainerPositionDefault = "bottom";
var PoComboComponent = class _PoComboComponent extends PoComboBaseComponent {
  element;
  differs;
  defaultService;
  renderer;
  controlPosition;
  changeDetector;
  comboOptionTemplate;
  outerContainer;
  containerElement;
  contentElement;
  iconElement;
  inputEl;
  poListbox;
  comboIcon = "ICON_ARROW_DOWN";
  comboOpen = false;
  differ;
  id = `po-combo[${uuid()}]`;
  isProcessingValueByTab = false;
  scrollTop = 0;
  shouldMarkLetters = true;
  infiniteLoading = false;
  containerWidth;
  _isServerSearching = false;
  lastKey;
  clickoutListener;
  eventResizeListener;
  filterSubscription;
  getSubscription;
  subscriptionScrollEvent;
  constructor(element, differs, defaultService, renderer, controlPosition, changeDetector, languageService) {
    super(languageService, changeDetector);
    this.element = element;
    this.differs = differs;
    this.defaultService = defaultService;
    this.renderer = renderer;
    this.controlPosition = controlPosition;
    this.changeDetector = changeDetector;
    this.differ = differs.find([]).create(null);
  }
  set isServerSearching(value) {
    if (value) {
      this._isServerSearching = value;
      this.changeDetector.detectChanges();
      this.setContainerPosition();
      this.initializeListeners();
    } else {
      this._isServerSearching = value;
    }
  }
  get isServerSearching() {
    return this._isServerSearching;
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
    this.setContainerWidth();
  }
  ngOnChanges(changes) {
    if (changes.debounceTime) {
      this.unsubscribeKeyupObservable();
      this.initInputObservable();
    }
    if (changes.filterService) {
      this.configAfterSetFilterService(this.filterService);
    }
  }
  ngOnDestroy() {
    this.removeListeners();
    if (this.filterSubscription) {
      this.filterSubscription.unsubscribe();
    }
    if (this.getSubscription) {
      this.getSubscription.unsubscribe();
    }
    if (this.infiniteScroll) {
      this.subscriptionScrollEvent?.unsubscribe();
    }
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoComboComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoComboComponent, { static: true }) combo: PoComboComponent;
   *
   * focusCombo() {
   *   this.combo.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  onBlur() {
    this.onModelTouched?.();
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
  }
  onKeyDown(event) {
    const key = event?.keyCode;
    const inputValue = event?.target?.value;
    const isFieldFocused = document.activeElement === this.inputEl.nativeElement;
    if (event.shiftKey && key === PoKeyCodeEnum.tab) {
      this.controlComboVisibility(false);
      return;
    }
    if (this.service && key === PoKeyCodeEnum.tab && inputValue && !this.disabledTabFilter) {
      this.controlComboVisibility(false);
      return this.getObjectByValue(inputValue);
    }
    if (key === PoKeyCodeEnum.arrowDown) {
      event.preventDefault();
      if (this.visibleOptions.length) {
        this.focusItem();
      }
      this.controlComboVisibility(true);
      this.isFiltering = this.changeOnEnter ? this.isFiltering : false;
      return;
    }
    if (key === PoKeyCodeEnum.enter && this.selectedView && this.comboOpen) {
      const isUpdateModel = this.selectedView.value !== this.selectedValue || inputValue !== this.selectedView.label;
      this.controlComboVisibility(false);
      this.updateSelectedValue(this.selectedView, isUpdateModel);
      this.isFiltering = false;
      if (!this.service) {
        this.updateComboList([...this.cacheStaticOptions]);
      }
      return;
    }
    if (key === PoKeyCodeEnum.enter) {
      this.controlComboVisibility(true);
    }
    if (key === PoKeyCodeEnum.esc) {
      if (key === this.lastKey) {
        this.lastKey = "";
        if (this.selectedValue) {
          this.clearAndFocus();
        }
        return;
      } else {
        this.onCloseCombo();
      }
    }
    this.lastKey = event.keyCode;
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  onKeyUp(event) {
    const key = event.keyCode || event.which;
    const inputValue = event.target.value;
    const isValidKey = key !== PoKeyCodeEnum.arrowUp && key !== PoKeyCodeEnum.arrowDown && key !== PoKeyCodeEnum.enter && key !== PoKeyCodeEnum.esc && key !== PoKeyCodeEnum.tab;
    if (isValidKey) {
      if (inputValue) {
        if (!this.service && this.previousSearchValue !== inputValue) {
          this.shouldMarkLetters = true;
          this.isFiltering = true;
          this.searchForLabel(inputValue, this.comboOptionsList, this.filterMode);
          this.inputChange.emit(inputValue);
        }
      } else {
        const useDefaultOptionsService = this.service && this.selectedValue && this.selectedOption.label === this.previousSearchValue;
        this.updateSelectedValue(null);
        if (!this.service) {
          this.updateComboList();
        } else if (useDefaultOptionsService) {
          this.updateComboList([...this.cacheOptions]);
        }
        this.isFiltering = false;
      }
      if (this.previousSearchValue !== inputValue) {
        this.changeDetector.detectChanges();
        this.controlComboVisibility(true);
      }
    }
    this.previousSearchValue = inputValue;
  }
  initInputObservable() {
    if (this.service) {
      const keyupObservable = fromEvent(this.inputEl.nativeElement, "keyup").pipe(filter((e) => this.isValidCharacterToSearch(e.keyCode)), map((e) => e.currentTarget.value), distinctUntilChanged(), tap(() => {
        this.shouldMarkLetters = false;
      }), debounceTime(this.debounceTime));
      this.keyupSubscribe = keyupObservable.subscribe((value) => {
        if (value.length >= this.filterMinlength || !value) {
          this.controlApplyFilter(value);
        }
      });
    }
  }
  controlApplyFilter(value, isArrowDown) {
    if (!this.isProcessingValueByTab && (!this.selectedOption || value !== this.selectedOption[this.dynamicLabel]) || !this.cache) {
      this.defaultService.hasNext = true;
      this.page = this.setPage();
      this.options = [];
      this.applyFilter(value, true, isArrowDown);
    }
    this.isProcessingValueByTab = false;
  }
  applyFilter(value, reset = false, isArrowDown) {
    if (this.removeInitialFilter) {
      this.defaultService.hasNext = true;
    }
    if (this.defaultService.hasNext) {
      this.controlComboVisibility(false, reset);
      this.isServerSearching = true;
      const param = this.infiniteScroll ? {
        property: this.fieldLabel,
        value,
        page: this.page,
        pageSize: this.pageSize
      } : {
        property: this.fieldLabel,
        value
      };
      this.filterSubscription = this.service.getFilteredData(param, this.filterParams).subscribe((items) => {
        this.setOptionsByApplyFilter(value, items, reset);
        if (isArrowDown) {
          this.focusItem();
        }
      }, (error) => this.onErrorFilteredData());
    }
  }
  setOptionsByApplyFilter(value, items, reset = false) {
    this.shouldMarkLetters = true;
    this.isServerSearching = false;
    this.infiniteLoading = false;
    this.options = this.prepareOptions(items);
    this.searchForLabel(value, items, this.filterMode);
    this.changeDetector.detectChanges();
    this.controlComboVisibility(true, reset);
    if (this.isFirstFilter) {
      this.isFirstFilter = !this.isFirstFilter;
      this.updateCacheOptions();
    }
  }
  getErrorPattern() {
    return this.fieldErrorMessage && this.hasInvalidClass() ? this.fieldErrorMessage : "";
  }
  hasInvalidClass() {
    return this.element.nativeElement.classList.contains("ng-invalid") && this.element.nativeElement.classList.contains("ng-dirty");
  }
  getObjectByValue(value) {
    if (this.selectedValue !== value && this.selectedOption?.[this.dynamicLabel] !== value) {
      this.isProcessingValueByTab = true;
      this.getSubscription = this.service.getObjectByValue(value, this.filterParams).subscribe((item) => this.updateOptionByFilteredValue(item), (error) => this.onErrorGetObjectByValue());
    }
  }
  updateOptionByFilteredValue(item) {
    if (item) {
      this.options = [item];
      this.onOptionClick(item);
    } else {
      this.updateSelectedValue(null);
    }
    setTimeout(() => {
      this.isProcessingValueByTab = false;
    }, this.debounceTime);
  }
  setShouldApplyFocus(value) {
    this.shouldApplyFocus = value;
  }
  toggleComboVisibility(isButton) {
    if (this.disabled) {
      return;
    }
    this.setShouldApplyFocus(true);
    if (this.service && !this.disabledInitFilter) {
      this.applyFilterInFirstClick();
    }
    this.controlComboVisibility(!this.comboOpen, false, isButton);
  }
  applyFilterInFirstClick() {
    const isEmptyFirstFilter = this.isFirstFilter && !this.selectedValue;
    if (this.removeInitialFilter || isEmptyFirstFilter) {
      this.options = [];
      const scrollingControl = this.setScrollingControl();
      this.applyFilter("", scrollingControl);
    }
  }
  controlComboVisibility(toOpen, reset = false, isButton) {
    toOpen ? this.open(reset, isButton) : this.close(reset);
  }
  onCloseCombo() {
    this.controlComboVisibility(false);
    this.inputEl.nativeElement.focus();
  }
  onOptionClick(option, event) {
    const inputValue = this.getInputValue();
    const isUpdateModel = option[this.dynamicValue] !== this.selectedValue || !!(this.selectedView && inputValue !== this.selectedView[this.dynamicLabel]);
    if (event) {
      event.stopPropagation();
    }
    this.updateSelectedValue(option, isUpdateModel);
    this.controlComboVisibility(false);
    if (!this.service) {
      this.updateComboList([...this.cacheStaticOptions]);
    }
    this.previousSearchValue = this.selectedView[this.dynamicLabel];
    if (this.shouldApplyFocus) {
      this.inputEl.nativeElement.focus();
    }
  }
  calculateScrollTop(selectedItem, index) {
    if (!selectedItem.length || index <= 1) {
      return 0;
    } else {
      return selectedItem[0].offsetTop;
    }
  }
  cleanListbox() {
    this.updateSelectedValue(null);
    this.options.map((option) => option.selected = false);
  }
  getInputValue() {
    return this.inputEl.nativeElement.value;
  }
  setInputValue(value) {
    this.inputEl.nativeElement.value = value;
    if (value === null) {
      this.cleanListbox();
    }
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-combo
   *  #combo
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, combo)"
   * ></po-combo>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoComboComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  wasClickedOnToggle(event) {
    if (this.comboOpen && !this.inputEl.nativeElement.contains(event.target) && !this.iconElement.nativeElement.contains(event.target) && (!this.contentElement || !this.contentElement.nativeElement.contains(event.target))) {
      this.controlComboVisibility(false);
      this.verifyValidOption();
      this.selectedView = this.changeOnEnter && !this.selectedValue ? void 0 : this.selectedView;
    } else {
      if (this.service && !this.getInputValue() && !this.isFirstFilter) {
        const scrollingControl = this.setScrollingControl();
        this.applyFilter("", scrollingControl);
      }
    }
  }
  isValidCharacterToSearch(keyCode) {
    return keyCode !== 9 && // tab
    keyCode !== 13 && // entet
    keyCode !== 16 && // shift
    keyCode !== 17 && // ctrl
    keyCode !== 18 && // alt
    keyCode !== 20 && // capslock
    keyCode !== 27 && // esc
    keyCode !== 37 && // seta
    keyCode !== 38 && // seta
    keyCode !== 39 && // seta
    keyCode !== 40 && // seta
    keyCode !== 93;
  }
  searchOnEnterOrArrow(event, value) {
    if ((event.key === "ArrowDown" || event.key === "Enter") && this.service && !this.selectedView && value.length >= this.filterMinlength) {
      this.controlApplyFilter(value, event.key === "ArrowDown");
    }
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  showMoreInfiniteScroll() {
    if (this.defaultService.hasNext) {
      this.infiniteLoading = true;
    }
    this.page++;
    this.applyFilter("", true);
  }
  clearAndFocus() {
    this.clear(null);
    this.inputEl.nativeElement.focus();
  }
  updateCacheOptions() {
    this.cacheOptions = this.comboOptionsList.map((item) => item.value === this.selectedValue ? __spreadProps(__spreadValues({}, item), {
      selected: true
    }) : item);
  }
  adjustContainerPosition() {
    this.controlPosition.adjustPosition(poComboContainerPositionDefault);
  }
  close(reset) {
    this.comboOpen = false;
    if (!reset) {
      if (!this.getInputValue()) {
        this.page = this.setPage();
        this.defaultService.hasNext = true;
      }
      if (this.infiniteScroll) {
        this.options = this.setOptions();
      }
    }
    this.changeDetector.detectChanges();
    this.comboIcon = "ICON_ARROW_DOWN";
    this.removeListeners();
    this.isFiltering = false;
    this.renderer.removeClass(this.inputEl.nativeElement, "po-combo-input-focus");
  }
  initializeListeners() {
    this.removeListeners();
    this.clickoutListener = this.renderer.listen("document", "click", (event) => {
      this.wasClickedOnToggle(event);
    });
    this.eventResizeListener = this.renderer.listen("window", "resize", () => {
      setTimeout(() => this.adjustContainerPosition(), 250);
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  onErrorGetObjectByValue() {
    this.updateOptionByFilteredValue(null);
  }
  onScroll = () => {
    this.adjustContainerPosition();
  };
  onErrorFilteredData() {
    this.isServerSearching = false;
    this.updateComboList([]);
    this.controlComboVisibility(true);
  }
  open(reset, isButton) {
    this.comboOpen = true;
    if (!reset && this.infiniteScroll) {
      if (!this.getInputValue()) {
        this.page = 1;
      }
      this.options = this.setOptions();
    }
    this.changeDetector.detectChanges();
    this.comboIcon = "ICON_ARROW_UP";
    this.initializeListeners();
    isButton ? this.renderer.addClass(this.inputEl.nativeElement, "po-combo-input-focus") : this.inputEl.nativeElement.focus();
    this.setContainerPosition();
    if (this.comboOpen) {
      this.setContainerWidth();
    }
  }
  removeListeners() {
    if (this.clickoutListener) {
      this.clickoutListener();
    }
    if (this.eventResizeListener) {
      this.eventResizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
  }
  setContainerPosition() {
    this.controlPosition.setElements(this.containerElement.nativeElement, poComboContainerOffset, this.inputEl, ["top", "bottom"], true);
    this.adjustContainerPosition();
  }
  setContainerWidth() {
    if (this.outerContainer) {
      this.containerWidth = this.outerContainer.nativeElement.offsetWidth;
    }
  }
  setOptions() {
    return this.getInputValue() ? this.options : [];
  }
  prepareOptions(items) {
    return this.infiniteScroll ? [...this.options, ...items] : items;
  }
  setPage() {
    return this.infiniteScroll ? 1 : void 0;
  }
  setScrollingControl() {
    return this.infiniteScroll ? true : false;
  }
  focusItem() {
    this.poListbox?.listboxItemList?.nativeElement.focus();
    setTimeout(() => {
      let item;
      if (this.selectedValue) {
        item = document.querySelector('.po-listbox-item[aria-selected="true"]');
      } else {
        item = document.querySelectorAll(".po-listbox-item")[0];
      }
      this.poListbox?.listboxItemList?.nativeElement.focus();
      item?.focus();
    });
  }
  static ɵfac = function PoComboComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoComboComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(PoComboFilterService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoControlPositionService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoComboComponent,
    selectors: [["po-combo"]],
    contentQueries: function PoComboComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PoComboOptionTemplateDirective, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.comboOptionTemplate = _t.first);
      }
    },
    viewQuery: function PoComboComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$X, 5, ElementRef);
        ɵɵviewQuery(_c1$n, 5, ElementRef);
        ɵɵviewQuery(_c2$b, 5, ElementRef);
        ɵɵviewQuery(_c3$7, 7, ElementRef);
        ɵɵviewQuery(_c4$2, 7, ElementRef);
        ɵɵviewQuery(_c5, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.outerContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.containerElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.iconElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poListbox = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoComboFilterService, PoControlPositionService, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoComboComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoComboComponent),
      multi: true
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 23,
    vars: 36,
    consts: [["outerContainer", ""], ["searchContainer", "", "trigger", "cdkOverlayOrigin"], ["inp", ""], ["iconArrow", ""], ["dropdownDefault", ""], ["dropdownCDK", ""], ["dropdownListbox", ""], ["containerElement", ""], ["poListbox", "", "contentElement", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], ["cdkOverlayOrigin", "", 1, "po-field-container-content", "po-combo-container-content"], [1, "po-combo-container-wrapper"], ["class", "po-field-icon-container-left", 4, "ngIf"], ["autocomplete", "off", "type", "text", 1, "po-combo-input", 3, "click", "keyup", "blur", "keydown", "ngClass", "disabled", "id", "placeholder", "required"], [1, "po-field-icon-container-right"], ["tabindex", "0", "role", "button", "class", "po-combo-clean po-icon-input", 3, "p-element-ref", "p-change-event", "click", "keydown.enter", 4, "ngIf"], [1, "po-combo-arrow", "po-field-icon", 3, "click"], [3, "p-icon"], [4, "ngIf", "ngIfThen", "ngIfElse"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon"], [1, "po-field-icon-container-left"], [1, "po-field-icon", "po-icon-input", 3, "p-icon"], ["tabindex", "0", "role", "button", 1, "po-combo-clean", "po-icon-input", 3, "p-change-event", "click", "keydown.enter", "p-element-ref"], [4, "ngTemplateOutlet"], ["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen"], [1, "po-combo-container", 3, "hidden"], ["p-type", "option", 3, "p-selectcombo-item", "p-update-infinite-scroll", "p-close", "p-items", "p-field-value", "p-field-label", "p-template", "p-search-value", "p-infinite-loading", "p-infinite-scroll", "p-filtering", "p-cache", "p-filter-mode", "p-visible", "p-is-searching", "p-should-mark-letter", "p-compare-cache", "p-combo-service", "p-infinite-scroll-distance", "p-container-width"]],
    template: function PoComboComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", null, 0)(2, "po-field-container", 9)(3, "div", 10, 1)(6, "div", 11);
        ɵɵtemplate(7, PoComboComponent_div_7_Template, 2, 3, "div", 12);
        ɵɵelementStart(8, "input", 13, 2);
        ɵɵlistener("click", function PoComboComponent_Template_input_click_8_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.toggleComboVisibility());
        })("keyup", function PoComboComponent_Template_input_keyup_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyUp($event));
        })("blur", function PoComboComponent_Template_input_blur_8_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        })("keyup", function PoComboComponent_Template_input_keyup_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.searchOnEnterOrArrow($event, $event.target.value));
        })("keydown", function PoComboComponent_Template_input_keydown_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(10, "div", 14);
        ɵɵtemplate(11, PoComboComponent_po_clean_11_Template, 1, 2, "po-clean", 15);
        ɵɵelementStart(12, "div", 16, 3);
        ɵɵlistener("click", function PoComboComponent_Template_div_click_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.toggleComboVisibility(true));
        });
        ɵɵelement(14, "po-icon", 17);
        ɵɵelementEnd()()()();
        ɵɵtemplate(15, PoComboComponent_ng_container_15_Template, 1, 0, "ng-container", 18)(16, PoComboComponent_ng_template_16_Template, 1, 1, "ng-template", null, 4, ɵɵtemplateRefExtractor)(18, PoComboComponent_ng_template_18_Template, 1, 2, "ng-template", null, 5, ɵɵtemplateRefExtractor);
        ɵɵelementStart(20, "po-field-container-bottom", 19);
        ɵɵlistener("p-additional-help", function PoComboComponent_Template_po_field_container_bottom_p_additional_help_20_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.emitAdditionalHelp());
        });
        ɵɵelementEnd()();
        ɵɵtemplate(21, PoComboComponent_ng_template_21_Template, 5, 18, "ng-template", null, 6, ɵɵtemplateRefExtractor);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        const inp_r7 = ɵɵreference(9);
        const dropdownDefault_r8 = ɵɵreference(17);
        const dropdownCDK_r9 = ɵɵreference(19);
        ɵɵadvance(2);
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx.icon);
        ɵɵadvance();
        ɵɵclassProp("po-input-icon-left", ctx.icon);
        ɵɵproperty("ngClass", ctx.clean && inp_r7.value ? "po-input-double-icon-right" : "po-input-icon-right")("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("required", ctx.required);
        ɵɵattribute("name", ctx.name);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && inp_r7.value);
        ɵɵadvance();
        ɵɵclassProp("po-field-icon-disabled", ctx.disabled);
        ɵɵadvance(2);
        ɵɵclassProp("po-field-icon", !ctx.disabled)("po-combo-default-border", !ctx.disabled && inp_r7.value)("po-combo-background-arrow-up", !ctx.disabled && ctx.comboOpen);
        ɵɵproperty("p-icon", ctx.comboOpen ? "ICON_ARROW_UP po-icon-input" : "ICON_ARROW_DOWN po-icon-input");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.appendBox)("ngIfThen", dropdownCDK_r9)("ngIfElse", dropdownDefault_r8);
        ɵɵadvance(5);
        ɵɵproperty("p-additional-help-tooltip", ctx.getAdditionalHelpTooltip())("p-append-in-body", ctx.appendBox)("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorPattern())("p-error-limit", ctx.errorLimit)("p-show-additional-help", ctx.displayAdditionalHelp)("p-show-additional-help-icon", ctx.showAdditionalHelpIcon());
      }
    },
    dependencies: [NgClass, NgIf, NgTemplateOutlet, CdkConnectedOverlay, CdkOverlayOrigin, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent, PoListBoxComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComboComponent, [{
    type: Component,
    args: [{
      selector: "po-combo",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [PoComboFilterService, PoControlPositionService, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoComboComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoComboComponent),
        multi: true
      }],
      standalone: false,
      template: `<div #outerContainer>
  <po-field-container
    [p-disabled]="disabled"
    [p-id]="id"
    [p-label]="label"
    [p-optional]="optional"
    [p-required]="required"
    [p-show-required]="showRequired"
  >
    <div
      #searchContainer
      cdkOverlayOrigin
      #trigger="cdkOverlayOrigin"
      class="po-field-container-content po-combo-container-content"
    >
      <div class="po-combo-container-wrapper">
        <div *ngIf="icon" class="po-field-icon-container-left">
          <po-icon
            class="po-field-icon po-icon-input"
            [class.po-field-icon-disabled]="disabled"
            [p-icon]="icon"
          ></po-icon>
        </div>

        <input
          #inp
          class="po-combo-input"
          [ngClass]="clean && inp.value ? 'po-input-double-icon-right' : 'po-input-icon-right'"
          [class.po-input-icon-left]="icon"
          autocomplete="off"
          type="text"
          [attr.name]="name"
          [disabled]="disabled"
          [id]="id"
          [placeholder]="disabled ? '' : placeholder"
          [required]="required"
          (click)="toggleComboVisibility()"
          (keyup)="onKeyUp($event)"
          (blur)="onBlur()"
          (keyup)="searchOnEnterOrArrow($event, $event.target.value)"
          (keydown)="onKeyDown($event)"
        />

        <div class="po-field-icon-container-right">
          <po-clean
            tabindex="0"
            role="button"
            [attr.aria-label]="literals.clean"
            class="po-combo-clean po-icon-input"
            *ngIf="clean && !disabled && inp.value"
            [p-element-ref]="inputEl"
            (p-change-event)="clear($event)"
            (click)="clear(null); $event.preventDefault()"
            (keydown.enter)="clearAndFocus(); $event.preventDefault()"
          >
          </po-clean>

          <div
            #iconArrow
            class="po-combo-arrow po-field-icon"
            [class.po-field-icon-disabled]="disabled"
            (click)="toggleComboVisibility(true)"
          >
            <po-icon
              [p-icon]="comboOpen ? 'ICON_ARROW_UP po-icon-input' : 'ICON_ARROW_DOWN po-icon-input'"
              [class.po-field-icon]="!disabled"
              [class.po-combo-default-border]="!disabled && inp.value"
              [class.po-combo-background-arrow-up]="!disabled && comboOpen"
            ></po-icon>
          </div>
        </div>
      </div>
    </div>

    <ng-container *ngIf="appendBox; then dropdownCDK; else dropdownDefault"> </ng-container>

    <ng-template #dropdownDefault>
      <ng-container *ngTemplateOutlet="dropdownListbox"> </ng-container>
    </ng-template>

    <ng-template #dropdownCDK>
      <ng-template cdkConnectedOverlay [cdkConnectedOverlayOrigin]="trigger" [cdkConnectedOverlayOpen]="true">
        <ng-container *ngTemplateOutlet="dropdownListbox"></ng-container>
      </ng-template>
    </ng-template>

    <po-field-container-bottom
      [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
      [p-append-in-body]="appendBox"
      [p-help]="help"
      [p-disabled]="disabled"
      [p-error-pattern]="getErrorPattern()"
      [p-error-limit]="errorLimit"
      [p-show-additional-help]="displayAdditionalHelp"
      [p-show-additional-help-icon]="showAdditionalHelpIcon()"
      (p-additional-help)="emitAdditionalHelp()"
    ></po-field-container-bottom>
  </po-field-container>

  <ng-template #dropdownListbox>
    <div #containerElement class="po-combo-container" [hidden]="!comboOpen && !isServerSearching">
      <po-listbox
        #poListbox
        #contentElement
        p-type="option"
        [p-items]="visibleOptions"
        [p-field-value]="dynamicValue"
        [p-field-label]="dynamicLabel"
        [p-template]="comboOptionTemplate"
        [p-search-value]="getInputValue()"
        [p-infinite-loading]="infiniteLoading"
        [p-infinite-scroll]="infiniteScroll"
        [p-filtering]="isFiltering"
        [p-cache]="cache"
        (p-selectcombo-item)="onOptionClick($event, $event.event)"
        [p-filter-mode]="filterMode"
        [p-visible]="comboOpen"
        [p-is-searching]="isServerSearching"
        [p-should-mark-letter]="shouldMarkLetters"
        [p-compare-cache]="compareObjects(cacheOptions, visibleOptions)"
        [p-combo-service]="service"
        [p-infinite-scroll-distance]="infiniteScrollDistance"
        (p-update-infinite-scroll)="showMoreInfiniteScroll()"
        (p-close)="onCloseCombo()"
        [p-container-width]="containerWidth"
      ></po-listbox>
    </div>
  </ng-template>
</div>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: IterableDiffers
  }, {
    type: PoComboFilterService
  }, {
    type: Renderer2
  }, {
    type: PoControlPositionService
  }, {
    type: ChangeDetectorRef
  }, {
    type: PoLanguageService
  }], {
    comboOptionTemplate: [{
      type: ContentChild,
      args: [PoComboOptionTemplateDirective, {
        static: true
      }]
    }],
    outerContainer: [{
      type: ViewChild,
      args: ["outerContainer ", {
        read: ElementRef
      }]
    }],
    containerElement: [{
      type: ViewChild,
      args: ["containerElement", {
        read: ElementRef
      }]
    }],
    contentElement: [{
      type: ViewChild,
      args: ["contentElement", {
        read: ElementRef
      }]
    }],
    iconElement: [{
      type: ViewChild,
      args: ["iconArrow", {
        read: ElementRef,
        static: true
      }]
    }],
    inputEl: [{
      type: ViewChild,
      args: ["inp", {
        read: ElementRef,
        static: true
      }]
    }],
    poListbox: [{
      type: ViewChild,
      args: ["poListbox"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoComboComponent, {
    className: "PoComboComponent",
    filePath: "lib/components/po-field/po-combo/po-combo.component.ts",
    lineNumber: 103
  });
})();
var poDatepickerRangeLiteralsDefault = {
  en: {
    invalidFormat: "Date in invalid format",
    startDateGreaterThanEndDate: "Start date greater than end date",
    invalidDate: "Invalid date",
    dateOutOfPeriod: "Date out of period"
  },
  es: {
    invalidFormat: "Fecha en formato no válido",
    startDateGreaterThanEndDate: "Fecha de inicio mayor que fecha final",
    invalidDate: "Fecha invalida",
    dateOutOfPeriod: "Fecha fuera de período"
  },
  pt: {
    invalidFormat: "Data no formato inválido",
    startDateGreaterThanEndDate: "Data inicial maior que data final",
    invalidDate: "Data inválida",
    dateOutOfPeriod: "Data fora do período"
  },
  ru: {
    invalidFormat: "Дата в неверном формате",
    startDateGreaterThanEndDate: "Дата начала больше даты окончания",
    invalidDate: "Недействительная дата",
    dateOutOfPeriod: "дата вне периода"
  }
};
var PoDatepickerRangeBaseComponent = class _PoDatepickerRangeBaseComponent {
  changeDetector;
  poDateService;
  languageService;
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /* Nome do componente. */
  name;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Define que o `calendar` e/ou tooltip (`p-additional-help-tooltip` e/ou `p-error-limit`) serão incluídos no body da
   * página e não dentro do componente. Essa opção pode ser necessária em cenários com containers que possuem scroll ou
   * overflow escondido, garantindo o posicionamento correto de ambos próximo ao elemento.
   *
   * > Quando utilizado com `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /**
   * @optional
   *
   * @description
   *
   * Texto de apoio do campo.
   */
  help;
  /**
   * @optional
   *
   * @description
   *
   * Rótulo do campo.
   */
  label;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * @optional
   *
   * @description
   *
   * Exibe a mensagem setada se o campo estiver vazio e for requerido.
   *
   * > Necessário que a propriedade `p-required` esteja habilitada.
   *
   */
  fieldErrorMessage;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   *
   * > Caso essa propriedade seja definida como `true`, a mensagem de erro será limitada a duas linhas
   * e um tooltip será exibido ao passar o mouse sobre a mensagem para mostrar o conteúdo completo.
   *
   * @default `false`
   */
  errorLimit = false;
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do campo.
   */
  onChange = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  errorMessage = "";
  dateRange = {
    start: "",
    end: ""
  };
  displayAdditionalHelp = false;
  format = "dd/mm/yyyy";
  isDateRangeInputFormatValid = true;
  isStartDateRangeInputValid = true;
  onTouchedModel;
  poMaskObject;
  hasValidatorRequired = false;
  _clean = false;
  _disabled;
  _endDate;
  _literals;
  _maxDate;
  _minDate;
  _noAutocomplete = false;
  _readonly = false;
  _required = false;
  _startDate;
  _locale;
  language;
  onChangeModel;
  validatorChange;
  subscription = new Subscription();
  get isDateRangeInputValid() {
    return this.isDateRangeInputFormatValid && this.isStartDateRangeInputValid;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita ação para limpar o campo.
   *
   * @default `false`
   */
  set clean(clean) {
    this._clean = convertToBoolean(clean);
  }
  get clean() {
    return this._clean;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o campo.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
    this.validateModel(this.dateRange);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Data final.
   */
  set endDate(date) {
    this._endDate = this.convertPatternDateFormat(date);
    this.dateRange.end = this.endDate;
    this.updateScreenByModel(this.dateRange);
    this.updateModel(this.dateRange);
  }
  get endDate() {
    return this._endDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-datepicker-range`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoDatepickerRangeLiterals = {
   *    invalidFormat: 'Date in inconsistent format',
   *    startDateGreaterThanEndDate: 'End date less than start date'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoDatepickerRangeLiterals = {
   *    invalidFormat: 'Date in inconsistent format'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-datepicker-range
   *   [p-literals]="customLiterals">
   * </po-datepicker-range>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poDatepickerRangeLiteralsDefault[poLocaleDefault]), poDatepickerRangeLiteralsDefault[this.language]), value);
    } else {
      this._literals = poDatepickerRangeLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poDatepickerRangeLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma data mínima para o `po-datepicker-range`.
   */
  set minDate(value) {
    if (value instanceof Date) {
      const year = value.getFullYear();
      const date = new Date(year, value.getMonth(), value.getDate(), 0, 0, 0);
      setYearFrom0To100(date, year);
      this._minDate = date;
    } else {
      this._minDate = convertIsoToDate(value, true, false);
    }
  }
  get minDate() {
    return this._minDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma data máxima para o `po-datepicker-range`.
   */
  set maxDate(value) {
    if (value instanceof Date) {
      const year = value.getFullYear();
      const date = new Date(year, value.getMonth(), value.getDate(), 23, 59, 59);
      setYearFrom0To100(date, year);
      this._maxDate = date;
    } else {
      this._maxDate = convertIsoToDate(value, false, true);
    }
  }
  get maxDate() {
    return this._maxDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a propriedade nativa `autocomplete` do campo como `off`.
   *
   * @default `false`
   */
  set noAutocomplete(value) {
    this._noAutocomplete = convertToBoolean(value);
  }
  get noAutocomplete() {
    return this._noAutocomplete;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será somente leitura.
   *
   * @default `false`
   */
  set readonly(value) {
    this._readonly = convertToBoolean(value);
    this.validateModel(this.dateRange);
  }
  get readonly() {
    return this._readonly;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel(this.dateRange);
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * @optional
   *
   * @description
   *
   * Data inicial.
   */
  set startDate(date) {
    this._startDate = this.convertPatternDateFormat(date);
    this.dateRange.start = this.startDate;
    this.updateScreenByModel(this.dateRange);
    this.updateModel(this.dateRange);
  }
  get startDate() {
    return this._startDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Idioma que o calendário utilizará para exibir as datas.
   *
   * > O locale padrão será recuperado com base no [`PoI18nService`](/documentation/po-i18n) ou *browser*.
   */
  set locale(value) {
    if (value) {
      this._locale = value.length >= 2 ? value : poLocaleDefault;
      this.poMaskObject = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
    } else {
      this._locale = this.language;
      this.poMaskObject = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
    }
  }
  get locale() {
    return this._locale || this.language;
  }
  constructor(changeDetector, poDateService, languageService) {
    this.changeDetector = changeDetector;
    this.poDateService = poDateService;
    this.languageService = languageService;
    this.language = languageService.getShortLanguage();
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnChange(func) {
    this.onChangeModel = func;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnTouched(func) {
    this.onTouchedModel = func;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(control) {
    const value = control.value || {};
    const startDate = value.start ? this.convertPatternDateFormat(value.start) : "";
    const endDate = value.end ? this.convertPatternDateFormat(value.end) : "";
    if (!this.hasValidatorRequired && this.fieldErrorMessage && control.hasValidator(Validators.required)) {
      this.hasValidatorRequired = true;
    }
    if (this.requiredDateRangeFailed(startDate, endDate)) {
      this.errorMessage = "";
      return {
        required: {
          valid: false
        }
      };
    }
    if (!this.verifyValidDate(startDate, endDate)) {
      this.errorMessage = this.literals.invalidDate;
      return {
        date: {
          valid: false
        }
      };
    }
    if (this.dateRangeObjectFailed(control.value) || this.dateRangeFormatFailed(startDate, endDate)) {
      this.errorMessage = this.literals.invalidFormat;
      return {
        date: {
          valid: false
        }
      };
    }
    if (this.dateRangeFailed(startDate, endDate)) {
      this.errorMessage = this.literals.startDateGreaterThanEndDate;
      return {
        date: {
          valid: false
        }
      };
    }
    if (startDate && !this.validateDateInRange(startDate) || endDate && !this.validateDateInRange(endDate)) {
      this.errorMessage = this.literals.dateOutOfPeriod;
      return {
        date: {
          valid: false
        }
      };
    }
    if (this.fieldErrorMessage) {
      this.subscription?.unsubscribe();
      this.subscription = control.statusChanges.pipe(switchMap((status) => {
        if (status === "INVALID") {
          this.changeDetector.markForCheck();
        }
        return [];
      })).subscribe();
    }
    return null;
  }
  validateDateInRange(startDate) {
    return validateDateRange(convertIsoToDate(startDate, false, false), this._minDate, this._maxDate);
  }
  writeValue(dateRange) {
    this.resetDateRangeInputValidation();
    if (!dateRange || this.dateRangeObjectFailed(dateRange)) {
      this.dateRange = {
        start: "",
        end: ""
      };
    }
    if (!dateRange) {
      this.validateModel(this.dateRange);
    }
    if (this.dateRangeObjectFailed(dateRange)) {
      this.updateModel(dateRange);
    }
    if (this.isDateRangeObject(dateRange)) {
      this.dateRange = {
        start: this.convertPatternDateFormat(dateRange.start),
        end: this.convertPatternDateFormat(dateRange.end)
      };
      this.updateModel(this.dateRange);
    }
    this.updateScreenByModel(this.dateRange);
  }
  // Retorna um objeto do tipo PoMask com a mascara configurada.
  buildMask(format = this.format) {
    let mask = format.toUpperCase();
    mask = mask.replace(/DD/g, "99");
    mask = mask.replace(/MM/g, "99");
    mask = mask.replace(/YYYY/g, "9999");
    return new PoMask(mask, true);
  }
  dateFormatFailed(value) {
    return value && !this.poDateService.isValidIso(value);
  }
  // Executa a função onChange
  updateModel(value) {
    const model = typeof value === "object" ? __spreadValues({}, value) : value;
    if (this.onChangeModel) {
      this.onChangeModel(model);
    }
  }
  validateModel(value) {
    const model = __spreadValues({}, value);
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  verifyValidDate(startDate, endDate) {
    if (startDate !== "" && endDate !== "") {
      return this.dateIsValid(startDate) && this.dateIsValid(endDate);
    } else if (startDate !== "") {
      return this.dateIsValid(startDate);
    } else {
      return this.dateIsValid(endDate);
    }
  }
  convertPatternDateFormat(value) {
    if (value instanceof Date) {
      return this.poDateService.convertDateToISO(value);
    }
    return value;
  }
  dateRangeFailed(startDate, endDate) {
    return !this.poDateService.isDateRangeValid(endDate, startDate) || !this.isStartDateRangeInputValid;
  }
  dateRangeFormatFailed(startDate, endDate) {
    return this.dateFormatFailed(endDate) || this.dateFormatFailed(startDate) || !this.isDateRangeInputFormatValid;
  }
  dateRangeObjectFailed(value) {
    return value && !this.isDateRangeObject(value);
  }
  isDateRangeObject(value) {
    return value && value.hasOwnProperty("start") && value.hasOwnProperty("end");
  }
  requiredDateRangeFailed(startDate, endDate) {
    return this.isDateRangeInputValid && requiredFailed(this.required || this.hasValidatorRequired, this.disabled, startDate) && requiredFailed(this.required || this.hasValidatorRequired, this.disabled, endDate);
  }
  dateIsValid(date) {
    const [strYear, strMonth, strDay] = date.split("-");
    const year = Number(strYear);
    const month = Number(strMonth);
    const day = Number(strDay);
    if (month === 1 || month === 3 || month === 5 || month === 7 || month === 8 || month === 10 || month === 12) {
      return day < 1 || day > 31 ? false : true;
    } else if (month === 4 || month === 6 || month === 9 || month === 11) {
      return day < 1 || day > 30 ? false : true;
    } else {
      if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
        return day < 1 || day > 29 ? false : true;
      } else {
        return day < 1 || day > 28 ? false : true;
      }
    }
  }
  static ɵfac = function PoDatepickerRangeBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDatepickerRangeBaseComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoDatepickerRangeBaseComponent,
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      name: "name",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      help: [0, "p-help", "help"],
      label: [0, "p-label", "label"],
      optional: [0, "p-optional", "optional"],
      fieldErrorMessage: [0, "p-field-error-message", "fieldErrorMessage"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      clean: [0, "p-clean", "clean"],
      disabled: [0, "p-disabled", "disabled"],
      endDate: [0, "p-end-date", "endDate"],
      literals: [0, "p-literals", "literals"],
      minDate: [0, "p-min-date", "minDate"],
      maxDate: [0, "p-max-date", "maxDate"],
      noAutocomplete: [0, "p-no-autocomplete", "noAutocomplete"],
      readonly: [0, "p-readonly", "readonly"],
      required: [0, "p-required", "required"],
      showRequired: [0, "p-show-required", "showRequired"],
      startDate: [0, "p-start-date", "startDate"],
      locale: [0, "p-locale", "locale"]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      onChange: "p-change",
      keydown: "p-keydown"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDatepickerRangeBaseComponent, [{
    type: Directive
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: PoDateService
  }, {
    type: PoLanguageService
  }], {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    fieldErrorMessage: [{
      type: Input,
      args: ["p-field-error-message"]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    onChange: [{
      type: Output,
      args: ["p-change"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    clean: [{
      type: Input,
      args: ["p-clean"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    endDate: [{
      type: Input,
      args: ["p-end-date"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    minDate: [{
      type: Input,
      args: ["p-min-date"]
    }],
    maxDate: [{
      type: Input,
      args: ["p-max-date"]
    }],
    noAutocomplete: [{
      type: Input,
      args: ["p-no-autocomplete"]
    }],
    readonly: [{
      type: Input,
      args: ["p-readonly"]
    }],
    required: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }],
    startDate: [{
      type: Input,
      args: ["p-start-date"]
    }],
    locale: [{
      type: Input,
      args: ["p-locale"]
    }]
  });
})();
var _c0$W = ["dateRangeField"];
var _c1$m = ["endDateInput"];
var _c2$a = ["startDateInput"];
var _c3$6 = ["iconCalendar"];
var _c4$1 = ["calendarPicker"];
function PoDatepickerRangeComponent_po_clean_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 18);
    ɵɵlistener("p-change-event", function PoDatepickerRangeComponent_po_clean_14_Template_po_clean_p_change_event_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.clear());
    });
    ɵɵelementEnd();
  }
}
function PoDatepickerRangeComponent_po_field_container_bottom_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 19);
    ɵɵlistener("p-additional-help", function PoDatepickerRangeComponent_po_field_container_bottom_18_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.emitAdditionalHelp());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r2.getAdditionalHelpTooltip())("p-append-in-body", ctx_r2.appendBox)("p-help", ctx_r2.help)("p-disabled", ctx_r2.disabled)("p-error-pattern", ctx_r2.getErrorMessage)("p-error-limit", ctx_r2.errorLimit)("p-show-additional-help", ctx_r2.displayAdditionalHelp)("p-show-additional-help-icon", ctx_r2.showAdditionalHelpIcon());
  }
}
function PoDatepickerRangeComponent_ng_container_19_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 20, 4)(3, "po-calendar", 21);
    ɵɵlistener("ngModelChange", function PoDatepickerRangeComponent_ng_container_19_Template_po_calendar_ngModelChange_3_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onCalendarChange($event));
    });
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngModel", ctx_r2.dateRange)("p-max-date", ctx_r2.maxDate)("p-min-date", ctx_r2.minDate)("p-locale", ctx_r2.locale);
  }
}
var arrowLeftKey = 37;
var arrowRightKey = 39;
var backspaceKey = 8;
var poDatepickerRangeDateLengthDefault = 10;
var poCalendarContentOffset = 8;
var poCalendarPositionDefault = "bottom-left";
var providers$5 = [{
  provide: NG_VALUE_ACCESSOR,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoDatepickerRangeComponent),
  multi: true
}, {
  provide: NG_VALIDATORS,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoDatepickerRangeComponent),
  multi: true
}, PoControlPositionService];
var PoDatepickerRangeComponent = class _PoDatepickerRangeComponent extends PoDatepickerRangeBaseComponent {
  changeDetector;
  controlPosition;
  renderer;
  cd;
  poLanguageService;
  dateRangeField;
  endDateInput;
  startDateInput;
  iconCalendar;
  calendarPicker;
  isCalendarVisible = false;
  clickListener;
  eventResizeListener;
  poDatepickerRangeElement;
  get autocomplete() {
    return this.noAutocomplete ? "off" : "on";
  }
  get enableCleaner() {
    return this.clean && (this.startDateInputValue || this.endDateInputValue) && !this.disabled && !this.readonly;
  }
  get endDateInputName() {
    return "end-date";
  }
  get endDateInputValue() {
    return this.endDateInput.nativeElement.value;
  }
  get getErrorMessage() {
    if (this.fieldErrorMessage && !this.errorMessage && this.hasInvalidClass()) {
      return this.fieldErrorMessage;
    }
    return this.errorMessage !== "" && this.hasInvalidClass() ? this.errorMessage : "";
  }
  get isDateRangeInputUncompleted() {
    return this.endDateInputValue.length < poDatepickerRangeDateLengthDefault && this.startDateInputValue.length < poDatepickerRangeDateLengthDefault;
  }
  get isDirtyDateRangeInput() {
    return this.endDateInputValue.length > 0 || this.startDateInputValue.length > 0;
  }
  get startDateInputName() {
    return "start-date";
  }
  get startDateInputValue() {
    return this.startDateInput.nativeElement.value;
  }
  constructor(changeDetector, controlPosition, renderer, cd, poLanguageService, poDateService, poDatepickerRangeElement) {
    super(changeDetector, poDateService, poLanguageService);
    this.changeDetector = changeDetector;
    this.controlPosition = controlPosition;
    this.renderer = renderer;
    this.cd = cd;
    this.poLanguageService = poLanguageService;
    this.poDatepickerRangeElement = poDatepickerRangeElement;
  }
  static getKeyCode(event) {
    return event.keyCode || event.which;
  }
  static getTargetElement(event) {
    return event.target || event.srcElement;
  }
  static isValidKey(keyCode) {
    const isNumericKey = keyCode >= 48 && keyCode <= 57;
    const isNumericNumpadKey = keyCode >= 96 && keyCode <= 105;
    return isNumericKey || isNumericNumpadKey;
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  ngOnInit() {
    this.poMaskObject = this.buildMask(replaceFormatSeparator(this.format, this.poLanguageService.getDateSeparator(this.locale)));
  }
  ngOnChanges(changes) {
    if (changes.minDate || changes.maxDate) {
      this.validateModel(this.dateRange);
    }
    if (changes.locale) {
      if (this.dateRange) {
        this.updateScreenByModel(this.dateRange);
      }
      this.poMaskObject = this.buildMask(replaceFormatSeparator(this.format, this.poLanguageService.getDateSeparator(this.locale)));
    }
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  clear() {
    this.resetDateRangeInputValidation();
    this.dateRange = {
      start: "",
      end: ""
    };
    this.updateScreenByModel(this.dateRange);
    this.updateModel(this.dateRange);
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  eventOnClick($event) {
    this.poMaskObject.click($event);
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoDatepickerRangeComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoDatepickerRangeComponent, { static: true }) datepickerRange: PoDatepickerRangeComponent;
   *
   * focusDatepickerRange() {
   *   this.datepickerRange.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.startDateInput.nativeElement.focus();
    }
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  onBlur(event) {
    this.onTouchedModel?.();
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
    const isStartDateTargetEvent = event.target.name === this.startDateInputName;
    this.updateModelByScreen(isStartDateTargetEvent);
    this.removeFocusFromDatePickerRangeField();
  }
  onCalendarChange({
    start,
    end
  }) {
    const isStartDateTargetEvent = start && !end;
    this.updateScreenByModel({
      start: start || "",
      end: end || ""
    });
    this.updateModelByScreen(isStartDateTargetEvent, start || "", end || "");
    if (start && end) {
      setTimeout(() => {
        this.isCalendarVisible = false;
        this.cd.markForCheck();
      }, 300);
    }
  }
  onFocus(event) {
    this.applyFocusOnDatePickerRangeField();
    this.poMaskObject.resetPositions(event);
  }
  onKeydown(event) {
    const isStartDateFocused = document.activeElement === this.startDateInput.nativeElement;
    const isEndDateFocused = document.activeElement === this.endDateInput.nativeElement;
    const isFieldFocused = isStartDateFocused || isEndDateFocused;
    if (this.readonly) {
      return;
    }
    if (this.isSetFocusOnBackspace(event)) {
      event.preventDefault();
      this.setFocusOnBackspace();
    } else {
      this.poMaskObject.keydown(event);
    }
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  onKeyup(event) {
    if (this.readonly) {
      return;
    }
    const isStartDateTargetEvent = event.target.name === this.startDateInputName;
    this.setFocus(event);
    this.poMaskObject.keyup(event);
    this.updateModelWhenComplete(isStartDateTargetEvent, this.startDateInputValue, this.endDateInputValue);
  }
  resetDateRangeInputValidation() {
    this.isStartDateRangeInputValid = true;
    this.isDateRangeInputFormatValid = true;
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-datepicker-range
   *  #datepickerRange
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, datepickerRange)"
   * ></po-datepicker-range>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoDatepickerRangeComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  toggleCalendar() {
    if (this.disabled || this.readonly) {
      return;
    }
    this.isCalendarVisible = !this.isCalendarVisible;
    this.changeDetector.detectChanges();
    if (this.isCalendarVisible) {
      this.setCalendarPosition();
      this.initializeListeners();
    } else {
      this.removeListeners();
    }
  }
  updateScreenByModel(model) {
    const dateRange = {
      start: model.start,
      end: model.end
    };
    const isStartDateValid = this.poDateService.isDateRangeValid(dateRange.end, dateRange.start);
    const isDateValid = (date) => !this.dateFormatFailed(date) && isStartDateValid;
    const endDateFormated = isDateValid(dateRange.end) ? this.formatModelToScreen(dateRange.end) : "";
    const startDateFormated = isDateValid(dateRange.start) ? this.formatModelToScreen(dateRange.start) : "";
    this.endDateInput.nativeElement.value = endDateFormated;
    this.startDateInput.nativeElement.value = startDateFormated;
    this.changeDetector.detectChanges();
  }
  applyFocusOnDatePickerRangeField() {
    this.dateRangeField.nativeElement.classList.add("po-datepicker-range-field-focused");
  }
  formatDate(format, day = "", month = "", year = "") {
    let dateFormatted = replaceFormatSeparator(format || this.format, this.poLanguageService.getDateSeparator(this.locale));
    day = day && day.includes("T") ? day.slice(0, 2) : day;
    dateFormatted = dateFormatted.replace("dd", ("0" + day).slice(-2));
    dateFormatted = dateFormatted.replace("mm", ("0" + month).slice(-2));
    dateFormatted = dateFormatted.replace("yyyy", String(year));
    return dateFormatted;
  }
  formatScreenToModel(value = "") {
    const [day, month, year] = value.split(this.poLanguageService.getDateSeparator(this.locale));
    return value ? this.formatDate("yyyy-mm-dd", day, month, year) : "";
  }
  formatModelToScreen(value = "") {
    const [year, month, day] = value.split("-");
    return value ? this.formatDate(this.format, day, month, year) : "";
  }
  getDateRangeFormatValidation(startDate, endDate, isStartDateTargetEvent) {
    this.setDateRangeInputValidation(startDate, endDate);
    return {
      isValid: this.isDateRangeInputFormatValid && this.isStartDateRangeInputValid && this.verifyValidDate(startDate, endDate),
      dateRangeModel: this.getValidatedModel(startDate, endDate, isStartDateTargetEvent)
    };
  }
  getValidatedModel(startDate, endDate, isStartDateTargetEvent) {
    const dateRangeModel = {
      start: "",
      end: ""
    };
    dateRangeModel.end = (isStartDateTargetEvent || this.isStartDateRangeInputValid) && !this.dateFormatFailed(endDate) ? endDate : "";
    dateRangeModel.start = (!isStartDateTargetEvent || this.isStartDateRangeInputValid) && !this.dateFormatFailed(startDate) ? startDate : "";
    return dateRangeModel;
  }
  hasAttrCalendar(element) {
    const attrCalendar = "attr-calendar";
    return element?.hasAttribute(attrCalendar) || element?.parentElement?.hasAttribute(attrCalendar);
  }
  hasInvalidClass() {
    return this.poDatepickerRangeElement.nativeElement.classList.contains("ng-invalid") && this.poDatepickerRangeElement.nativeElement.classList.contains("ng-dirty");
  }
  initializeListeners() {
    this.clickListener = this.renderer.listen("document", "click", (event) => {
      this.wasClickedOnPicker(event);
    });
    this.eventResizeListener = this.renderer.listen("window", "resize", () => {
      this.isCalendarVisible = false;
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  isEqualBeforeValue(startDate, endDate) {
    return this.isDateRangeInputFormatValid && endDate === this.dateRange.end && startDate === this.dateRange.start;
  }
  isSetFocusOnBackspace(event) {
    return event.target.name === this.endDateInputName && this.endDateInput.nativeElement.selectionStart === 0 && this.endDateInput.nativeElement.selectionEnd === 0 && event.keyCode === backspaceKey;
  }
  onScroll = () => {
    if (this.isCalendarVisible) {
      this.controlPosition.adjustPosition(poCalendarPositionDefault);
    }
  };
  removeFocusFromDatePickerRangeField() {
    this.dateRangeField.nativeElement.classList.remove("po-datepicker-range-field-focused");
  }
  setDateRangeInputValidation(startDate, endDate) {
    this.isStartDateRangeInputValid = this.poDateService.isDateRangeValid(endDate, startDate);
    this.isDateRangeInputFormatValid = !this.dateFormatFailed(startDate) && !this.dateFormatFailed(endDate);
  }
  setFocus(event) {
    const inputElement = _PoDatepickerRangeComponent.getTargetElement(event);
    const keyCode = _PoDatepickerRangeComponent.getKeyCode(event);
    const inputName = inputElement["name"];
    this.setFocusOnArrowLeft(keyCode, inputName);
    this.setFocusOnArrowRight(keyCode, inputName, inputElement);
    this.setFocusOnStartDateCompleted(keyCode, inputName);
  }
  setFocusAndPosition(position, inputElement, selectionRange) {
    this.focusOnElement(inputElement);
    setTimeout(() => {
      inputElement.nativeElement.setSelectionRange(selectionRange, selectionRange);
      this.poMaskObject.initialPosition = position;
      this.poMaskObject.finalPosition = position;
    });
  }
  focusOnElement(inputElement) {
    inputElement.nativeElement.focus();
  }
  removeListeners() {
    if (this.clickListener) {
      this.clickListener();
    }
    if (this.eventResizeListener) {
      this.eventResizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
  }
  setCalendarPosition() {
    this.controlPosition.setElements(this.calendarPicker.nativeElement, poCalendarContentOffset, this.dateRangeField, ["bottom-left", "bottom-right", "top-left", "top-right"], false, true);
    this.controlPosition.adjustPosition(poCalendarPositionDefault);
  }
  setFocusOnArrowLeft(keyCode, inputName) {
    const isCursorAtStartOfInput = this.endDateInput.nativeElement.selectionStart === 0;
    if (inputName === this.endDateInputName && isCursorAtStartOfInput && keyCode === arrowLeftKey) {
      const inputLength = this.startDateInput.nativeElement.value.length;
      this.setFocusAndPosition(inputLength, this.startDateInput, inputLength);
    }
  }
  setFocusOnArrowRight(keyCode, inputName, inputElement) {
    const isCursorAtEndOfInput = this.startDateInput.nativeElement.selectionStart === inputElement.value.length;
    if (inputName === this.startDateInputName && isCursorAtEndOfInput && keyCode === arrowRightKey) {
      this.setFocusAndPosition(0, this.endDateInput, 0);
    }
  }
  setFocusOnBackspace() {
    const inputLength = this.startDateInput.nativeElement.value.length;
    this.startDateInput.nativeElement.value = this.startDateInputValue.slice(0, -1);
    this.setFocusAndPosition(inputLength, this.startDateInput, inputLength);
  }
  setFocusOnStartDateCompleted(keyCode, inputName) {
    const isLastKeyPressed = this.startDateInput.nativeElement.selectionStart === poDatepickerRangeDateLengthDefault;
    const isNewDateCompleted = this.startDateInputValue.length === poDatepickerRangeDateLengthDefault && isLastKeyPressed;
    const isValidKey = _PoDatepickerRangeComponent.isValidKey(keyCode);
    if (inputName === this.startDateInputName && isNewDateCompleted && isValidKey) {
      this.setFocusAndPosition(0, this.endDateInput, 0);
    }
  }
  updateModelWhenComplete(isStartDateTargetEvent, startDate, endDate) {
    const endDateFormatted = this.formatScreenToModel(endDate);
    const startDateFormatted = this.formatScreenToModel(startDate);
    const dateFormatValidation = this.getDateRangeFormatValidation(startDateFormatted, endDateFormatted, isStartDateTargetEvent);
    if (this.isEqualBeforeValue(startDateFormatted, endDateFormatted)) {
      this.resetDateRangeInputValidation();
      this.validateModel(this.dateRange);
      return;
    }
    if (dateFormatValidation.isValid) {
      this.dateRange = {
        start: startDateFormatted,
        end: endDateFormatted
      };
      this.updateModel(this.dateRange);
      this.onChange.emit(__spreadValues({}, this.dateRange));
    }
  }
  updateModelByScreen(isStartDateTargetEvent, startDate, endDate) {
    const endDateFormatted = endDate || this.formatScreenToModel(this.endDateInputValue);
    const startDateFormatted = startDate || this.formatScreenToModel(this.startDateInputValue);
    if (this.isDateRangeInputUncompleted && this.isDirtyDateRangeInput) {
      this.updateModel(this.dateRange);
      return;
    }
    if (this.isEqualBeforeValue(startDateFormatted, endDateFormatted)) {
      this.resetDateRangeInputValidation();
      this.validateModel(this.dateRange);
      return;
    }
    const dateFormatValidation = this.getDateRangeFormatValidation(startDateFormatted, endDateFormatted, isStartDateTargetEvent);
    if (dateFormatValidation.isValid) {
      this.dateRange = {
        start: startDateFormatted,
        end: endDateFormatted
      };
      this.updateModel(this.dateRange);
      this.onChange.emit(__spreadValues({}, this.dateRange));
    }
    if (!dateFormatValidation.isValid && this.verifyFormattedDates(startDateFormatted, endDateFormatted)) {
      this.dateRange = __spreadValues({}, dateFormatValidation.dateRangeModel);
      this.updateModel(dateFormatValidation.dateRangeModel);
    }
  }
  verifyFormattedDates(start, end) {
    return !!start || !!end;
  }
  wasClickedOnPicker(event) {
    if (!this.isCalendarVisible) {
      return;
    }
    if (!this.calendarPicker.nativeElement.contains(event.target) && !this.iconCalendar.nativeElement.contains(event.target) && !this.hasAttrCalendar(event.target)) {
      this.isCalendarVisible = false;
    }
    this.cd.markForCheck();
  }
  static ɵfac = function PoDatepickerRangeComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDatepickerRangeComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoControlPositionService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDatepickerRangeComponent,
    selectors: [["po-datepicker-range"]],
    viewQuery: function PoDatepickerRangeComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$W, 7, ElementRef);
        ɵɵviewQuery(_c1$m, 7, ElementRef);
        ɵɵviewQuery(_c2$a, 7, ElementRef);
        ɵɵviewQuery(_c3$6, 7, ElementRef);
        ɵɵviewQuery(_c4$1, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateRangeField = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.endDateInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.startDateInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.iconCalendar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.calendarPicker = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature(providers$5), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 20,
    vars: 28,
    consts: [["dateRangeField", ""], ["startDateInput", ""], ["endDateInput", ""], ["iconCalendar", ""], ["calendarPicker", ""], [3, "p-disabled", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [1, "po-field-container-input"], [1, "po-datepicker-range-field", "po-input"], [1, "po-datepicker-range-start-date"], ["maxlength", "10", "type", "text", 1, "po-datepicker-range-input", 3, "blur", "focus", "keydown", "keyup", "click", "autocomplete", "disabled", "name", "readonly"], [1, "po-datepicker-range-separator"], [1, "po-datepicker-range-end-date"], [1, "po-datepicker-range-icon"], ["class", "po-icon-input", 3, "p-change-event", 4, "ngIf"], [3, "click", "p-icon"], [3, "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [4, "ngIf"], [1, "po-icon-input", 3, "p-change-event"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon"], [1, "po-calendar-range-picker"], ["p-mode", "range", 3, "ngModelChange", "ngModel", "p-max-date", "p-min-date", "p-locale"]],
    template: function PoDatepickerRangeComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 5)(1, "div", 6)(2, "div", 7)(3, "div", 8, 0)(5, "div", 9)(6, "input", 10, 1);
        ɵɵlistener("blur", function PoDatepickerRangeComponent_Template_input_blur_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur($event));
        })("focus", function PoDatepickerRangeComponent_Template_input_focus_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFocus($event));
        })("keydown", function PoDatepickerRangeComponent_Template_input_keydown_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeydown($event));
        })("keyup", function PoDatepickerRangeComponent_Template_input_keyup_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyup($event));
        })("click", function PoDatepickerRangeComponent_Template_input_click_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnClick($event));
        });
        ɵɵelementEnd()();
        ɵɵelementStart(8, "div", 11);
        ɵɵtext(9, "-");
        ɵɵelementEnd();
        ɵɵelementStart(10, "div", 12)(11, "input", 10, 2);
        ɵɵlistener("blur", function PoDatepickerRangeComponent_Template_input_blur_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur($event));
        })("focus", function PoDatepickerRangeComponent_Template_input_focus_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFocus($event));
        })("keydown", function PoDatepickerRangeComponent_Template_input_keydown_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeydown($event));
        })("keyup", function PoDatepickerRangeComponent_Template_input_keyup_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyup($event));
        })("click", function PoDatepickerRangeComponent_Template_input_click_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnClick($event));
        });
        ɵɵelementEnd()();
        ɵɵelementStart(13, "div", 13);
        ɵɵtemplate(14, PoDatepickerRangeComponent_po_clean_14_Template, 1, 0, "po-clean", 14);
        ɵɵelementEnd();
        ɵɵelementStart(15, "div", 13)(16, "po-icon", 15, 3);
        ɵɵlistener("click", function PoDatepickerRangeComponent_Template_po_icon_click_16_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.toggleCalendar());
        });
        ɵɵelementEnd()()()()();
        ɵɵtemplate(18, PoDatepickerRangeComponent_po_field_container_bottom_18_Template, 1, 8, "po-field-container-bottom", 16);
        ɵɵelementEnd();
        ɵɵtemplate(19, PoDatepickerRangeComponent_ng_container_19_Template, 4, 4, "ng-container", 17);
      }
      if (rf & 2) {
        ɵɵclassProp("po-date-picker-container-disabled", ctx.disabled);
        ɵɵproperty("p-disabled", ctx.disabled)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(3);
        ɵɵclassProp("po-datepicker-range-field-disabled", ctx.disabled);
        ɵɵattribute("disabled", ctx.disabled);
        ɵɵadvance(3);
        ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("name", ctx.startDateInputName)("readonly", ctx.readonly);
        ɵɵattribute("aria-label", ctx.label);
        ɵɵadvance(5);
        ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("name", ctx.endDateInputName)("readonly", ctx.readonly);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.enableCleaner);
        ɵɵadvance(2);
        ɵɵclassMapInterpolate1("po-field-icon ", ctx.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
        ɵɵclassProp("po-field-icon-disabled", ctx.disabled || ctx.readonly);
        ɵɵproperty("p-icon", !ctx.disabled || !ctx.readonly ? "ICON_CALENDAR po-clickable" : "ICON_CALENDAR");
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.readonly);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isCalendarVisible);
      }
    },
    dependencies: [NgIf, NgControlStatus, NgModel, PoCleanComponent, PoCalendarComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDatepickerRangeComponent, [{
    type: Component,
    args: [{
      selector: "po-datepicker-range",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: providers$5,
      standalone: false,
      template: `<po-field-container
  [class.po-date-picker-container-disabled]="disabled"
  [p-disabled]="disabled"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div class="po-field-container-input">
      <div
        #dateRangeField
        class="po-datepicker-range-field po-input"
        [class.po-datepicker-range-field-disabled]="disabled"
        [attr.disabled]="disabled"
      >
        <div class="po-datepicker-range-start-date">
          <input
            #startDateInput
            class="po-datepicker-range-input"
            maxlength="10"
            type="text"
            [attr.aria-label]="label"
            [autocomplete]="autocomplete"
            [disabled]="disabled"
            [name]="startDateInputName"
            [readonly]="readonly"
            (blur)="onBlur($event)"
            (focus)="onFocus($event)"
            (keydown)="onKeydown($event)"
            (keyup)="onKeyup($event)"
            (click)="eventOnClick($event)"
          />
        </div>

        <div class="po-datepicker-range-separator">-</div>

        <div class="po-datepicker-range-end-date">
          <input
            #endDateInput
            class="po-datepicker-range-input"
            maxlength="10"
            type="text"
            [autocomplete]="autocomplete"
            [disabled]="disabled"
            [name]="endDateInputName"
            [readonly]="readonly"
            (blur)="onBlur($event)"
            (focus)="onFocus($event)"
            (keydown)="onKeydown($event)"
            (keyup)="onKeyup($event)"
            (click)="eventOnClick($event)"
          />
        </div>

        <div class="po-datepicker-range-icon">
          <po-clean class="po-icon-input" *ngIf="enableCleaner" (p-change-event)="clear()"></po-clean>
        </div>

        <div class="po-datepicker-range-icon">
          <po-icon
            #iconCalendar
            [p-icon]="!disabled || !readonly ? 'ICON_CALENDAR po-clickable' : 'ICON_CALENDAR'"
            class="po-field-icon {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
            [class.po-field-icon-disabled]="disabled || readonly"
            (click)="toggleCalendar()"
          >
          </po-icon>
        </div>
      </div>
    </div>
  </div>

  <po-field-container-bottom
    *ngIf="!readonly"
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorMessage"
    [p-error-limit]="errorLimit"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>

<ng-container *ngIf="isCalendarVisible">
  <div #calendarPicker class="po-calendar-range-picker">
    <po-calendar
      p-mode="range"
      [ngModel]="dateRange"
      [p-max-date]="maxDate"
      [p-min-date]="minDate"
      [p-locale]="locale"
      (ngModelChange)="onCalendarChange($event)"
    ></po-calendar>
  </div>
</ng-container>
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: PoControlPositionService
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: PoLanguageService
  }, {
    type: PoDateService
  }, {
    type: ElementRef
  }], {
    dateRangeField: [{
      type: ViewChild,
      args: ["dateRangeField", {
        read: ElementRef,
        static: true
      }]
    }],
    endDateInput: [{
      type: ViewChild,
      args: ["endDateInput", {
        read: ElementRef,
        static: true
      }]
    }],
    startDateInput: [{
      type: ViewChild,
      args: ["startDateInput", {
        read: ElementRef,
        static: true
      }]
    }],
    iconCalendar: [{
      type: ViewChild,
      args: ["iconCalendar", {
        read: ElementRef,
        static: true
      }]
    }],
    calendarPicker: [{
      type: ViewChild,
      args: ["calendarPicker", {
        read: ElementRef
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDatepickerRangeComponent, {
    className: "PoDatepickerRangeComponent",
    filePath: "lib/components/po-field/po-datepicker-range/po-datepicker-range.component.ts",
    lineNumber: 83
  });
})();
var PoInputBaseComponent = class _PoInputBaseComponent {
  cd;
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Define que o tooltip (`p-additional-help-tooltip` e/ou `p-error-limit`) será incluído no body da página e não
   * dentro do componente. Essa opção pode ser necessária em cenários com containers que possuem scroll ou overflow
   * escondido, garantindo o posicionamento correto do tooltip próximo ao elemento.
   *
   * > Quando utilizado com `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /**
   * @optional
   *
   * @description
   *
   * Define o ícone que será exibido no início do campo.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](https://po-ui.io/icons). conforme exemplo abaixo:
   * ```
   * <po-input p-icon="an an-user" p-label="PO input"></po-input>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-input p-icon="fa fa-podcast" p-label="PO input"></po-input>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-input [p-icon]="template" p-label="input template ionic"></po-input>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   */
  icon;
  /**
   * @optional
   *
   * @description
   *
   * Sempre emite as alterações do model mesmo quando o valor atual for igual ao valor anterior.
   *
   * @default `false`
   */
  emitAllChanges = false;
  /** Rótulo do campo. */
  label;
  /** Texto de apoio do campo. */
  help;
  /** Nome e identificador do campo. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Realiza alguma validação customizada assíncrona no componente.
   * Aconselhamos a utilização dessa propriedade somente em componentes que não estejam
   * utilizando `Reactive Forms`. Em formulários reativos, pode-se utilizar o próprio `asyncValidators`.
   */
  errorAsyncProperties;
  /**
   * @description
   *
   * Mensagem que será apresentada quando o `pattern` ou a máscara não for satisfeita.
   *
   * > Por padrão, esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja requerido.
   * Para exibir a mensagem com o campo vazio, utilize a propriedade `p-required-field-error-message` em conjunto.
   */
  errorPattern = "";
  /**
   * @optional
   *
   * @description
   *
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   *
   * > Caso essa propriedade seja definida como `true`, a mensagem de erro será limitada a duas linhas
   * e um tooltip será exibido ao passar o mouse sobre a mensagem para mostrar o conteúdo completo.
   *
   * @default `false`
   */
  errorLimit = false;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * @optional
   *
   * @description
   *
   * Exibe a mensagem setada na propriedade `p-error-pattern` se o campo estiver vazio e for requerido.
   *
   * > Necessário que a propriedade `p-required` esteja habilitada.
   *
   * @default `false`
   */
  showErrorMessageRequired = false;
  /**
   * @description
   *
   * Converte o conteúdo do campo em maiúsulo automaticamente.
   *
   */
  upperCase = false;
  _maskNoLengthValidation = false;
  /**
   * @description
   *
   * Define se os caracteres especiais da máscara devem ser ignorados ao validar os comprimentos mínimo (`minLength`) e máximo (`maxLength`) do campo.
   *
   * - Quando `true`, apenas os caracteres alfanuméricos serão contabilizados para a validação dos comprimentos.
   * - Quando `false`, todos os caracteres, incluindo os especiais da máscara, serão considerados na validação.
   *
   * > Será ignorado essa propriedade , caso esteja utilizando junto com a propriedade `p-mask-format-model`.
   *
   * Exemplo:
   * ```
   * <po-input
   *   p-mask="999-999"
   *   p-maxlength="6"
   *   p-minlength="4"
   *   p-mask-no-length-validation="true"
   * ></po-input>
   * ```
   * - Entrada: `123-456` → Validação será aplicada somente aos números, ignorando o caractere especial `-`.
   *
   * @default `false`
   */
  set maskNoLengthValidation(value) {
    this._maskNoLengthValidation = convertToBoolean(value);
    this.validateModel();
  }
  get maskNoLengthValidation() {
    return this._maskNoLengthValidation;
  }
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao sair do campo.
   */
  blur = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao entrar do campo.
   */
  enter = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor e deixar o campo.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do model.
   */
  changeModel = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  displayAdditionalHelp = false;
  type;
  onChangePropagate = null;
  objMask;
  modelLastUpdate;
  isInvalid;
  hasValidatorRequired = false;
  subscription = new Subscription();
  onTouched = null;
  passedWriteValue = false;
  validatorChange;
  _maxlength;
  _minlength;
  _noAutocomplete = false;
  _placeholder = "";
  /**
   * @optional
   *
   * @description
   *
   * Define a propriedade nativa `autocomplete` do campo como `off`.
   *
   * > No componente `po-password` será definido como `new-password`.
   *
   * Nos componentes `po-password` e `po-login` o valor padrão será `true`.
   *
   * @default `false`
   */
  set noAutocomplete(value) {
    this._noAutocomplete = convertToBoolean(value);
  }
  get noAutocomplete() {
    return this._noAutocomplete;
  }
  /**
   * @optional
   *
   * @description
   *
   * Mensagem que aparecerá enquanto o campo não estiver preenchido.
   *
   * @default ''
   */
  set placeholder(value) {
    this._placeholder = value || "";
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * @description
   *
   * Se verdadeiro, desabilita o campo.
   *
   * @default `false`
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  disabled = false;
  set setDisabled(disabled) {
    this.disabled = disabled === "" ? true : convertToBoolean(disabled);
    this.validateModel();
  }
  /** Indica que o campo será somente leitura. */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  readonly = false;
  set setReadonly(readonly) {
    this.readonly = readonly === "" ? true : convertToBoolean(readonly);
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   * > Esta propriedade é desconsiderada quando o input está desabilitado `(p-disabled)`.
   *
   * @default `false`
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  required = false;
  set setRequired(required) {
    this.required = required === "" ? true : convertToBoolean(required);
    this.validateModel();
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /** Se verdadeiro, o campo receberá um botão para ser limpo. */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  clean = false;
  set setClean(clean) {
    this.clean = clean === "" ? true : convertToBoolean(clean);
  }
  /**
   * @description
   *
   * Expressão regular para validar o campo.
   * Quando o campo possuir uma máscara `(p-mask)` será automaticamente validado por ela, porém
   * é possível definir um p-pattern para substituir a validação da máscara.
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  pattern;
  set setPattern(pattern) {
    this.pattern = pattern;
    this.validateModel();
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica a quantidade máxima de caracteres que o campo aceita.
   */
  set maxlength(value) {
    if (!isNaN(parseInt(value, 10))) {
      this._maxlength = parseInt(value, 10);
      this.validateModel();
    } else if (!value) {
      this._maxlength = void 0;
      this.validateModel();
    }
  }
  get maxlength() {
    return this._maxlength;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica a quantidade mínima de caracteres que o campo aceita.
   */
  set minlength(value) {
    if (!isNaN(parseInt(value, 10))) {
      this._minlength = parseInt(value, 10);
      this.validateModel();
    } else if (!value) {
      this._minlength = void 0;
      this.validateModel();
    }
  }
  get minlength() {
    return this._minlength;
  }
  /**
   * @description
   *
   * Indica uma máscara para o campo. Exemplos: (+99) (99) 99999?-9999, 99999-999, 999.999.999-99.
   * A máscara gera uma validação automática do campo, podendo esta ser substituída por um REGEX específico
   * através da propriedade p-pattern.
   * O campo será sinalizado e o formulário ficará inválido quando o valor informado estiver fora do padrão definido,
   * mesmo quando desabilitado.
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  mask = "";
  set setMask(mask) {
    this.mask = mask;
    this.objMask = new PoMask(this.mask, this.maskFormatModel);
  }
  /**
   * @description
   *
   * Indica se o `model` receberá o valor formatado pela máscara ou apenas o valor puro (sem formatação).
   *
   * @default `false`
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  maskFormatModel = false;
  set setMaskFormatModel(maskFormatModel) {
    this.maskFormatModel = maskFormatModel === "" ? true : convertToBoolean(maskFormatModel);
    if (this.objMask instanceof PoMask) {
      this.objMask.formatModel = this.maskFormatModel;
      this.validateModel();
    }
  }
  constructor(cd) {
    this.cd = cd;
    this.objMask = new PoMask(this.mask, this.maskFormatModel);
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  callOnChange(value) {
    this.updateModel(value);
    this.controlChangeModelEmitter(value);
  }
  callUpdateModelWithTimeout(value) {
    setTimeout(() => this.updateModel(value));
  }
  controlChangeModelEmitter(value) {
    if (this.modelLastUpdate !== value || this.emitAllChanges) {
      this.changeModel.emit(value);
      this.modelLastUpdate = value;
    }
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd?.markForCheck();
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnChange(func) {
    this.onChangePropagate = func;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnTouched(func) {
    this.onTouched = func;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-nome-component
   *  #component
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, component)"
   * ></po-nome-component>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoNomeDoComponente): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  updateModel(value) {
    if (this.onChangePropagate) {
      this.onChangePropagate(value);
    }
  }
  validate(c) {
    this.subscription?.unsubscribe();
    if (!this.hasValidatorRequired && this.showErrorMessageRequired && c.hasValidator(Validators.required)) {
      this.hasValidatorRequired = true;
    }
    if (requiredFailed(this.required, this.disabled, this.getScreenValue())) {
      this.isInvalid = true;
      return {
        required: {
          valid: false
        }
      };
    }
    if (maxlengpoailed(this.maxlength, this.getScreenValue(), this.maskFormatModel ? false : this.maskNoLengthValidation)) {
      this.isInvalid = true;
      return {
        maxlength: {
          valid: false
        }
      };
    }
    if (minlengpoailed(this.minlength, this.getScreenValue(), this.maskFormatModel ? false : this.maskNoLengthValidation)) {
      this.isInvalid = true;
      return {
        minlength: {
          valid: false
        }
      };
    }
    if (patternFailed(this.pattern, c.value)) {
      this.isInvalid = true;
      this.validatePatternOnWriteValue(c.value);
      return {
        pattern: {
          valid: false
        }
      };
    }
    if (this.errorPattern !== "") {
      this.subscription = c.statusChanges.pipe(switchMap((status) => {
        if (status === "INVALID") {
          this.isInvalid = true;
          this.cd.markForCheck();
        }
        return [];
      })).subscribe();
    }
    this.isInvalid = false;
    return this.extraValidation(c);
  }
  // Função implementada do ControlValueAccessor
  writeValue(value) {
    this.writeValueModel(value);
    this.cd?.markForCheck();
  }
  validateModel() {
    if (this.validatorChange) {
      this.validatorChange();
    }
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  // utilizado para validar o pattern na inicializacao, fazendo dessa forma o campo fica sujo (dirty).
  validatePatternOnWriteValue(value) {
    if (value && this.passedWriteValue) {
      setTimeout(() => {
        this.updateModel(value);
      });
      this.passedWriteValue = false;
    }
  }
  static ɵfac = function PoInputBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoInputBaseComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoInputBaseComponent,
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      icon: [0, "p-icon", "icon"],
      emitAllChanges: [2, "p-emit-all-changes", "emitAllChanges", convertToBoolean],
      label: [0, "p-label", "label"],
      help: [0, "p-help", "help"],
      name: "name",
      errorAsyncProperties: [0, "p-error-async-properties", "errorAsyncProperties"],
      errorPattern: [0, "p-error-pattern", "errorPattern"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      optional: [0, "p-optional", "optional"],
      showErrorMessageRequired: [0, "p-required-field-error-message", "showErrorMessageRequired"],
      upperCase: [2, "p-upper-case", "upperCase", convertToBoolean],
      maskNoLengthValidation: [0, "p-mask-no-length-validation", "maskNoLengthValidation"],
      noAutocomplete: [0, "p-no-autocomplete", "noAutocomplete"],
      placeholder: [0, "p-placeholder", "placeholder"],
      setDisabled: [0, "p-disabled", "setDisabled"],
      setReadonly: [0, "p-readonly", "setReadonly"],
      setRequired: [0, "p-required", "setRequired"],
      showRequired: [0, "p-show-required", "showRequired"],
      setClean: [0, "p-clean", "setClean"],
      setPattern: [0, "p-pattern", "setPattern"],
      maxlength: [0, "p-maxlength", "maxlength"],
      minlength: [0, "p-minlength", "minlength"],
      setMask: [0, "p-mask", "setMask"],
      setMaskFormatModel: [0, "p-mask-format-model", "setMaskFormatModel"]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      blur: "p-blur",
      enter: "p-enter",
      change: "p-change",
      changeModel: "p-change-model",
      keydown: "p-keydown"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInputBaseComponent, [{
    type: Directive
  }], () => [{
    type: ChangeDetectorRef
  }], {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }],
    emitAllChanges: [{
      type: Input,
      args: [{
        alias: "p-emit-all-changes",
        transform: convertToBoolean
      }]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    errorAsyncProperties: [{
      type: Input,
      args: ["p-error-async-properties"]
    }],
    errorPattern: [{
      type: Input,
      args: ["p-error-pattern"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    showErrorMessageRequired: [{
      type: Input,
      args: ["p-required-field-error-message"]
    }],
    upperCase: [{
      type: Input,
      args: [{
        alias: "p-upper-case",
        transform: convertToBoolean
      }]
    }],
    maskNoLengthValidation: [{
      type: Input,
      args: ["p-mask-no-length-validation"]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    blur: [{
      type: Output,
      args: ["p-blur"]
    }],
    enter: [{
      type: Output,
      args: ["p-enter"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    changeModel: [{
      type: Output,
      args: ["p-change-model"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    noAutocomplete: [{
      type: Input,
      args: ["p-no-autocomplete"]
    }],
    placeholder: [{
      type: Input,
      args: ["p-placeholder"]
    }],
    setDisabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    setReadonly: [{
      type: Input,
      args: ["p-readonly"]
    }],
    setRequired: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }],
    setClean: [{
      type: Input,
      args: ["p-clean"]
    }],
    setPattern: [{
      type: Input,
      args: ["p-pattern"]
    }],
    maxlength: [{
      type: Input,
      args: ["p-maxlength"]
    }],
    minlength: [{
      type: Input,
      args: ["p-minlength"]
    }],
    setMask: [{
      type: Input,
      args: ["p-mask"]
    }],
    setMaskFormatModel: [{
      type: Input,
      args: ["p-mask-format-model"]
    }]
  });
})();
var _c0$V = ["inp"];
function PoDecimalComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵelement(1, "po-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-field-icon-disabled", ctx_r1.disabled);
    ɵɵproperty("p-icon", ctx_r1.icon);
  }
}
function PoDecimalComponent_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 10);
    ɵɵlistener("p-change-event", function PoDecimalComponent_po_clean_6_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-element-ref", ctx_r1.inputEl);
  }
}
function PoDecimalComponent_po_field_container_bottom_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 11);
    ɵɵlistener("p-additional-help", function PoDecimalComponent_po_field_container_bottom_7_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitAdditionalHelp());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r1.getAdditionalHelpTooltip())("p-append-in-body", ctx_r1.appendBox)("p-help", ctx_r1.help)("p-disabled", ctx_r1.disabled)("p-error-limit", ctx_r1.errorLimit)("p-error-pattern", ctx_r1.getErrorPatternMessage())("p-show-additional-help", ctx_r1.displayAdditionalHelp)("p-show-additional-help-icon", ctx_r1.showAdditionalHelpIcon());
  }
}
var poDecimalDefaultDecimalsLength = 2;
var poDecimalDefaultThousandMaxlength = 13;
var poDecimalMaxDecimalsLength = 15;
var poDecimalTotalLengthLimit = 16;
var PoDecimalComponent = class _PoDecimalComponent extends PoInputBaseComponent {
  el;
  poLanguageService;
  inputEl;
  id = `po-decimal[${uuid()}]`;
  _decimalsLength = poDecimalDefaultDecimalsLength;
  _thousandMaxlength = poDecimalDefaultThousandMaxlength;
  _locale;
  _min;
  _max;
  decimalSeparator;
  fireChange = false;
  isKeyboardAndroid = false;
  minusSign = "-";
  oldDotsLength = null;
  thousandSeparator;
  valueBeforeChange;
  subscriptionValidator = new Subscription();
  regex = {
    thousand: new RegExp("\\,", "g"),
    decimal: new RegExp("\\.", "g")
  };
  get autocomplete() {
    return this.noAutocomplete ? "off" : "on";
  }
  /**
   * @optional
   *
   * @description
   *
   * Quantidade máxima de casas decimais.
   *
   * > **Importante:**
   * - O valor máximo permitido é 15;
   * - A soma total de `p-decimals-length` com `p-thousand-maxlength` limita-se à 16;
   * - Esta propriedade sobrepõe apenas o valor **padrão** de `p-thousand-maxlength`;
   * - Caso `p-thousand-maxlength` tenha um valor definido, esta propriedade poderá receber apenas o valor restante do limite total (16).
   *
   * @default `2`
   */
  set decimalsLength(value) {
    let decimalsLength = convertToInt(value);
    decimalsLength = this.isValueBetweenAllowed(decimalsLength, poDecimalMaxDecimalsLength) ? decimalsLength : poDecimalDefaultDecimalsLength;
    if (this.isGreaterThanTotalLengthLimit(decimalsLength, this.thousandMaxlength)) {
      this.thousandMaxlength = poDecimalTotalLengthLimit - decimalsLength;
    }
    this._decimalsLength = decimalsLength;
  }
  get decimalsLength() {
    return this._decimalsLength;
  }
  /**
   * @optional
   *
   * @description
   *
   * Quantidade máxima de dígitos antes do separador decimal.
   *
   * > **Importante:**
   * - O valor máximo permitido é 13;
   * - A soma total de `p-decimals-length` com `p-thousand-maxlength` limita-se à 16;
   * - Esta propriedade sobrepõe o valor definido em `p-decimals-length`.
   *
   * @default `13`
   */
  set thousandMaxlength(value) {
    let thousandMaxlength = convertToInt(value);
    if (this.decimalsLength > poDecimalDefaultDecimalsLength && !thousandMaxlength) {
      thousandMaxlength = poDecimalTotalLengthLimit - this.decimalsLength;
    }
    thousandMaxlength = this.isValueBetweenAllowed(thousandMaxlength, poDecimalDefaultThousandMaxlength) ? thousandMaxlength : poDecimalDefaultThousandMaxlength;
    if (this.isGreaterThanTotalLengthLimit(this.decimalsLength, thousandMaxlength)) {
      this.decimalsLength = poDecimalTotalLengthLimit - thousandMaxlength;
    }
    this._thousandMaxlength = thousandMaxlength;
  }
  get thousandMaxlength() {
    return this._thousandMaxlength;
  }
  /**
   * @optional
   *
   * @description
   *
   * Informa o locale(país) para a formatação do valor.
   * Por padrão o valor será configurado segundo a o módulo [`I18n`](documentation/po-i18n)
   *
   * > Para ver quais linguagens suportadas acesse [`I18n`](documentation/po-i18n)
   *
   */
  set locale(locale) {
    this._locale = locale;
    this.setNumbersSeparators();
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor mínimo.
   */
  set min(value) {
    if (!isNaN(value)) {
      this._min = value;
      this.validateModel();
    } else if (!value) {
      this._min = void 0;
      this.validateModel();
    }
  }
  get min() {
    return this._min;
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor máximo.
   */
  set max(value) {
    if (!isNaN(value)) {
      this._max = value;
      this.validateModel();
    } else if (!value) {
      this._max = void 0;
      this.validateModel();
    }
  }
  get max() {
    return this._max;
  }
  constructor(el, poLanguageService, cd) {
    super(cd);
    this.el = el;
    this.poLanguageService = poLanguageService;
    this.isKeyboardAndroid = !!navigator.userAgent.match(/Android/i);
  }
  ngOnInit() {
    this.setNumbersSeparators();
  }
  setNumbersSeparators() {
    const {
      decimalSeparator,
      thousandSeparator
    } = this.poLanguageService.getNumberSeparators(this._locale);
    this.decimalSeparator = decimalSeparator;
    this.thousandSeparator = thousandSeparator;
    this.regex = {
      thousand: new RegExp("\\" + thousandSeparator, "g"),
      decimal: new RegExp("\\" + decimalSeparator, "g")
    };
  }
  ngAfterViewInit() {
    this.verifyAutoFocus();
    this.setPaddingInput();
  }
  ngOnDestroy() {
    this.subscriptionValidator?.unsubscribe();
  }
  clear(value) {
    this.callOnChange(value);
    this.controlChangeEmitter();
    if (this.errorAsyncProperties?.triggerMode === "changeModel") {
      this.verifyErrorAsync(value);
    }
  }
  extraValidation(abstractControl) {
    const value = abstractControl.value;
    const thousandValue = Math.trunc(value);
    this.errorPattern = this.errorPattern !== "Valor Inválido" ? this.errorPattern : "";
    if (minFailed(this.min, value)) {
      return {
        min: {
          valid: false
        }
      };
    }
    if (maxFailed(this.max, value)) {
      return {
        max: {
          valid: false
        }
      };
    }
    if (maxlengpoailed(this.thousandMaxlength, thousandValue) && this.thousandMaxlength < poDecimalDefaultThousandMaxlength || maxlengpoailed(poDecimalTotalLengthLimit, value)) {
      return {
        max: {
          valid: false
        }
      };
    }
    return null;
  }
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  getScreenValue() {
    return this.inputEl ? this.inputEl.nativeElement.value : "";
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty") && (this.getScreenValue() !== "" || this.showErrorMessageRequired && (this.required || this.hasValidatorRequired));
  }
  hasLetters(value = "") {
    return value.match(/[a-zA-Z:;+=_´`^~"'?!@#$%¨&*()><{}çÇ\[\]/\\|]+/);
  }
  hasNotSpace(value = "") {
    return value.match(/^\S*$/);
  }
  isValidNumber(event) {
    const keyValue = String.fromCharCode(event.which);
    const validKey = event.which !== 8 && event.which !== 0;
    return !this.hasLetters(keyValue) && this.hasNotSpace(keyValue) && validKey;
  }
  // função responsável por adicionar os zeros com as casa decimais ao sair do campo.
  onBlur(event) {
    this.onTouched?.();
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
    const value = event.target.value;
    if (value) {
      if (this.hasLetters(value) || this.containsMoreThanOneDecimalSeparator(value)) {
        this.setViewValue("");
        this.callOnChange(void 0);
        return;
      }
      const valueWithoutThousandSeparator = this.formatValueWithoutThousandSeparator(value);
      const formatedViewValue = this.formatToViewValue(valueWithoutThousandSeparator);
      this.setViewValue(formatedViewValue);
      if (!formatedViewValue) {
        this.callOnChange(void 0);
        return;
      }
    }
    this.blur.emit();
    this.controlChangeEmitter();
  }
  onFocus(event) {
    this.valueBeforeChange = this.getScreenValue();
    this.enter.emit();
  }
  onInput(event) {
    const selectionStart = event.target.selectionStart;
    const selectionEnd = event.target.selectionEnd;
    let modelValue;
    if (this.isKeyboardAndroid) {
      this.onInputKeyboardAndroid(event);
    }
    modelValue = this.formatValueWithoutThousandSeparator(event.target.value);
    modelValue = this.addZeroBefore(modelValue);
    const viewValue = this.formatMask(modelValue);
    if (viewValue) {
      this.setViewValue(viewValue);
      this.setCursorInput(event, selectionStart, selectionEnd);
    }
    this.callOnChange(this.formatToModelValue(modelValue));
    if (this.errorAsyncProperties?.triggerMode === "changeModel") {
      this.verifyErrorAsync(this.formatToModelValue(modelValue));
    }
  }
  onInputKeyboardAndroid(event) {
    const inputValue = event.target.value;
    const selectionStart = event.target.selectionStart;
    const hasLetters = this.hasLetters(inputValue);
    if (hasLetters) {
      this.setViewValue(inputValue.replace(hasLetters[0], ""));
      return event.preventDefault();
    } else {
      const position = selectionStart - 1;
      const key = inputValue.charAt(position);
      this.setPositionValue(event);
      if (this.isValidKey(event, key)) {
        this.setViewValue(inputValue);
      }
    }
  }
  onKeyDown(event) {
    const isFieldFocused = document.activeElement === this.inputEl.nativeElement;
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  onKeyPress(event) {
    this.isValidKey(event);
  }
  setPaddingInput() {
    setTimeout(() => {
      const selectorIcons = ".po-field-icon-container:not(.po-field-icon-container-left) > .po-icon";
      let icons = this.el.nativeElement.querySelectorAll(selectorIcons).length;
      if (this.clean) {
        icons++;
      }
      if (icons) {
        this.inputEl.nativeElement.style.paddingRight = `${icons * 36}px`;
      }
    });
  }
  writeValueModel(value) {
    let formatedViewValue;
    if (this.inputEl) {
      if (value || value === 0) {
        formatedViewValue = this.formatToViewValue(value);
        this.setViewValue(formatedViewValue);
      } else {
        this.setViewValue("");
      }
    }
    if (formatedViewValue) {
      this.change.emit(value);
      this.verifyErrorAsync(value);
    }
  }
  getErrorPatternMessage() {
    return this.errorPattern !== "" && this.hasInvalidClass() ? this.errorPattern : "";
  }
  // responsável por adicionar 0 antes da virgula (decimalSeparator).
  addZeroBefore(value) {
    const isDecimalSeparator = value === this.decimalSeparator;
    return isDecimalSeparator ? `0${value}` : value;
  }
  containsComma(value) {
    return value.includes(this.decimalSeparator);
  }
  containsMoreThanOneDecimalSeparator(value = "") {
    const foundComma = value.match(this.regex.decimal);
    return !!(foundComma && foundComma.length > 1);
  }
  controlChangeEmitter() {
    const elementValue = this.getScreenValue();
    if (elementValue !== this.valueBeforeChange) {
      this.fireChange = true;
      setTimeout(() => {
        this.change.emit(elementValue);
        const errorAsync = this.errorAsyncProperties;
        if (errorAsync?.triggerMode === "change" || !errorAsync?.triggerMode) {
          this.verifyErrorAsync(elementValue);
        }
      }, 200);
    }
  }
  formatMask(value) {
    if (value.match(this.regex.decimal)) {
      const regex = new RegExp(`(\\d)(?=(\\d{3})+(?!\\d)${this.decimalSeparator})`, "g");
      return value.toString().replace(regex, `$1${this.thousandSeparator}`);
    }
    return value.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${this.thousandSeparator}`);
  }
  formatToModelValue(value) {
    const formattedValue = this.replaceCommaToDot(value);
    const parsedValue = formattedValue ? parseFloat(Number(formattedValue).toFixed(this.decimalsLength)) : void 0;
    return parsedValue === 0 || parsedValue ? parsedValue : void 0;
  }
  formatToViewValue(value) {
    value = this.replaceCommaToDot(value);
    const numberValue = Number(value).toFixed(this.decimalsLength);
    const valueBeforeDot = this.getValueBeforeSeparator(numberValue, ".");
    const valueAfterDot = this.getValueAfterSeparator(numberValue, ".");
    const formatedNumber = this.formatMask(valueBeforeDot);
    if (formatedNumber === "NaN") {
      return "";
    }
    if (this.decimalsLength === 0) {
      return formatedNumber;
    } else {
      return `${formatedNumber}${this.decimalSeparator}${valueAfterDot}`;
    }
  }
  formatValueWithoutThousandSeparator(value = "") {
    return value.toString().replace(this.regex.thousand, "");
  }
  getValueAfterSeparator(value = "", separator) {
    return value.split(separator)[1] || "";
  }
  getValueBeforeSeparator(value = "", separator) {
    return value.split(separator)[0] || "";
  }
  hasLessDot(value) {
    if (value) {
      const dots = value.match(this.regex.thousand);
      const dotsLength = dots && dots.length;
      if (dotsLength < this.oldDotsLength) {
        this.oldDotsLength = dotsLength;
        return true;
      }
    }
    if (!value) {
      this.oldDotsLength = null;
    }
    return false;
  }
  hasMoreDot(value) {
    if (value) {
      const dots = value.match(this.regex.thousand);
      const dotsLength = dots && dots.length;
      if (dotsLength > this.oldDotsLength) {
        this.oldDotsLength = dotsLength;
        return true;
      }
    }
    if (!value) {
      this.oldDotsLength = null;
    }
    return false;
  }
  hasMinusSignInvalidPosition(event) {
    const keyIsMinusSign = event.key === this.minusSign;
    const selectionStart = event.target.selectionStart;
    return keyIsMinusSign && selectionStart !== 0;
  }
  isInvalidKey(event, charCode) {
    const isInvalidNumber = !this.isValidNumber(event);
    return this.verifyInsertComma(event) || this.verifyThousandLength(event) || this.verifyValueAfterComma(event) || this.verifyInsertMinusSign(event) || this.hasMinusSignInvalidPosition(event) || isInvalidNumber || this.validateCursorPositionBeforeSeparator(event) || this.verifyDecimalLengthIsZeroAndKeyPressedIsComma(charCode);
  }
  isGreaterThanTotalLengthLimit(decimalsMaxLength, thousandMaxlength) {
    return decimalsMaxLength + thousandMaxlength > poDecimalTotalLengthLimit;
  }
  isKeyDecimalSeparator(event) {
    return event.key === this.decimalSeparator || event.char === this.decimalSeparator;
  }
  isPositionAfterDecimalSeparator(positionCursor, value) {
    const indexComma = value && value.indexOf(this.decimalSeparator);
    if (indexComma && this.decimalsLength > 0) {
      return positionCursor > indexComma;
    }
  }
  isSelectionStartDifferentSelectionEnd(target) {
    return target.selectionStart !== target.selectionEnd;
  }
  isValidKey(event, key) {
    const charCode = event.which || event.keyCode;
    const validKey = event.which === 8 || event.which === 0;
    if (validKey && !this.isKeyboardAndroid) {
      return;
    }
    if (key) {
      event.key = key;
    }
    if (this.isInvalidKey(event, charCode)) {
      event.preventDefault();
      return false;
    }
    return true;
  }
  isValueBetweenAllowed(value, maxAllowed) {
    return value >= 0 && value <= maxAllowed;
  }
  // Quando decimalsLength for 0 não deve permitir informar vírgula (decimalSeparator)
  verifyDecimalLengthIsZeroAndKeyPressedIsComma(charCode) {
    return charCode === 44 && this.decimalsLength === 0;
  }
  verifyAutoFocus() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  setInitialSelectionRange(target, selectionStart, selectionEnd) {
    if (selectionStart === 1 && selectionEnd === 1) {
      return target.setSelectionRange(selectionStart + 1, selectionEnd + 1);
    }
    return target.setSelectionRange(selectionStart - 1, selectionEnd - 1);
  }
  replaceAt(value, index, replace) {
    return value.substring(0, index) + replace + value.substring(index + 1);
  }
  replaceCommaToDot(value = "") {
    if (this.decimalSeparator === ",") {
      value = value.toString().replace(this.regex.decimal, ".");
    }
    return value;
  }
  setCursorInput(event, selectionStart, selectionEnd) {
    const target = event.target;
    const viewValue = target.value;
    if (this.hasMoreDot(viewValue) || viewValue === "0" + this.decimalSeparator) {
      return target.setSelectionRange(selectionStart + 1, selectionEnd + 1);
    }
    if (this.hasLessDot(viewValue)) {
      this.setInitialSelectionRange(target, selectionStart, selectionEnd);
    }
    return target.setSelectionRange(selectionStart, selectionEnd);
  }
  setPositionValue(event) {
    const value = event.target.value;
    const position = event.target.selectionStart - 1;
    if (position > 0 && event.key === this.minusSign) {
      event.target.value = value.substring(0, position) + value.substr(position + 1);
    }
  }
  setViewValue(value) {
    this.inputEl.nativeElement.value = value;
  }
  validateCursorPositionBeforeSeparator(event) {
    const target = event.target;
    const originalValue = this.formatValueWithoutThousandSeparator(target.value);
    const valueBeforeSeparator = this.getValueBeforeSeparator(target.value, this.decimalSeparator);
    const valueBeforeSeparatorOriginal = this.getValueBeforeSeparator(originalValue, this.decimalSeparator);
    if (this.isSelectionStartDifferentSelectionEnd(target)) {
      return false;
    }
    return target.selectionStart <= valueBeforeSeparator.length && valueBeforeSeparatorOriginal.length === this.thousandMaxlength && !this.isKeyDecimalSeparator(event);
  }
  verifyErrorAsync(value) {
    if (this.errorPattern !== "" && this.errorAsyncProperties?.errorAsync) {
      const errorAsync = this.errorAsyncProperties.errorAsync(value);
      if (isObservable(errorAsync)) {
        this.subscriptionValidator?.unsubscribe();
        this.subscriptionValidator = errorAsync.pipe(switchMap((error) => {
          const element = this.el.nativeElement;
          if (error) {
            element.classList.add("ng-invalid");
            element.classList.add("ng-dirty");
            this.cd.detectChanges();
          } else if (element.classList.contains("ng-invalid") && element.classList.contains("ng-dirty") && !this.isInvalid) {
            element.classList.remove("ng-invalid");
            this.cd.detectChanges();
          }
          return of("");
        })).subscribe();
      }
    }
  }
  verifyThousandLength(event) {
    const target = event.target;
    const originalValue = this.formatValueWithoutThousandSeparator(target.value);
    const valueBeforeSeparatorOriginal = this.getValueBeforeSeparator(originalValue, this.decimalSeparator);
    if (this.isSelectionStartDifferentSelectionEnd(target)) {
      return false;
    }
    return valueBeforeSeparatorOriginal.length >= this.thousandMaxlength && !this.isKeyDecimalSeparator(event) && this.isPositionAfterDecimalSeparator(target.selectionStart - this.decimalsLength, target.value);
  }
  verifyInsertComma(e) {
    const hasComma = this.containsComma(e.target.value);
    return hasComma && e.key === this.decimalSeparator;
  }
  verifyInsertMinusSign(event) {
    const value = event.target.value;
    const indexMinusSign = value.lastIndexOf(this.minusSign) !== -1;
    const positionMinusSign = value.lastIndexOf("-");
    const occurancesMinusSign = value.match(new RegExp("-", "g"));
    if (this.isKeyboardAndroid && indexMinusSign && occurancesMinusSign.length > 1) {
      event.target.value = this.replaceAt(value, positionMinusSign, "");
    }
    return indexMinusSign && event.key === this.minusSign;
  }
  verifyValueAfterComma(event) {
    const value = event.target.value;
    const selectionStart = event.target.selectionStart;
    const valueAfterSeparator = this.getValueAfterSeparator(value, this.decimalSeparator);
    return this.isPositionAfterDecimalSeparator(selectionStart, value) && valueAfterSeparator.length >= this.decimalsLength;
  }
  static ɵfac = function PoDecimalComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDecimalComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDecimalComponent,
    selectors: [["po-decimal"]],
    viewQuery: function PoDecimalComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$V, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
      }
    },
    inputs: {
      decimalsLength: [0, "p-decimals-length", "decimalsLength"],
      thousandMaxlength: [0, "p-thousand-maxlength", "thousandMaxlength"],
      locale: [0, "p-locale", "locale"],
      min: [0, "p-min", "min"],
      max: [0, "p-max", "max"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoDecimalComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoDecimalComponent),
      multi: true
    }]), ɵɵInheritDefinitionFeature],
    decls: 8,
    vars: 22,
    consts: [["inp", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["class", "po-field-icon-container-left", 4, "ngIf"], ["inputmode", "decimal", "type", "text", 1, "po-input", 3, "blur", "focus", "input", "keypress", "keydown", "autocomplete", "disabled", "id", "placeholder", "readonly", "required"], [1, "po-field-icon-container-right"], ["class", "po-icon-input", 3, "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-limit", "p-error-pattern", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [1, "po-field-icon-container-left"], [1, "po-field-icon", "po-icon-input", 3, "p-icon"], [1, "po-icon-input", 3, "p-change-event", "p-element-ref"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-limit", "p-error-pattern", "p-show-additional-help", "p-show-additional-help-icon"]],
    template: function PoDecimalComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2);
        ɵɵtemplate(2, PoDecimalComponent_div_2_Template, 2, 3, "div", 3);
        ɵɵelementStart(3, "input", 4, 0);
        ɵɵlistener("blur", function PoDecimalComponent_Template_input_blur_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur($event));
        })("focus", function PoDecimalComponent_Template_input_focus_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFocus($event));
        })("input", function PoDecimalComponent_Template_input_input_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onInput($event));
        })("keypress", function PoDecimalComponent_Template_input_keypress_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyPress($event));
        })("keydown", function PoDecimalComponent_Template_input_keydown_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(5, "div", 5);
        ɵɵtemplate(6, PoDecimalComponent_po_clean_6_Template, 1, 1, "po-clean", 6);
        ɵɵelementEnd()();
        ɵɵtemplate(7, PoDecimalComponent_po_field_container_bottom_7_Template, 1, 8, "po-field-container-bottom", 7);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.icon);
        ɵɵadvance();
        ɵɵclassProp("po-input-icon-left", ctx.icon)("po-input-icon-right", ctx.clean);
        ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required);
        ɵɵattribute("max", ctx.max)("min", ctx.min)("name", ctx.name);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.readonly);
      }
    },
    dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDecimalComponent, [{
    type: Component,
    args: [{
      selector: "po-decimal",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoDecimalComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoDecimalComponent),
        multi: true
      }],
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div *ngIf="icon" class="po-field-icon-container-left">
      <po-icon class="po-field-icon po-icon-input" [class.po-field-icon-disabled]="disabled" [p-icon]="icon"></po-icon>
    </div>

    <input
      #inp
      class="po-input"
      [attr.max]="max"
      [attr.min]="min"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-icon-left]="icon"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      inputmode="decimal"
      type="text"
      (blur)="onBlur($event)"
      (focus)="onFocus($event)"
      (input)="onInput($event)"
      (keypress)="onKeyPress($event)"
      (keydown)="onKeyDown($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="po-icon-input"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom
    *ngIf="!readonly"
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-limit]="errorLimit"
    [p-error-pattern]="getErrorPatternMessage()"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: PoLanguageService
  }, {
    type: ChangeDetectorRef
  }], {
    inputEl: [{
      type: ViewChild,
      args: ["inp", {
        read: ElementRef,
        static: true
      }]
    }],
    decimalsLength: [{
      type: Input,
      args: ["p-decimals-length"]
    }],
    thousandMaxlength: [{
      type: Input,
      args: ["p-thousand-maxlength"]
    }],
    locale: [{
      type: Input,
      args: ["p-locale"]
    }],
    min: [{
      type: Input,
      args: ["p-min"]
    }],
    max: [{
      type: Input,
      args: ["p-max"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDecimalComponent, {
    className: "PoDecimalComponent",
    filePath: "lib/components/po-field/po-decimal/po-decimal.component.ts",
    lineNumber: 84
  });
})();
var _c0$U = ["inp"];
var PoInputGeneric = class _PoInputGeneric extends PoInputBaseComponent {
  inputEl;
  type = "text";
  el;
  valueBeforeChange;
  timeoutChange;
  subscriptionValidator = new Subscription();
  get autocomplete() {
    return this.noAutocomplete ? "off" : "on";
  }
  constructor(el, cd) {
    super(cd);
    this.el = el;
  }
  onKeydown(e) {
    if (this.mask && !this.readonly && e.target.keyCode !== 229) {
      this.objMask.keydown(e);
      if (this.passedWriteValue) {
        this.validateClassesForMask(true);
      }
    }
  }
  onKeyup(e) {
    if (this.mask && !this.readonly) {
      if (e.target.keyCode !== 229) {
        this.objMask.keyup(e);
      }
      this.callOnChange(this.objMask.valueToModel);
      if (this.errorAsyncProperties?.triggerMode === "changeModel") {
        this.verifyErrorAsync();
      }
    }
  }
  ngAfterViewInit() {
    this.afterViewInit();
  }
  afterViewInit() {
    this.verifyAutoFocus();
    if (this.type !== "password") {
      this.setPaddingInput();
    }
  }
  ngOnDestroy() {
    this.subscriptionValidator?.unsubscribe();
  }
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  onKeyDown(event) {
    const isFieldFocused = document.activeElement === this.inputEl.nativeElement;
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  setPaddingInput() {
    setTimeout(() => {
      const selectorIcons = ".po-field-icon-container:not(.po-field-icon-container-left) > .po-icon";
      let icons = this.el.nativeElement.querySelectorAll(selectorIcons).length;
      if (this.clean) {
        icons++;
      }
      if (icons) {
        this.inputEl.nativeElement.style.paddingRight = `${icons * 36}px`;
      }
    });
  }
  verifyAutoFocus() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  eventOnInput(e) {
    let value = "";
    if (!this.mask) {
      value = this.validMaxLength(this.maxlength, e.target.value);
      this.inputEl.nativeElement.value = value;
    } else {
      this.objMask.blur(e);
      this.inputEl.nativeElement.value = this.objMask.valueToInput;
      value = this.objMask.valueToModel;
    }
    this.inputEl.nativeElement.value = this.upperCase ? String(this.inputEl.nativeElement.value).toUpperCase() : this.inputEl.nativeElement.value;
    value = this.upperCase ? value.toUpperCase() : value;
    this.callOnChange(value);
    if (this.errorAsyncProperties?.triggerMode === "changeModel") {
      this.verifyErrorAsync();
    }
  }
  validMaxLength(maxlength, value) {
    return (maxlength || maxlength === 0) && value.length > maxlength ? value.toString().substring(0, maxlength) : value;
  }
  eventOnFocus(e) {
    this.valueBeforeChange = this.inputEl.nativeElement.value;
    this.enter.emit();
  }
  eventOnBlur(e) {
    this.onTouched?.();
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
    if (this.mask) {
      this.objMask.blur(e);
    }
    if (e.type === "blur") {
      this.blur.emit();
      this.controlChangeEmitter();
    }
  }
  controlChangeEmitter() {
    const elementValue = this.inputEl.nativeElement.value;
    if (elementValue !== this.valueBeforeChange) {
      clearTimeout(this.timeoutChange);
      this.timeoutChange = setTimeout(() => {
        this.change.emit(elementValue);
        const errorAsync = this.errorAsyncProperties;
        if (errorAsync?.triggerMode === "change" || !errorAsync?.triggerMode) {
          this.verifyErrorAsync();
        }
      }, 200);
    }
  }
  eventOnClick(e) {
    if (this.mask) {
      this.objMask.click(e);
    }
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty") && (this.inputEl.nativeElement.value !== "" || this.showErrorMessageRequired && (this.required || this.hasValidatorRequired));
  }
  verifyErrorAsync() {
    if (this.errorPattern !== "" && this.errorAsyncProperties?.errorAsync) {
      const errorAsync = this.errorAsyncProperties.errorAsync(this.inputEl.nativeElement.value);
      if (isObservable(errorAsync)) {
        this.subscriptionValidator.unsubscribe();
        this.subscriptionValidator = errorAsync.pipe(switchMap((error) => {
          const element = this.el.nativeElement;
          if (error) {
            element.classList.add("ng-invalid");
            element.classList.add("ng-dirty");
            this.cd.detectChanges();
          } else if (element.classList.contains("ng-invalid") && element.classList.contains("ng-dirty") && !this.isInvalid) {
            element.classList.remove("ng-invalid");
            this.cd.detectChanges();
          }
          return of("");
        })).subscribe();
      }
    }
  }
  getErrorPattern() {
    return this.errorPattern !== "" && this.hasInvalidClass() ? this.errorPattern : "";
  }
  validateClassesForPattern() {
    const value = this.getScreenValue();
    const element = this.el.nativeElement;
    if (value && !this.verifyPattern(this.pattern, value)) {
      element.classList.add("ng-invalid");
      element.classList.add("ng-dirty");
    } else {
      element.classList.remove("ng-invalid");
    }
  }
  validateClassesForMask(keyDown = false) {
    const element = this.el.nativeElement;
    const elementValue = this.inputEl.nativeElement.value;
    if (!keyDown && !elementValue) {
      element.classList.add("ng-invalid-mask");
    } else {
      element.classList.remove("ng-invalid-mask");
    }
  }
  verifyPattern(pattern, value) {
    return new RegExp(pattern).test(value);
  }
  clear(value) {
    this.callOnChange(value);
    this.controlChangeEmitter();
    if (this.errorAsyncProperties?.triggerMode === "changeModel") {
      this.verifyErrorAsync();
    }
  }
  writeValueModel(value) {
    this.passedWriteValue = true;
    if (this.inputEl) {
      if (value) {
        if (this.mask) {
          this.inputEl.nativeElement.value = this.objMask.controlFormatting(String(value));
          if (this.objMask.formatModel) {
            this.callUpdateModelWithTimeout(this.objMask.valueToModel);
          }
        } else {
          this.inputEl.nativeElement.value = value;
        }
      } else {
        this.inputEl.nativeElement.value = "";
      }
    }
    if (value) {
      this.validateInitMask();
      this.changeModel.emit(value);
      this.verifyErrorAsync();
    }
  }
  getScreenValue() {
    const screenValue = this.inputEl && this.inputEl.nativeElement.value || void 0;
    if (this.type === "number") {
      const parsedValue = parseFloat(screenValue);
      return parsedValue || parsedValue === 0 ? parsedValue : null;
    } else {
      return screenValue;
    }
  }
  validateInitMask() {
    if (this.mask) {
      this.validateClassesForMask();
    }
  }
  static ɵfac = function PoInputGeneric_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoInputGeneric)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoInputGeneric,
    viewQuery: function PoInputGeneric_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$U, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
      }
    },
    hostBindings: function PoInputGeneric_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function PoInputGeneric_keydown_HostBindingHandler($event) {
          return ctx.onKeydown($event);
        })("keyup", function PoInputGeneric_keyup_HostBindingHandler($event) {
          return ctx.onKeyup($event);
        });
      }
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInputGeneric, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    inputEl: [{
      type: ViewChild,
      args: ["inp", {
        read: ElementRef,
        static: true
      }]
    }],
    onKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    onKeyup: [{
      type: HostListener,
      args: ["keyup", ["$event"]]
    }]
  });
})();
function PoEmailComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵelement(1, "po-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMapInterpolate1("po-field-icon ", ctx_r1.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
    ɵɵclassProp("po-field-icon-disabled", ctx_r1.disabled);
    ɵɵproperty("p-icon", ctx_r1.icon);
  }
}
function PoEmailComponent_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 10);
    ɵɵlistener("p-change-event", function PoEmailComponent_po_clean_6_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.disabled ? "po-icon-input-disabled" : "po-icon-input");
    ɵɵproperty("p-element-ref", ctx_r1.inputEl);
  }
}
function PoEmailComponent_po_field_container_bottom_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 11);
    ɵɵlistener("p-additional-help", function PoEmailComponent_po_field_container_bottom_7_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitAdditionalHelp());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r1.getAdditionalHelpTooltip())("p-append-in-body", ctx_r1.appendBox)("p-help", ctx_r1.help)("p-disabled", ctx_r1.disabled)("p-error-pattern", ctx_r1.getErrorPattern())("p-error-limit", ctx_r1.errorLimit)("p-show-additional-help", ctx_r1.displayAdditionalHelp)("p-show-additional-help-icon", ctx_r1.showAdditionalHelpIcon());
  }
}
var providers$4 = [{
  provide: NG_VALUE_ACCESSOR,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoEmailComponent),
  multi: true
}, {
  provide: NG_VALIDATORS,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoEmailComponent),
  multi: true
}];
var PoEmailComponent = class _PoEmailComponent extends PoInputGeneric {
  id = `po-email[${uuid()}]`;
  icon = "ICON_MAIL";
  type = "email";
  // Consideramos o uso do nosso pattern com a seguinte expressão.
  // Antes do símbolo @:
  // - não há limite de caracteres.
  // - não pode haver espaços em branco, caracteres acentuados, caracteres especiais ou símbolos.
  // - pode começar com letras, números, hífen ou undescore (underline).
  //
  // Depois do símbolo @:
  // - o domínio tem um limite de até 66 caracteres após um separador.
  // - separador deve ser um 'ponto' (.).
  // - o primeiro bloco pode conter letras, números, hífen ou underscore (underline).
  // - após o primeiro separador é permitido apenas letras.
  // - não pode haver espaços em branco, caracteres acentuados, caracteres especiais ou símbolos.
  //
  // Limite total de 254 caracteres para o e-mail.
  //
  // As recomendações foram consultadas nas RFC 1034, RFC 5321 e RFC 5322.
  //
  // RFC 1034 - https://datatracker.ietf.org/doc/html/rfc1034#section-3
  // RFC 5321 - https://datatracker.ietf.org/doc/html/rfc5321#section-4.5.3.1
  // RFC 5322 - https://datatracker.ietf.org/doc/html/rfc5322#section-3.4
  pattern = "^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([A-Za-z]{2,66}(?:\\.[A-Za-z]{2})?)$";
  mask = "";
  listener = this.validateClassesForPattern.bind(this);
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
    this.maxlength = 254;
  }
  ngAfterViewInit() {
    setTimeout(() => {
      if (!this.onChangePropagate) {
        this.inputEl.nativeElement.addEventListener("keyup", this.listener);
      }
    });
    super.ngAfterViewInit();
  }
  ngOnDestroy() {
    if (!this.onChangePropagate) {
      this.inputEl.nativeElement.removeEventListener("keyup", this.listener);
    }
  }
  extraValidation(c) {
    return null;
  }
  static ɵfac = function PoEmailComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoEmailComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoEmailComponent,
    selectors: [["po-email"]],
    standalone: false,
    features: [ɵɵProvidersFeature(providers$4), ɵɵInheritDefinitionFeature],
    decls: 8,
    vars: 21,
    consts: [["inp", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["class", "po-field-icon-container-left", 4, "ngIf"], [1, "po-input", 3, "blur", "click", "focus", "input", "keydown", "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "type"], [1, "po-field-icon-container-right"], [3, "class", "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [1, "po-field-icon-container-left"], [3, "p-icon"], [3, "p-change-event", "p-element-ref"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon"]],
    template: function PoEmailComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2);
        ɵɵtemplate(2, PoEmailComponent_div_2_Template, 2, 6, "div", 3);
        ɵɵelementStart(3, "input", 4, 0);
        ɵɵlistener("blur", function PoEmailComponent_Template_input_blur_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnBlur($event));
        })("click", function PoEmailComponent_Template_input_click_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnClick($event));
        })("focus", function PoEmailComponent_Template_input_focus_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnFocus($event));
        })("input", function PoEmailComponent_Template_input_input_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnInput($event));
        })("keydown", function PoEmailComponent_Template_input_keydown_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(5, "div", 5);
        ɵɵtemplate(6, PoEmailComponent_po_clean_6_Template, 1, 4, "po-clean", 6);
        ɵɵelementEnd()();
        ɵɵtemplate(7, PoEmailComponent_po_field_container_bottom_7_Template, 1, 8, "po-field-container-bottom", 7);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.icon);
        ɵɵadvance();
        ɵɵclassProp("po-input-icon-left", ctx.icon)("po-input-icon-right", ctx.clean);
        ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("type", ctx.type);
        ɵɵattribute("name", ctx.name);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.readonly);
      }
    },
    dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoEmailComponent, [{
    type: Component,
    args: [{
      selector: "po-email",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: providers$4,
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div *ngIf="icon" class="po-field-icon-container-left">
      <po-icon
        class="po-field-icon {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        [class.po-field-icon-disabled]="disabled"
        [p-icon]="icon"
      ></po-icon>
    </div>

    <input
      #inp
      class="po-input"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-icon-left]="icon"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [type]="type"
      (blur)="eventOnBlur($event)"
      (click)="eventOnClick($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
      (keydown)="onKeyDown($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="{{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom
    *ngIf="!readonly"
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
    [p-error-limit]="errorLimit"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoEmailComponent, {
    className: "PoEmailComponent",
    filePath: "lib/components/po-field/po-email/po-email.component.ts",
    lineNumber: 64
  });
})();
var _c0$T = ["inp"];
function PoInputComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵelement(1, "po-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMapInterpolate1("po-field-icon ", ctx_r1.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
    ɵɵclassProp("po-field-icon-disabled", ctx_r1.disabled);
    ɵɵproperty("p-icon", ctx_r1.icon);
  }
}
function PoInputComponent_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 10);
    ɵɵlistener("p-change-event", function PoInputComponent_po_clean_6_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.disabled ? "po-icon-input-disabled" : "po-icon-input");
    ɵɵproperty("p-element-ref", ctx_r1.inputEl);
  }
}
function PoInputComponent_po_field_container_bottom_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 11);
    ɵɵlistener("p-additional-help", function PoInputComponent_po_field_container_bottom_7_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitAdditionalHelp());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r1.getAdditionalHelpTooltip())("p-append-in-body", ctx_r1.appendBox)("p-help", ctx_r1.help)("p-disabled", ctx_r1.disabled)("p-error-pattern", ctx_r1.getErrorPattern())("p-error-limit", ctx_r1.errorLimit)("p-show-additional-help", ctx_r1.displayAdditionalHelp)("p-show-additional-help-icon", ctx_r1.showAdditionalHelpIcon());
  }
}
var PoInputComponent = class _PoInputComponent extends PoInputGeneric {
  inp;
  id = `po-input[${uuid()}]`;
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
  }
  extraValidation(c) {
    return null;
  }
  static ɵfac = function PoInputComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoInputComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoInputComponent,
    selectors: [["po-input"]],
    viewQuery: function PoInputComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$T, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inp = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoInputComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoInputComponent),
      multi: true
    }]), ɵɵInheritDefinitionFeature],
    decls: 8,
    vars: 21,
    consts: [["inp", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["class", "po-field-icon-container-left", 4, "ngIf"], [1, "po-input", 3, "blur", "click", "focus", "input", "keydown", "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "type"], [1, "po-field-icon-container-right"], [3, "class", "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [1, "po-field-icon-container-left"], [3, "p-icon"], [3, "p-change-event", "p-element-ref"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon"]],
    template: function PoInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2);
        ɵɵtemplate(2, PoInputComponent_div_2_Template, 2, 6, "div", 3);
        ɵɵelementStart(3, "input", 4, 0);
        ɵɵlistener("blur", function PoInputComponent_Template_input_blur_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnBlur($event));
        })("click", function PoInputComponent_Template_input_click_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnClick($event));
        })("focus", function PoInputComponent_Template_input_focus_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnFocus($event));
        })("input", function PoInputComponent_Template_input_input_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnInput($event));
        })("keydown", function PoInputComponent_Template_input_keydown_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(5, "div", 5);
        ɵɵtemplate(6, PoInputComponent_po_clean_6_Template, 1, 4, "po-clean", 6);
        ɵɵelementEnd()();
        ɵɵtemplate(7, PoInputComponent_po_field_container_bottom_7_Template, 1, 8, "po-field-container-bottom", 7);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.icon);
        ɵɵadvance();
        ɵɵclassProp("po-input-icon-left", ctx.icon)("po-input-icon-right", ctx.clean);
        ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("type", ctx.type);
        ɵɵattribute("name", ctx.name);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.readonly);
      }
    },
    dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInputComponent, [{
    type: Component,
    args: [{
      selector: "po-input",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoInputComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoInputComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div *ngIf="icon" class="po-field-icon-container-left">
      <po-icon
        class="po-field-icon {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        [class.po-field-icon-disabled]="disabled"
        [p-icon]="icon"
      ></po-icon>
    </div>

    <input
      #inp
      class="po-input"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-icon-left]="icon"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [type]="type"
      (blur)="eventOnBlur($event)"
      (click)="eventOnClick($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
      (keydown)="onKeyDown($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="{{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom
    *ngIf="!readonly"
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
    [p-error-limit]="errorLimit"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    inp: [{
      type: ViewChild,
      args: ["inp", {
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoInputComponent, {
    className: "PoInputComponent",
    filePath: "lib/components/po-field/po-input/po-input.component.ts",
    lineNumber: 53
  });
})();
function PoLoginComponent_po_clean_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 9);
    ɵɵlistener("p-change-event", function PoLoginComponent_po_clean_7_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-element-ref", ctx_r2.inputEl);
  }
}
function PoLoginComponent_po_field_container_bottom_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 10);
    ɵɵlistener("p-additional-help", function PoLoginComponent_po_field_container_bottom_8_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.emitAdditionalHelp());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r2.getAdditionalHelpTooltip())("p-help", ctx_r2.help)("p-disabled", ctx_r2.disabled)("p-error-pattern", ctx_r2.getErrorPattern())("p-error-limit", ctx_r2.errorLimit)("p-show-additional-help", ctx_r2.displayAdditionalHelp)("p-show-additional-help-icon", ctx_r2.showAdditionalHelpIcon());
  }
}
var providers$3 = [{
  provide: NG_VALUE_ACCESSOR,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoLoginComponent),
  multi: true
}, {
  provide: NG_VALIDATORS,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoLoginComponent),
  multi: true
}];
var PoLoginComponent = class _PoLoginComponent extends PoInputGeneric {
  id = `po-login[${uuid()}]`;
  type = "text";
  _noAutocompleteLogin = true;
  set noAutocomplete(value) {
    this._noAutocompleteLogin = convertToBoolean(value);
  }
  get noAutocomplete() {
    return this._noAutocompleteLogin;
  }
  get autocomplete() {
    return this.noAutocomplete ? "off" : "on";
  }
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
  }
  extraValidation(c) {
    return null;
  }
  static ɵfac = function PoLoginComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLoginComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoLoginComponent,
    selectors: [["po-login"]],
    inputs: {
      noAutocomplete: [0, "p-no-autocomplete", "noAutocomplete"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature(providers$3), ɵɵInheritDefinitionFeature],
    decls: 9,
    vars: 23,
    consts: [["inp", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [1, "po-field-icon-container-left"], ["p-icon", "ICON_USER"], [1, "po-input", "po-input-icon-left", 3, "blur", "click", "focus", "input", "keydown", "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "type"], [1, "po-field-icon-container-right"], ["class", "po-icon-input", 3, "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-additional-help-tooltip", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [1, "po-icon-input", 3, "p-change-event", "p-element-ref"], [3, "p-additional-help", "p-additional-help-tooltip", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon"]],
    template: function PoLoginComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2)(2, "div", 3);
        ɵɵelement(3, "po-icon", 4);
        ɵɵelementEnd();
        ɵɵelementStart(4, "input", 5, 0);
        ɵɵlistener("blur", function PoLoginComponent_Template_input_blur_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnBlur($event));
        })("click", function PoLoginComponent_Template_input_click_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnClick($event));
        })("focus", function PoLoginComponent_Template_input_focus_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnFocus($event));
        })("input", function PoLoginComponent_Template_input_input_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnInput($event));
        })("keydown", function PoLoginComponent_Template_input_keydown_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(6, "div", 6);
        ɵɵtemplate(7, PoLoginComponent_po_clean_7_Template, 1, 1, "po-clean", 7);
        ɵɵelementEnd()();
        ɵɵtemplate(8, PoLoginComponent_po_field_container_bottom_8_Template, 1, 7, "po-field-container-bottom", 8);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(3);
        ɵɵclassMapInterpolate1("po-field-icon ", ctx.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
        ɵɵclassProp("po-field-icon-disabled", ctx.disabled);
        ɵɵadvance();
        ɵɵclassProp("po-input-icon-right", ctx.clean);
        ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("type", ctx.type);
        ɵɵattribute("name", ctx.name);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.readonly);
      }
    },
    dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoginComponent, [{
    type: Component,
    args: [{
      selector: "po-login",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: providers$3,
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div class="po-field-icon-container-left">
      <po-icon
        p-icon="ICON_USER"
        class="po-field-icon {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        [class.po-field-icon-disabled]="disabled"
      ></po-icon>
    </div>

    <input
      #inp
      class="po-input po-input-icon-left"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [type]="type"
      (blur)="eventOnBlur($event)"
      (click)="eventOnClick($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
      (keydown)="onKeyDown($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="po-icon-input"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom
    *ngIf="!readonly"
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
    [p-error-limit]="errorLimit"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  >
  </po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    noAutocomplete: [{
      type: Input,
      args: ["p-no-autocomplete"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLoginComponent, {
    className: "PoLoginComponent",
    filePath: "lib/components/po-field/po-login/po-login.component.ts",
    lineNumber: 55
  });
})();
var poLookupLiteralsDefault$1 = {
  en: {
    modalPrimaryActionLabel: "Select",
    modalSecondaryActionLabel: "Cancel",
    modalPlaceholder: "Search",
    modalTitle: "Select a record",
    modalTableNoColumns: poTableLiteralsDefault.en.noColumns,
    modalTableNoData: poTableLiteralsDefault.en.noData,
    modalTableLoadingData: poTableLiteralsDefault.en.loadingData,
    modalTableLoadMoreData: poTableLiteralsDefault.en.loadMoreData,
    modalAdvancedSearch: "Advanced search",
    modalAdvancedSearchTitle: "Advanced search",
    modalAdvancedSearchPrimaryActionLabel: "Filter",
    modalAdvancedSearchSecondaryActionLabel: "Return",
    modalDisclaimerGroupTitle: "Presenting results filtered by:"
  },
  es: {
    modalPrimaryActionLabel: "Seleccionar",
    modalSecondaryActionLabel: "Cancelar",
    modalPlaceholder: "Buscar",
    modalTitle: "Seleccione un registro",
    modalTableNoColumns: poTableLiteralsDefault.es.noColumns,
    modalTableNoData: poTableLiteralsDefault.es.noData,
    modalTableLoadingData: poTableLiteralsDefault.es.loadingData,
    modalTableLoadMoreData: poTableLiteralsDefault.es.loadMoreData,
    modalAdvancedSearch: "Búsqueda Avanzada",
    modalAdvancedSearchTitle: "Búsqueda Avanzada",
    modalAdvancedSearchPrimaryActionLabel: "Filtrar",
    modalAdvancedSearchSecondaryActionLabel: "Vuelve",
    modalDisclaimerGroupTitle: "Presentar resultados filtrados por:"
  },
  pt: {
    modalPrimaryActionLabel: "Selecionar",
    modalSecondaryActionLabel: "Cancelar",
    modalPlaceholder: "Pesquisar",
    modalTitle: "Selecione um registro",
    modalTableNoColumns: poTableLiteralsDefault.pt.noColumns,
    modalTableNoData: poTableLiteralsDefault.pt.noData,
    modalTableLoadingData: poTableLiteralsDefault.pt.loadingData,
    modalTableLoadMoreData: poTableLiteralsDefault.pt.loadMoreData,
    modalAdvancedSearch: "Busca avançada",
    modalAdvancedSearchTitle: "Busca Avançada",
    modalAdvancedSearchPrimaryActionLabel: "Filtrar",
    modalAdvancedSearchSecondaryActionLabel: "Voltar",
    modalDisclaimerGroupTitle: "Apresentando resultados filtrados por:"
  },
  ru: {
    modalPrimaryActionLabel: "Выбрать",
    modalSecondaryActionLabel: "Отменить",
    modalPlaceholder: "Поиск",
    modalTitle: "Выберите запись",
    modalTableNoColumns: poTableLiteralsDefault.ru.noColumns,
    modalTableNoData: poTableLiteralsDefault.ru.noData,
    modalTableLoadingData: poTableLiteralsDefault.ru.loadingData,
    modalTableLoadMoreData: poTableLiteralsDefault.ru.loadMoreData,
    modalAdvancedSearch: "Расширенный поиск",
    modalAdvancedSearchTitle: "Расширенный поиск",
    modalAdvancedSearchPrimaryActionLabel: "Фильтр",
    modalAdvancedSearchSecondaryActionLabel: "Назад",
    modalDisclaimerGroupTitle: "Представленные результаты отфильтрованы по:"
  }
};
var PoLookupModalBaseComponent = class _PoLookupModalBaseComponent {
  changeDetector;
  poModal;
  poTable;
  /**
   * Objeto com os campos que serão criados no busca avançada.
   *
   * > Caso não seja passado um objeto ou então ele esteja em branco o link de busca avançada ficará escondido.
   *
   * Exemplo de URL com busca avançada: http://localhost:3000/v1/heroes?filter=&page=1&pageSize=10`&name=Tony%20Stark&nickname=Homem%20de%20Ferro&email=irnman@marvel.com`
   *
   * Caso algum parâmetro seja uma lista, a concatenação é feita utilizando virgula.
   * Exemplo: http://localhost:3000/v1/heroes?filter=&page=1&pageSize=10`&name=Tony%20Stark,Peter%20Parker,Gohan`
   *
   */
  advancedFilters;
  /**
   * Lista das colunas da tabela.
   * Essa propriedade deve receber um array de objetos que implementam a interface PoLookupColumn.
   */
  columns;
  /** Lista de itens da tabela. */
  items;
  /** Classe de serviço com a implementação do cliente. */
  filterService;
  /** Classe de serviço com a implementação do cliente. */
  filterParams;
  /** Se verdadeiro, esconde o gerenciador de tarefas, responsável pela definição de quais colunas serão exibidas. */
  hideColumnsManager = false;
  /** Se verdadeiro, ativa a funcionalidade de scroll infinito para a tabela exibida no retorno da consulta. */
  infiniteScroll = false;
  /** Se verdadeiro, ativa a funcionalidade de multipla seleção. */
  multiple = false;
  /** Evento utilizado ao selecionar um registro da tabela. */
  model = new EventEmitter();
  /** Classe de serviço com items selecionados */
  selectedItems;
  /** Indica a coluna que será utilizada como descrição do campo e como filtro dentro da janela. */
  fieldLabel;
  /**
   * @description
   *
   * Indica a coluna que será utilizada como valor do campo.
   *
   * > Atenção: Caso não seja passada ou tenha o conteúdo incorreto, não irá atualizar o model do formulário.
   */
  fieldValue;
  /**
   * Responsável por aplicar espaçamento nas colunas da tabela contida no lookup.
   * Deve receber um dos valores do enum `PoTableColumnSpacing`.
   */
  spacing = PoTableColumnSpacing.Medium;
  /**
   * Habilita ou desabilita a quebra automática de texto. Quando ativada, o texto que excede
   * o espaço disponível é transferido para a próxima linha em pontos apropriados para uma
   * leitura clara.
   *
   * > Incompatível com `virtual-scroll`, que requer altura fixa nas linhas.
   *
   */
  textWrap = false;
  /**
   * @optional
   *
   * @description
   *
   * Habilita o `virtual-scroll` na tabela para melhorar a performance com grandes volumes de dados.
   * A altura da tabela já é pré-definida, portanto o `virtual-scroll` será ativado automaticamente.
   *
   * > Incompatível com `p-text-wrap` e `master-detail`, pois o `virtual-scroll` exige altura fixa nas linhas.
   *
   * @default `true`
   */
  virtualScroll = true;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao fechar o popover do gerenciador de colunas após alterar as colunas visíveis.
   *
   * O componente envia como parâmetro um array de string com as colunas visíveis atualizadas.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  changeVisibleColumns = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no botão de restaurar padrão no gerenciador de colunas.
   *
   * O componente envia como parâmetro um array de string com as colunas configuradas inicialmente.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  columnRestoreManager = new EventEmitter();
  hasNext = true;
  isLoading = false;
  page = 1;
  pageSize = 10;
  searchValue = "";
  tableLiterals;
  // Propriedade da modal de busca avançada:
  advancedFilterModalTitle = "";
  dynamicFormValue = {};
  disclaimer;
  disclaimerGroup;
  isAdvancedFilter = false;
  primaryActionAdvancedFilter;
  secondaryActionAdvancedFilter;
  selecteds = [];
  sort;
  filterSubscription;
  searchSubscription;
  showMoreSubscription;
  disclaimerLabel;
  _literals;
  _title;
  language = poLocaleDefault;
  // eslint-disable-next-line @typescript-eslint/member-ordering
  primaryAction = {
    action: () => {
      let selectedsItems = [];
      if (!this.multiple) {
        this.items.forEach((element) => {
          if (element["$selected"]) {
            selectedsItems.push(element);
          }
        });
      } else {
        selectedsItems = this.selecteds;
      }
      this.model.emit(selectedsItems);
      this.poModal.close();
    },
    label: this.literals.modalPrimaryActionLabel
  };
  // eslint-disable-next-line @typescript-eslint/member-ordering
  secondaryAction = {
    action: () => {
      this.model.emit(null);
      this.poModal.close();
    },
    label: this.literals.modalSecondaryActionLabel
  };
  /** Objeto com as literais usadas no `po-lookup-modal`. */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poLookupLiteralsDefault$1[poLocaleDefault]), poLookupLiteralsDefault$1[this.language]), value);
      if (value.modalTitle) {
        this.title = this.literals.modalTitle;
      }
    } else {
      this._literals = poLookupLiteralsDefault$1[this.language];
    }
    this.primaryAction.label = this.literals.modalPrimaryActionLabel;
    this.secondaryAction.label = this.literals.modalSecondaryActionLabel;
    this.setTableLiterals();
  }
  get literals() {
    return this._literals || poLookupLiteralsDefault$1[this.language];
  }
  /** Título da modal. */
  set title(value) {
    this._title = isTypeof(value, "string") ? value : this.literals.modalTitle;
  }
  get title() {
    return this._title;
  }
  constructor(languageService, changeDetector) {
    this.changeDetector = changeDetector;
    this.language = languageService.getShortLanguage();
  }
  ngOnDestroy() {
    if (this.filterSubscription) {
      this.filterSubscription.unsubscribe();
    }
    if (this.searchSubscription) {
      this.searchSubscription.unsubscribe();
    }
    if (this.showMoreSubscription) {
      this.showMoreSubscription.unsubscribe();
    }
  }
  ngOnInit() {
    this.setAdvancedFilterModalProperties();
    this.initializeData();
    this.setTableLiterals();
  }
  createDisclaimer() {
    this.disclaimerGroup.disclaimers = [];
    this.searchValue = "";
    for (const [key, value] of Object.entries(this.dynamicFormValue)) {
      this.addDisclaimer(value, key);
    }
    if (!Object.values(this.dynamicFormValue).some((v) => v !== null && typeof v !== "undefined")) {
      this.initializeData();
    }
  }
  addDisclaimer(value, property) {
    this.disclaimerLabel = "";
    const fieldFilter = this.advancedFilters.find((filter2) => filter2.property === property);
    this.disclaimer = {
      property
    };
    this.disclaimer.value = value;
    const labelProperty = fieldFilter.label || capitalizeFirstLetter(fieldFilter.property);
    if (fieldFilter.type === "currency" && value) {
      this.formatValueToCurrency(fieldFilter, value);
    }
    if (fieldFilter.type === "boolean" && (value === true || value === false)) {
      this.formatValueToBoolean(fieldFilter, value);
    }
    if (fieldFilter.options && value) {
      this.applyDisclaimerLabelValue(fieldFilter, value);
    }
    if (!this.disclaimerLabel) {
      this.disclaimerLabel = this.disclaimer.value;
    }
    this.disclaimer.label = `${labelProperty}: ${this.disclaimerLabel}`;
    this.disclaimerGroup.disclaimers = [...this.disclaimerGroup.disclaimers, this.disclaimer];
  }
  onChangeDisclaimerGroup() {
    if (!this.searchValue) {
      this.isLoading = true;
      this.searchValue = "";
      this.searchFilteredItems();
    }
  }
  search() {
    this.page = 1;
    if (this.searchValue) {
      this.isLoading = true;
      this.disclaimerGroup.disclaimers = [];
      this.searchFilteredItems();
    } else {
      this.initializeData();
    }
  }
  searchFilteredItems() {
    this.searchSubscription = this.getFilteredItems(this.searchValue).pipe(catchError((error) => {
      this.setLookupResponseProperties();
      return throwError(error);
    })).subscribe((data) => this.setLookupResponseProperties(data), () => {
    });
  }
  showMoreEvent() {
    this.page++;
    this.isLoading = true;
    this.showMoreSubscription = this.getFilteredItems(this.searchValue).pipe(catchError((error) => {
      this.hasNext = false;
      this.isLoading = false;
      return throwError(error);
    })).subscribe((data) => {
      this.items = [...this.items, ...data.items];
      this.hasNext = data.hasNext;
      this.isLoading = false;
      this.changeDetector.detectChanges();
      this.setSelectedItems();
    }, () => {
    });
  }
  //Método responsável por selecionar as linhas quando abre o modal.
  setSelectedItems() {
    this.selecteds.forEach((selectedItem) => {
      if (this.multiple) {
        this.poTable.selectRowItem((item) => item[this.fieldValue] === selectedItem.value);
      } else {
        this.poTable.selectRowItem((item) => item[this.fieldValue] === selectedItem[this.fieldValue]);
      }
    });
  }
  //Método responsável por criar os disclaimers quando abre o modal.
  setDisclaimersItems() {
    if (this.selectedItems && !Array.isArray(this.selectedItems)) {
      this.multiple ? this.selecteds = [{
        value: this.selectedItems
      }] : this.selecteds = [this.selectedItems];
      return;
    }
    if (this.selecteds.length === 0 && this.selectedItems && this.selectedItems.length) {
      this.selecteds = [...this.selectedItems];
    }
  }
  applyDisclaimerLabelValue(field, filterValue) {
    const values = Array.isArray(filterValue) ? filterValue : [filterValue];
    const labels = values.map((optionValue) => {
      const findOption = field.options.find((option) => option.value === optionValue);
      return findOption.label;
    });
    if (labels.join()) {
      this.disclaimerLabel = labels.join(", ");
    }
  }
  formatValueToCurrency(field, filterValue) {
    const currencyLabel = new Intl.NumberFormat(field.locale ? field.locale : this.language, {
      minimumFractionDigits: 2
    }).format(filterValue);
    this.disclaimerLabel = currencyLabel;
  }
  formatValueToBoolean(field, filterValue) {
    let labelBoolean;
    if (filterValue) {
      labelBoolean = field.booleanTrue ? field.booleanTrue : filterValue;
    } else {
      labelBoolean = field.booleanFalse ? field.booleanFalse : filterValue;
    }
    this.disclaimerLabel = `${labelBoolean}`;
  }
  setAdvancedFilterModalProperties() {
    this.advancedFilterModalTitle = this.literals.modalAdvancedSearchTitle;
    this.disclaimerGroup = {
      title: this.literals.modalDisclaimerGroupTitle,
      disclaimers: []
    };
    this.primaryActionAdvancedFilter = {
      action: () => {
        this.destroyDynamicForm();
        this.isAdvancedFilter = false;
        this.page = 1;
        this.createDisclaimer();
      },
      label: this.literals.modalAdvancedSearchPrimaryActionLabel
    };
    this.secondaryActionAdvancedFilter = {
      action: () => {
        this.destroyDynamicForm();
        this.isAdvancedFilter = false;
      },
      label: this.literals.modalAdvancedSearchSecondaryActionLabel
    };
  }
  getAdvancedFilters(advancedParams) {
    if (advancedParams && advancedParams.length > 0) {
      const filters = {};
      let validatedAdvacendFilters;
      advancedParams.forEach((filter2) => {
        filters[filter2.property] = filter2.value instanceof Array ? filter2.value.join() : filter2.value;
        validatedAdvacendFilters = __spreadValues(__spreadValues({}, validatedAdvacendFilters), filters);
      });
      return validatedAdvacendFilters;
    }
    return void 0;
  }
  getFilteredItems(filter2) {
    const filteredParams = this.getFilteredParams(filter2);
    return this.filterService.getFilteredItems(filteredParams);
  }
  getFilteredParams(filter2) {
    const {
      page,
      pageSize,
      filterParams,
      sort
    } = this;
    const filteredParams = {};
    const order = this.getOrderParam(sort);
    const advancedFilters = this.getAdvancedFilters(this.disclaimerGroup.disclaimers);
    const params = {
      filter: filter2,
      page,
      pageSize,
      order,
      filterParams,
      advancedFilters
    };
    for (const key in params) {
      if (params.hasOwnProperty(key) && params[key] !== void 0) {
        filteredParams[key] = params[key];
      }
    }
    return filteredParams;
  }
  getOrderParam(sort = {
    type: void 0
  }) {
    const {
      column,
      type
    } = sort;
    if (!column) {
      return;
    }
    if (type === PoTableColumnSortType.Descending) {
      return `-${column.property}`;
    }
    return `${column.property}`;
  }
  initializeData() {
    this.isLoading = true;
    this.filterSubscription = this.getFilteredItems("").subscribe((data) => {
      this.setLookupResponseProperties(data);
    });
  }
  setLookupResponseProperties(data) {
    this.items = data?.items ?? [];
    this.hasNext = data?.hasNext ?? false;
    this.isLoading = false;
    this.changeDetector.detectChanges();
    this.setDisclaimersItems();
    this.setSelectedItems();
  }
  setTableLiterals() {
    this.tableLiterals = {
      "noColumns": this.literals.modalTableNoColumns,
      "noData": this.literals.modalTableNoData,
      "loadingData": this.literals.modalTableLoadingData,
      "loadMoreData": this.literals.modalTableLoadMoreData
    };
  }
  static ɵfac = function PoLookupModalBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLookupModalBaseComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoLookupModalBaseComponent,
    viewQuery: function PoLookupModalBaseComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoModalComponent, 7);
        ɵɵviewQuery(PoTableComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poModal = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poTable = _t.first);
      }
    },
    inputs: {
      advancedFilters: [0, "p-advanced-filters", "advancedFilters"],
      columns: [0, "p-columns", "columns"],
      items: [0, "p-items", "items"],
      filterService: [0, "p-filter-service", "filterService"],
      filterParams: [0, "p-filter-params", "filterParams"],
      hideColumnsManager: [2, "p-hide-columns-manager", "hideColumnsManager", convertToBoolean],
      infiniteScroll: [2, "p-infinite-scroll", "infiniteScroll", convertToBoolean],
      multiple: [2, "p-multiple", "multiple", convertToBoolean],
      selectedItems: [0, "p-selected-items", "selectedItems"],
      fieldLabel: [0, "p-field-label", "fieldLabel"],
      fieldValue: [0, "p-field-value", "fieldValue"],
      spacing: [0, "p-spacing", "spacing"],
      textWrap: [2, "p-text-wrap", "textWrap", convertToBoolean],
      virtualScroll: [2, "p-virtual-scroll", "virtualScroll", convertToBoolean],
      literals: [0, "p-literals", "literals"],
      title: [0, "p-title", "title"]
    },
    outputs: {
      model: "p-change-model",
      changeVisibleColumns: "p-change-visible-columns",
      columnRestoreManager: "p-restore-column-manager"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupModalBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }, {
    type: ChangeDetectorRef
  }], {
    poModal: [{
      type: ViewChild,
      args: [PoModalComponent, {
        static: true
      }]
    }],
    poTable: [{
      type: ViewChild,
      args: [PoTableComponent, {
        static: true
      }]
    }],
    advancedFilters: [{
      type: Input,
      args: ["p-advanced-filters"]
    }],
    columns: [{
      type: Input,
      args: ["p-columns"]
    }],
    items: [{
      type: Input,
      args: ["p-items"]
    }],
    filterService: [{
      type: Input,
      args: ["p-filter-service"]
    }],
    filterParams: [{
      type: Input,
      args: ["p-filter-params"]
    }],
    hideColumnsManager: [{
      type: Input,
      args: [{
        alias: "p-hide-columns-manager",
        transform: convertToBoolean
      }]
    }],
    infiniteScroll: [{
      type: Input,
      args: [{
        alias: "p-infinite-scroll",
        transform: convertToBoolean
      }]
    }],
    multiple: [{
      type: Input,
      args: [{
        alias: "p-multiple",
        transform: convertToBoolean
      }]
    }],
    model: [{
      type: Output,
      args: ["p-change-model"]
    }],
    selectedItems: [{
      type: Input,
      args: ["p-selected-items"]
    }],
    fieldLabel: [{
      type: Input,
      args: ["p-field-label"]
    }],
    fieldValue: [{
      type: Input,
      args: ["p-field-value"]
    }],
    spacing: [{
      type: Input,
      args: ["p-spacing"]
    }],
    textWrap: [{
      type: Input,
      args: [{
        alias: "p-text-wrap",
        transform: convertToBoolean
      }]
    }],
    virtualScroll: [{
      type: Input,
      args: [{
        alias: "p-virtual-scroll",
        transform: convertToBoolean
      }]
    }],
    changeVisibleColumns: [{
      type: Output,
      args: ["p-change-visible-columns"]
    }],
    columnRestoreManager: [{
      type: Output,
      args: ["p-restore-column-manager"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    title: [{
      type: Input,
      args: ["p-title"]
    }]
  });
})();
var PoDynamicFormBaseComponent = class _PoDynamicFormBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Nome da propriedade, atribuída ao `PoDynamicFormField.property`, que iniciará o campo com foco.
   */
  autoFocus;
  /**
   * @description
   *
   * Coleção de objetos que implementam a interface `PoDynamicFormField`, para definição dos campos que serão criados
   * dinamicamente.
   *
   * > Ex: `[ { property: 'name' } ]`
   *
   * Regras de tipagem e criação dos componentes:
   *
   * - Caso o *type* informado seja *boolean* o componente criado será o `po-switch`.
   * - Caso o *type* informado seja *currency* e não seja informado um *mask* ou *pattern* o componente criado será o `po-decimal`,
   * caso seja informado um *mask* ou *pattern* o componente criado será o `po-input`.
   * - Caso o *type* informado seja *number* e não seja informado um *mask* ou *pattern* o componente criado será o `po-number`, caso seja
   * informado um *mask* ou *pattern* o componente criado será o `po-input`.
   * - Caso a lista possua a propriedade `options` e a mesma possua até 3 itens o componente criado será o `po-radio-group`
   * ou `po-checkbox-group` se informar a propriedade `optionsMulti`.
   * - Caso a mesma possua 3 ou mais itens, será criado o componente `po-select` ou, `po-multiselect` se a propriedade `optionsMulti`
   * for verdadeira.
   * - Caso o *type* informado seja *date* ou *datetime* o componente criado será o `po-datepicker`.
   * - Caso seja informado a propriedade `optionsService` o componente criado será o `po-combo`.
   * - Caso o *type* informado seja *time* o componente criado será um `po-input` podendo receber um *mask* para formatar
   * o valor exibido, caso não seja informado um *mask* o componente será criado com a máscara '99:99' por padrão.
   * - Caso a lista possua a propriedade `rows` e esta seja definida com valor maior ou igual a 3 o componente criado será
   * o `po-textarea`, caso o valor da propriedade `rows` seja menor que 3 o componente criado será o `po-input`.
   * - Caso seja informada a propriedade `secret` o componente criado será o `po-password`.
   * - Caso o *type* informado seja *string* o componente criado será o `po-input`.
   * > Ao alterar o valor das `properties`, visibilidade e/ou agrupamentos via container, os `fields` que utilizam serviço podem refazer as chamadas para as API's.
   * @default `[]`
   */
  fields;
  /**
   * Objeto que será utilizado como valor para exibir as informações, será recuperado e preenchido através do atributo *property*
   * dos objetos contidos na propridade `p-fields`.
   *
   * Pode iniciar com valor ou apenas com um objeto vazio que será preenchido conforme descrito acima.
   *
   * > Ex: `{ name: 'po' }`
   */
  value;
  /**
   * @optional
   *
   * @description
   *
   * Na inicialização do componente será repassado o objeto de formulário utilizado no componente,
   * podendo ser utilizado para validações e/ou detecção de mudança dos valores.
   *
   * Portanto existem duas maneiras de recuperar o formulário,
   * através de *template reference* e através do *output*, veja os exemplos abaixo:
   *
   * > *template reference*
   *
   * ```html
   *  <po-dynamic-form #dynamicForm>
   *  </po-dynamic-form>
   *
   *  <po-button p-label="Adicionar" [p-disabled]="dynamicForm?.form.invalid">
   *  </po-button>
   *
   * ```
   *
   * > *Output*
   *
   * ```html
   *  ...
   *  <po-dynamic-form (p-form)="getForm($event)">
   *  </po-dynamic-form>
   *
   *  <po-button p-label="Adicionar" [p-disabled]="dynamicForm?.invalid">
   *  </po-button>
   *  ...
   *
   * ```
   *
   * ```ts
   *  ...
   *
   *  export class AppComponent {
   *
   *    dynamicForm: NgForm;
   *
   *    getForm(form: NgForm) {
   *      this.dynamicForm = form;
   *    }
   *
   *  }
   * ```
   *
   * > Caso a propriedade `p-group-form` for verdadeira não será repassado o formulário, pois o mesmo utilizará
   * o formulário pai.
   */
  formOutput = new EventEmitter();
  /**
   * Função ou serviço que será executado na inicialização do componente.
   *
   * A propriedade aceita os seguintes tipos:
   * - `string`: *Endpoint* usado pelo componente para requisição via `POST`.
   * - `function`: Método que será executado.
   *
   * Ao ser executado, irá receber como parâmetro o objeto informado no `p-value`.
   *
   * O retorno desta função deve ser do tipo [PoDynamicFormLoad](documentation/po-dynamic-form#po-dynamic-form-load),
   * onde o usuário poderá determinar as novas atualizações dos campos, valores e determinar o campo a ser focado.
   *
   * Por exemplo:
   *
   * ```
   * onLoadFields(): PoDynamicFormLoad {
   *
   *   return {
   *     value: { cpf: undefined },
   *     fields: [
   *       { property: 'cpf' }
   *     ],
   *     focus: 'cpf'
   *   };
   * }
   *
   * ```
   * Para referenciar a sua função utilize a propriedade `bind`, por exemplo:
   * ```
   *  [p-load]="onLoadFields.bind(this)"
   * ```
   */
  load;
  /**
   * Função ou serviço para validar as **mudanças do formulário**.
   *
   * A propriedade aceita os seguintes tipos:
   * - `string`: *Endpoint* usado pelo componente para requisição via `POST`.
   * - `function`: Método que será executado.
   *
   * Ao ser executado, irá receber como parâmetro um objeto com o nome da propriedade
   * alterada e os valores atualizados do formulario, conforme a interface `PoDynamicFormFieldChanged`
   *
   *
   * O retorno desta função deve ser do tipo [PoDynamicFormValidation](documentation/po-dynamic-form#po-dynamic-form-validation),
   * onde o usuário poderá determinar as novas atualizações dos campos.
   * Por exemplo:
   *
   * ```
   * onChangeFields(changeValue): PoDynamicFormValidation {
   *
   * if (changeValue.property === 'state') {
   *
   *   return {
   *     value: { city: undefined },
   *     fields: [
   *       { property: 'city', options: this.getCity(changeValue.value.state) }
   *     ],
   *     focus: 'city'
   *   };
   * }
   *
   * ```
   * Para referenciar a sua função utilize a propriedade `bind`, por exemplo:
   * ```
   *  [p-validate]="this.myFunction.bind(this)"
   * ```
   *
   * > Se houver uma lista de campos para validação definida em `p-validate-fields`, a propriedade `validate` só receberá o disparo para os campos equivalentes.
   */
  validate;
  /**
   * @optional
   *
   * @description
   *
   * Lista que define os campos que irão disparar o validate do form.
   */
  validateFields;
  _groupForm = false;
  /**
   * @optional
   *
   * @description
   * Ao informar esta propriedade, o componente passará a utilizar o formulário pai para criar os `FormControl`
   * e com isso é possível recuperar o valor do formulário e suas validações a partir do formulário pai.
   *
   * ```html
   * <form #parentForm="ngForm">
   *
   *   <po-dynamic-form p-group-form [p-fields]="fields"></po-dynamic-form>
   *
   *  <po-button p-label="Adicionar" [p-disabled]="parentForm.invalid"></po-button>
   * </form>
   * ```
   */
  set groupForm(value) {
    this._groupForm = value === "" ? true : convertToBoolean(value);
  }
  get groupForm() {
    return this._groupForm;
  }
  /**
   * @optional
   *
   * @description
   *
   * Ao informar esta propriedade, o componente passará a emitir o valor a cada caractere digitado.
   *
   * Pode ser aplicado nos seguintes componentes:
   * - po-input
   * - po-number
   * - po-decimal
   * - po-textarea
   * - po-password
   *
   * Deve informar os campos que deseja receber as emissões na propriedade `p-validate-fields`.
   *
   *
   */
  validateOnInput = false;
  static ɵfac = function PoDynamicFormBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicFormBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoDynamicFormBaseComponent,
    inputs: {
      autoFocus: [0, "p-auto-focus", "autoFocus"],
      fields: [0, "p-fields", "fields"],
      value: [0, "p-value", "value"],
      load: [0, "p-load", "load"],
      validate: [0, "p-validate", "validate"],
      validateFields: [0, "p-validate-fields", "validateFields"],
      groupForm: [0, "p-group-form", "groupForm"],
      validateOnInput: [2, "p-validate-on-input", "validateOnInput", convertToBoolean]
    },
    outputs: {
      formOutput: "p-form"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormBaseComponent, [{
    type: Directive
  }], null, {
    autoFocus: [{
      type: Input,
      args: ["p-auto-focus"]
    }],
    fields: [{
      type: Input,
      args: ["p-fields"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }],
    formOutput: [{
      type: Output,
      args: ["p-form"]
    }],
    load: [{
      type: Input,
      args: ["p-load"]
    }],
    validate: [{
      type: Input,
      args: ["p-validate"]
    }],
    validateFields: [{
      type: Input,
      args: ["p-validate-fields"]
    }],
    groupForm: [{
      type: Input,
      args: ["p-group-form"]
    }],
    validateOnInput: [{
      type: Input,
      args: [{
        alias: "p-validate-on-input",
        transform: convertToBoolean
      }]
    }]
  });
})();
var PoDynamicFormOperation = class {
  http;
  constructor(http) {
    this.http = http;
  }
  execute(action, param) {
    return typeof action === "string" ? this.post(action, param) : of(action(param));
  }
  post(url, body) {
    return this.http.post(url, body);
  }
  setFormDefaultIfEmpty(validateFields) {
    return validateFields || {
      value: {},
      fields: [],
      focus: void 0
    };
  }
};
var PoDynamicFormLoadService = class _PoDynamicFormLoadService extends PoDynamicFormOperation {
  constructor(http) {
    super(http);
  }
  createAndUpdateFieldsForm(loadedFields = [], fields = []) {
    return [...loadedFields].reduce((updatedFields, field) => {
      const index = updatedFields.findIndex((updatedField) => updatedField.property === field.property);
      const hasProperty = index >= 0;
      if (hasProperty) {
        updatedFields[index] = __spreadValues(__spreadValues({}, fields[index]), field);
      } else {
        updatedFields.push(field);
      }
      return updatedFields;
    }, [...fields]);
  }
  executeLoad(load, value) {
    return this.execute(load, value).pipe(map((loadedFormdData) => this.setFormDefaultIfEmpty(loadedFormdData)));
  }
  static ɵfac = function PoDynamicFormLoadService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicFormLoadService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoDynamicFormLoadService,
    factory: _PoDynamicFormLoadService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormLoadService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }], null);
})();
var PoDynamicFormValidationService = class _PoDynamicFormValidationService extends PoDynamicFormOperation {
  constructor(http) {
    super(http);
  }
  sendFieldChange(field, value) {
    const changedValue = {
      property: field.property,
      value
    };
    return this.execute(field.validate, changedValue).pipe(map((validateFields) => this.setFieldDefaultIfEmpty(validateFields)));
  }
  sendFormChange(validate, field, value) {
    const changedValue = {
      property: field.property,
      value
    };
    return this.execute(validate, changedValue).pipe(map((validateFields) => this.setFormDefaultIfEmpty(validateFields)));
  }
  updateFieldsForm(validatedFields = [], fields = []) {
    return [...validatedFields].reduce((updatedFields, validatedField) => {
      const index = updatedFields.findIndex((field) => field.property === validatedField.property);
      const hasProperty = index >= 0;
      if (hasProperty) {
        updatedFields[index] = __spreadValues(__spreadValues({}, fields[index]), validatedField);
      }
      return updatedFields;
    }, [...fields]);
  }
  setFieldDefaultIfEmpty(validateFields) {
    return validateFields || {
      field: {}
    };
  }
  static ɵfac = function PoDynamicFormValidationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicFormValidationService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoDynamicFormValidationService,
    factory: _PoDynamicFormValidationService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormValidationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }], null);
})();
var _c0$S = ["fieldsComponent"];
var _c1$l = ["dynamicForm"];
function PoDynamicFormComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoDynamicFormComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-dynamic-form-fields", 5, 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-auto-focus", ctx_r0.autoFocus)("p-fields", ctx_r0.fields)("p-value", ctx_r0.value);
  }
}
function PoDynamicFormComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "form", null, 3)(2, "po-dynamic-form-fields", 6, 2);
    ɵɵtwoWayListener("p-fieldsChange", function PoDynamicFormComponent_ng_template_3_Template_po_dynamic_form_fields_p_fieldsChange_2_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r0.fields, $event) || (ctx_r0.fields = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-object-value", function PoDynamicFormComponent_ng_template_3_Template_po_dynamic_form_fields_p_object_value_2_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.sendObjectValue($event));
    })("p-form-validate", function PoDynamicFormComponent_ng_template_3_Template_po_dynamic_form_fields_p_form_validate_2_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.validateForm($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtwoWayProperty("p-fields", ctx_r0.fields);
    ɵɵproperty("p-auto-focus", ctx_r0.autoFocus)("p-disabled-form", ctx_r0.disabledForm)("p-validate", ctx_r0.validate)("p-validate-fields", ctx_r0.validateFields)("p-validate-on-input", ctx_r0.validateOnInput)("p-value", ctx_r0.value);
  }
}
var PoDynamicFormComponent = class _PoDynamicFormComponent extends PoDynamicFormBaseComponent {
  changes;
  loadService;
  validationService;
  fieldsComponent;
  disabledForm;
  displayAdditionalHelp = false;
  _form;
  onLoadSubscription;
  sendFormSubscription;
  comboOptionSubject = new Subject();
  set form(value) {
    setTimeout(() => {
      this._form = value;
      this.emitForm();
    });
  }
  get form() {
    return this._form || {};
  }
  constructor(changes, loadService, validationService) {
    super();
    this.changes = changes;
    this.loadService = loadService;
    this.validationService = validationService;
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  ngOnInit() {
    if (this.load) {
      this.loadDataOnInitialize();
    }
  }
  /**
   * Função que atribui foco ao campo desejado.
   *
   * Para utilizá-la é necessário capturar a instância do `dynamic form`, como por exemplo:
   *
   * ``` html
   * <po-dynamic-form #dynamicForm [p-fields]="fields"></po-dynamic-form>
   * ```
   *
   * ``` javascript
   * import { PoDynamicFormComponent, PoDynamicFormField } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild('dynamicForm', { static: true }) dynamicForm: PoDynamicFormComponent;
   *
   * fields: Array<PoDynamicFormField> = [
   *   { property: 'fieldOne' },
   *   { property: 'fieldTwo' }
   * ];
   *
   * fieldFocus() {
   *   this.dynamicForm.focus('fieldTwo');
   * }
   * ```
   *
   * @param {string} property Nome da propriedade atribuída ao `PoDynamicFormField.property`.
   */
  focus(property) {
    this.fieldsComponent.focus(property);
  }
  getObjectValue() {
    return this.comboOptionSubject.asObservable();
  }
  sendObjectValue(objectValue) {
    this.comboOptionSubject.next(objectValue);
  }
  /**
   * Método que exibe `additionalHelpTooltip` ou executa a ação definida em `additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `keydown`.
   *
   * ```
   * import { PoDynamicModule } from '@po-ui/ng-components';
   * ...
   * @ViewChild('dynamicForm', { static: true }) dynamicForm: PoDynamicFormComponent;
   *
   * fields: Array<PoDynamicFormField> = [
   *  {
   *    property: 'name',
   *    ...
   *    help: 'Mensagem de ajuda.',
   *    additionalHelpTooltip: 'Mensagem de ajuda complementar.',
   *    keydown: this.onKeyDown.bind(this, 'name')
   *  },
   * ]
   *
   * onKeyDown(property: string, event: KeyboardEvent): void {
   *  if (event.code === 'F9') {
   *    this.dynamicForm.showAdditionalHelp(property);
   *  }
   * }
   * ```
   *
   * @param { string } property Identificador da coluna.
   */
  showAdditionalHelp(property) {
    this.fieldsComponent.showAdditionalHelp(property);
  }
  validateForm(field) {
    const previousFocusElement = document.activeElement;
    this.disableForm(true);
    const errorOnValidation = () => this.disableForm(false);
    this.sendFormSubscription = this.validationService.sendFormChange(this.validate, field, this.value).subscribe(this.applyFormValidation(previousFocusElement), errorOnValidation);
  }
  applyFormUpdatesOnLoad(previousFocusElement) {
    return (dynamicFormData) => {
      this.updateModelOnLoad(dynamicFormData);
      this.disableForm(false);
      this.setFocusOnFieldByProperty(dynamicFormData.focus, previousFocusElement);
    };
  }
  applyFormValidation(previousFocusElement) {
    return (dynamicFormData) => {
      this.updateModelWithValidation(dynamicFormData);
      this.disableForm(false);
      this.setFocusOnFieldByProperty(dynamicFormData.focus, previousFocusElement);
    };
  }
  disableForm(value) {
    this.disabledForm = value;
    this.changes.detectChanges();
  }
  emitForm() {
    if (!this.groupForm && this.formOutput.observers.length) {
      this.formOutput.emit(this.form);
    }
  }
  loadDataOnInitialize() {
    const previousFocusElement = document.activeElement;
    this.disabledForm = true;
    const errorOnLoad = () => this.disabledForm = false;
    this.onLoadSubscription = this.loadService.executeLoad(this.load, this.value).subscribe(this.applyFormUpdatesOnLoad(previousFocusElement), errorOnLoad);
  }
  removeListeners() {
    if (this.onLoadSubscription) {
      this.onLoadSubscription.unsubscribe();
    }
    if (this.sendFormSubscription) {
      this.sendFormSubscription.unsubscribe();
    }
  }
  setFocusOnFieldByProperty(property, previousFocusElement) {
    if (property) {
      setTimeout(() => this.focus(property));
    } else {
      previousFocusElement["focus"]();
    }
  }
  updateModelOnLoad(loadedFormData) {
    Object.assign(this.value, loadedFormData.value);
    this.fields = this.loadService.createAndUpdateFieldsForm(loadedFormData.fields, this.fields);
  }
  updateModelWithValidation(formData) {
    Object.assign(this.value, formData.value);
    this.fieldsComponent.updatePreviousValue();
    this.fields = this.validationService.updateFieldsForm(formData.fields, this.fields);
  }
  static ɵfac = function PoDynamicFormComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicFormComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoDynamicFormLoadService), ɵɵdirectiveInject(PoDynamicFormValidationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDynamicFormComponent,
    selectors: [["po-dynamic-form"]],
    viewQuery: function PoDynamicFormComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$S, 5);
        ɵɵviewQuery(_c1$l, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fieldsComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.form = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 5,
    vars: 3,
    consts: [["reuseFormTemplate", ""], ["uniqueFormTemplate", ""], ["fieldsComponent", ""], ["dynamicForm", "ngForm"], [4, "ngIf", "ngIfThen", "ngIfElse"], [3, "p-auto-focus", "p-fields", "p-value"], [3, "p-fieldsChange", "p-object-value", "p-form-validate", "p-fields", "p-auto-focus", "p-disabled-form", "p-validate", "p-validate-fields", "p-validate-on-input", "p-value"]],
    template: function PoDynamicFormComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoDynamicFormComponent_ng_container_0_Template, 1, 0, "ng-container", 4)(1, PoDynamicFormComponent_ng_template_1_Template, 2, 3, "ng-template", null, 0, ɵɵtemplateRefExtractor)(3, PoDynamicFormComponent_ng_template_3_Template, 4, 7, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const reuseFormTemplate_r3 = ɵɵreference(2);
        const uniqueFormTemplate_r4 = ɵɵreference(4);
        ɵɵproperty("ngIf", ctx.groupForm)("ngIfThen", reuseFormTemplate_r3)("ngIfElse", uniqueFormTemplate_r4);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormComponent, [{
    type: Component,
    args: [{
      selector: "po-dynamic-form",
      standalone: false,
      template: '<ng-container *ngIf="groupForm; then reuseFormTemplate; else uniqueFormTemplate"></ng-container>\n\n<ng-template #reuseFormTemplate>\n  <po-dynamic-form-fields #fieldsComponent [p-auto-focus]="autoFocus" [p-fields]="fields" [p-value]="value">\n  </po-dynamic-form-fields>\n</ng-template>\n\n<ng-template #uniqueFormTemplate>\n  <form #dynamicForm="ngForm">\n    <po-dynamic-form-fields\n      #fieldsComponent\n      [(p-fields)]="fields"\n      [p-auto-focus]="autoFocus"\n      [p-disabled-form]="disabledForm"\n      [p-validate]="validate"\n      [p-validate-fields]="validateFields"\n      [p-validate-on-input]="validateOnInput"\n      [p-value]="value"\n      (p-object-value)="sendObjectValue($event)"\n      (p-form-validate)="validateForm($event)"\n    >\n    </po-dynamic-form-fields>\n  </form>\n</ng-template>\n'
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: PoDynamicFormLoadService
  }, {
    type: PoDynamicFormValidationService
  }], {
    fieldsComponent: [{
      type: ViewChild,
      args: ["fieldsComponent"]
    }],
    form: [{
      type: ViewChild,
      args: ["dynamicForm"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDynamicFormComponent, {
    className: "PoDynamicFormComponent",
    filePath: "lib/components/po-dynamic/po-dynamic-form/po-dynamic-form.component.ts",
    lineNumber: 42
  });
})();
var _c0$R = ["inpsearch"];
var _c1$k = ["container"];
function PoLookupModalComponent_div_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 16)(1, "span", 17);
    ɵɵlistener("click", function PoLookupModalComponent_div_9_Template_span_click_1_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onAdvancedFilter());
    })("keydown.enter", function PoLookupModalComponent_div_9_Template_span_keydown_enter_1_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onAdvancedFilter());
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2.literals.modalAdvancedSearch, " ");
  }
}
function PoLookupModalComponent_po_disclaimer_group_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-disclaimer-group", 18);
    ɵɵlistener("p-change", function PoLookupModalComponent_po_disclaimer_group_10_Template_po_disclaimer_group_p_change_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onChangeDisclaimerGroup());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-disclaimers", ctx_r2.disclaimerGroup == null ? null : ctx_r2.disclaimerGroup.disclaimers)("p-title", ctx_r2.disclaimerGroup == null ? null : ctx_r2.disclaimerGroup.title);
  }
}
function PoLookupModalComponent_po_disclaimer_group_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-disclaimer-group", 19);
    ɵɵlistener("p-remove", function PoLookupModalComponent_po_disclaimer_group_14_Template_po_disclaimer_group_p_remove_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onUnselectFromDisclaimer($event.removedDisclaimer));
    })("p-remove-all", function PoLookupModalComponent_po_disclaimer_group_14_Template_po_disclaimer_group_p_remove_all_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onAllUnselected($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-disclaimers", ctx_r2.selecteds);
  }
}
var PoLookupModalComponent = class _PoLookupModalComponent extends PoLookupModalBaseComponent {
  componentFactory;
  inputSearchEl;
  container;
  keyUpObservable = null;
  tableHeight;
  componentRef;
  dynamicForm;
  constructor(componentFactory, poLanguage, changeDetector) {
    super(poLanguage, changeDetector);
    this.componentFactory = componentFactory;
  }
  ngOnInit() {
    super.ngOnInit();
    this.setTableHeight();
  }
  // Seleciona um item na tabela
  onSelect(item) {
    if (this.multiple) {
      this.selecteds = [...this.selecteds, __spreadValues({
        value: item[this.fieldValue],
        label: item[this.fieldLabel]
      }, item)];
    } else {
      this.selecteds = [__spreadValues({
        value: item[this.fieldValue],
        label: item[this.fieldLabel]
      }, item)];
    }
  }
  // Remove a seleção de um item na tabela
  onUnselect(unselectedItem) {
    this.selecteds = this.selecteds.filter((itemSelected) => itemSelected.value !== unselectedItem[this.fieldValue]);
  }
  onUnselectFromDisclaimer(removedDisclaimer) {
    this.poTable.unselectRowItem((item) => item[this.fieldValue] === removedDisclaimer.value);
  }
  // Seleciona todos os itens visíveis na tabela
  onAllSelected(items) {
    this.selecteds = items.map((item) => __spreadValues({
      value: item[this.fieldValue],
      label: item[this.fieldLabel]
    }, item));
  }
  // Remove a seleção de todos os itens visíveis na tabela
  onAllUnselected(items) {
    this.poTable.unselectRows();
    this.selecteds = [];
  }
  openModal() {
    this.poModal.open();
  }
  sortBy(sort) {
    const order = sort.type === "ascending" ? true : false;
    sortArrayOfObjects(this.items, sort.column.property, order);
    this.sort = sort;
  }
  destroyDynamicForm() {
    if (this.componentRef) {
      this.componentRef.destroy();
    }
  }
  onAdvancedFilter() {
    this.setupModalAdvancedFilter();
    this.createDynamicForm();
  }
  setTableHeight() {
    this.tableHeight = this.infiniteScroll ? 515 : 615;
  }
  setupModalAdvancedFilter() {
    this.dynamicFormValue = {};
    this.isAdvancedFilter = true;
  }
  createDynamicForm() {
    const component = this.componentFactory.resolveComponentFactory(PoDynamicFormComponent);
    this.componentRef = this.container.createComponent(component);
    this.componentRef.instance.fields = this.advancedFilters;
    this.componentRef.instance.value = this.dynamicFormValue;
    this.componentRef.instance.formOutput.pipe(tap((form) => {
      this.dynamicForm = form;
      this.primaryActionAdvancedFilter.disabled = this.dynamicForm.invalid;
    }), switchMap((form) => form.valueChanges)).subscribe(() => {
      this.primaryActionAdvancedFilter.disabled = this.dynamicForm.invalid;
    });
    this.changeDetector.markForCheck();
  }
  static ɵfac = function PoLookupModalComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLookupModalComponent)(ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoLookupModalComponent,
    selectors: [["po-lookup-modal"]],
    viewQuery: function PoLookupModalComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$R, 5);
        ɵɵviewQuery(_c1$k, 5, ViewContainerRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputSearchEl = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 18,
    vars: 28,
    consts: [["iconLookup", ""], ["inpsearch", ""], ["poTable", ""], ["container", ""], ["p-click-out", "false", "p-hide-close", "false", "p-size", "lg", 3, "p-primary-action", "p-secondary-action", "p-title"], [3, "hidden"], [1, "po-lookup-header", "po-pull-right", 3, "p-optional"], [1, "po-lookup-filter-content"], [1, "po-field-icon-container-right"], ["p-icon", "ICON_SEARCH", 1, "po-field-icon", "po-icon-input", 3, "click"], ["name", "contentSearch", "type", "text", 1, "po-input", "po-input-icon-right", 3, "ngModelChange", "keydown.enter", "ngModel", "placeholder"], ["class", "po-lookup-advanced-search", 4, "ngIf"], ["class", "po-md-12", 3, "p-disclaimers", "p-title", "p-change", 4, "ngIf"], [1, "po-row", "po-lookup-container-table"], [1, "po-md-12", 3, "p-selected", "p-unselected", "p-all-selected", "p-all-unselected", "p-show-more", "p-sort-by", "p-change-visible-columns", "p-restore-column-manager", "p-selectable", "p-hide-detail", "p-single-select", "p-hide-action-fixed-columns", "p-sort", "p-columns", "p-height", "p-hide-columns-manager", "p-items", "p-literals", "p-loading", "p-show-more-disabled", "p-infinite-scroll", "p-spacing", "p-text-wrap", "p-virtual-scroll"], ["class", "po-md-12", 3, "p-disclaimers", "p-remove", "p-remove-all", 4, "ngIf"], [1, "po-lookup-advanced-search"], ["tabindex", "0", 1, "po-lookup-advanced-search-link", 3, "click", "keydown.enter"], [1, "po-md-12", 3, "p-change", "p-disclaimers", "p-title"], [1, "po-md-12", 3, "p-remove", "p-remove-all", "p-disclaimers"]],
    template: function PoLookupModalComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-modal", 4)(1, "div", 5)(2, "po-field-container", 6)(3, "div", 7)(4, "div", 8)(5, "po-icon", 9, 0);
        ɵɵlistener("click", function PoLookupModalComponent_Template_po_icon_click_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.search());
        });
        ɵɵelementEnd()();
        ɵɵelementStart(7, "input", 10, 1);
        ɵɵtwoWayListener("ngModelChange", function PoLookupModalComponent_Template_input_ngModelChange_7_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.searchValue, $event) || (ctx.searchValue = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("keydown.enter", function PoLookupModalComponent_Template_input_keydown_enter_7_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.search());
        });
        ɵɵelementEnd()();
        ɵɵtemplate(9, PoLookupModalComponent_div_9_Template, 3, 1, "div", 11);
        ɵɵelementEnd();
        ɵɵtemplate(10, PoLookupModalComponent_po_disclaimer_group_10_Template, 1, 2, "po-disclaimer-group", 12);
        ɵɵelementStart(11, "div", 13)(12, "po-table", 14, 2);
        ɵɵlistener("p-selected", function PoLookupModalComponent_Template_po_table_p_selected_12_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onSelect($event));
        })("p-unselected", function PoLookupModalComponent_Template_po_table_p_unselected_12_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onUnselect($event));
        })("p-all-selected", function PoLookupModalComponent_Template_po_table_p_all_selected_12_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onAllSelected($event));
        })("p-all-unselected", function PoLookupModalComponent_Template_po_table_p_all_unselected_12_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onAllUnselected($event));
        })("p-show-more", function PoLookupModalComponent_Template_po_table_p_show_more_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.showMoreEvent());
        })("p-sort-by", function PoLookupModalComponent_Template_po_table_p_sort_by_12_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.sortBy($event));
        })("p-change-visible-columns", function PoLookupModalComponent_Template_po_table_p_change_visible_columns_12_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.changeVisibleColumns.emit($event));
        })("p-restore-column-manager", function PoLookupModalComponent_Template_po_table_p_restore_column_manager_12_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.columnRestoreManager.emit($event));
        });
        ɵɵelementEnd()();
        ɵɵtemplate(14, PoLookupModalComponent_po_disclaimer_group_14_Template, 1, 1, "po-disclaimer-group", 15);
        ɵɵelementEnd();
        ɵɵelementStart(15, "div", 5);
        ɵɵelementContainer(16, null, 3);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("p-primary-action", ctx.isAdvancedFilter ? ctx.primaryActionAdvancedFilter : ctx.primaryAction)("p-secondary-action", ctx.isAdvancedFilter ? ctx.secondaryActionAdvancedFilter : ctx.secondaryAction)("p-title", ctx.isAdvancedFilter ? ctx.advancedFilterModalTitle : ctx.title);
        ɵɵadvance();
        ɵɵproperty("hidden", ctx.isAdvancedFilter);
        ɵɵadvance();
        ɵɵproperty("p-optional", false);
        ɵɵadvance(5);
        ɵɵtwoWayProperty("ngModel", ctx.searchValue);
        ɵɵproperty("placeholder", ctx.literals.modalPlaceholder);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.advancedFilters && ctx.advancedFilters.length > 0);
        ɵɵadvance();
        ɵɵproperty("ngIf", !!ctx.disclaimerGroup);
        ɵɵadvance();
        ɵɵattribute("data-multiple", ctx.multiple);
        ɵɵadvance();
        ɵɵproperty("p-selectable", true)("p-hide-detail", true)("p-single-select", !ctx.multiple)("p-hide-action-fixed-columns", true)("p-sort", true)("p-columns", ctx.columns)("p-height", ctx.tableHeight)("p-hide-columns-manager", ctx.hideColumnsManager)("p-items", ctx.items)("p-literals", ctx.tableLiterals)("p-loading", ctx.isLoading)("p-show-more-disabled", !ctx.hasNext)("p-infinite-scroll", ctx.infiniteScroll)("p-spacing", ctx.spacing)("p-text-wrap", ctx.textWrap)("p-virtual-scroll", ctx.virtualScroll);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.multiple);
        ɵɵadvance();
        ɵɵproperty("hidden", !ctx.isAdvancedFilter);
      }
    },
    dependencies: [NgIf, DefaultValueAccessor, NgControlStatus, NgModel, PoDisclaimerGroupComponent, PoFieldContainerComponent, PoModalComponent, PoTableComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupModalComponent, [{
    type: Component,
    args: [{
      selector: "po-lookup-modal",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<po-modal\n  p-click-out="false"\n  p-hide-close="false"\n  p-size="lg"\n  [p-primary-action]="isAdvancedFilter ? primaryActionAdvancedFilter : primaryAction"\n  [p-secondary-action]="isAdvancedFilter ? secondaryActionAdvancedFilter : secondaryAction"\n  [p-title]="isAdvancedFilter ? advancedFilterModalTitle : title"\n>\n  <div [hidden]="isAdvancedFilter">\n    <po-field-container class="po-lookup-header po-pull-right" [p-optional]="false">\n      <div class="po-lookup-filter-content">\n        <div class="po-field-icon-container-right">\n          <po-icon #iconLookup p-icon="ICON_SEARCH" class="po-field-icon po-icon-input" (click)="search()"> </po-icon>\n        </div>\n\n        <input\n          #inpsearch\n          class="po-input po-input-icon-right"\n          name="contentSearch"\n          [(ngModel)]="searchValue"\n          [placeholder]="literals.modalPlaceholder"\n          (keydown.enter)="search()"\n          type="text"\n        />\n      </div>\n\n      <div *ngIf="advancedFilters && advancedFilters.length > 0" class="po-lookup-advanced-search">\n        <span\n          class="po-lookup-advanced-search-link"\n          tabindex="0"\n          (click)="onAdvancedFilter()"\n          (keydown.enter)="onAdvancedFilter()"\n        >\n          {{ literals.modalAdvancedSearch }}\n        </span>\n      </div>\n    </po-field-container>\n\n    <!-- DISCLAIMER -->\n    <po-disclaimer-group\n      *ngIf="!!disclaimerGroup"\n      class="po-md-12"\n      [p-disclaimers]="disclaimerGroup?.disclaimers"\n      [p-title]="disclaimerGroup?.title"\n      (p-change)="onChangeDisclaimerGroup()"\n    >\n    </po-disclaimer-group>\n\n    <div class="po-row po-lookup-container-table" [attr.data-multiple]="multiple">\n      <po-table\n        #poTable\n        class="po-md-12"\n        [p-selectable]="true"\n        [p-hide-detail]="true"\n        [p-single-select]="!multiple"\n        [p-hide-action-fixed-columns]="true"\n        [p-sort]="true"\n        [p-columns]="columns"\n        [p-height]="tableHeight"\n        [p-hide-columns-manager]="hideColumnsManager"\n        [p-items]="items"\n        [p-literals]="tableLiterals"\n        [p-loading]="isLoading"\n        [p-show-more-disabled]="!hasNext"\n        [p-infinite-scroll]="infiniteScroll"\n        [p-spacing]="spacing"\n        [p-text-wrap]="textWrap"\n        [p-virtual-scroll]="virtualScroll"\n        (p-selected)="onSelect($event)"\n        (p-unselected)="onUnselect($event)"\n        (p-all-selected)="onAllSelected($event)"\n        (p-all-unselected)="onAllUnselected($event)"\n        (p-show-more)="showMoreEvent()"\n        (p-sort-by)="sortBy($event)"\n        (p-change-visible-columns)="changeVisibleColumns.emit($event)"\n        (p-restore-column-manager)="columnRestoreManager.emit($event)"\n      >\n      </po-table>\n    </div>\n\n    <!-- DISCLAIMER -->\n    <po-disclaimer-group\n      *ngIf="multiple"\n      class="po-md-12"\n      [p-disclaimers]="selecteds"\n      (p-remove)="onUnselectFromDisclaimer($event.removedDisclaimer)"\n      (p-remove-all)="onAllUnselected($event)"\n    >\n    </po-disclaimer-group>\n  </div>\n  <div [hidden]="!isAdvancedFilter">\n    <ng-container #container> </ng-container>\n  </div>\n</po-modal>\n'
    }]
  }], () => [{
    type: ComponentFactoryResolver$1
  }, {
    type: PoLanguageService
  }, {
    type: ChangeDetectorRef
  }], {
    inputSearchEl: [{
      type: ViewChild,
      args: ["inpsearch"]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLookupModalComponent, {
    className: "PoLookupModalComponent",
    filePath: "lib/components/po-field/po-lookup/po-lookup-modal/po-lookup-modal.component.ts",
    lineNumber: 32
  });
})();
var PoLookupFilterService = class _PoLookupFilterService {
  httpClient;
  headers = new HttpHeaders({
    "X-PO-No-Message": "true"
  });
  url;
  fieldValue;
  multiple = false;
  constructor(httpClient) {
    this.httpClient = httpClient;
  }
  getFilteredItems(filteredItemsParams) {
    const _a = filteredItemsParams, {
      filterParams,
      advancedFilters
    } = _a, restFilteredItemsParams = __objRest(_a, [
      "filterParams",
      "advancedFilters"
    ]);
    const validatedFilterParams = this.validateParams(filterParams);
    const validatedAdvancedFilters = this.validateParams(advancedFilters);
    const params = __spreadValues(__spreadValues(__spreadValues({}, restFilteredItemsParams), validatedFilterParams), validatedAdvancedFilters);
    return this.httpClient.get(this.url, {
      headers: this.headers,
      params
    });
  }
  getObjectByValue(value, filterParams) {
    const validatedFilterParams = this.validateParams(filterParams);
    let newURL;
    let encodedValue;
    if (this.multiple) {
      encodedValue = encodeURIComponent(Array.isArray(value) ? value.join(",") : value);
      newURL = `${this.url}?${this.fieldValue}=${encodedValue}`;
    } else {
      encodedValue = encodeURIComponent(value);
      newURL = `${this.url}/${encodedValue}`;
    }
    return this.httpClient.get(newURL, {
      headers: this.headers,
      params: validatedFilterParams
    }).pipe(map((response) => "items" in response ? response.items : response));
  }
  setConfig(url, fieldValue, multiple) {
    this.url = url;
    this.fieldValue = fieldValue;
    this.multiple = multiple;
  }
  validateParams(params) {
    return isTypeof(params, "object") && !Array.isArray(params) ? params : void 0;
  }
  static ɵfac = function PoLookupFilterService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLookupFilterService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoLookupFilterService,
    factory: _PoLookupFilterService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupFilterService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }], null);
})();
var PoLookupModalService = class _PoLookupModalService {
  poComponentInjector;
  selectValueEvent = new EventEmitter();
  componentRef = null;
  constructor(poComponentInjector) {
    this.poComponentInjector = poComponentInjector;
  }
  /**
   * Método responsável por abrir a modal de busca das informações.
   *
   * @param advancedFilters {Array<PoDynamicFormField>} Objeto utilizado para criar o busca avançada.
   * @param service {PoLookupFilter} Serviço responsável por realizar a busca no serviço dos dados.
   * @param columns {Array<PoLookupColumn>} Definição das colunas na modal de busca.
   * @param filterParams {any} Valor que será repassado aos métodos do serviço para auxiliar no filtro dos dados.
   * @param title {string} Definição do título da modal.
   * @param literals {PoLookupLiterals} Literais utilizadas no componente.
   * @param selectedItems {any} Valor que está selecionado que será repassado para o modal para apresentar na tabela.
   * @param fieldLabel {string} Valor que será utilizado como descrição do campo.
   * @param fieldValue {string} Valor que será utilizado como valor do campo.
   * @param changeVisibleColumns {function} Função que será executada quando for alterada a visibilidade das colunas.
   * @param columnRestoreManager {function} Função que será executada quando for restaurar as colunas padrão.
   */
  openModal(params) {
    const {
      advancedFilters,
      service,
      columns,
      filterParams,
      hideColumnsManager,
      title,
      literals,
      infiniteScroll,
      multiple,
      selectedItems,
      fieldLabel,
      fieldValue,
      spacing,
      textWrap,
      virtualScroll,
      changeVisibleColumns,
      columnRestoreManager
    } = params;
    this.componentRef = this.poComponentInjector.createComponentInApplication(PoLookupModalComponent);
    this.componentRef.instance.advancedFilters = advancedFilters;
    this.componentRef.instance.title = title;
    this.componentRef.instance.columns = columns;
    this.componentRef.instance.filterService = service;
    this.componentRef.instance.filterParams = filterParams;
    this.componentRef.instance.literals = literals;
    this.componentRef.instance.model.subscribe(($event) => {
      this.selectValue($event);
    });
    this.componentRef.instance.infiniteScroll = infiniteScroll;
    this.componentRef.instance.multiple = multiple;
    this.componentRef.instance.selectedItems = selectedItems;
    this.componentRef.instance.fieldLabel = fieldLabel;
    this.componentRef.instance.fieldValue = fieldValue;
    this.componentRef.instance.changeVisibleColumns = changeVisibleColumns;
    this.componentRef.instance.columnRestoreManager = columnRestoreManager;
    this.componentRef.instance.hideColumnsManager = hideColumnsManager;
    this.componentRef.instance.spacing = spacing;
    this.componentRef.instance.textWrap = textWrap;
    this.componentRef.instance.virtualScroll = virtualScroll;
    this.componentRef.changeDetectorRef.detectChanges();
    this.componentRef.instance.openModal();
  }
  setChangeColumns(columns) {
    if (this.componentRef !== null) {
      this.componentRef.instance.columns = columns;
      this.componentRef.changeDetectorRef.detectChanges();
    }
  }
  // Este metodo é chamado quando é selecionado um item na lookup modal.
  selectValue(value) {
    if (value) {
      this.selectValueEvent.emit(value);
    }
    this.componentRef.destroy();
  }
  static ɵfac = function PoLookupModalService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLookupModalService)(ɵɵinject(PoComponentInjectorService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoLookupModalService,
    factory: _PoLookupModalService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupModalService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PoComponentInjectorService
  }], null);
})();
var poLookupLiteralsDefault = {
  en: {
    search: "Search",
    clean: "Clean"
  },
  es: {
    search: "Buscar",
    clean: "Limpiar"
  },
  pt: {
    search: "Pesquisar",
    clean: "Apagar"
  },
  ru: {
    search: "Поиск",
    clean: "чистый"
  }
};
var PoLookupBaseComponent = class _PoLookupBaseComponent {
  defaultService;
  injector;
  poLookupModalService;
  _literals;
  language;
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Define que o tooltip (`p-additional-help-tooltip` e/ou `p-error-limit`) será incluído no body da página e não
   * dentro do componente. Essa opção pode ser necessária em cenários com containers que possuem scroll ou overflow
   * escondido, garantindo o posicionamento correto do tooltip próximo ao elemento.
   *
   * > Quando utilizado com `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /**
   * Label do campo.
   *
   * > Quando utilizar esta propriedade o seu valor será utilizado como título da modal do componente caso não tenha
   * sido definido um `modalTitle` na propriedade `p-literals`.
   */
  label;
  /**
   * @description
   *
   * Objeto com as literais usadas no `po-lookup`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoLookupLiterals = {
   *    modalPrimaryActionLabel: 'Select',
   *    modalSecondaryActionLabel: 'Cancel',
   *    modalPlaceholder: 'Search Value',
   *    modalTableNoColumns: 'No columns',
   *    modalTableNoData: 'No data',
   *    modalTableLoadingData: 'Loading data',
   *    modalTableLoadMoreData: 'Load more',
   *    modalTitle: 'Select a user',
   *    modalAdvancedSearch: 'Advanced search',
   *    modalAdvancedSearchTitle: 'Advanced search',
   *    modalAdvancedSearchPrimaryActionLabel: 'Filter',
   *    modalAdvancedSearchSecondaryActionLabel: 'Return',
   *    modalDisclaimerGroupTitle: 'Presenting results filtered by:'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoLookupLiterals = {
   *    modalPrimaryActionLabel: 'Select'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-lookup
   *   [p-literals]="customLiterals">
   * </po-lookup>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poLookupLiteralsDefault[poLocaleDefault]), poLookupLiteralsDefault[this.language]), value);
    } else {
      this._literals = poLookupLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poLookupLiteralsDefault[this.language];
  }
  /** Texto de apoio do campo. */
  help;
  /** Mensagem que aparecerá enquanto o campo não estiver preenchido. */
  set placeholder(value) {
    this._placeholder = value || "";
  }
  get placeholder() {
    return this._placeholder;
  }
  /** Nome e Id do componente. */
  name;
  /**
   * @description
   *
   * Indica a coluna que será utilizada como valor do campo.
   *
   * > Atenção: Caso não seja passada ou tenha o conteúdo incorreto, não irá atualizar o model do formulário.
   */
  fieldValue;
  /** Indica a coluna que será utilizada como descrição do campo e como filtro dentro da janela. */
  set fieldLabel(value) {
    this._fieldLabel = value;
    this.keysDescription = [this.fieldLabel];
  }
  get fieldLabel() {
    return this._fieldLabel;
  }
  /** Valor que será repassado como parâmetro para a URL ou aos métodos do serviço que implementam a interface `PoLookupFilter`. */
  filterParams;
  /**
   * @optional
   *
   * @description
   *
   * Formato de exibição do campo.
   *
   * Recebe uma função que deve retornar uma *string* com o/os valores do objeto formatados para exibição, por exemplo:
   *
   * ```
   * fieldFormat(obj) {
   *   return `${obj.id} - ${obj.name}`;
   * }
   * ```
   * > Esta propriedade sobrepõe o valor da propriedade `p-field-label` na descrição do campo.
   *
   * Pode-se informar uma lista de propriedades que deseja exibir como descrição do campo, Por exemplo:
   * ```
   * <po-lookup
   *  ...
   *  [p-field-format]="['id','nickname']"
   *  ...
   * >
   *
   * Objeto retornado:
   *   {
   *      id:123,
   *      name: 'Kakaroto',
   *      nickname: 'Goku',
   *   }
   * Apresentação no campo: 123 - Goku
   * ```
   *
   * > Será utilizado ` - ` como separador.
   */
  fieldFormat;
  /**
   * Lista das colunas da tabela.
   * Essa propriedade deve receber um array de objetos que implementam a interface PoLookupColumn.
   */
  columns;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   *
   * @optional
   *
   * @description
   *
   * Lista de objetos dos campos que serão criados na busca avançada.
   *
   * > Caso não seja passado um objeto ou então ele esteja em branco o link de busca avançada ficará escondido.
   *
   * Exemplo de URL com busca avançada:
   *
   * ```
   * url + ?page=1&pageSize=20&name=Tony%20Stark&nickname=Homem%20de%20Ferro
   * ```
   *
   * Caso algum parâmetro seja uma lista, a concatenação é feita utilizando vírgula.
   * Exemplo:
   *
   * ```
   * url + ?page=1&pageSize=20&name=Tony%20Stark,Peter%20Parker,Gohan
   * ```
   *
   */
  advancedFilters;
  /**
   * @optional
   *
   * @description
   *
   * Permite que o gerenciador de colunas, responsável pela definição de quais colunas serão exibidas, seja escondido.
   *
   * @default `false`
   */
  hideColumnsManager = false;
  /**
   * @optional
   *
   * @description
   *
   * Ativa a funcionalidade de scroll infinito para a tabela exibida no retorno da consulta.
   *
   * @default `false`
   */
  infiniteScroll = false;
  /** Exibe um ícone que permite limpar o campo. */
  clean = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite a seleção de múltiplos itens.
   *
   * > Quando habilitado o valor do campo passará a ser uma lista de valores, por exemplo: `[ 12345, 67890 ]`
   *
   * @default `false`
   */
  multiple = false;
  /**
   * @optional
   *
   * @description
   *
   * Define que a altura do componente será auto ajustável, possuindo uma altura minima porém a altura máxima será de acordo
   * com o número de itens selecionados e a extensão dos mesmos, mantendo-os sempre visíveis.
   *
   * @default `false`
   */
  autoHeight = false;
  /**
   * @optional
   *
   * @description
   *
   * Exibe a mensagem setada se o campo estiver vazio e for requerido.
   *
   * > Necessário que a propriedade `p-required` esteja habilitada.
   *
   */
  fieldErrorMessage;
  /**
   * @optional
   *
   * @description
   *
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   *
   * > Caso essa propriedade seja definida como `true`, a mensagem de erro será limitada a duas linhas
   * e um tooltip será exibido ao passar o mouse sobre a mensagem para mostrar o conteúdo completo.
   *
   * @default `false`
   */
  errorLimit = false;
  /**
   * @optional
   *
   * @description
   *
   * Responsável por aplicar espaçamento nas colunas da tabela contida no lookup.
   *
   * Deve receber um dos valores do enum `PoTableColumnSpacing`.
   *
   * @default `medium`
   */
  spacing = PoTableColumnSpacing.Medium;
  /**
   * @optional
   *
   * @description
   *
   * Habilita ou desabilita a quebra automática de texto. Quando ativada, o texto que excede
   * o espaço disponível é transferido para a próxima linha em pontos apropriados para uma
   * leitura clara.
   *
   * Esta propriedade aplica-se ao texto contido nas células da tabela.
   *
   * > Incompatível com `virtual-scroll`, que requer altura fixa nas linhas.
   *
   * @default `false`
   */
  textWrap = false;
  /**
   * @optional
   *
   * @description
   *
   * Habilita o `virtual-scroll` na tabela para melhorar a performance com grandes volumes de dados.
   * A altura da tabela já é pré-definida, portanto o `virtual-scroll` será ativado automaticamente.
   *
   * > Incompatível com `p-text-wrap` e `master-detail`, pois o `virtual-scroll` exige altura fixa nas linhas.
   *
   * @default `true`
   */
  virtualScroll = true;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * Evento será disparado quando ocorrer algum erro na requisição de busca do item.
   * Será passado por parâmetro o objeto de erro retornado.
   */
  onError = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento será disparado quando ocorrer alguma seleção.
   * Será passado por parâmetro o objeto com o valor selecionado.
   */
  selected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   *  Evento que será disparado ao alterar o model.
   *  Por parâmetro será passado o novo valor.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado ao fechar o popover do gerenciador de colunas após alterar as colunas visíveis.
   *
   * O componente envia como parâmetro um array de string com as colunas visíveis atualizadas.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  changeVisibleColumns = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no botão de restaurar padrão no gerenciador de colunas.
   *
   * O componente envia como parâmetro um array de string com as colunas configuradas inicialmente.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  columnRestoreManager = new EventEmitter();
  displayAdditionalHelp = false;
  service;
  selectedOptions = [];
  getSubscription;
  keysDescription;
  oldValue = "";
  valueToModel;
  oldValueToModel = null;
  // eslint-disable-next-line
  onTouched = null;
  resizeListener;
  _disabled = false;
  _fieldLabel;
  _filterService;
  _noAutocomplete;
  _placeholder = "";
  _required = false;
  _autoHeight = false;
  autoHeightInitialValue;
  onChangePropagate = null;
  validatorChange;
  control;
  injectOptions = {
    self: true
  };
  /**
   * Serviço responsável por buscar os dados da tabela na janela. Pode ser informado um serviço que implemente a interface
   * `PoLookupFilter` ou uma URL.
   *
   * Quando utilizada uma URL de um serviço, será concatenada nesta URL o valor que deseja-se filtrar, por exemplo:
   *
   * ```
   * url + ?page=1&pageSize=20&filter=Peter
   * ```
   *
   * Caso utilizar ordenação, a coluna ordenada será enviada através do parâmetro `order`, por exemplo:
   * - Coluna decrescente:
   * ```
   *  url + ?page=1&pageSize=20&filter=Peter&order=-name
   * ```
   *
   * - Coluna ascendente:
   * ```
   *  url + ?page=1&pageSize=20&filter=Peter&order=name
   * ```
   *
   * Se for definido a propriedade `p-filter-params`, o mesmo também será concatenado. Por exemplo, para o
   * parâmetro `{ age: 23 }` a URL ficaria:
   *
   * ```
   * url + ?page=1&pageSize=20&age=23&filter=Peter
   * ```
   *
   * Ao iniciar o campo com valor, os registros serão buscados da seguinte forma:
   * ```
   * model = 1234;
   *
   * GET url/1234
   * ```
   *
   * Caso estiver com múltipla seleção habilitada:
   * ```
   * model = [1234, 5678]
   *
   * GET url?${fieldValue}=1234,5678
   * ```
   *
   * > Esta URL deve retornar e receber os dados no padrão de [API do PO UI](https://po-ui.io/guides/api) e utiliza os valores
   * definidos nas propriedades `p-field-label` e `p-field-value` para a construção do `po-lookup`.
   *
   * Caso o usuário digite um valor e pressione a tecla *TAB* para realizar a busca de um registro específico, o valor que se
   * deseja filtrar será codificado utilizando a função [encodeURIComponent](https://tc39.es/ecma262/#sec-encodeuricomponent-uricomponent)
   * e concatenado na URL da seguinte forma:
   *
   * ```
   * url/valor%20que%20se%20deseja%20filtrar
   * ```
   *
   * > Quando informado um serviço que implemente a interface `PoLookupFilter` o tratamento de encoding do valor a ser filtrado ficará a cargo do desenvolvedor.
   *
   */
  set filterService(filterService) {
    this._filterService = filterService;
    this.setService(this.filterService);
  }
  get filterService() {
    return this._filterService;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a propriedade nativa `autocomplete` do campo como `off`.
   *
   * @default `false`
   */
  set noAutocomplete(value) {
    this._noAutocomplete = convertToBoolean(value);
  }
  get noAutocomplete() {
    return this._noAutocomplete;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   * > Esta propriedade é desconsiderada quando o input está desabilitado `(p-disabled)`.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel(this.valueToModel);
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório seré exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * @description
   *
   * Indica que o campo será desabilitado.
   *
   * @default false
   * @optional
   */
  set disabled(disabled) {
    this._disabled = disabled === "" ? true : convertToBoolean(disabled);
  }
  get disabled() {
    return this._disabled;
  }
  constructor(defaultService, injector, poLookupModalService, languageService) {
    this.defaultService = defaultService;
    this.injector = injector;
    this.poLookupModalService = poLookupModalService;
    this.language = languageService.getShortLanguage();
  }
  ngOnDestroy() {
    if (this.getSubscription) {
      this.getSubscription.unsubscribe();
    }
  }
  ngOnInit() {
    this.initializeColumn();
  }
  ngAfterViewInit() {
    this.setControl();
  }
  cleanModel() {
    this.cleanViewValue();
    this.callOnChange(void 0);
  }
  ngOnChanges(changes) {
    if (changes.columns?.currentValue) {
      this.columns = changes.columns.currentValue;
      this.poLookupModalService?.setChangeColumns(this.columns);
    }
    if (changes.multiple && isTypeof(this.filterService, "string")) {
      this.service.setConfig(this.filterService, this.fieldValue, this.multiple);
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  // Função implementada do ControlValueAccessor.
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model.
  registerOnChange(func) {
    this.onChangePropagate = func;
  }
  // Função implementada do ControlValueAccessor.
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model.
  registerOnTouched(func) {
    this.onTouched = func;
  }
  // Seleciona o valor do model.
  selectValue(valueSelected) {
    this.valueToModel = valueSelected;
    this.multiple ? this.callOnChange(this.valueToModel) : this.valueToModel ? this.callOnChange(this.valueToModel[this.fieldValue]) : this.callOnChange(void 0);
    this.selected.emit(valueSelected);
  }
  callOnChange(value) {
    if (this.onChangePropagate) {
      this.onChangePropagate(value);
    }
    if (this.oldValueToModel !== this.valueToModel) {
      this.change.emit(value);
    }
    this.oldValueToModel = this.valueToModel;
  }
  searchById(value) {
    let checkedValue = value;
    if (typeof checkedValue === "string") {
      checkedValue = checkedValue.trim();
    }
    if (checkedValue !== "") {
      const oldDisable = this.disabled;
      this.disabled = true;
      if (this.control) {
        setTimeout(() => this.control.markAsPending());
      }
      this.getSubscription = this.service.getObjectByValue(value, this.filterParams).pipe(finalize(() => {
        this.disabled = oldDisable;
        if (this.control) {
          this.control.updateValueAndValidity();
        }
      })).subscribe((element) => {
        if (element?.length || !Array.isArray(element) && element) {
          if (Array.isArray(element) && element.length > 1) {
            this.setDisclaimers(element);
            this.updateVisibleItems();
          }
          this.selectModel(this.multiple ? element : [element]);
        } else {
          this.cleanModel();
        }
      }, (error) => {
        this.cleanModel();
        this.onError.emit(error);
      });
    } else {
      this.cleanModel();
    }
  }
  validate(abstractControl) {
    if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
  }
  writeValue(value) {
    if (value?.length || !Array.isArray(value) && value) {
      this.searchById(value);
    } else {
      this.cleanViewValue();
    }
  }
  // Retorna o Subscriber da propriedade getSubscription que ocorre
  // no evento de blur que executa o método searchEvent().
  getSubscriptionFunction() {
    return this.getSubscription;
  }
  cleanViewValue() {
    this.setDisclaimers([]);
    this.setViewValue("", {});
    this.oldValue = "";
    this.valueToModel = null;
  }
  // Formata a label do campo.
  getFormattedLabel(value) {
    return value ? this.keysDescription.map((column) => value[column]).join(" - ") : "";
  }
  // Chama o método writeValue e preenche o model.
  selectModel(options) {
    if (options.length) {
      this.selectedOptions = [...options];
      const newModel = this.multiple ? options.map((option) => option[this.fieldValue]) : options[0];
      this.selectValue(newModel);
      if (options.length === 1) {
        this.oldValue = options[0][this.fieldLabel];
        this.setViewValue(this.getFormattedLabel(options[0]), options[0]);
      }
    } else {
      this.selectValue(void 0);
      this.cleanViewValue();
    }
  }
  validateModel(model) {
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  setService(service) {
    if (isTypeof(service, "object")) {
      this.service = service;
    }
    if (service && isTypeof(service, "string")) {
      this.service = this.defaultService;
      this.service.setConfig(service, this.fieldValue, this.multiple);
    }
  }
  setControl() {
    const ngControl = this.injector.get(NgControl, null, this.injectOptions);
    if (ngControl) {
      this.control = ngControl.control;
    }
  }
  initializeColumn() {
    if (this.fieldLabel) {
      this.keysDescription = [this.fieldLabel];
    } else {
      this.keysDescription = [];
      this.keysDescription = this.columns.filter((element) => element.fieldLabel).map((element) => element.property);
    }
  }
  static ɵfac = function PoLookupBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLookupBaseComponent)(ɵɵdirectiveInject(PoLookupFilterService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(PoLookupModalService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoLookupBaseComponent,
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      label: [0, "p-label", "label"],
      literals: [0, "p-literals", "literals"],
      help: [0, "p-help", "help"],
      placeholder: [0, "p-placeholder", "placeholder"],
      name: "name",
      fieldValue: [0, "p-field-value", "fieldValue"],
      fieldLabel: [0, "p-field-label", "fieldLabel"],
      filterParams: [0, "p-filter-params", "filterParams"],
      fieldFormat: [0, "p-field-format", "fieldFormat"],
      columns: [0, "p-columns", "columns"],
      optional: [0, "p-optional", "optional"],
      advancedFilters: [0, "p-advanced-filters", "advancedFilters"],
      hideColumnsManager: [2, "p-hide-columns-manager", "hideColumnsManager", convertToBoolean],
      infiniteScroll: [2, "p-infinite-scroll", "infiniteScroll", convertToBoolean],
      clean: [2, "p-clean", "clean", convertToBoolean],
      multiple: [2, "p-multiple", "multiple", convertToBoolean],
      autoHeight: [2, "p-auto-height", "autoHeight", convertToBoolean],
      fieldErrorMessage: [0, "p-field-error-message", "fieldErrorMessage"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      spacing: [0, "p-spacing", "spacing"],
      textWrap: [2, "p-text-wrap", "textWrap", convertToBoolean],
      virtualScroll: [2, "p-virtual-scroll", "virtualScroll", convertToBoolean],
      filterService: [0, "p-filter-service", "filterService"],
      noAutocomplete: [0, "p-no-autocomplete", "noAutocomplete"],
      required: [0, "p-required", "required"],
      showRequired: [0, "p-show-required", "showRequired"],
      disabled: [0, "p-disabled", "disabled"]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      onError: "p-error",
      keydown: "p-keydown",
      selected: "p-selected",
      change: "p-change",
      changeVisibleColumns: "p-change-visible-columns",
      columnRestoreManager: "p-restore-column-manager"
    },
    features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLookupFilterService
  }, {
    type: Injector,
    decorators: [{
      type: Inject,
      args: [Injector]
    }]
  }, {
    type: PoLookupModalService
  }, {
    type: PoLanguageService
  }], {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    placeholder: [{
      type: Input,
      args: ["p-placeholder"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    fieldValue: [{
      type: Input,
      args: ["p-field-value"]
    }],
    fieldLabel: [{
      type: Input,
      args: ["p-field-label"]
    }],
    filterParams: [{
      type: Input,
      args: ["p-filter-params"]
    }],
    fieldFormat: [{
      type: Input,
      args: ["p-field-format"]
    }],
    columns: [{
      type: Input,
      args: ["p-columns"]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    advancedFilters: [{
      type: Input,
      args: ["p-advanced-filters"]
    }],
    hideColumnsManager: [{
      type: Input,
      args: [{
        alias: "p-hide-columns-manager",
        transform: convertToBoolean
      }]
    }],
    infiniteScroll: [{
      type: Input,
      args: [{
        alias: "p-infinite-scroll",
        transform: convertToBoolean
      }]
    }],
    clean: [{
      type: Input,
      args: [{
        alias: "p-clean",
        transform: convertToBoolean
      }]
    }],
    multiple: [{
      type: Input,
      args: [{
        alias: "p-multiple",
        transform: convertToBoolean
      }]
    }],
    autoHeight: [{
      type: Input,
      args: [{
        alias: "p-auto-height",
        transform: convertToBoolean
      }]
    }],
    fieldErrorMessage: [{
      type: Input,
      args: ["p-field-error-message"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    spacing: [{
      type: Input,
      args: ["p-spacing"]
    }],
    textWrap: [{
      type: Input,
      args: [{
        alias: "p-text-wrap",
        transform: convertToBoolean
      }]
    }],
    virtualScroll: [{
      type: Input,
      args: [{
        alias: "p-virtual-scroll",
        transform: convertToBoolean
      }]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    onError: [{
      type: Output,
      args: ["p-error"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    selected: [{
      type: Output,
      args: ["p-selected"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    changeVisibleColumns: [{
      type: Output,
      args: ["p-change-visible-columns"]
    }],
    columnRestoreManager: [{
      type: Output,
      args: ["p-restore-column-manager"]
    }],
    filterService: [{
      type: Input,
      args: ["p-filter-service"]
    }],
    noAutocomplete: [{
      type: Input,
      args: ["p-no-autocomplete"]
    }],
    required: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }]
  });
})();
var _c0$Q = ["inp"];
function PoLookupComponent_div_1_po_clean_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 13);
    ɵɵlistener("p-change-event", function PoLookupComponent_div_1_po_clean_5_Template_po_clean_p_change_event_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.cleanModel());
    })("click", function PoLookupComponent_div_1_po_clean_5_Template_po_clean_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext(2);
      ctx_r2.cleanModel();
      return ɵɵresetView($event.preventDefault());
    })("keydown.enter", function PoLookupComponent_div_1_po_clean_5_Template_po_clean_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext(2);
      ctx_r2.cleanModel();
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const inp_r5 = ɵɵreference(3);
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-element-ref", inp_r5);
    ɵɵattribute("aria-label", ctx_r2.literals.clean);
  }
}
function PoLookupComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 6)(1, "div", 7)(2, "input", 8, 1);
    ɵɵlistener("blur", function PoLookupComponent_div_1_Template_input_blur_2_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.searchEvent());
    })("keydown", function PoLookupComponent_div_1_Template_input_keydown_2_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onKeyDown($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 9);
    ɵɵtemplate(5, PoLookupComponent_div_1_po_clean_5_Template, 1, 2, "po-clean", 10);
    ɵɵelementStart(6, "div", 11, 2);
    ɵɵlistener("p-change-event", function PoLookupComponent_div_1_Template_div_p_change_event_6_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.openLookup());
    })("click", function PoLookupComponent_div_1_Template_div_click_6_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      ctx_r2.openLookup();
      return ɵɵresetView($event.preventDefault());
    })("keydown.enter", function PoLookupComponent_div_1_Template_div_keydown_enter_6_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      ctx_r2.openLookup();
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelement(8, "po-icon", 12);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const inp_r5 = ɵɵreference(3);
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("po-lookup-disabled", ctx_r2.disabled);
    ɵɵadvance(2);
    ɵɵproperty("ngClass", ctx_r2.clean && inp_r5.value ? "po-input-double-icon-right" : "po-input-icon-right")("id", ctx_r2.id)("autocomplete", ctx_r2.autocomplete)("disabled", ctx_r2.disabled)("placeholder", ctx_r2.placeholder)("required", ctx_r2.required);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r2.clean && !ctx_r2.disabled && !!inp_r5.value);
    ɵɵadvance();
    ɵɵclassProp("po-field-icon-disabled", ctx_r2.disabled);
    ɵɵproperty("ariaLabel", ctx_r2.literals.search);
    ɵɵadvance(2);
    ɵɵclassProp("po-field-icon", !ctx_r2.disabled);
  }
}
function PoLookupComponent_ng_template_3_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 18);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.placeholder, " ");
  }
}
function PoLookupComponent_ng_template_3_po_disclaimer_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-disclaimer", 19);
    ɵɵlistener("p-close-action", function PoLookupComponent_ng_template_3_po_disclaimer_4_Template_po_disclaimer_p_close_action_0_listener() {
      const disclaimer_r8 = ɵɵrestoreView(_r7).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.closeDisclaimer(disclaimer_r8.value));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const disclaimer_r8 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵclassProp("po-clickable", disclaimer_r8.value === "" && !ctx_r2.disabled);
    ɵɵproperty("p-label", disclaimer_r8.label)("p-value", disclaimer_r8.value)("p-hide-close", disclaimer_r8.value === "" || ctx_r2.disabled);
  }
}
function PoLookupComponent_ng_template_3_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 13);
    ɵɵlistener("p-change-event", function PoLookupComponent_ng_template_3_po_clean_6_Template_po_clean_p_change_event_0_listener() {
      ɵɵrestoreView(_r9);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.cleanModel());
    })("click", function PoLookupComponent_ng_template_3_po_clean_6_Template_po_clean_click_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r2 = ɵɵnextContext(2);
      ctx_r2.cleanModel();
      return ɵɵresetView($event.preventDefault());
    })("keydown.enter", function PoLookupComponent_ng_template_3_po_clean_6_Template_po_clean_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r2 = ɵɵnextContext(2);
      ctx_r2.cleanModel();
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const inp_r10 = ɵɵreference(2);
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-element-ref", inp_r10);
    ɵɵattribute("aria-label", ctx_r2.literals.clean);
  }
}
function PoLookupComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 14)(1, "div", 15, 1);
    ɵɵlistener("blur", function PoLookupComponent_ng_template_3_Template_div_blur_1_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onBlur());
    })("keydown", function PoLookupComponent_ng_template_3_Template_div_keydown_1_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onKeyDown($event));
    });
    ɵɵtemplate(3, PoLookupComponent_ng_template_3_span_3_Template, 2, 1, "span", 16)(4, PoLookupComponent_ng_template_3_po_disclaimer_4_Template, 1, 5, "po-disclaimer", 17);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 9);
    ɵɵtemplate(6, PoLookupComponent_ng_template_3_po_clean_6_Template, 1, 2, "po-clean", 10);
    ɵɵelementStart(7, "div", 11, 2);
    ɵɵlistener("p-change-event", function PoLookupComponent_ng_template_3_Template_div_p_change_event_7_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.openLookup());
    })("click", function PoLookupComponent_ng_template_3_Template_div_click_7_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      ctx_r2.openLookup();
      return ɵɵresetView($event.preventDefault());
    })("keydown.enter", function PoLookupComponent_ng_template_3_Template_div_keydown_enter_7_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      ctx_r2.openLookup();
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelement(9, "po-icon", 12);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const inp_r10 = ɵɵreference(2);
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("po-lookup-disabled", ctx_r2.disabled);
    ɵɵadvance();
    ɵɵclassProp("po-lookup-input-auto", ctx_r2.autoHeight)("po-lookup-input-static", !ctx_r2.autoHeight)("po-lookup-input-padding-button-clean", ctx_r2.clean)("po-lookup-input-disabled", ctx_r2.disabled);
    ɵɵproperty("tabindex", ctx_r2.disabled ? -1 : 0)("ngClass", ctx_r2.clean && inp_r10.value ? "po-input-double-icon-right" : "po-input-icon-right");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r2.placeholder && !(ctx_r2.disclaimers == null ? null : ctx_r2.disclaimers.length));
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.visibleDisclaimers);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r2.clean && !ctx_r2.disabled && !!inp_r10.value);
    ɵɵadvance();
    ɵɵclassProp("po-field-icon-disabled", ctx_r2.disabled);
    ɵɵproperty("ariaLabel", ctx_r2.literals.search);
    ɵɵadvance(2);
    ɵɵclassProp("po-field-icon", !ctx_r2.disabled);
  }
}
var providers$2 = [PoLookupFilterService, PoLookupModalService, {
  provide: NG_VALUE_ACCESSOR,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoLookupComponent),
  multi: true
}, {
  provide: NG_VALIDATORS,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoLookupComponent),
  multi: true
}, {
  provide: NgControl,
  useExisting: forwardRef(() => PoLookupComponent),
  multi: false
}];
var PoLookupComponent = class _PoLookupComponent extends PoLookupBaseComponent {
  renderer;
  cd;
  el;
  inputEl;
  initialized = false;
  timeoutResize;
  visibleElement = false;
  heightGroupButtons = 44;
  disclaimers = [];
  visibleDisclaimers = [];
  id = `po-lookup[${uuid()}]`;
  modalSubscription;
  isCalculateVisibleItems = true;
  get autocomplete() {
    return this.noAutocomplete ? "off" : "on";
  }
  constructor(languageService, renderer, poLookupFilterService, poLookupModalService, cd, el, injector) {
    super(poLookupFilterService, injector, poLookupModalService, languageService);
    this.renderer = renderer;
    this.cd = cd;
    this.el = el;
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    if (this.autoFocus) {
      this.focus();
    }
    this.initialized = true;
  }
  ngDoCheck() {
    const inputWidth = this.inputEl?.nativeElement.offsetWidth;
    if (inputWidth && !this.visibleElement && this.initialized || inputWidth && this.isCalculateVisibleItems) {
      this.debounceResize();
      this.visibleElement = true;
    }
    this.cd.markForCheck();
  }
  ngOnDestroy() {
    if (this.modalSubscription) {
      this.modalSubscription.unsubscribe();
    }
  }
  ngOnInit() {
    super.ngOnInit();
    this.initializeListeners();
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoLookupComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoLookupComponent, { static: true }) lookup: PoLookupComponent;
   *
   * focusLookup() {
   *   this.lookup.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  openLookup() {
    if (this.isAllowedOpenModal()) {
      const {
        advancedFilters,
        service,
        columns,
        filterParams,
        hideColumnsManager,
        literals,
        infiniteScroll,
        multiple,
        fieldLabel,
        fieldValue,
        spacing,
        textWrap,
        virtualScroll,
        changeVisibleColumns,
        columnRestoreManager
      } = this;
      const selectedItems = this.checkSelectedItems();
      this.poLookupModalService.openModal({
        advancedFilters,
        service,
        columns,
        filterParams,
        hideColumnsManager,
        title: this.label,
        literals,
        infiniteScroll,
        multiple,
        selectedItems,
        fieldLabel,
        fieldValue,
        spacing,
        textWrap,
        virtualScroll,
        changeVisibleColumns,
        columnRestoreManager
      });
      if (!this.modalSubscription) {
        this.modalSubscription = this.poLookupModalService.selectValueEvent.subscribe((selectedOptions) => {
          if (selectedOptions.length > 1 || this.disclaimers.length) {
            this.setDisclaimers(selectedOptions);
            this.updateVisibleItems();
          }
          this.selectModel(selectedOptions);
        });
      }
    }
  }
  checkSelectedItems() {
    if (this.multiple) {
      if (!this.disclaimers.length && this.valueToModel?.length) {
        return [__spreadValues({
          value: this.valueToModel[0],
          label: this.oldValue
        }, this.selectedOptions[0])];
      }
      return this.disclaimers;
    } else {
      return this.valueToModel;
    }
  }
  setDisclaimers(selectedOptions) {
    this.disclaimers = selectedOptions.map((selectedOption) => __spreadValues({
      value: selectedOption[this.fieldValue],
      label: selectedOption[this.fieldLabel]
    }, selectedOption));
    this.visibleDisclaimers = [...this.disclaimers];
    this.cd.markForCheck();
  }
  setViewValue(value, object) {
    if (this.inputEl && this.fieldFormat) {
      this.setInputValueWipoieldFormat(object);
    } else if (this.inputEl) {
      this.inputEl.nativeElement.value = this.valueToModel || this.valueToModel === 0 ? value : "";
    }
    this.cd.markForCheck();
  }
  getViewValue() {
    return this.inputEl.nativeElement.value;
  }
  getErrorPattern() {
    return this.fieldErrorMessage && this.hasInvalidClass() ? this.fieldErrorMessage : "";
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty");
  }
  onBlur() {
    this.onTouched?.();
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
  }
  searchEvent() {
    this.onBlur();
    const value = this.getViewValue();
    if (this.oldValue?.toString() !== value) {
      this.searchById(value);
    }
  }
  closeDisclaimer(value) {
    this.disclaimers = this.disclaimers.filter((disclaimer) => disclaimer.value !== value);
    this.valueToModel = this.valueToModel.filter((model) => model !== value);
    this.updateVisibleItems();
    this.callOnChange(this.valueToModel.length ? this.valueToModel : void 0);
  }
  updateVisibleItems() {
    if (this.disclaimers && this.disclaimers.length > 0) {
      this.visibleDisclaimers = [].concat(this.disclaimers);
    }
    this.debounceResize();
    if (!this.inputEl.nativeElement.offsetWidth) {
      this.isCalculateVisibleItems = true;
    }
  }
  debounceResize() {
    if (!this.autoHeight) {
      clearTimeout(this.timeoutResize);
      this.debounce(this.calculateVisibleItems.bind(this), 200);
    }
  }
  debounce(func, delay2) {
    this.timeoutResize = setTimeout(func, delay2);
  }
  getInputWidth() {
    return this.inputEl.nativeElement.offsetWidth - (this.clean ? 80 : 40);
  }
  getDisclaimersWidth() {
    const disclaimers = this.inputEl.nativeElement.querySelectorAll("po-disclaimer");
    return Array.from(disclaimers).map((disclaimer) => disclaimer["offsetWidth"]);
  }
  calculateVisibleItems() {
    const disclaimersWidth = this.getDisclaimersWidth();
    const inputWidth = this.getInputWidth();
    const extraDisclaimerSize = 38;
    const disclaimersVisible = disclaimersWidth[0];
    const newDisclaimers = [];
    const disclaimers = this.disclaimers;
    if (inputWidth > 0) {
      let sum = 0;
      let i = 0;
      for (i = 0; i < disclaimers.length; i++) {
        sum += disclaimersWidth[i];
        newDisclaimers.push(disclaimers[i]);
        if (sum > inputWidth) {
          sum -= disclaimersWidth[i];
          this.isCalculateVisibleItems = false;
          break;
        }
      }
      if (disclaimersVisible || !disclaimers.length) {
        if (i === disclaimers.length) {
          this.isCalculateVisibleItems = false;
          return;
        }
        if (sum + extraDisclaimerSize > inputWidth) {
          newDisclaimers.splice(-2, 2);
          const label = "+" + (disclaimers.length + 1 - i).toString();
          newDisclaimers.push({
            value: "",
            label
          });
        } else {
          newDisclaimers.splice(-1, 1);
          const label = "+" + (disclaimers.length - i).toString();
          newDisclaimers.push({
            value: "",
            label
          });
        }
      }
    }
    this.visibleDisclaimers = [...newDisclaimers];
  }
  onKeyDown(event) {
    const isFieldFocused = document.activeElement === this.inputEl.nativeElement;
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-lookup
   *  #lookup
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, lookup)"
   * ></po-lookup>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoLookupComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  isAllowedOpenModal() {
    if (!this.service) {
      console.warn("No service informed");
    }
    return !!(this.service && !this.disabled);
  }
  formatFields(objectSelected, properties) {
    let formatedField;
    if (Array.isArray(properties)) {
      for (const property of properties) {
        if (objectSelected && objectSelected[property]) {
          if (!formatedField) {
            formatedField = objectSelected[property];
          } else {
            formatedField = formatedField + " - " + objectSelected[property];
          }
        }
      }
    }
    if (!formatedField) {
      formatedField = objectSelected[this.fieldValue];
    }
    return formatedField;
  }
  setInputValueWipoieldFormat(objectSelected) {
    const isEmpty = Object.keys(objectSelected).length === 0;
    let fieldFormated;
    if (Array.isArray(this.fieldFormat)) {
      fieldFormated = this.formatFields(objectSelected, this.fieldFormat);
    } else {
      fieldFormated = this.fieldFormat(objectSelected);
    }
    this.oldValue = isEmpty ? "" : fieldFormated;
    this.inputEl.nativeElement.value = isEmpty ? "" : fieldFormated;
  }
  initializeListeners() {
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.updateVisibleItems();
    });
  }
  static ɵfac = function PoLookupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLookupComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoLookupFilterService), ɵɵdirectiveInject(PoLookupModalService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoLookupComponent,
    selectors: [["po-lookup"]],
    viewQuery: function PoLookupComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$Q, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature(providers$2), ɵɵInheritDefinitionFeature],
    decls: 5,
    vars: 16,
    consts: [["disclaimersTemplate", ""], ["inp", ""], ["iconLookup", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], ["class", "po-field-container-content po-lookup", 3, "po-lookup-disabled", 4, "ngIf", "ngIfElse"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon"], [1, "po-field-container-content", "po-lookup"], [1, "po-search-container-wrapper"], ["type", "text", 1, "po-lookup-input", "po-lookup-input-trigger", 3, "blur", "keydown", "ngClass", "id", "autocomplete", "disabled", "placeholder", "required"], [1, "po-field-icon-container-right", "po-lookup-buttons"], ["tabindex", "0", "role", "button", "class", "po-lookup-button po-lookup-button-clean", 3, "p-element-ref", "p-change-event", "click", "keydown.enter", 4, "ngIf"], ["tabindex", "0", "role", "button", 1, "po-lookup-button", "po-lookup-button-trigger", "po-field-icon", 3, "p-change-event", "click", "keydown.enter", "ariaLabel"], ["p-icon", "ICON_SEARCH"], ["tabindex", "0", "role", "button", 1, "po-lookup-button", "po-lookup-button-clean", 3, "p-change-event", "click", "keydown.enter", "p-element-ref"], [1, "po-lookup"], [1, "po-lookup-input", "po-input-icon-right", "po-lookup-input", "po-icon-input", 3, "blur", "keydown", "tabindex", "ngClass"], ["class", "po-lookup-input-placeholder", 4, "ngIf"], ["class", "po-lookup-input-disclaimer", 3, "p-label", "p-value", "p-hide-close", "po-clickable", "p-close-action", 4, "ngFor", "ngForOf"], [1, "po-lookup-input-placeholder"], [1, "po-lookup-input-disclaimer", 3, "p-close-action", "p-label", "p-value", "p-hide-close"]],
    template: function PoLookupComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 3);
        ɵɵtemplate(1, PoLookupComponent_div_1_Template, 9, 14, "div", 4);
        ɵɵelementStart(2, "po-field-container-bottom", 5);
        ɵɵlistener("p-additional-help", function PoLookupComponent_Template_po_field_container_bottom_p_additional_help_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.emitAdditionalHelp());
        });
        ɵɵelementEnd()();
        ɵɵtemplate(3, PoLookupComponent_ng_template_3_Template, 10, 20, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const disclaimersTemplate_r11 = ɵɵreference(4);
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.disclaimers.length)("ngIfElse", disclaimersTemplate_r11);
        ɵɵadvance();
        ɵɵproperty("p-additional-help-tooltip", ctx.getAdditionalHelpTooltip())("p-append-in-body", ctx.appendBox)("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorPattern())("p-error-limit", ctx.errorLimit)("p-show-additional-help", ctx.displayAdditionalHelp)("p-show-additional-help-icon", ctx.showAdditionalHelpIcon());
      }
    },
    dependencies: [NgClass, NgForOf, NgIf, PoCleanComponent, PoDisclaimerComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupComponent, [{
    type: Component,
    args: [{
      selector: "po-lookup",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: providers$2,
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div
    class="po-field-container-content po-lookup"
    [class.po-lookup-disabled]="disabled"
    *ngIf="!disclaimers.length; else disclaimersTemplate"
  >
    <div class="po-search-container-wrapper">
      <input
        #inp
        class="po-lookup-input po-lookup-input-trigger"
        [ngClass]="clean && inp.value ? 'po-input-double-icon-right' : 'po-input-icon-right'"
        [id]="id"
        type="text"
        [autocomplete]="autocomplete"
        [disabled]="disabled"
        [placeholder]="placeholder"
        [required]="required"
        (blur)="searchEvent()"
        (keydown)="onKeyDown($event)"
      />

      <div class="po-field-icon-container-right po-lookup-buttons">
        <po-clean
          *ngIf="clean && !disabled && !!inp.value"
          tabindex="0"
          role="button"
          [attr.aria-label]="literals.clean"
          class="po-icon-input po-lookup-button po-lookup-button-clean"
          class="po-lookup-button po-lookup-button-clean"
          [p-element-ref]="inp"
          (p-change-event)="cleanModel()"
          (click)="cleanModel(); $event.preventDefault()"
          (keydown.enter)="cleanModel(); $event.preventDefault()"
        >
        </po-clean>
        <div
          #iconLookup
          tabindex="0"
          role="button"
          class="po-lookup-button po-lookup-button-trigger po-field-icon"
          [class.po-field-icon-disabled]="disabled"
          [ariaLabel]="literals.search"
          (p-change-event)="openLookup()"
          (click)="openLookup(); $event.preventDefault()"
          (keydown.enter)="openLookup(); $event.preventDefault()"
        >
          <po-icon p-icon="ICON_SEARCH" [class.po-field-icon]="!disabled"></po-icon>
        </div>
      </div>
    </div>
  </div>
  <po-field-container-bottom
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
    [p-error-limit]="errorLimit"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>

<ng-template #disclaimersTemplate>
  <div class="po-lookup" [class.po-lookup-disabled]="disabled">
    <div
      #inp
      [tabindex]="disabled ? -1 : 0"
      class="po-lookup-input po-input-icon-right po-lookup-input po-icon-input"
      [ngClass]="clean && inp.value ? 'po-input-double-icon-right' : 'po-input-icon-right'"
      [class.po-lookup-input-auto]="autoHeight"
      [class.po-lookup-input-static]="!autoHeight"
      [class.po-lookup-input-padding-button-clean]="clean"
      [class.po-lookup-input-disabled]="disabled"
      (blur)="onBlur()"
      (keydown)="onKeyDown($event)"
    >
      <span *ngIf="placeholder && !disclaimers?.length" class="po-lookup-input-placeholder">
        {{ placeholder }}
      </span>

      <po-disclaimer
        *ngFor="let disclaimer of visibleDisclaimers"
        class="po-lookup-input-disclaimer"
        [p-label]="disclaimer.label"
        [p-value]="disclaimer.value"
        [p-hide-close]="disclaimer.value === '' || disabled"
        [class.po-clickable]="disclaimer.value === '' && !disabled"
        (p-close-action)="closeDisclaimer(disclaimer.value)"
      >
      </po-disclaimer>
    </div>
    <div class="po-field-icon-container-right po-lookup-buttons">
      <po-clean
        *ngIf="clean && !disabled && !!inp.value"
        tabindex="0"
        role="button"
        [attr.aria-label]="literals.clean"
        class="po-lookup-button po-lookup-button-clean"
        [p-element-ref]="inp"
        (p-change-event)="cleanModel()"
        (click)="cleanModel(); $event.preventDefault()"
        (keydown.enter)="cleanModel(); $event.preventDefault()"
      >
      </po-clean>
      <div
        #iconLookup
        tabindex="0"
        role="button"
        class="po-lookup-button po-lookup-button-trigger po-field-icon"
        [class.po-field-icon-disabled]="disabled"
        [ariaLabel]="literals.search"
        (p-change-event)="openLookup()"
        (click)="openLookup(); $event.preventDefault()"
        (keydown.enter)="openLookup(); $event.preventDefault()"
      >
        <po-icon p-icon="ICON_SEARCH" [class.po-field-icon]="!disabled"></po-icon>
      </div>
    </div>
  </div>
</ng-template>
`
    }]
  }], () => [{
    type: PoLanguageService
  }, {
    type: Renderer2
  }, {
    type: PoLookupFilterService
  }, {
    type: PoLookupModalService
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Injector
  }], {
    inputEl: [{
      type: ViewChild,
      args: ["inp", {
        read: ElementRef,
        static: false
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLookupComponent, {
    className: "PoLookupComponent",
    filePath: "lib/components/po-field/po-lookup/po-lookup.component.ts",
    lineNumber: 144
  });
})();
var PoMultiselectOptionTemplateDirective = class _PoMultiselectOptionTemplateDirective {
  templateRef;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoMultiselectOptionTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMultiselectOptionTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoMultiselectOptionTemplateDirective,
    selectors: [["", "p-multiselect-option-template", ""]],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMultiselectOptionTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-multiselect-option-template]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var PoMultiselectFilterMode;
(function(PoMultiselectFilterMode2) {
  PoMultiselectFilterMode2[PoMultiselectFilterMode2["startsWith"] = 0] = "startsWith";
  PoMultiselectFilterMode2[PoMultiselectFilterMode2["contains"] = 1] = "contains";
  PoMultiselectFilterMode2[PoMultiselectFilterMode2["endsWith"] = 2] = "endsWith";
})(PoMultiselectFilterMode || (PoMultiselectFilterMode = {}));
var PO_MULTISELECT_DEBOUNCE_TIME_DEFAULT = 400;
var PO_MULTISELECT_FIELD_LABEL_DEFAULT = "label";
var PO_MULTISELECT_FIELD_VALUE_DEFAULT = "value";
var poMultiselectLiteralsDefault = {
  en: {
    noData: "No data found",
    placeholderSearch: "Search",
    selectAll: "Select all",
    selectItem: "Select items"
  },
  es: {
    noData: "Datos no encontrados",
    placeholderSearch: "Busca",
    selectAll: "Seleccionar todo",
    selectItem: "Seleccionar items"
  },
  pt: {
    noData: "Nenhum dado encontrado",
    placeholderSearch: "Buscar",
    selectAll: "Selecionar todos",
    selectItem: "Selecionar itens"
  },
  ru: {
    noData: "Данные не найдены",
    placeholderSearch: "искать",
    selectAll: "Выбрать все",
    selectItem: "Выбрать элементы"
  }
};
var PoMultiselectBaseComponent = class _PoMultiselectBaseComponent {
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Label no componente. */
  label;
  /** Texto de apoio para o campo. */
  help;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /** Mensagem apresentada enquanto o campo estiver vazio. */
  placeholder = "";
  /**
   * @description
   *
   * Placeholder do campo de pesquisa.
   *
   * > Caso o mesmo não seja informado, o valor padrão será traduzido com base no idioma do navegador (pt, es e en).
   *
   * @default `Buscar`
   */
  placeholderSearch = "";
  /** Nome do componente. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Indica se o campo "Selecionar todos" será escondido.
   *
   * @default `false`
   */
  hideSelectAll;
  /**
   * @optional
   *
   * @description
   *
   * Exibe a mensagem setada se o campo estiver vazio e for requerido.
   *
   * > Necessário que a propriedade `p-required` esteja habilitada.
   *
   */
  fieldErrorMessage;
  /**
   * @optional
   *
   * @description
   *
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   *
   * > Caso essa propriedade seja definida como `true`, a mensagem de erro será limitada a duas linhas
   * e um tooltip será exibido ao passar o mouse sobre a mensagem para mostrar o conteúdo completo.
   *
   * @default `false`
   */
  errorLimit = false;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Pode ser informada uma função que será disparada quando houver alterações no ngModel.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Define que o `listbox` e/ou tooltip (`p-additional-help-tooltip` e/ou `p-error-limit`) serão incluídos no body da
   * página e não dentro do componente. Essa opção pode ser necessária em cenários com containers que possuem scroll ou
   * overflow escondido, garantindo o posicionamento correto de ambos próximo ao elemento.
   *
   * > O uso dessa propriedade pode interferir na sequência de tabulação da página. Quando utilizado com
   * `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  /**
   * @docsPrivate
   *
   * Determinar se o valor do compo deve retorna objeto do tipo {value: any, label: any}
   */
  controlValueWithLabel = false;
  selectedOptions = [];
  visibleOptionsDropdown = [];
  visibleTags = [];
  isServerSearching = false;
  isFirstFilter = true;
  filterSubject = new Subject();
  service;
  defaultService;
  displayAdditionalHelp = false;
  // eslint-disable-next-line
  onModelTouched = null;
  clickOutListener;
  resizeListener;
  getObjectsByValuesSubscription;
  _filterService;
  _debounceTime = 400;
  _disabled = false;
  _filterMode = PoMultiselectFilterMode.startsWith;
  _hideSearch = false;
  _literals;
  _options;
  _required = false;
  _sort = false;
  _autoHeight = false;
  _fieldLabel = PO_MULTISELECT_FIELD_LABEL_DEFAULT;
  _fieldValue = PO_MULTISELECT_FIELD_VALUE_DEFAULT;
  language;
  lastLengthModel;
  onModelChange;
  validatorChange;
  autoHeightInitialValue;
  /**
   * @optional
   *
   * @description
   * Nesta propriedade pode ser informada a URL do serviço em que será realizado o filtro para carregamento da lista de itens no componente.
   *
   *Também existe a possibilidade de informar um serviço implementando a interface `PoMultiselectFilter`.
   *
   *Caso utilizado uma URL, o serviço deve ser retornado no padrão [API PO UI](https://po-ui.io/guides/api) e utilizar as propriedades `p-field-label` e `p-field-value` para a construção da lista de itens.
   *
   *Quando utilizada uma URL de serviço, então será concatenada nesta URL o valor que deseja-se filtrar da seguinte forma:
   *
   *```
   * // caso filtrar por "Peter"
   *  https://localhost:8080/api/heroes?filter=Peter
   *```
   *
   *E caso iniciar o campo com valor, os itens serão buscados da seguinte forma:
   *
   *```
   * // caso o valor do campo for [1234, 5678];
   *  https://localhost:8080/api/heroes?value=1234,5678
   *
   * //O *value* é referente ao `fieldValue`.
   *```
   *
   */
  set filterService(value) {
    if (value) {
      this._filterService = value;
      this.autoHeight = this.autoHeightInitialValue !== void 0 ? this.autoHeightInitialValue : true;
      this.options = [];
    }
  }
  get filterService() {
    return this._filterService;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que a altura do componente será auto ajustável, possuindo uma altura minima porém a altura máxima será de acordo
   * com o número de itens selecionados e a extensão dos mesmos, mantendo-os sempre visíveis.
   *
   * > O valor padrão será `true` quando houver serviço (`p-filter-service`).
   *
   * @default `false`
   */
  set autoHeight(value) {
    this._autoHeight = value;
    this.autoHeightInitialValue = value;
  }
  get autoHeight() {
    return this._autoHeight;
  }
  /**
   * @optional
   *
   * @description
   * Esta propriedade define em quanto tempo (em milissegundos), aguarda para acionar o evento de filtro após cada pressionamento de tecla.
   *
   * > Será utilizada apenas quando houver serviço (`p-filter-service`) e somente será aceito valor maior do que *zero*.
   *
   * @default `400`
   */
  set debounceTime(value) {
    const parsedValue = parseInt(value, 10);
    this._debounceTime = !isNaN(parsedValue) && parsedValue > 0 ? parsedValue : PO_MULTISELECT_DEBOUNCE_TIME_DEFAULT;
  }
  get debounceTime() {
    return this._debounceTime;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-multiselect`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoMultiselectLiterals = {
   *    noData: 'Nenhum dado encontrado',
   *    placeholderSearch: 'Buscar',
   *    selectAll: 'Select all',
   *    selectItem: 'Select items'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoMultiselectLiterals = {
   *    noData: 'Sem dados'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente:
   *
   * ```
   * <po-multiselect
   *   [p-literals]="customLiterals">
   * </po-po-multiselect>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poMultiselectLiteralsDefault[poLocaleDefault]), poMultiselectLiteralsDefault[this.language]), value);
    } else {
      this._literals = poMultiselectLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poMultiselectLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * > Esta propriedade é desconsiderada quando o input está desabilitado `(p-disabled)`.
   *
   * @default `false`
   */
  set required(required) {
    this._required = required === "" ? true : convertToBoolean(required);
    this.validateModel();
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será desabilitado.
   *
   * @default `false`
   */
  set disabled(disabled) {
    this._disabled = disabled === "" ? true : convertToBoolean(disabled);
    this.validateModel();
    this.updateVisibleItems();
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Esconde o campo de pesquisa existente dentro do dropdown do po-multiselect.
   *
   * @default `false`
   */
  set hideSearch(hideSearch) {
    this._hideSearch = hideSearch === "" ? true : convertToBoolean(hideSearch);
  }
  get hideSearch() {
    return this._hideSearch;
  }
  /**
   * @description
   *
   * Nesta propriedade deve ser definida uma lista de objetos que será exibida no multiselect.
   * Esta lista deve conter os valores e os labels que serão apresentados na tela.
   *
   * > Essa propriedade é imutável, ou seja, sempre que quiser atualizar a lista de opções disponíveis
   * atualize a referência do objeto:
   *
   * ```
   * // atualiza a referência do objeto garantindo a atualização do template
   * this.options = [...this.options, { value: 'x', label: 'Nova opção' }];
   *
   * // evite, pois não atualiza a referência do objeto podendo gerar atrasos na atualização do template
   * this.options.push({ value: 'x', label: 'Nova opção' });
   * ```
   * > A lista pode ser definida utilizando um array com o valor representando `value` e `label` das seguintes formas:
   *
   * ```
   * <po-multiselect name="multiselect" p-label="PO Multiselect" [p-options]="[{value: 1, label: 'One'}, {value: 2, label: 'two'}]"> </po-multiselect>
   * ```
   *
   * ```
   * <po-multiselect name="multiselect" p-label="PO Multiselect" [p-options]="[{name: 'Roger', age: 28}, {name: 'Anne', age: 35}]" p-field-label="name" p-field-value="age"> </po-multiselect>
   * ```
   *
   * - Aconselha-se utilizar valores distintos no `label` e `value` dos itens.
   */
  set options(options) {
    this._options = options;
  }
  get options() {
    return this._options;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que a lista definida na propriedade p-options será ordenada pelo label antes de ser apresentada no
   * dropdown.
   *
   * @default `false`
   */
  set sort(sort) {
    this._sort = sort === "" ? true : convertToBoolean(sort);
    this.validAndSortOptions();
  }
  get sort() {
    return this._sort;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o modo de pesquisa utilizado no campo de busca, quando habilitado.
   * Valores definidos no enum: PoMultiselectFilterMode
   *
   * @default `startsWith`
   */
  set filterMode(filterMode) {
    this._filterMode = filterMode in PoMultiselectFilterMode ? filterMode : PoMultiselectFilterMode.startsWith;
    switch (this._filterMode.toString()) {
      case "startsWith":
        this._filterMode = PoMultiselectFilterMode.startsWith;
        break;
      case "contains":
        this._filterMode = PoMultiselectFilterMode.contains;
        break;
      case "endsWith":
        this._filterMode = PoMultiselectFilterMode.endsWith;
        break;
    }
  }
  get filterMode() {
    return this._filterMode;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo texto de apresentação de cada item da lista.
   *
   * Necessário quando informar o serviço como URL e o mesmo não estiver retornando uma lista de objetos no padrão da interface
   * `PoMultiSelectOption`.
   *
   * @default `label`
   */
  set fieldLabel(value) {
    this._fieldLabel = value ? value : PO_MULTISELECT_FIELD_LABEL_DEFAULT;
    if (isTypeof(this.filterService, "string") && this.service) {
      this.service.fieldLabel = this._fieldLabel;
    }
  }
  get fieldLabel() {
    return this._fieldLabel;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo valor de cada item da lista.
   *
   * Necessário quando informar o serviço como URL e o mesmo não estiver retornando uma lista de objetos no padrão da interface
   * `PoMultiSelectOption`.
   *
   * @default `value`
   */
  set fieldValue(value) {
    this._fieldValue = value ? value : PO_MULTISELECT_FIELD_VALUE_DEFAULT;
    if (isTypeof(this.filterService, "string") && this.service) {
      this.service.fieldValue = this._fieldValue;
    }
  }
  get fieldValue() {
    return this._fieldValue;
  }
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  ngOnInit() {
    if (this.filterService) {
      this.setService(this.filterService);
    }
    this.filterSubject.pipe(debounceTime(this.debounceTime), distinctUntilChanged(), tap(() => this.isServerSearching = true), switchMap((search) => this.applyFilter(search)), tap(() => this.isServerSearching = false)).subscribe();
    this.setLabelsAndValuesOptions();
    this.validAndSortOptions();
    this.updateList(this.options);
  }
  setService(service) {
    if (isTypeof(service, "object")) {
      this.service = service;
    } else {
      this.service = this.defaultService;
      this.service.configProperties(service, this.fieldLabel, this.fieldValue);
    }
    this.isFirstFilter = true;
  }
  validAndSortOptions() {
    if (this.options && this.options.length) {
      removeUndefinedAndNullOptionsWithFieldValue(this.options, this.fieldValue);
      removeDuplicatedOptionsWithFieldValue(this.options, this.fieldValue);
      this.setUndefinedLabels(this.options);
      if (this.sort) {
        sortOptionsByProperty(this.options, this.fieldLabel);
      }
    }
  }
  setUndefinedLabels(options) {
    options.forEach((option) => {
      if (!option[this.fieldLabel]) {
        option[this.fieldLabel] = option[this.fieldValue];
      }
    });
  }
  updateList(options) {
    if (options) {
      this.visibleOptionsDropdown = options;
    }
  }
  callOnChange(selectedOptions) {
    if (this.onModelChange) {
      this.onModelChange(this.getValueUpdate(selectedOptions));
      this.eventChange(selectedOptions);
    }
  }
  eventChange(selectedOptions) {
    if (selectedOptions && this.lastLengthModel !== selectedOptions.length) {
      this.change.emit(selectedOptions);
    }
    this.lastLengthModel = selectedOptions ? selectedOptions.length : null;
  }
  getValuesFromOptions(selectedOptions) {
    return selectedOptions && selectedOptions.length ? selectedOptions.map((option) => option[this.fieldValue]) : [];
  }
  getLabelByValue(value) {
    const index = this.options.findIndex((option) => option[this.fieldValue] === value);
    return this.options[index].label;
  }
  searchByLabel(search, options, filterMode) {
    if (search && options && options.length) {
      const newOptions = [];
      options.forEach((option) => {
        if (option[this.fieldLabel] && this.compareMethod(search, option, filterMode)) {
          newOptions.push(option);
        }
      });
      this.visibleOptionsDropdown = newOptions;
    } else {
      this.visibleOptionsDropdown = [...options];
    }
  }
  compareMethod(search, option, filterMode) {
    switch (filterMode) {
      case PoMultiselectFilterMode.startsWith:
        return this.startsWith(search, option);
      case PoMultiselectFilterMode.contains:
        return this.contains(search, option);
      case PoMultiselectFilterMode.endsWith:
        return this.endsWith(search, option);
    }
  }
  startsWith(search, option) {
    return option[this.fieldLabel].toLowerCase().startsWith(search.toLowerCase());
  }
  contains(search, option) {
    return option[this.fieldLabel].toLowerCase().indexOf(search.toLowerCase()) > -1;
  }
  endsWith(search, option) {
    return option[this.fieldLabel].toLowerCase().endsWith(search.toLowerCase());
  }
  validate(c) {
    if (requiredFailed(this.required, this.disabled, c.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
    return null;
  }
  updateSelectedOptions(newOptions, options = this.options) {
    this.selectedOptions = [];
    if (newOptions.length === 0) {
      this.lastLengthModel = void 0;
    }
    if (this.filterService) {
      this.selectedOptions = newOptions;
    } else {
      newOptions.forEach((newOption) => {
        options.forEach((option) => {
          if (option[this.fieldValue] === newOption[this.fieldValue]) {
            this.selectedOptions.push(option);
          }
        });
      });
    }
    this.updateVisibleItems();
  }
  writeValue(values) {
    values = this.getValueWrite(values) || [];
    if (this.service && values.length) {
      this.getObjectsByValuesSubscription = this.service.getObjectsByValues(values).subscribe((options) => {
        this.updateSelectedOptions(options);
        this.callOnChange(this.selectedOptions);
      });
    } else {
      this.updateSelectedOptions(values.map((value) => ({
        [this.fieldValue]: value
      })));
      if (this.selectedOptions && this.selectedOptions.length < values.length) {
        this.callOnChange(this.selectedOptions);
      }
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.onModelChange = fn;
  }
  registerOnTouched(fn) {
    this.onModelTouched = fn;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  getValueUpdate(selectedOptions) {
    if (this.controlValueWithLabel && selectedOptions?.length) {
      return selectedOptions.map((option) => ({
        value: option[this.fieldValue],
        label: option[this.fieldLabel]
      }));
    }
    return this.getValuesFromOptions(selectedOptions);
  }
  getValueWrite(data) {
    if (this.controlValueWithLabel && data?.length && data.every((x) => x?.value !== void 0)) {
      return data.map((option) => option.value);
    }
    return data;
  }
  setLabelsAndValuesOptions() {
    if (this.fieldLabel && this.fieldValue && this.options) {
      this.options.map((option) => {
        option.label = option[this.fieldLabel];
        option.value = option[this.fieldValue];
      });
    }
  }
  validateModel() {
    if (this.validatorChange) {
      this.validatorChange();
    }
  }
  static ɵfac = function PoMultiselectBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMultiselectBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoMultiselectBaseComponent,
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      label: [0, "p-label", "label"],
      help: [0, "p-help", "help"],
      optional: [0, "p-optional", "optional"],
      placeholder: [0, "p-placeholder", "placeholder"],
      placeholderSearch: [0, "p-placeholder-search", "placeholderSearch"],
      name: "name",
      hideSelectAll: [2, "p-hide-select-all", "hideSelectAll", convertToBoolean],
      fieldErrorMessage: [0, "p-field-error-message", "fieldErrorMessage"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      controlValueWithLabel: [2, "p-control-value-with-label", "controlValueWithLabel", convertToBoolean],
      filterService: [0, "p-filter-service", "filterService"],
      autoHeight: [2, "p-auto-height", "autoHeight", convertToBoolean],
      debounceTime: [0, "p-debounce-time", "debounceTime"],
      literals: [0, "p-literals", "literals"],
      required: [0, "p-required", "required"],
      showRequired: [0, "p-show-required", "showRequired"],
      disabled: [0, "p-disabled", "disabled"],
      hideSearch: [0, "p-hide-search", "hideSearch"],
      options: [0, "p-options", "options"],
      sort: [0, "p-sort", "sort"],
      filterMode: [0, "p-filter-mode", "filterMode"],
      fieldLabel: [0, "p-field-label", "fieldLabel"],
      fieldValue: [0, "p-field-value", "fieldValue"]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      change: "p-change",
      keydown: "p-keydown"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMultiselectBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    placeholder: [{
      type: Input,
      args: ["p-placeholder"]
    }],
    placeholderSearch: [{
      type: Input,
      args: ["p-placeholder-search"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    hideSelectAll: [{
      type: Input,
      args: [{
        alias: "p-hide-select-all",
        transform: convertToBoolean
      }]
    }],
    fieldErrorMessage: [{
      type: Input,
      args: ["p-field-error-message"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    controlValueWithLabel: [{
      type: Input,
      args: [{
        alias: "p-control-value-with-label",
        transform: convertToBoolean
      }]
    }],
    filterService: [{
      type: Input,
      args: ["p-filter-service"]
    }],
    autoHeight: [{
      type: Input,
      args: [{
        alias: "p-auto-height",
        transform: convertToBoolean
      }]
    }],
    debounceTime: [{
      type: Input,
      args: ["p-debounce-time"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    required: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    hideSearch: [{
      type: Input,
      args: ["p-hide-search"]
    }],
    options: [{
      type: Input,
      args: ["p-options"]
    }],
    sort: [{
      type: Input,
      args: ["p-sort"]
    }],
    filterMode: [{
      type: Input,
      args: ["p-filter-mode"]
    }],
    fieldLabel: [{
      type: Input,
      args: ["p-field-label"]
    }],
    fieldValue: [{
      type: Input,
      args: ["p-field-value"]
    }]
  });
})();
var PoMultiselectFilterService = class _PoMultiselectFilterService {
  http;
  fieldLabel = "label";
  fieldValue = "value";
  _url;
  messages = [];
  get url() {
    return this._url;
  }
  constructor(http) {
    this.http = http;
  }
  getFilteredData({
    value
  }) {
    const params = value ? {
      filter: value
    } : {};
    return this.http.get(this.url, {
      params
    }).pipe(map((response) => this.parseToArrayMultiselectOptions(response["items"])));
  }
  getObjectsByValues(value) {
    return this.http.get(`${this.url}?${this.fieldValue}=${value.toString()}`).pipe(map((response) => this.parseToArrayMultiselectOptions(response["items"])));
  }
  configProperties(url, fieldLabel, fieldValue) {
    this._url = url;
    this.fieldLabel = fieldLabel;
    this.fieldValue = fieldValue;
  }
  parseToArrayMultiselectOptions(items) {
    if (items && items.length > 0) {
      return items.map((item) => this.parseToMultiselectOption(item));
    }
    return [];
  }
  parseToMultiselectOption(item) {
    const label = item[this.fieldLabel];
    const value = item[this.fieldValue];
    return {
      [this.fieldLabel]: label,
      [this.fieldValue]: value
    };
  }
  static ɵfac = function PoMultiselectFilterService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMultiselectFilterService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoMultiselectFilterService,
    factory: _PoMultiselectFilterService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMultiselectFilterService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }], null);
})();
var _c0$P = ["dropdownElement"];
var _c1$j = ["iconElement"];
var _c2$9 = ["inputElement"];
var _c3$5 = ["outerContainer"];
function PoMultiselectComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.placeholder ? ctx_r1.placeholder : ctx_r1.literals.selectItem, " ");
  }
}
function PoMultiselectComponent_po_tag_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-tag", 18);
    ɵɵlistener("p-close", function PoMultiselectComponent_po_tag_8_Template_po_tag_p_close_0_listener($event) {
      const tag_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.closeTag(tag_r4[ctx_r1.fieldValue], $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tag_r4 = ctx.$implicit;
    const i_r5 = ctx.index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-clickable", tag_r4[ctx_r1.fieldValue] === "" && !ctx_r1.disabled);
    ɵɵproperty("p-value", tag_r4[ctx_r1.fieldLabel])("p-literals", i_r5 + 1 === ctx_r1.visibleTags.length && ctx_r1.hasMoreTag ? ctx_r1.literalsTag : void 0)("p-removable", true)("p-disabled", ctx_r1.disabled);
  }
}
function PoMultiselectComponent_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMultiselectComponent_ng_template_13_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMultiselectComponent_ng_template_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoMultiselectComponent_ng_template_13_ng_container_0_Template, 1, 0, "ng-container", 19);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const dropdownListbox_r6 = ɵɵreference(19);
    ɵɵproperty("ngTemplateOutlet", dropdownListbox_r6);
  }
}
function PoMultiselectComponent_ng_template_15_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMultiselectComponent_ng_template_15_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoMultiselectComponent_ng_template_15_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 19);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const dropdownListbox_r6 = ɵɵreference(19);
    ɵɵproperty("ngTemplateOutlet", dropdownListbox_r6);
  }
}
function PoMultiselectComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoMultiselectComponent_ng_template_15_ng_template_0_Template, 1, 1, "ng-template", 20);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const trigger_r7 = ɵɵreference(4);
    ɵɵproperty("cdkConnectedOverlayOrigin", trigger_r7)("cdkConnectedOverlayOpen", true);
  }
}
function PoMultiselectComponent_ng_template_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-multiselect-dropdown", 21, 7);
    ɵɵlistener("p-change", function PoMultiselectComponent_ng_template_18_Template_po_multiselect_dropdown_p_change_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changeItems($event));
    })("p-change-search", function PoMultiselectComponent_ng_template_18_Template_po_multiselect_dropdown_p_change_search_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changeSearch($event));
    })("p-close-dropdown", function PoMultiselectComponent_ng_template_18_Template_po_multiselect_dropdown_p_close_dropdown_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.controlDropdownVisibility(false));
    })("keydown", function PoMultiselectComponent_ng_template_18_Template_po_multiselect_dropdown_keydown_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onKeyDownDropdown($event, 0));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-searching", ctx_r1.isServerSearching)("p-hide-search", ctx_r1.hideSearch)("p-hide-select-all", ctx_r1.hideSelectAll)("p-literals", ctx_r1.literals)("p-options", ctx_r1.options)("p-visible-options", ctx_r1.visibleOptionsDropdown)("p-selected-options", ctx_r1.selectedOptions)("p-placeholder-search", ctx_r1.placeholderSearch)("p-field-value", ctx_r1.fieldValue)("p-field-label", ctx_r1.fieldLabel)("p-multiselect-template", ctx_r1.multiselectOptionTemplate)("p-container-width", ctx_r1.containerWidth);
  }
}
var poMultiselectContainerOffset = 8;
var poMultiselectContainerPositionDefault = "bottom";
var poMultiselectInputPaddingRight = 52;
var poMultiselectSpaceBetweenTags = 8;
var literalsTagRemoveOthers = {
  pt: {
    remove: "Remover todos os itens selecionados"
  },
  ru: {
    remove: "Удалить все выбранные элементы"
  },
  es: {
    remove: "Eliminar todos los elementos seleccionados"
  },
  en: {
    remove: "Clear all selected items"
  }
};
var providers$1 = [PoMultiselectFilterService, PoControlPositionService, {
  provide: NG_VALUE_ACCESSOR,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoMultiselectComponent),
  multi: true
}, {
  provide: NG_VALIDATORS,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoMultiselectComponent),
  multi: true
}];
var PoMultiselectComponent = class _PoMultiselectComponent extends PoMultiselectBaseComponent {
  renderer;
  changeDetector;
  el;
  controlPosition;
  defaultService;
  multiselectOptionTemplate;
  dropdownElement;
  dropdown;
  iconElement;
  inputElement;
  outerContainer;
  literalsTag;
  dropdownIcon = "ICON_ARROW_DOWN";
  dropdownOpen = false;
  initialized = false;
  hasMoreTag;
  timeoutResize;
  visibleElement = false;
  containerWidth;
  subscription = new Subscription();
  enterCloseTag = false;
  initCalculateItems = true;
  isCalculateVisibleItems = true;
  cacheOptions;
  focusOnTag = false;
  constructor(renderer, changeDetector, el, controlPosition, defaultService, languageService) {
    super(languageService);
    this.renderer = renderer;
    this.changeDetector = changeDetector;
    this.el = el;
    this.controlPosition = controlPosition;
    this.defaultService = defaultService;
    const language = languageService.getShortLanguage();
    this.literalsTag = __spreadValues(__spreadValues({}, literalsTagRemoveOthers[poLocaleDefault]), literalsTagRemoveOthers[language]);
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
    this.initialized = true;
  }
  ngOnChanges(changes) {
    if (this.filterService && (changes.filterService || changes.fieldValue || changes.fieldLabel)) {
      this.setService(this.filterService);
    }
  }
  ngDoCheck() {
    const inputWidth = this.inputElement.nativeElement.offsetWidth;
    if (inputWidth && !this.visibleElement && this.initialized || inputWidth && this.isCalculateVisibleItems) {
      this.debounceResize();
      this.visibleElement = true;
    }
  }
  ngOnDestroy() {
    this.removeListeners();
    this.getObjectsByValuesSubscription?.unsubscribe();
    this.filterSubject?.unsubscribe();
    this.subscription.unsubscribe();
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoMultiselectComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoMultiselectComponent, { static: true }) multiselect: PoMultiselectComponent;
   *
   * focusMultiselect() {
   *   this.multiselect.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.inputElement.nativeElement.focus();
    }
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  getInputWidth() {
    return this.el.nativeElement.querySelector(".po-multiselect-input").offsetWidth - poMultiselectInputPaddingRight;
  }
  getTagsWidth() {
    const tags = this.el.nativeElement.querySelectorAll("po-tag");
    return Array.from(tags).map((tag) => tag["offsetWidth"]);
  }
  getErrorPattern() {
    return this.fieldErrorMessage && this.hasInvalidClass() ? this.fieldErrorMessage : "";
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty");
  }
  calculateVisibleItems() {
    this.hasMoreTag = false;
    const tagsWidth = this.getTagsWidth();
    const inputWidth = this.getInputWidth();
    const extraTagSize = 63;
    const tagsVisible = tagsWidth[0];
    this.visibleTags = [];
    if (inputWidth > 0) {
      let sum = 0;
      let i = 0;
      for (i = 0; i < this.selectedOptions.length; i++) {
        sum += tagsWidth[i] + poMultiselectSpaceBetweenTags;
        this.visibleTags.push(this.selectedOptions[i]);
        if (sum > inputWidth) {
          sum -= tagsWidth[i];
          this.isCalculateVisibleItems = false;
          break;
        }
      }
      if (tagsVisible || !this.selectedOptions.length) {
        if (i === this.selectedOptions.length) {
          this.isCalculateVisibleItems = false;
          return;
        }
        this.hasMoreTag = true;
        if (sum + extraTagSize > inputWidth) {
          this.visibleTags.splice(-2, 2);
          const label = "+" + (this.selectedOptions.length + 1 - i).toString();
          this.visibleTags.push({
            [this.fieldValue]: "",
            [this.fieldLabel]: label
          });
        } else {
          this.visibleTags.splice(-1, 1);
          const label = "+" + (this.selectedOptions.length - i).toString();
          this.visibleTags.push({
            [this.fieldValue]: "",
            [this.fieldLabel]: label
          });
        }
      }
      if (this.initCalculateItems) {
        setTimeout(() => {
          this.handleKeyboardNavigationTag();
        }, 300);
      }
      this.initCalculateItems = false;
    }
    this.changeDetector.markForCheck();
  }
  changeItems(changedItems) {
    this.updateSelectedOptions(changedItems);
    this.callOnChange(this.selectedOptions);
    if (this.autoHeight && this.dropdownOpen) {
      this.changeDetector.detectChanges();
      this.adjustContainerPosition();
    }
    setTimeout(() => {
      this.handleKeyboardNavigationTag();
    }, 300);
  }
  updateVisibleItems() {
    if (this.selectedOptions) {
      this.visibleTags = [].concat(this.selectedOptions);
    }
    this.debounceResize();
    if (!this.inputElement.nativeElement.offsetWidth) {
      this.isCalculateVisibleItems = true;
    }
  }
  debounceResize() {
    if (!this.autoHeight) {
      clearTimeout(this.timeoutResize);
      this.timeoutResize = setTimeout(() => {
        this.calculateVisibleItems();
      }, 200);
    }
    this.changeDetector.markForCheck();
  }
  onBlur() {
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
    if (typeof this.inputElement.nativeElement.getAttribute("aria-label") === "string" && this.inputElement.nativeElement.getAttribute("aria-label").includes("Unselected")) {
      this.inputElement.nativeElement.setAttribute("aria-label", this.label ? this.label : "");
    }
    this.onModelTouched?.();
  }
  onKeyDown(event) {
    const isFieldFocused = document.activeElement === this.inputElement.nativeElement;
    if (event.shiftKey && event.keyCode === PoKeyCodeEnum.tab && !this.focusOnTag) {
      this.controlDropdownVisibility(false);
    }
    this.focusOnTag = false;
    if (event.keyCode === PoKeyCodeEnum.tab) {
      return;
    }
    if (event.keyCode === PoKeyCodeEnum.esc) {
      event.preventDefault();
      this.controlDropdownVisibility(false);
      return;
    }
    if (event.keyCode === PoKeyCodeEnum.arrowDown && this.visibleTags.length > 0) {
      event.preventDefault();
      this.controlDropdownVisibility(true);
      this.dropdown?.listbox?.setFocus();
      return;
    }
    if (event.keyCode === PoKeyCodeEnum.enter && !this.enterCloseTag) {
      if (this.visibleTags.length === 0) {
        this.toggleDropdownVisibility();
        this.focus();
        return;
      } else {
        event.preventDefault();
        this.toggleDropdownVisibility();
        return;
      }
    }
    if (event.keyCode === PoKeyCodeEnum.space) {
      event.preventDefault();
      this.toggleDropdownVisibility();
    }
    this.enterCloseTag = false;
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  toggleDropdownVisibility() {
    if (this.disabled) {
      return;
    }
    if (this.filterService) {
      this.applyFilterInFirstClick();
    }
    this.controlDropdownVisibility(!this.dropdownOpen);
  }
  onKeyDownDropdown(event, index) {
    if (event.key === "Escape") {
      event.preventDefault();
      this.controlDropdownVisibility(false);
      this.inputElement.nativeElement.focus();
    }
  }
  openDropdown(toOpen) {
    if (toOpen && !this.disabled) {
      this.controlDropdownVisibility(true);
    }
  }
  controlDropdownVisibility(toOpen) {
    toOpen ? this.open() : this.close();
  }
  scrollToSelectedOptions() {
    if (this.selectedOptions && this.selectedOptions.length) {
      const index = this.options.findIndex((option) => option[this.fieldValue] === this.selectedOptions[0][this.fieldValue]);
      this.dropdown.scrollTo(index);
    }
  }
  setVisibleOptionsDropdown(options) {
    this.visibleOptionsDropdown = options;
    this.changeDetector.markForCheck();
  }
  changeSearch(event) {
    if (event && event[this.fieldValue] !== void 0) {
      if (this.filterService) {
        this.filterSubject.next(event[this.fieldValue]);
      } else {
        this.searchByLabel(event[this.fieldValue], this.options, this.filterMode);
      }
    } else {
      this.setVisibleOptionsDropdown(this.options);
    }
    setTimeout(() => this.adjustContainerPosition());
  }
  closeTag(value, event) {
    let index;
    this.enterCloseTag = true;
    if (value === null || value === void 0 || typeof value === "string" && value.includes("+")) {
      index = null;
      const itemsNotInVisibleTags = this.selectedOptions.filter((option) => !this.visibleTags.includes(option));
      for (const option of this.visibleTags) {
        if (!this.selectedOptions.includes(option)) {
          this.selectedOptions.splice(this.visibleTags.length - 1, itemsNotInVisibleTags.length);
          this.updateVisibleItems();
          this.callOnChange(this.selectedOptions);
        }
      }
    } else {
      index = this.selectedOptions.findIndex((option) => option[this.fieldValue] === value);
      this.selectedOptions.splice(index, 1);
      this.updateVisibleItems();
      this.callOnChange(this.selectedOptions);
    }
    setTimeout(() => {
      this.focusOnNextTag(index, event);
    }, 300);
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-multiselect
   *  #multiselect
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, multiselect)"
   * ></po-multiselect>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoMultiselectComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  wasClickedOnToggle(event) {
    if (this.dropdownOpen && !this.inputElement.nativeElement.contains(event.target) && !this.iconElement.nativeElement.contains(event.target) && !this.dropdownElement.nativeElement.contains(event.target)) {
      this.controlDropdownVisibility(false);
    }
  }
  applyFilter(value = "") {
    const param = {
      property: this.fieldLabel,
      value
    };
    return this.service.getFilteredData(param).pipe(catchError((err) => {
      this.isServerSearching = false;
      return of([]);
    }), tap((options) => {
      this.setOptionsByApplyFilter(options);
    }));
  }
  applyFilterInFirstClick() {
    if (this.isFirstFilter) {
      this.isServerSearching = true;
      this.filterSubject.next(new String());
    } else {
      this.options = [...this.cacheOptions];
    }
  }
  setOptionsByApplyFilter(items) {
    if (this.isFirstFilter) {
      this.cacheOptions = [...items];
      this.isFirstFilter = false;
    }
    this.options = [...items];
    this.setVisibleOptionsDropdown(this.options);
  }
  adjustContainerPosition() {
    this.controlPosition.adjustPosition(poMultiselectContainerPositionDefault);
  }
  close() {
    this.dropdownIcon = "ICON_ARROW_DOWN";
    this.dropdownOpen = false;
    this.dropdown.controlVisibility(false);
    this.setVisibleOptionsDropdown(this.options);
    this.removeListeners();
  }
  focusOnNextTag(indexClosed, clickOrEnter) {
    if (clickOrEnter === "enter") {
      const tagRemoveElements = this.el.nativeElement.querySelectorAll(".po-tag-remove");
      indexClosed = indexClosed || indexClosed === 0 ? indexClosed : tagRemoveElements.length;
      if (tagRemoveElements.length === 0) {
        this.inputElement.nativeElement.focus();
        this.inputElement.nativeElement.setAttribute("aria-label", `Unselected items ${this.label}`);
        this.controlDropdownVisibility(true);
      }
      this.focusOnRemoveTag(tagRemoveElements, indexClosed);
    } else {
      indexClosed = 0;
    }
    this.handleKeyboardNavigationTag(indexClosed);
  }
  focusOnRemoveTag(tag, indexClosed) {
    if (tag.length === indexClosed) {
      tag[indexClosed - 1]?.focus();
    } else {
      tag[indexClosed]?.focus();
    }
  }
  handleKeyboardNavigationTag(initialIndex = 0) {
    this.subscription.unsubscribe();
    this.subscription = new Subscription();
    const tagRemoveElements = this.el.nativeElement.querySelectorAll(".po-tag-remove");
    this.initializeTagRemoveElements(tagRemoveElements, initialIndex);
  }
  setTabIndex(element, tabIndex) {
    element.setAttribute("tabindex", tabIndex);
  }
  handleArrowLeft(tagRemoveElements, index) {
    if (index > 0) {
      this.setTabIndex(tagRemoveElements[index], -1);
      tagRemoveElements[index - 1].focus();
      this.setTabIndex(tagRemoveElements[index - 1], 0);
    }
  }
  handleArrowRight(tagRemoveElements, index) {
    if (index < tagRemoveElements.length - 1) {
      this.setTabIndex(tagRemoveElements[index], -1);
      tagRemoveElements[index + 1].focus();
      this.setTabIndex(tagRemoveElements[index + 1], 0);
    }
  }
  handleKeyDown(event, tagRemoveElements, index) {
    const KEY_SPACE = "Space";
    const KEY_ARROW_LEFT = "ArrowLeft";
    const KEY_ARROW_RIGHT = "ArrowRight";
    this.focusOnTag = true;
    if (event.code === KEY_SPACE) {
      event.preventDefault();
      event.stopPropagation();
    }
    if (event.key === KEY_ARROW_LEFT) {
      this.handleArrowLeft(tagRemoveElements, index);
    } else if (event.key === KEY_ARROW_RIGHT) {
      this.handleArrowRight(tagRemoveElements, index);
    }
  }
  initializeTagRemoveElements(tagRemoveElements, initialIndex) {
    tagRemoveElements.forEach((tagRemoveElement, index) => {
      if (index === initialIndex) {
        this.setTabIndex(tagRemoveElements[initialIndex], 0);
      } else if (tagRemoveElements.length === initialIndex) {
        this.setTabIndex(tagRemoveElements[initialIndex - 1], 0);
      } else {
        this.setTabIndex(tagRemoveElement, -1);
      }
      this.subscription.add(fromEvent(tagRemoveElement, "keydown").subscribe((event) => {
        this.handleKeyDown(event, tagRemoveElements, index);
      }));
    });
  }
  initializeListeners() {
    this.clickOutListener = this.renderer.listen("document", "click", (event) => {
      this.wasClickedOnToggle(event);
    });
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.updateVisibleItems();
      isMobile() ? this.adjustContainerPosition() : this.close();
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  onScroll = () => {
    this.adjustContainerPosition();
  };
  open() {
    this.dropdownIcon = "ICON_ARROW_UP";
    this.dropdownOpen = true;
    this.dropdown.controlVisibility(true);
    this.setVisibleOptionsDropdown(this.options);
    this.initializeListeners();
    this.scrollToSelectedOptions();
    this.changeDetector.detectChanges();
    this.setPositionDropdown();
    if (this.dropdownOpen) {
      this.setContainerWidth();
    }
  }
  removeListeners() {
    if (this.clickOutListener) {
      this.clickOutListener();
    }
    if (this.resizeListener) {
      this.resizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
    this.changeDetector.markForCheck();
  }
  setContainerWidth() {
    if (this.outerContainer) {
      this.containerWidth = this.outerContainer.nativeElement.offsetWidth;
    }
  }
  setPositionDropdown() {
    this.controlPosition.setElements(this.dropdown.container.nativeElement, poMultiselectContainerOffset, this.inputElement, ["top", "bottom"], true);
    this.adjustContainerPosition();
  }
  static ɵfac = function PoMultiselectComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMultiselectComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoControlPositionService), ɵɵdirectiveInject(PoMultiselectFilterService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoMultiselectComponent,
    selectors: [["po-multiselect"]],
    contentQueries: function PoMultiselectComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PoMultiselectOptionTemplateDirective, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.multiselectOptionTemplate = _t.first);
      }
    },
    viewQuery: function PoMultiselectComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$P, 5, ElementRef);
        ɵɵviewQuery(_c0$P, 5);
        ɵɵviewQuery(_c1$j, 7, ElementRef);
        ɵɵviewQuery(_c2$9, 7, ElementRef);
        ɵɵviewQuery(_c3$5, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdownElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdown = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.iconElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.outerContainer = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature(providers$1), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 20,
    vars: 36,
    consts: [["outerContainer", ""], ["trigger", "cdkOverlayOrigin"], ["inputElement", ""], ["iconElement", ""], ["dropdownDefault", ""], ["dropdownCDK", ""], ["dropdownListbox", ""], ["dropdownElement", ""], [3, "p-disabled", "p-label", "p-optional", "p-required", "p-show-required"], ["cdkOverlayOrigin", "", 1, "po-field-container-content"], [1, "po-input-icon-right", "po-multiselect-input", 3, "keydown", "click", "blur", "tabindex"], ["class", "po-multiselect-input-placeholder", "aria-hidden", "true", 4, "ngIf"], [3, "p-value", "p-literals", "p-removable", "po-clickable", "p-disabled", "p-close", 4, "ngFor", "ngForOf"], [1, "po-field-icon-container-right"], [3, "p-icon", "ngClass"], [4, "ngIf", "ngIfThen", "ngIfElse"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon"], ["aria-hidden", "true", 1, "po-multiselect-input-placeholder"], [3, "p-close", "p-value", "p-literals", "p-removable", "p-disabled"], [4, "ngTemplateOutlet"], ["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen"], [3, "p-change", "p-change-search", "p-close-dropdown", "keydown", "p-searching", "p-hide-search", "p-hide-select-all", "p-literals", "p-options", "p-visible-options", "p-selected-options", "p-placeholder-search", "p-field-value", "p-field-label", "p-multiselect-template", "p-container-width"]],
    template: function PoMultiselectComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", null, 0)(2, "po-field-container", 8)(3, "div", 9, 1)(5, "div", 10, 2);
        ɵɵlistener("keydown", function PoMultiselectComponent_Template_div_keydown_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        })("click", function PoMultiselectComponent_Template_div_click_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.toggleDropdownVisibility());
        })("blur", function PoMultiselectComponent_Template_div_blur_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        });
        ɵɵtemplate(7, PoMultiselectComponent_span_7_Template, 2, 1, "span", 11)(8, PoMultiselectComponent_po_tag_8_Template, 1, 6, "po-tag", 12);
        ɵɵelementStart(9, "div", 13);
        ɵɵelement(10, "po-icon", 14, 3);
        ɵɵelementEnd()()();
        ɵɵtemplate(12, PoMultiselectComponent_ng_container_12_Template, 1, 0, "ng-container", 15)(13, PoMultiselectComponent_ng_template_13_Template, 1, 1, "ng-template", null, 4, ɵɵtemplateRefExtractor)(15, PoMultiselectComponent_ng_template_15_Template, 1, 2, "ng-template", null, 5, ɵɵtemplateRefExtractor);
        ɵɵelementStart(17, "po-field-container-bottom", 16);
        ɵɵlistener("p-additional-help", function PoMultiselectComponent_Template_po_field_container_bottom_p_additional_help_17_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.emitAdditionalHelp());
        });
        ɵɵelementEnd()();
        ɵɵtemplate(18, PoMultiselectComponent_ng_template_18_Template, 2, 12, "ng-template", null, 6, ɵɵtemplateRefExtractor);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        const dropdownDefault_r9 = ɵɵreference(14);
        const dropdownCDK_r10 = ɵɵreference(16);
        ɵɵadvance(2);
        ɵɵproperty("p-disabled", ctx.disabled)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance();
        ɵɵclassProp("po-multiselect-show", ctx.dropdownOpen);
        ɵɵadvance(2);
        ɵɵclassProp("po-multiselect-input-auto", ctx.autoHeight)("po-multiselect-input-static", !ctx.autoHeight)("po-multiselect-input-disabled", ctx.disabled)("po-multiselect-input-font", !ctx.disabled && !(ctx.visibleTags == null ? null : ctx.visibleTags.length));
        ɵɵproperty("tabindex", ctx.disabled ? -1 : 0);
        ɵɵattribute("disabled", ctx.disabled)("aria-label", ctx.label);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.disabled && !(ctx.visibleTags == null ? null : ctx.visibleTags.length));
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.visibleTags);
        ɵɵadvance(2);
        ɵɵclassMapInterpolate1("po-field-icon ", ctx.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
        ɵɵpropertyInterpolate("p-icon", ctx.dropdownIcon);
        ɵɵproperty("ngClass", ctx.disabled ? "po-field-icon-disabled" : "");
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.appendBox)("ngIfThen", dropdownCDK_r10)("ngIfElse", dropdownDefault_r9);
        ɵɵadvance(5);
        ɵɵproperty("p-additional-help-tooltip", ctx.getAdditionalHelpTooltip())("p-append-in-body", ctx.appendBox)("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorPattern())("p-error-limit", ctx.errorLimit)("p-show-additional-help", ctx.displayAdditionalHelp)("p-show-additional-help-icon", ctx.showAdditionalHelpIcon());
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMultiselectComponent, [{
    type: Component,
    args: [{
      selector: "po-multiselect",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: providers$1,
      standalone: false,
      template: `<div #outerContainer>
  <po-field-container
    [p-disabled]="disabled"
    [p-label]="label"
    [p-optional]="optional"
    [p-required]="required"
    [p-show-required]="showRequired"
  >
    <div
      cdkOverlayOrigin
      #trigger="cdkOverlayOrigin"
      class="po-field-container-content"
      [class.po-multiselect-show]="dropdownOpen"
    >
      <div
        #inputElement
        [tabindex]="disabled ? -1 : 0"
        [attr.disabled]="disabled"
        [attr.aria-label]="label"
        class="po-input-icon-right po-multiselect-input"
        [class.po-multiselect-input-auto]="autoHeight"
        [class.po-multiselect-input-static]="!autoHeight"
        [class.po-multiselect-input-disabled]="disabled"
        [class.po-multiselect-input-font]="!disabled && !visibleTags?.length"
        (keydown)="onKeyDown($event)"
        (click)="toggleDropdownVisibility()"
        (blur)="onBlur()"
      >
        <span *ngIf="!disabled && !visibleTags?.length" class="po-multiselect-input-placeholder" aria-hidden="true">
          {{ placeholder ? placeholder : literals.selectItem }}
        </span>

        <po-tag
          *ngFor="let tag of visibleTags; index as i"
          [p-value]="tag[fieldLabel]"
          [p-literals]="i + 1 === visibleTags.length && hasMoreTag ? literalsTag : undefined"
          [p-removable]="true"
          [class.po-clickable]="tag[fieldValue] === '' && !disabled"
          [p-disabled]="disabled"
          (p-close)="closeTag(tag[fieldValue], $event)"
        ></po-tag>

        <div class="po-field-icon-container-right">
          <po-icon
            p-icon="{{ dropdownIcon }}"
            #iconElement
            class="po-field-icon {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
            [ngClass]="disabled ? 'po-field-icon-disabled' : ''"
          >
          </po-icon>
        </div>
      </div>
    </div>

    <ng-container *ngIf="appendBox; then dropdownCDK; else dropdownDefault"> </ng-container>

    <ng-template #dropdownDefault>
      <ng-container *ngTemplateOutlet="dropdownListbox"> </ng-container>
    </ng-template>

    <ng-template #dropdownCDK>
      <ng-template cdkConnectedOverlay [cdkConnectedOverlayOrigin]="trigger" [cdkConnectedOverlayOpen]="true">
        <ng-container *ngTemplateOutlet="dropdownListbox"></ng-container>
      </ng-template>
    </ng-template>

    <po-field-container-bottom
      [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
      [p-append-in-body]="appendBox"
      [p-help]="help"
      [p-disabled]="disabled"
      [p-error-pattern]="getErrorPattern()"
      [p-error-limit]="errorLimit"
      [p-show-additional-help]="displayAdditionalHelp"
      [p-show-additional-help-icon]="showAdditionalHelpIcon()"
      (p-additional-help)="emitAdditionalHelp()"
    ></po-field-container-bottom>
  </po-field-container>

  <ng-template #dropdownListbox>
    <po-multiselect-dropdown
      #dropdownElement
      [p-searching]="isServerSearching"
      [p-hide-search]="hideSearch"
      [p-hide-select-all]="hideSelectAll"
      [p-literals]="literals"
      [p-options]="options"
      [p-visible-options]="visibleOptionsDropdown"
      [p-selected-options]="selectedOptions"
      [p-placeholder-search]="placeholderSearch"
      [p-field-value]="fieldValue"
      [p-field-label]="fieldLabel"
      [p-multiselect-template]="multiselectOptionTemplate"
      (p-change)="changeItems($event)"
      (p-change-search)="changeSearch($event)"
      (p-close-dropdown)="controlDropdownVisibility(false)"
      (keydown)="onKeyDownDropdown($event, 0)"
      [p-container-width]="containerWidth"
    >
    </po-multiselect-dropdown>
  </ng-template>
</div>
`
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: PoControlPositionService
  }, {
    type: PoMultiselectFilterService
  }, {
    type: PoLanguageService
  }], {
    multiselectOptionTemplate: [{
      type: ContentChild,
      args: [PoMultiselectOptionTemplateDirective, {
        static: true
      }]
    }],
    dropdownElement: [{
      type: ViewChild,
      args: ["dropdownElement", {
        read: ElementRef
      }]
    }],
    dropdown: [{
      type: ViewChild,
      args: ["dropdownElement"]
    }],
    iconElement: [{
      type: ViewChild,
      args: ["iconElement", {
        read: ElementRef,
        static: true
      }]
    }],
    inputElement: [{
      type: ViewChild,
      args: ["inputElement", {
        read: ElementRef,
        static: true
      }]
    }],
    outerContainer: [{
      type: ViewChild,
      args: ["outerContainer ", {
        read: ElementRef
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMultiselectComponent, {
    className: "PoMultiselectComponent",
    filePath: "lib/components/po-field/po-multiselect/po-multiselect.component.ts",
    lineNumber: 119
  });
})();
var PoNumberBaseComponent = class _PoNumberBaseComponent extends PoInputGeneric {
  type = "number";
  invalidInputValueOnBlur = false;
  /* istanbul ignore next */
  constructor(elementRef, cd) {
    super(elementRef, cd);
  }
  eventOnInput(e) {
    if (!this.mask) {
      let value = e.target.value;
      const valueMaxlength = this.validMaxLength(this.maxlength, value);
      this.invalidInputValueOnBlur = false;
      if (value !== valueMaxlength) {
        value = valueMaxlength;
        this.inputEl.nativeElement.value = value;
      }
      this.callOnChange(this.formatNumber(value));
      if (this.errorAsyncProperties?.triggerMode === "changeModel") {
        this.verifyErrorAsync();
      }
    }
  }
  onBlur(event) {
    const target = event.target;
    this.invalidInputValueOnBlur = target.value === "" && !target.validity.valid;
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
    if (this.invalidInputValueOnBlur) {
      this.callOnChange("Valor Inválido");
    }
    this.eventOnBlur(event);
  }
  onKeyDown(event) {
    const isFieldFocused = document.activeElement === this.inputEl.nativeElement;
    if (!this.isKeyAllowed(event)) {
      event.stopPropagation();
      event.preventDefault();
    }
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  validMaxLength(maxlength, value) {
    if (maxlength && value.length > maxlength) {
      const substringValue = value.toString().substring(0, maxlength);
      if (substringValue && this.isEndWithDot(substringValue)) {
        return substringValue.toString().substring(0, maxlength - 1);
      }
      return substringValue;
    }
    return value;
  }
  writeValueModel(value) {
    if (this.inputEl) {
      if (value || value === 0) {
        if (this.mask) {
          this.inputEl.nativeElement.value = this.objMask.controlFormatting(String(value));
          if (this.objMask.formatModel) {
            this.onChangePropagate(this.objMask.valueToModel);
          }
        } else {
          this.inputEl.nativeElement.value = value;
        }
      } else {
        this.inputEl.nativeElement.value = "";
      }
    }
    this.changeModel.emit(value);
    this.verifyErrorAsync();
  }
  isEndWithDot(value) {
    return value && value.lastIndexOf(".") === value.length - 1;
  }
  formatNumber(value) {
    return value ? Number(value) : null;
  }
  isKeyAllowed(event) {
    return this.isShortcut(event) || this.isControlKeys(event) || !this.isInvalidKey(event.key);
  }
  isInvalidKey(key) {
    const validatesKey = new RegExp(/[a-zA-Z:;=_´`^~"'?!@#$%¨&*()><{}çÇ\[\]/\\|]+/);
    return validatesKey.test(key);
  }
  isShortcut(event) {
    const key = event.keyCode;
    const ctrl = event.ctrlKey || event.metaKey;
    const keyA = key === 65;
    const keyC = key === 67;
    const keyX = key === 88;
    const keyV = key === 86;
    return ctrl && keyC || ctrl && keyV || ctrl && keyA || ctrl && keyX;
  }
  isControlKeys(event) {
    const controlKeys = ["Backspace", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Left", "Right", "Up", "Down", "Tab", "Delete", "Home", "End", "Enter"];
    return controlKeys.indexOf(event.key) !== -1;
  }
  static ɵfac = function PoNumberBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNumberBaseComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoNumberBaseComponent,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNumberBaseComponent, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], null);
})();
function PoNumberComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵelement(1, "po-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-field-icon-disabled", ctx_r1.disabled);
    ɵɵproperty("p-icon", ctx_r1.icon);
  }
}
function PoNumberComponent_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 10);
    ɵɵlistener("p-change-event", function PoNumberComponent_po_clean_6_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-default-value", null)("p-element-ref", ctx_r1.inputEl);
  }
}
function PoNumberComponent_po_field_container_bottom_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 11);
    ɵɵlistener("p-additional-help", function PoNumberComponent_po_field_container_bottom_7_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitAdditionalHelp());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r1.getAdditionalHelpTooltip())("p-append-in-body", ctx_r1.appendBox)("p-help", ctx_r1.help)("p-disabled", ctx_r1.disabled)("p-error-limit", ctx_r1.errorLimit)("p-error-pattern", ctx_r1.getErrorPatternMessage())("p-show-additional-help", ctx_r1.displayAdditionalHelp)("p-show-additional-help-icon", ctx_r1.showAdditionalHelpIcon());
  }
}
var PoNumberComponent = class _PoNumberComponent extends PoNumberBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Intervalo.
   *
   * @default 1
   */
  step = "1";
  /** Valor mínimo.
   *
   * > Quando o valor mínimo for um número com decimais aconselha-se utilizar junto da propriedade `p-step` também passando a ela um valor decimal.
   */
  min;
  set setMin(min) {
    this.min = !isNaN(min) ? min : void 0;
    this.validateModel();
  }
  /** Valor máximo.
   *
   * > Quando o valor máximo for um número com decimais aconselha-se utilizar junto da propriedade `p-step` também passando a ela um valor decimal.
   */
  max;
  set setMax(max) {
    this.max = !isNaN(max) ? max : void 0;
    this.validateModel();
  }
  id = `po-number[${uuid()}]`;
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
  }
  onWheel(event) {
    event.preventDefault();
  }
  extraValidation(abstractControl) {
    this.errorPattern = this.errorPattern !== "Valor Inválido" ? this.errorPattern : "";
    if (minFailed(this.min, abstractControl.value)) {
      return {
        min: {
          valid: false
        }
      };
    }
    if (maxFailed(this.max, abstractControl.value)) {
      return {
        max: {
          valid: false
        }
      };
    }
    if (this.invalidInputValueOnBlur) {
      this.errorPattern = this.errorPattern || "Valor Inválido";
      return {
        number: {
          valid: false
        }
      };
    }
    return null;
  }
  getErrorPatternMessage() {
    return this.errorPattern !== "" && this.containsInvalidClass() ? this.errorPattern : "";
  }
  containsInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty") && (this.inputEl.nativeElement.value !== "" || this.showErrorMessageRequired && (this.required || this.hasValidatorRequired)) || this.invalidInputValueOnBlur;
  }
  static ɵfac = function PoNumberComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNumberComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoNumberComponent,
    selectors: [["po-number"]],
    hostBindings: function PoNumberComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("wheel", function PoNumberComponent_wheel_HostBindingHandler($event) {
          return ctx.onWheel($event);
        });
      }
    },
    inputs: {
      step: [0, "p-step", "step"],
      setMin: [0, "p-min", "setMin"],
      setMax: [0, "p-max", "setMax"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoNumberComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoNumberComponent),
      multi: true
    }]), ɵɵInheritDefinitionFeature],
    decls: 8,
    vars: 24,
    consts: [["inp", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["class", "po-field-icon-container-left", 4, "ngIf"], ["type", "number", 1, "po-input", 3, "blur", "focus", "input", "keydown", "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "tabindex"], [1, "po-field-icon-container-right"], ["class", "po-icon-input", 3, "p-default-value", "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-limit", "p-error-pattern", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [1, "po-field-icon-container-left"], [1, "po-field-icon", "po-icon-input", 3, "p-icon"], [1, "po-icon-input", 3, "p-change-event", "p-default-value", "p-element-ref"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-limit", "p-error-pattern", "p-show-additional-help", "p-show-additional-help-icon"]],
    template: function PoNumberComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2);
        ɵɵtemplate(2, PoNumberComponent_div_2_Template, 2, 3, "div", 3);
        ɵɵelementStart(3, "input", 4, 0);
        ɵɵlistener("blur", function PoNumberComponent_Template_input_blur_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur($event));
        })("focus", function PoNumberComponent_Template_input_focus_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnFocus($event));
        })("input", function PoNumberComponent_Template_input_input_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnInput($event));
        })("keydown", function PoNumberComponent_Template_input_keydown_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(5, "div", 5);
        ɵɵtemplate(6, PoNumberComponent_po_clean_6_Template, 1, 2, "po-clean", 6);
        ɵɵelementEnd()();
        ɵɵtemplate(7, PoNumberComponent_po_field_container_bottom_7_Template, 1, 8, "po-field-container-bottom", 7);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.icon);
        ɵɵadvance();
        ɵɵclassProp("po-input-icon-left", ctx.icon)("po-input-icon-right", ctx.clean);
        ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("tabindex", ctx.disabled ? -1 : 0);
        ɵɵattribute("max", ctx.max)("min", ctx.min)("name", ctx.name)("step", ctx.step);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.readonly);
      }
    },
    dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNumberComponent, [{
    type: Component,
    args: [{
      selector: "po-number",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoNumberComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoNumberComponent),
        multi: true
      }],
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div *ngIf="icon" class="po-field-icon-container-left">
      <po-icon class="po-field-icon po-icon-input" [class.po-field-icon-disabled]="disabled" [p-icon]="icon"></po-icon>
    </div>
    <input
      #inp
      class="po-input"
      type="number"
      [attr.max]="max"
      [attr.min]="min"
      [attr.name]="name"
      [attr.step]="step"
      [autocomplete]="autocomplete"
      [class.po-input-icon-left]="icon"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [tabindex]="disabled ? -1 : 0"
      (blur)="onBlur($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
      (keydown)="onKeyDown($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="po-icon-input"
        *ngIf="clean && !disabled && !readonly"
        [p-default-value]="null"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom
    *ngIf="!readonly"
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-limit]="errorLimit"
    [p-error-pattern]="getErrorPatternMessage()"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  >
  </po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    step: [{
      type: Input,
      args: ["p-step"]
    }],
    setMin: [{
      type: Input,
      args: ["p-min"]
    }],
    setMax: [{
      type: Input,
      args: ["p-max"]
    }],
    onWheel: [{
      type: HostListener,
      args: ["wheel", ["$event"]]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNumberComponent, {
    className: "PoNumberComponent",
    filePath: "lib/components/po-field/po-number/po-number.component.ts",
    lineNumber: 62
  });
})();
function PoPasswordComponent_po_clean_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 10);
    ɵɵlistener("p-change-event", function PoPasswordComponent_po_clean_7_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-element-ref", ctx_r2.inputEl);
  }
}
function PoPasswordComponent_po_icon_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-icon", 11);
    ɵɵlistener("click", function PoPasswordComponent_po_icon_8_Template_po_icon_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.showPassword());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-icon", ctx_r2.visiblePassword ? "ICON_EYE" : "ICON_EYE_OFF po-field-icon-disabled")("ngClass", !ctx_r2.visiblePassword ? "po-field-icon-disabled" : "");
  }
}
function PoPasswordComponent_po_field_container_bottom_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 12);
    ɵɵlistener("p-additional-help", function PoPasswordComponent_po_field_container_bottom_9_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.emitAdditionalHelp());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r2.getAdditionalHelpTooltip())("p-help", ctx_r2.help)("p-disabled", ctx_r2.disabled)("p-error-limit", ctx_r2.errorLimit)("p-error-pattern", ctx_r2.getErrorPattern())("p-show-additional-help", ctx_r2.displayAdditionalHelp)("p-show-additional-help-icon", ctx_r2.showAdditionalHelpIcon());
  }
}
var PoPasswordComponent = class _PoPasswordComponent extends PoInputGeneric {
  id = `po-password[${uuid()}]`;
  type = "password";
  visiblePassword = false;
  _hidePasswordPeek = false;
  _noAutocompletePassword = true;
  /**
   * @optional
   *
   * @description
   *
   * Permite esconder a função de espiar a senha digitada.
   *
   * @default `false`
   */
  set hidePasswordPeek(value) {
    this._hidePasswordPeek = convertToBoolean(value);
    if (value) {
      this.visiblePassword = false;
      this.type = "password";
    }
  }
  set noAutocomplete(value) {
    this._noAutocompletePassword = convertToBoolean(value);
  }
  get noAutocomplete() {
    return this._noAutocompletePassword;
  }
  get hidePasswordPeek() {
    return this._hidePasswordPeek;
  }
  get autocomplete() {
    return this.noAutocomplete ? "new-password" : "on";
  }
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
  }
  extraValidation(c) {
    return null;
  }
  showPassword() {
    this.visiblePassword = !this.visiblePassword;
    this.type = this.type === "password" ? "text" : "password";
  }
  static ɵfac = function PoPasswordComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPasswordComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPasswordComponent,
    selectors: [["po-password"]],
    inputs: {
      hidePasswordPeek: [0, "p-hide-password-peek", "hidePasswordPeek"],
      noAutocomplete: [0, "p-no-autocomplete", "noAutocomplete"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoPasswordComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoPasswordComponent),
      multi: true
    }]), ɵɵInheritDefinitionFeature],
    decls: 10,
    vars: 26,
    consts: [["inp", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [1, "po-field-icon-container-left"], ["p-icon", "ICON_LOCK"], [1, "po-input", "po-input-icon-left", 3, "blur", "click", "focus", "input", "keydown", "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "type"], [1, "po-field-icon-container-right"], ["class", "po-icon-input", 3, "p-element-ref", "p-change-event", 4, "ngIf"], ["class", "po-field-icon po-icon-input", 3, "p-icon", "ngClass", "click", 4, "ngIf"], [3, "p-additional-help-tooltip", "p-help", "p-disabled", "p-error-limit", "p-error-pattern", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [1, "po-icon-input", 3, "p-change-event", "p-element-ref"], [1, "po-field-icon", "po-icon-input", 3, "click", "p-icon", "ngClass"], [3, "p-additional-help", "p-additional-help-tooltip", "p-help", "p-disabled", "p-error-limit", "p-error-pattern", "p-show-additional-help", "p-show-additional-help-icon"]],
    template: function PoPasswordComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2)(2, "div", 3);
        ɵɵelement(3, "po-icon", 4);
        ɵɵelementEnd();
        ɵɵelementStart(4, "input", 5, 0);
        ɵɵlistener("blur", function PoPasswordComponent_Template_input_blur_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnBlur($event));
        })("click", function PoPasswordComponent_Template_input_click_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnClick($event));
        })("focus", function PoPasswordComponent_Template_input_focus_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnFocus($event));
        })("input", function PoPasswordComponent_Template_input_input_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnInput($event));
        })("keydown", function PoPasswordComponent_Template_input_keydown_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(6, "div", 6);
        ɵɵtemplate(7, PoPasswordComponent_po_clean_7_Template, 1, 1, "po-clean", 7)(8, PoPasswordComponent_po_icon_8_Template, 1, 2, "po-icon", 8);
        ɵɵelementEnd()();
        ɵɵtemplate(9, PoPasswordComponent_po_field_container_bottom_9_Template, 1, 7, "po-field-container-bottom", 9);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        const inp_r6 = ɵɵreference(5);
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(3);
        ɵɵclassMapInterpolate1("po-field-icon ", ctx.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
        ɵɵclassProp("po-field-icon-disabled", ctx.disabled);
        ɵɵadvance();
        ɵɵclassProp("po-input-double-icon-right", ctx.clean && inp_r6.value && !ctx.hidePasswordPeek)("po-input-icon-right", ctx.clean || !ctx.hidePasswordPeek);
        ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("type", ctx.disabled ? "password" : ctx.type);
        ɵɵattribute("name", ctx.name);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.hidePasswordPeek && !ctx.disabled);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.readonly);
      }
    },
    dependencies: [NgClass, NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPasswordComponent, [{
    type: Component,
    args: [{
      selector: "po-password",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoPasswordComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoPasswordComponent),
        multi: true
      }],
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div class="po-field-icon-container-left">
      <po-icon
        p-icon="ICON_LOCK"
        class="po-field-icon {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        [class.po-field-icon-disabled]="disabled"
      >
      </po-icon>
    </div>

    <input
      #inp
      class="po-input po-input-icon-left"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-double-icon-right]="clean && inp.value && !hidePasswordPeek"
      [class.po-input-icon-right]="clean || !hidePasswordPeek"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [type]="disabled ? 'password' : type"
      (blur)="eventOnBlur($event)"
      (click)="eventOnClick($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
      (keydown)="onKeyDown($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="po-icon-input"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>

      <po-icon
        *ngIf="!hidePasswordPeek && !disabled"
        [p-icon]="visiblePassword ? 'ICON_EYE' : 'ICON_EYE_OFF po-field-icon-disabled'"
        class="po-field-icon po-icon-input"
        [ngClass]="!visiblePassword ? 'po-field-icon-disabled' : ''"
        (click)="showPassword()"
      >
      </po-icon>
    </div>
  </div>

  <po-field-container-bottom
    *ngIf="!readonly"
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-limit]="errorLimit"
    [p-error-pattern]="getErrorPattern()"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  >
  </po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    hidePasswordPeek: [{
      type: Input,
      args: ["p-hide-password-peek"]
    }],
    noAutocomplete: [{
      type: Input,
      args: ["p-no-autocomplete"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPasswordComponent, {
    className: "PoPasswordComponent",
    filePath: "lib/components/po-field/po-password/po-password.component.ts",
    lineNumber: 48
  });
})();
var PoRichTextToolbarActions;
(function(PoRichTextToolbarActions2) {
  PoRichTextToolbarActions2["Color"] = "color";
  PoRichTextToolbarActions2["Align"] = "align";
  PoRichTextToolbarActions2["Format"] = "format";
  PoRichTextToolbarActions2["List"] = "list";
  PoRichTextToolbarActions2["Link"] = "link";
  PoRichTextToolbarActions2["Media"] = "media";
})(PoRichTextToolbarActions || (PoRichTextToolbarActions = {}));
var PoRichTextService = class _PoRichTextService {
  model = new Subject();
  emitModel(value) {
    this.model.next(value);
  }
  getModel() {
    return this.model.asObservable();
  }
  static ɵfac = function PoRichTextService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRichTextService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoRichTextService,
    factory: _PoRichTextService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var PoRichTextBaseComponent = class _PoRichTextBaseComponent {
  richTextService;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Define que o tooltip (`p-additional-help-tooltip` e/ou `p-error-limit`) será incluído no body da página e não
   * dentro do componente. Essa opção pode ser necessária em cenários com containers que possuem scroll ou overflow
   * escondido, garantindo o posicionamento correto do tooltip próximo ao elemento.
   *
   * > Quando utilizado com `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /**
   * @optional
   *
   * @description
   *
   * Define se o alinhamento de texto será desabilitado.
   *
   * @default `false`
   */
  disabledTextAlign;
  /**
   * @description
   *
   * Mensagem que será apresentada quando a propriedade required estiver habilitada e o campo for limpo após algo ser digitado.
   */
  errorMessage = "";
  /**
   * @optional
   *
   * @description
   *
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   *
   * > Caso essa propriedade seja definida como `true`, a mensagem de erro será limitada a duas linhas
   * e um tooltip será exibido ao passar o mouse sobre a mensagem para mostrar o conteúdo completo.
   *
   * @default `false`
   */
  errorLimit = false;
  /**
   * @optional
   *
   * @description
   *
   * Texto de apoio do campo.
   */
  help;
  /**
   * @optional
   *
   * @description
   *
   * Rótulo do campo.
   */
  label;
  /** Nome e identificador do campo. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  _hideToolbarActions = [];
  /**
   * @optional
   *
   * @description
   *
   * Define as ações da barra de ferramentas do `PoRichTextComponent` que serão ocultadas.
   * Aceita um único valor do tipo `PoRichTextToolbarActions` ou uma lista de valores.
   *
   * > Esta propriedade sobrepõe a configuração da propriedade `p-disabled-text-align` quando for passada como `false`, caso sejam definidas simultaneamente.
   *
   * @default `[]`
   *
   * @example
   * ```
   * // Oculta apenas o seletor de cores
   * component.hideToolbarActions = PoRichTextToolbarActions.Color;
   *
   * // Oculta as opções de alinhamento e link
   * component.hideToolbarActions = [PoRichTextToolbarActions.Align, PoRichTextToolbarActions.Link];
   * ```
   */
  set hideToolbarActions(actions) {
    this._hideToolbarActions = Array.isArray(actions) ? [...actions] : [actions];
  }
  get hideToolbarActions() {
    return this._hideToolbarActions;
  }
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao deixar o campo e que recebe como parâmetro o valor alterado.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao modificar valor do model e que recebe como parâmetro o valor alterado.
   */
  changeModel = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  displayAdditionalHelp = false;
  invalid = false;
  onChangeModel = null;
  value;
  _height;
  _placeholder;
  _readonly;
  _required;
  validatorChange;
  // eslint-disable-next-line
  onTouched = null;
  /**
   * @optional
   *
   * @description
   *
   * Define a altura da área de edição de texto.
   *
   * > Altura mínima do componente é `94` e a altura máxima é `262`.
   */
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Mensagem que aparecerá enquanto o campo não estiver preenchido.
   *
   * @default ''
   */
  set placeholder(value) {
    this._placeholder = value || "";
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será somente leitura.
   *
   * @default `false`
   */
  set readonly(value) {
    this._readonly = convertToBoolean(value);
  }
  get readonly() {
    return this._readonly;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(value) {
    this._required = convertToBoolean(value);
    this.validateModel(this.value);
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  constructor(richTextService) {
    this.richTextService = richTextService;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnChange(func) {
    this.onChangeModel = func;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnTouched(func) {
    this.onTouched = func;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(abstractControl) {
    if (requiredFailed(this.required, false, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
  }
  writeValue(value) {
    this.value = value;
    this.richTextService.emitModel(value);
  }
  // Executa a função onChange
  updateModel(value) {
    if (this.onChangeModel) {
      this.onChangeModel(value);
    }
  }
  validateModel(value) {
    if (this.validatorChange) {
      this.validatorChange(value);
    }
  }
  static ɵfac = function PoRichTextBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRichTextBaseComponent)(ɵɵdirectiveInject(PoRichTextService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoRichTextBaseComponent,
    inputs: {
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      disabledTextAlign: [2, "p-disabled-text-align", "disabledTextAlign", convertToBoolean],
      errorMessage: [0, "p-error-message", "errorMessage"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      help: [0, "p-help", "help"],
      label: [0, "p-label", "label"],
      name: "name",
      optional: [0, "p-optional", "optional"],
      hideToolbarActions: [0, "p-hide-toolbar-actions", "hideToolbarActions"],
      height: [0, "p-height", "height"],
      placeholder: [0, "p-placeholder", "placeholder"],
      readonly: [0, "p-readonly", "readonly"],
      required: [0, "p-required", "required"],
      showRequired: [0, "p-show-required", "showRequired"]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      change: "p-change",
      changeModel: "p-change-model",
      keydown: "p-keydown"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoRichTextService
  }], {
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    disabledTextAlign: [{
      type: Input,
      args: [{
        alias: "p-disabled-text-align",
        transform: convertToBoolean
      }]
    }],
    errorMessage: [{
      type: Input,
      args: ["p-error-message"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    hideToolbarActions: [{
      type: Input,
      args: ["p-hide-toolbar-actions"]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    changeModel: [{
      type: Output,
      args: ["p-change-model"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    height: [{
      type: Input,
      args: ["p-height"]
    }],
    placeholder: [{
      type: Input,
      args: ["p-placeholder"]
    }],
    readonly: [{
      type: Input,
      args: ["p-readonly"]
    }],
    required: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }]
  });
})();
var _c0$O = ["bodyElement"];
var poRichTextBodyCommands = ["bold", "italic", "underline", "justifyleft", "justifycenter", "justifyright", "justifyfull", "insertUnorderedList", "Createlink"];
var PoRichTextBodyComponent = class _PoRichTextBodyComponent {
  richTextService;
  bodyElement;
  height;
  label;
  modelValue;
  placeholder;
  readonly;
  change = new EventEmitter();
  commands = new EventEmitter();
  keydown = new EventEmitter();
  selectedLink = new EventEmitter();
  shortcutCommand = new EventEmitter();
  value = new EventEmitter();
  blur = new EventEmitter();
  isLinkEditing;
  linkElement;
  timeoutChange;
  valueBeforeChange;
  modelSubscription;
  constructor(richTextService) {
    this.richTextService = richTextService;
  }
  ngOnInit() {
    this.bodyElement.nativeElement.designMode = "on";
    this.modelSubscription = this.richTextService.getModel().subscribe((modelValue) => {
      this.modelValue = modelValue;
      this.bodyElement.nativeElement.innerHTML = "";
      this.updateValueWithModelValue();
      this.addClickListenerOnAnchorElements();
    });
  }
  ngOnDestroy() {
    this.modelSubscription?.unsubscribe();
  }
  executeCommand(command) {
    this.bodyElement.nativeElement.focus();
    if (typeof command === "object") {
      if (command.command === "InsertHTML") {
        const {
          command: linkCommand,
          value: {
            urlLink
          },
          value: {
            urlLinkText
          }
        } = command;
        this.handleCommandLink(linkCommand, urlLink, urlLinkText);
      } else {
        document.execCommand(command.command, false, command.value);
      }
    } else {
      document.execCommand(command, false, null);
    }
    this.updateModel();
    this.value.emit(this.modelValue);
  }
  linkEditing(event) {
    this.isLinkEditing = !!event;
  }
  onBlur() {
    this.blur.emit();
    if (this.modelValue !== this.valueBeforeChange) {
      clearTimeout(this.timeoutChange);
      this.timeoutChange = setTimeout(() => {
        this.change.emit(this.modelValue);
      }, 200);
    }
  }
  focus() {
    this.bodyElement.nativeElement.focus();
  }
  onClick() {
    this.emitSelectionCommands();
  }
  onFocus() {
    this.valueBeforeChange = this.modelValue;
  }
  onKeyDown(event) {
    const keyK = event.keyCode === PoKeyCodeEnum.keyK;
    const isLinkShortcut = keyK && event.ctrlKey || keyK && event.metaKey;
    const isFieldFocused = document.activeElement === this.bodyElement.nativeElement;
    if (isLinkShortcut) {
      event.preventDefault();
      this.shortcutCommand.emit();
    }
    this.toggleCursorOnLink(event, "add");
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  onKeyUp(event) {
    this.toggleCursorOnLink(event, "remove");
    this.removeBrElement();
    this.updateModel();
    this.emitSelectionCommands();
  }
  onPaste() {
    this.update();
    setTimeout(() => this.addClickListenerOnAnchorElements());
  }
  update() {
    setTimeout(() => this.updateModel());
    setTimeout(() => {
      this.removeBrElement();
      this.updateModel();
      this.emitSelectionCommands();
    });
  }
  addClickListenerOnAnchorElements() {
    this.bodyElement.nativeElement.querySelectorAll("a").forEach((element) => {
      element.addEventListener("click", this.onAnchorClick);
    });
  }
  emitSelectionCommands() {
    const commands = poRichTextBodyCommands.filter((command) => document.queryCommandState(command));
    const rgbColor = document.queryCommandValue("ForeColor");
    let hexColor;
    if (!isIE()) {
      hexColor = this.rgbToHex(rgbColor);
    }
    if (this.isCursorPositionedInALink()) {
      commands.push("Createlink");
    }
    this.selectedLink.emit(this.linkElement);
    this.commands.emit({
      commands,
      hexColor
    });
  }
  getTextSelection() {
    const textSelection = document.getSelection();
    if (!textSelection) {
      return;
    }
    const focusNode = textSelection.focusNode ? textSelection.focusNode.parentElement : void 0;
    const anchorNode = textSelection.anchorNode ? textSelection.anchorNode.parentNode : void 0;
    const node = focusNode || anchorNode;
    let tagName;
    if (node) {
      tagName = node["tagName"] || node["nodeName"];
      return {
        node,
        tagName
      };
    }
  }
  handleCommandLink(linkCommand, urlLink, urlLinkText) {
    if (isIE()) {
      this.insertHtmlLinkElement(urlLink, urlLinkText);
    } else {
      const linkValue = isFirefox() && !this.isLinkEditing ? `&nbsp;${this.makeLinkTag(urlLink, urlLinkText)}&nbsp;` : this.makeLinkTag(urlLink, urlLinkText);
      document.execCommand(linkCommand, false, linkValue);
    }
    this.addClickListenerOnAnchorElements();
  }
  // tratamento específico para IE pois não suporta o comando 'insertHTML'.
  insertHtmlLinkElement(urlLink, urlLinkText) {
    const selection = document.getSelection();
    const selectionRange = selection.getRangeAt(0);
    const elementLink = document.createElement("a");
    const elementlinkText = document.createTextNode(urlLinkText);
    elementLink.appendChild(elementlinkText);
    elementLink.href = urlLink;
    elementLink.setAttribute("target", "_blank");
    elementLink.classList.add("po-rich-text-link");
    selectionRange.deleteContents();
    selectionRange.insertNode(elementLink);
  }
  isCursorPositionedInALink() {
    const textSelection = this.getTextSelection();
    this.linkElement = void 0;
    let isLink = false;
    if (textSelection && textSelection.node && textSelection.tagName === "A") {
      this.linkElement = textSelection.node;
      isLink = true;
    } else if ((isFirefox() || isIEOrEdge()) && this.verifyCursorPositionInFirefoxIEEdge()) {
      isLink = true;
    } else {
      isLink = textSelection ? this.isParentNodeAnchor(textSelection) : false;
    }
    return isLink;
  }
  isParentNodeAnchor(textSelection) {
    let element = textSelection.node;
    let isLink = false;
    while (element && (element.tagName !== null || element.nodeName !== null)) {
      if (element.tagName === "A" || element.nodeName === "A") {
        this.linkElement = element;
        isLink = true;
        return isLink;
      }
      element = element.parentElement || element.parentNode;
    }
    this.linkElement = void 0;
    return isLink;
  }
  makeLinkTag(urlLink, urlLinkText) {
    return `<a class="po-rich-text-link" href="${urlLink}" target="_blank">${urlLinkText || urlLink}</a>`;
  }
  onAnchorClick = (event) => {
    const {
      target,
      ctrlKey,
      metaKey
    } = event;
    let url;
    let elementLink;
    if (ctrlKey || metaKey) {
      if (event.path) {
        event.path.forEach((element) => {
          if (element.nodeName === "A") {
            url = element.href;
            elementLink = element;
          }
        });
      } else {
        url = target.attributes.href.value;
        elementLink = target;
      }
      openExternalLink(url);
      elementLink.classList.remove("po-clickable");
    }
  };
  // Tratamento necessário para eliminar a tag <br> criada no firefox quando o body for limpo.
  removeBrElement() {
    const bodyElement = this.bodyElement.nativeElement;
    if (!bodyElement.innerText.trim() && bodyElement.childNodes.length === 1 && bodyElement.querySelector("br")) {
      bodyElement.querySelector("br").remove();
    }
  }
  rgbToHex(rgb) {
    const sep = rgb.indexOf(",") > -1 ? "," : " ";
    rgb = rgb.substr(4).split(")")[0].split(sep);
    let r = (+rgb[0]).toString(16);
    let g = (+rgb[1]).toString(16);
    let b = (+rgb[2]).toString(16);
    if (r.length === 1) {
      r = "0" + r;
    }
    if (g.length === 1) {
      g = "0" + g;
    }
    if (b.length === 1) {
      b = "0" + b;
    }
    return "#" + r + g + b;
  }
  toggleCursorOnLink(event, action) {
    const selection = document.getSelection();
    const element = selection.focusNode ? selection.focusNode.parentNode : void 0;
    const isCtrl = event.key === "Control";
    const isCommand = event.key === "Meta";
    const isOnCtrlLink = this.isCursorPositionedInALink() && (isCtrl || isCommand);
    if (element) {
      if (isOnCtrlLink) {
        element["classList"][action]("po-clickable");
      } else {
        const isClickable = element["classList"] && element["classList"].contains("po-clickable");
        if (isClickable) {
          element["classList"].remove("po-clickable");
        }
      }
      this.updateModel();
    }
  }
  updateModel() {
    this.modelValue = this.bodyElement.nativeElement.innerHTML;
    this.value.emit(this.modelValue);
  }
  updateValueWithModelValue() {
    if (this.modelValue) {
      this.bodyElement.nativeElement.insertAdjacentHTML("afterbegin", this.modelValue);
    }
  }
  verifyCursorPositionInFirefoxIEEdge() {
    const textSelection = document.getSelection();
    const nodeLink = textSelection.focusNode;
    let isLink = false;
    if (nodeLink && nodeLink.nodeName === "A") {
      this.linkElement = nodeLink;
      isLink = true;
    } else {
      const range = textSelection.getRangeAt(0);
      const fragmentDocument = range.cloneContents();
      const element = fragmentDocument.childNodes[0] || fragmentDocument.firstElementChild;
      this.linkElement = element && element.nodeName === "A" ? element : void 0;
      isLink = !!this.linkElement;
    }
    return isLink;
  }
  static ɵfac = function PoRichTextBodyComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRichTextBodyComponent)(ɵɵdirectiveInject(PoRichTextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoRichTextBodyComponent,
    selectors: [["po-rich-text-body"]],
    viewQuery: function PoRichTextBodyComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$O, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.bodyElement = _t.first);
      }
    },
    inputs: {
      height: [0, "p-height", "height"],
      label: [0, "p-label", "label"],
      modelValue: [0, "p-model-value", "modelValue"],
      placeholder: [0, "p-placeholder", "placeholder"],
      readonly: [0, "p-readonly", "readonly"]
    },
    outputs: {
      change: "p-change",
      commands: "p-commands",
      keydown: "p-keydown",
      selectedLink: "p-selected-link",
      shortcutCommand: "p-shortcut-command",
      value: "p-value",
      blur: "p-blur"
    },
    standalone: false,
    decls: 2,
    vars: 5,
    consts: [["bodyElement", ""], ["tabindex", "0", 1, "po-rich-text-body", 3, "blur", "click", "cut", "focus", "keydown", "keyup", "paste"]],
    template: function PoRichTextBodyComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 1, 0);
        ɵɵlistener("blur", function PoRichTextBodyComponent_Template_div_blur_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        })("click", function PoRichTextBodyComponent_Template_div_click_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onClick());
        })("cut", function PoRichTextBodyComponent_Template_div_cut_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.update());
        })("focus", function PoRichTextBodyComponent_Template_div_focus_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFocus());
        })("keydown", function PoRichTextBodyComponent_Template_div_keydown_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        })("keyup", function PoRichTextBodyComponent_Template_div_keyup_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyUp($event));
        })("paste", function PoRichTextBodyComponent_Template_div_paste_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onPaste());
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵstyleProp("height", ctx.height, "px");
        ɵɵattribute("aria-label", ctx.label)("contenteditable", !ctx.readonly)("data-placeholder", ctx.placeholder);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextBodyComponent, [{
    type: Component,
    args: [{
      selector: "po-rich-text-body",
      standalone: false,
      template: '<div\n  #bodyElement\n  class="po-rich-text-body"\n  tabindex="0"\n  [attr.aria-label]="label"\n  [attr.contenteditable]="!readonly"\n  [attr.data-placeholder]="placeholder"\n  [style.height.px]="height"\n  (blur)="onBlur()"\n  (click)="onClick()"\n  (cut)="update()"\n  (focus)="onFocus()"\n  (keydown)="onKeyDown($event)"\n  (keyup)="onKeyUp($event)"\n  (paste)="onPaste()"\n></div>\n'
    }]
  }], () => [{
    type: PoRichTextService
  }], {
    bodyElement: [{
      type: ViewChild,
      args: ["bodyElement", {
        static: true
      }]
    }],
    height: [{
      type: Input,
      args: ["p-height"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    modelValue: [{
      type: Input,
      args: ["p-model-value"]
    }],
    placeholder: [{
      type: Input,
      args: ["p-placeholder"]
    }],
    readonly: [{
      type: Input,
      args: ["p-readonly"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    commands: [{
      type: Output,
      args: ["p-commands"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    selectedLink: [{
      type: Output,
      args: ["p-selected-link"]
    }],
    shortcutCommand: [{
      type: Output,
      args: ["p-shortcut-command"]
    }],
    value: [{
      type: Output,
      args: ["p-value"]
    }],
    blur: [{
      type: Output,
      args: ["p-blur"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRichTextBodyComponent, {
    className: "PoRichTextBodyComponent",
    filePath: "lib/components/po-field/po-rich-text/po-rich-text-body/po-rich-text-body.component.ts",
    lineNumber: 26
  });
})();
var poRichTextLiteralsDefault = {
  en: {
    bold: "Bold",
    italic: "Italic",
    underline: "Underline",
    left: "Left",
    center: "Center",
    right: "Right",
    justify: "Justify",
    textColor: "Text color",
    unorderedList: "Bulleted list",
    insertLink: "Insert link",
    linkTextLabel: "Text with link",
    linkUrlTextHelper: "Paste in the text box below the copied browser link",
    linkUrlTextPlaceholder: "Enter the link address that will be attached to the text.",
    cancel: "Cancel",
    editLink: "Edit link",
    insert: "Insert",
    insertImage: "Insert image",
    urlImage: "URL image"
  },
  es: {
    bold: "Negrita",
    italic: "Cursiva",
    underline: "Subrayado",
    left: "Izquierda",
    center: "Centro",
    right: "Derecha",
    justify: "Justificado",
    textColor: "Color del texto",
    unorderedList: "Lista con viñetas",
    insertLink: "Insertar el link",
    linkTextLabel: "Texto con enlace",
    linkUrlTextHelper: "Pegue en el cuadro de texto debajo del enlace del navegador copiado",
    linkUrlTextPlaceholder: "Ingrese la dirección del enlace que se adjuntará al texto.",
    cancel: "Cancelar",
    editLink: "Editar enlace",
    insert: "Insertar",
    insertImage: "Insertar imagen",
    urlImage: "Imagen URL"
  },
  pt: {
    bold: "Negrito",
    italic: "Itálico",
    underline: "Sublinhado",
    left: "Esquerda",
    center: "Centro",
    right: "Direita",
    justify: "Justificado",
    textColor: "Cor do texto",
    unorderedList: "Lista com marcadores",
    insertLink: "Inserir link",
    linkTextLabel: "Texto com link",
    linkUrlTextHelper: "Cole na caixa de texto abaixo o link copiado do navegador",
    linkUrlTextPlaceholder: "Insira o endereço do link que será anexado ao texto",
    cancel: "Cancelar",
    editLink: "Editar link",
    insert: "Inserir",
    insertImage: "Inserir imagem",
    urlImage: "Imagem em URL"
  },
  ru: {
    bold: "Жирный",
    italic: "Италик",
    underline: "Подчеркивание",
    left: "Влево",
    center: "Центр",
    right: "Вправо",
    justify: "Растянуть",
    textColor: "Цвет текста",
    unorderedList: "Список",
    insertLink: "Вставьте ссылку",
    linkTextLabel: "Текст со ссылкой",
    linkUrlTextHelper: "Вставьте в текстовое поле ниже скопированную ссылку",
    linkUrlTextPlaceholder: "Вставьте ссылку для привязки к тексту",
    cancel: "Отмена",
    editLink: "Редактировать ссылку",
    insert: "Вставить",
    insertImage: "Вставить изображение",
    urlImage: "Ссылка на изображение"
  }
};
var PoUploadStatus;
(function(PoUploadStatus2) {
  PoUploadStatus2[PoUploadStatus2["Uploaded"] = 0] = "Uploaded";
  PoUploadStatus2[PoUploadStatus2["Uploading"] = 1] = "Uploading";
  PoUploadStatus2[PoUploadStatus2["Error"] = 2] = "Error";
  PoUploadStatus2[PoUploadStatus2["None"] = 3] = "None";
})(PoUploadStatus || (PoUploadStatus = {}));
var PoUploadFile = class {
  // Nome do arquivo.
  name;
  // Arquivo bruto.
  rawFile;
  // Status de envio do arquivo.
  status;
  // Identificador do arquivo.
  uid;
  // Extensão do arquivo.
  extension;
  // Tamanho do arquivo em bytes;
  size;
  // propriedade para auxiliar a exibição do texto no componente progress
  displayName;
  // porcentagem utilizada para repassar ao componente progress
  percent;
  constructor(file) {
    if (file) {
      this.name = file.name;
      this.displayName = `${file.name} - ${this.getFileSize(file.size)}`;
      this.extension = this.getExtension(file.name);
      this.size = file.size;
      this.rawFile = file;
      this.uid = this.generateUUID();
      this.status = PoUploadStatus.None;
    }
  }
  getExtension(value) {
    if (value) {
      const extension = value.substr(value.lastIndexOf("."));
      return extension.toLowerCase();
    }
    return "";
  }
  generateUUID() {
    function s4() {
      return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
    }
    return s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
  }
  // Retorna o tamanho do arquivo em KBytes.
  getFileSize(size) {
    let kbSize = 0;
    if (size) {
      kbSize = Math.ceil(size / 1024);
    }
    return `${kbSize} KB`;
  }
};
var PoUploadBaseService = class _PoUploadBaseService {
  http;
  formField = "files";
  requests = [];
  constructor(http) {
    this.http = http;
  }
  /**
   * Método responsável por enviar os arquivos ao servidor, conforme o parâmetro URL.
   *
   * @param url URL da requisição a ser efetuada.
   * @param files Arquivos a serem enviados.
   * @param tOnUpload Função a ser executada quando o arquivo for enviado ao servidor.
   * @param uploadCallback Função que será executada enquanto os arquivos estiverem sendo enviados.
   * @param successCallback Função a ser executada quando a requisição for efetuada com sucesso.
   * @param errorCallback Função a ser executada quando a requisição foi efetuada com sucesso.
   */
  upload(url, files, headers, tOnUpload, uploadCallback, successCallback, errorCallback) {
    const filesLength = files.length;
    const uploadEvent = {
      data: {},
      extraFormData: {},
      file: null,
      url,
      headers
    };
    for (let i = 0; i < filesLength; i++) {
      const formData = new FormData();
      const file = files[i];
      const fileName = file.rawFile.name;
      formData.append(this.formField, file.rawFile, fileName);
      if (tOnUpload) {
        uploadEvent["file"] = file;
        tOnUpload.emit(uploadEvent);
        Object.keys(uploadEvent.extraFormData).forEach((key) => {
          formData.append(key, uploadEvent.extraFormData[key]);
        });
        formData.append("data", JSON.stringify(uploadEvent.data));
        url = uploadEvent.url;
        headers = uploadEvent.headers;
      }
      this.sendFile(url, file, headers, formData, uploadCallback, successCallback, errorCallback);
    }
  }
  sendFile(url, file, headers, formData, uploadCallback, successCallback, errorCallback) {
    let request = new Subscription();
    request = this.getRequest(url, headers, formData).subscribe((event) => {
      if (event.type === HttpEventType.UploadProgress) {
        this.addRequest(file, request);
        const percentDone = Math.round(100 * event.loaded / event.total);
        uploadCallback(file, percentDone);
      } else if (event instanceof HttpResponse) {
        successCallback(file, event);
      }
    }, (err) => {
      errorCallback(file, err);
    });
  }
  getRequest(url, headers, formData) {
    const httpHeaders = new HttpHeaders(headers);
    const req = new HttpRequest("POST", url, formData, {
      reportProgress: true,
      headers: httpHeaders
    });
    return this.http.request(req);
  }
  stopRequestByFile(file, callback) {
    const requestObj = this.requests.find((req) => req.file.uid === file.uid);
    if (requestObj) {
      const request = requestObj.request;
      request.unsubscribe();
      this.removeRequest(requestObj);
      callback();
    }
  }
  removeRequest(requestObj) {
    const index = this.requests.indexOf(requestObj);
    this.requests.splice(index, 1);
  }
  addRequest(file, request) {
    const hasRequest = this.requests.some((req) => req.file.uid === file.uid);
    if (!hasRequest) {
      this.requests.push({
        file,
        request
      });
    }
  }
  static ɵfac = function PoUploadBaseService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoUploadBaseService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoUploadBaseService,
    factory: _PoUploadBaseService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadBaseService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }], null);
})();
var PoUploadService = class _PoUploadService extends PoUploadBaseService {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoUploadService_BaseFactory;
    return function PoUploadService_Factory(__ngFactoryType__) {
      return (ɵPoUploadService_BaseFactory || (ɵPoUploadService_BaseFactory = ɵɵgetInheritedFactory(_PoUploadService)))(__ngFactoryType__ || _PoUploadService);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({
    token: _PoUploadService,
    factory: _PoUploadService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var poUploadLiteralsDefault = {
  en: {
    files: "files",
    folders: "folders",
    selectFile: "Select file",
    selectFiles: "Select files",
    selectFolder: "Select folder",
    startSending: "Start sending",
    dragFilesHere: "Drag files here",
    dragFoldersHere: "Drag folders here",
    selectFilesOnComputer: "or select files on your computer",
    selectFolderOnComputer: "or select folder on your computer",
    dropFilesHere: "Drop files here",
    dropFoldersHere: "Drop folders here",
    invalidDropArea: "{0} were not dropped in the correct area",
    invalidFileType: "Failed to load {0} file(s) as it is not the allowed file type.",
    invalidAmount: "Failed to load {0} file(s), as it exceeds the limit amount of files.",
    invalidFormat: "Failed to load {0} file(s), as it does not match the format(s): {1}.",
    invalidSize: "Failed to load {0} files(s), as it is not the allowed size: from {1} to {2}.",
    numberOfFilesAllowed: "{0} file(s) allowed",
    allowedFormats: "Accepted file formats: {0}.",
    allowedFileSizeRange: "Size limit per file: from {0} to {1}",
    maxFileSizeAllowed: "Size limit per file: {0} maximum",
    minFileSizeAllowed: "Size limit per file: {0} minimum",
    errorOccurred: "An error has occurred",
    sentWithSuccess: "Sent with success"
  },
  es: {
    files: "archivos",
    folders: "carpetas",
    selectFile: "Seleccionar archivo",
    selectFiles: "Seleccionar archivos",
    selectFolder: "Seleccionar carpeta",
    startSending: "Iniciar carga",
    dragFilesHere: "Arrastra los archivos aquí",
    dragFoldersHere: "Arrastra las carpetas aquí",
    selectFilesOnComputer: "o selecciona los archivos en tu computadora",
    selectFolderOnComputer: "o selecciona la carpeta en tu computadora",
    dropFilesHere: "Deja los archivos aquí",
    dropFoldersHere: "Deja las carpetas aquí",
    invalidDropArea: "Los {0} no se insertaron en la ubicación correcta",
    invalidFileType: "Error al cargar {0} archivo (s) ya que no es el tipo de archivo permitido",
    invalidAmount: "Error al cargar {0} archivo (s) ya que excede la cantidad limite de archivos.",
    invalidFormat: "Error al cargar {0} archivo (s) ya que no coincide con el formato (s): {1}.",
    invalidSize: "Error al cargar {0} archivo (s) ya que no cumple con el tamaño permitido: desde {1} hasta {2}.",
    numberOfFilesAllowed: "{0} archivo(s) permitido(s)",
    allowedFormats: "Formatos aceptados: {0}.",
    allowedFileSizeRange: "Limite de tamaño de archivo: desde {0} hasta {1}",
    maxFileSizeAllowed: "Limite de tamaño de archivo: hasta {0}",
    minFileSizeAllowed: "Limite de tamaño de archivo: minimo {0}",
    errorOccurred: "Ocurrio un error",
    sentWithSuccess: "Enviado con éxito"
  },
  pt: {
    files: "arquivos",
    folders: "diretórios",
    selectFile: "Selecionar arquivo",
    selectFiles: "Selecionar arquivos",
    selectFolder: "Selecionar pasta",
    startSending: "Iniciar envio",
    dragFilesHere: "Arraste os arquivos aqui",
    dragFoldersHere: "Arraste as pastas aqui",
    selectFilesOnComputer: "ou selecione os arquivos no computador",
    selectFolderOnComputer: "ou selecione a pasta no computador",
    dropFilesHere: "Solte os arquivos aqui",
    dropFoldersHere: "Solte as pastas aqui",
    invalidDropArea: "Os {0} não foram inseridos no local correto",
    invalidFileType: "Falha ao carregar {0} arquivo (s), pois não é o tipo de arquivo permitido",
    invalidAmount: "Falha ao carregar {0} arquivo(s), pois excede(m) a quantidade limite de arquivos.",
    invalidFormat: "Falha ao carregar {0} arquivo(s), pois não corresponde(m) ao(s) formato(s): {1}.",
    invalidSize: "Falha ao carregar {0} arquivo(s), pois não atende ao tamanho permitido: {1} até {2}.",
    numberOfFilesAllowed: "Quantidade máxima: {0} arquivo(s)",
    allowedFormats: "Formatos adotados: {0}.",
    allowedFileSizeRange: "Limite de tamanho por arquivo: de {0} até {1}",
    maxFileSizeAllowed: "Limite de tamanho por arquivo: até {0}",
    minFileSizeAllowed: "Limite de tamanho por arquivo: no mínimo {0}",
    errorOccurred: "Ocorreu um erro",
    sentWithSuccess: "Enviado com sucesso"
  },
  ru: {
    files: "файлы",
    folders: "папки с файлами",
    selectFile: "Выберите файл",
    selectFiles: "Выберите файлы",
    selectFolder: "Выберите папку с файлами",
    startSending: "Начать загрузку",
    dragFilesHere: "Перетащите файлы сюда",
    dragFoldersHere: "Перетащите сюда папки",
    selectFilesOnComputer: "или выберите файлы на компьютере",
    selectFolderOnComputer: "или выберите папку на вашем компьютере",
    dropFilesHere: "Оставьте файлы здесь",
    dropFoldersHere: "Перетащите сюда папки",
    invalidDropArea: "{0} не были вставлены в правильном месте.",
    invalidFileType: "Не удалось загрузить файлы {0}, так как это неверный тип файла",
    invalidAmount: "Não foi possível carregar os arquivos {0} porque eles excederam o limite de arquivos.",
    invalidFormat: "Не удалось загрузить файлы {0}, так как они не соответствуют формату (ам): {1}.",
    invalidSize: "Не удалось загрузить файлы {0}, поскольку они не соответствуют разрешенному размеру: от {1} до {2}.",
    numberOfFilesAllowed: "Максимальное количество: {0} файлов",
    allowedFormats: "Форматы приняты: {0}.",
    allowedFileSizeRange: "Ограничение размера файла: от {0} до {1}",
    maxFileSizeAllowed: "Ограничение размера файла: до {0}",
    minFileSizeAllowed: "Ограничение размера файла: не менее {0}",
    errorOccurred: "Произошла ошибка.",
    sentWithSuccess: "Успешно отправлено"
  }
};
var poUploadFormFieldDefault = "files";
var poUploadMaxFileSize = 31457280;
var poUploadMinFileSize = 0;
var PoUploadBaseComponent = class _PoUploadBaseComponent {
  uploadService;
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Define que o tooltip (`p-additional-help-tooltip`) será incluído no body da página e não dentro do componente. Essa
   * opção pode ser necessária em cenários com containers que possuem scroll ou overflow escondido, garantindo o
   * posicionamento correto do tooltip próximo ao elemento.
   *
   * > Quando utilizado com `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /**
   * @optional
   *
   * @description
   *
   * Define em *pixels* a altura da área onde podem ser arrastados os arquivos. A altura mínima aceita é `160px`.
   *
   * > Esta propriedade funciona somente se a propriedade `p-drag-drop` estiver habilitada.
   *
   * @default `320`
   */
  dragDropHeight;
  /** Rótulo do campo. */
  label;
  /** Texto de apoio para o campo. */
  help;
  /** URL que deve ser feita a requisição com os arquivos selecionados. */
  url;
  /** Define o valor do atributo `name` do componente. */
  name = "file";
  /**
   * @optional
   *
   * @description
   *
   * Define se o envio do arquivo será automático ao selecionar o mesmo.
   *
   * > Esta propriedade funciona somente se a propriedade `p-url` tiver um valor atribuído.
   *
   * @default `false`
   */
  autoUpload = false;
  /**
   * @optional
   *
   * @description
   *
   * Desabilita botão de remover o(s) arquivo(s) selecionado(s).
   *
   * @default `false`
   */
  disabledRemoveFile = false;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   *  - O campo conter `p-required`;
   *  - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /** Objeto que contém os cabeçalhos que será enviado na requisição dos arquivos. */
  headers;
  /**
   * @optional
   *
   * @description
   *
   * Define se a propriedade `p-url` é obrigatória.
   *
   * Caso a propriedade seja definida como `false`:
   * - o botão de "Selecionar arquivo" ficará habilitado mesmo sem a propriedade `p-url` definida.
   * - o botão "Iniciar envio" ficará oculto até que a propriedade `p-url` seja definida.
   *
   * > Se utilizada com a propriedade `p-auto-upload` definida como `true` será necessário definir a propriedade `p-url`.
   *
   * @default `true`
   */
  requiredUrl = true;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Define uma ação personalizada no componente `po-upload`, adicionando um botão no canto inferior direito
   * de cada barra de progresso associada aos arquivos enviados ou em envio.
   *
   * A ação deve implementar a interface **PoProgressAction**, permitindo configurar propriedades como:
   * - `label`: Texto do botão.
   * - `icon`: Ícone a ser exibido no botão.
   * - `type`: Tipo de botão (ex.: `danger` ou `default`).
   * - `disabled`: Indica se o botão deve estar desabilitado.
   * - `visible`: Indica se o botão deve estar visível.
   *
   * **Exemplo de uso:**
   *
   * ```html
   * <po-upload
   *  [p-custom-action]="customAction"
   *  (p-custom-action-click)="onCustomActionClick($event)">
   * </po-upload>
   * ```
   *
   * ```typescript
   * customAction: PoProgressAction = {
   *   label: 'Baixar',
   *   icon: 'an an-download',
   *   type: 'default',
   *   visible: true
   * };
   *
   * onCustomActionClick(file: PoUploadFile) {
   *   console.log(`Ação personalizada clicada para o arquivo: ${file.name}`);
   * }
   * ```
   */
  customAction;
  /**
   * @optional
   *
   * @description
   *
   * Evento emitido ao clicar na ação personalizada configurada no `p-custom-action`.
   *
   * O evento retorna o arquivo associado à barra de progresso onde a ação foi clicada,
   * permitindo executar operações específicas para aquele arquivo.
   *
   * **Exemplo de uso:**
   *
   * ```html
   * <po-upload
   *  [p-custom-action]="customAction"
   *  (p-custom-action-click)="onCustomActionClick($event)">
   * </po-upload>
   * ```
   *
   * ```typescript
   * customAction: PoProgressAction = {
   *   label: 'Baixar',
   *   icon: 'an an-download',
   *   type: 'default',
   *   visible: true
   * };
   *
   * onCustomActionClick(file: PoUploadFile) {
   *   console.log(`Ação personalizada clicada para o arquivo: ${file.name}`);
   *   // Lógica para download do arquivo
   *   this.downloadFile(file);
   * }
   *
   * downloadFile(file: PoUploadFile) {
   *   // Exemplo de download
   *   console.log(`Iniciando o download do arquivo: ${file.name}`);
   * }
   * ```
   */
  customActionClick = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função que será executada no momento de realizar o envio do arquivo,
   * onde será possível adicionar informações ao parâmetro que será enviado na requisição.
   * É passado por parâmetro um objeto com o arquivo e as propriedades data e extraFormData,
   * que serão enviadas em conjunto com o arquivo na requisição, por exemplo:
   *
   * > data, nesta propriedade pode ser informado algum dado
   * ```
   *   event.data = {id: 'id do usuário'};
   * ```
   * > extraFormData, nesta propriedade pode ser informado algum dado solicitado pela API
   * > que não possa estar no objeto `data`, assim o conteúdo sará extraído do objeto e
   * > enviado como parâmetro
   * ```
   *   event.extraFormData = {id: 'id do usuário'};
   * ```
   */
  onUpload = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento será disparado quando ocorrer algum erro no envio do arquivo.
   * > Por parâmetro será passado o objeto do retorno que é do tipo `HttpErrorResponse`.
   */
  onError = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento será disparado quando o envio do arquivo for realizado com sucesso.
   * > Por parâmetro será passado o objeto do retorno que é do tipo `HttpResponse`.
   */
  onSuccess = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da *tag* `form`.
   *
   * Na versão 12.2.0 do Angular a verificação `strictTemplates` vem true como default. Portanto, para utilizar
   * two-way binding no componente deve se utilizar da seguinte forma:
   *
   * ```
   * <po-upload ... [ngModel]="UploadModel" (ngModelChange)="uploadModel = $event"> </po-upload>
   * ```
   *
   */
  ngModelChange = new EventEmitter();
  allowedExtensions;
  currentFiles;
  canHandleDirectory;
  displayAdditionalHelp = false;
  onModelChange;
  extensionNotAllowed = 0;
  quantityNotAllowed = 0;
  sizeNotAllowed = 0;
  onModelTouched = null;
  _directory;
  _disabled;
  _dragDrop = false;
  _fileRestrictions;
  _formField;
  _hideRestrictionsInfo;
  _hideSelectButton;
  _hideSendButton;
  _isMultiple;
  _literals;
  _required;
  language;
  validatorChange;
  /**
   * @optional
   *
   * @description
   *
   * Permite a seleção de diretórios contendo um ou mais arquivos para envio.
   *
   * > A habilitação desta propriedade se restringe apenas à seleção de diretórios.
   *
   * > Definição não suportada pelo browser **Internet Explorer**, todavia será possível a seleção de arquivos padrão.
   *
   * @default `false`
   */
  set directory(value) {
    this._directory = convertToBoolean(value);
    this.canHandleDirectory = this._directory && !isIE() && !isMobile();
    this.setDirectoryAttribute(this.canHandleDirectory);
  }
  get directory() {
    return this._directory;
  }
  /**
   * @optional
   *
   * @description
   *
   * Exibe a área onde é possível arrastar e selecionar os arquivos. Quando estiver definida, omite o botão para seleção de arquivos
   * automaticamente.
   *
   * > Recomendamos utilizar apenas um `po-upload` com esta funcionalidade por tela.
   *
   * @default `false`
   */
  set dragDrop(value) {
    this._dragDrop = convertToBoolean(value);
  }
  get dragDrop() {
    return this._dragDrop;
  }
  /**
   * @optional
   *
   * @description
   *
   * Oculta visualmente as informações de restrições para o upload.
   *
   * @default `false`
   */
  set hideRestrictionsInfo(value) {
    this._hideRestrictionsInfo = convertToBoolean(value);
  }
  get hideRestrictionsInfo() {
    return this._hideRestrictionsInfo;
  }
  /**
   * @optional
   *
   * @description
   *
   * Omite o botão de seleção de arquivos.
   *
   * > Caso o valor definido seja `true`, caberá ao desenvolvedor a responsabilidade
   * pela chamada do método `selectFiles()` para seleção de arquivos.
   *
   * @default `false`
   */
  set hideSelectButton(value) {
    this._hideSelectButton = convertToBoolean(value);
  }
  get hideSelectButton() {
    return this._hideSelectButton;
  }
  /**
   * @optional
   *
   * @description
   *
   * Omite o botão de envio de arquivos.
   *
   * > Caso o valor definido seja `true`, caberá ao desenvolvedor a responsabilidade
   * pela chamada do método `sendFiles()` para envio do(s) arquivo(s) selecionado(s).
   *
   * @default `false`
   */
  set hideSendButton(value) {
    this._hideSendButton = convertToBoolean(value);
  }
  get hideSendButton() {
    return this._hideSendButton;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-upload`.
   *
   * Existem duas maneiras de customizar o componente:
   *
   * - passando um objeto implementando a interface `PoUploadLiterals` com todas as literais disponíveis;
   * - passando apenas as literais que deseja customizar:
   * ```
   *  const customLiterals: PoUploadLiterals = {
   *    folders: 'Pastas',
   *    selectFile: 'Buscar arquivo',
   *    startSending: 'Enviar'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente:
   *
   * ```
   * <po-upload
   *   [p-literals]="customLiterals">
   * </po-upload>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do *browser* (pt, en, es, ru).
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poUploadLiteralsDefault[poLocaleDefault]), poUploadLiteralsDefault[this.language]), value);
    } else {
      this._literals = poUploadLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poUploadLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto que segue a definição da interface `PoUploadFileRestrictions`,
   * que possibilita definir tamanho máximo/mínimo e extensão dos arquivos permitidos.
   */
  set fileRestrictions(restrictions) {
    this._fileRestrictions = this.initRestrictions(restrictions);
    this.setAllowedExtensions(restrictions);
  }
  get fileRestrictions() {
    return this._fileRestrictions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Nome do campo de formulário que será enviado para o serviço informado na propriedade `p-url`.
   *
   * @default `files`
   */
  set formField(value) {
    this._formField = value && typeof value === "string" ? value : poUploadFormFieldDefault;
    this.getUploadService().formField = this.formField;
  }
  get formField() {
    return this._formField;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será desabilitado.
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
    this.validateModel(this.currentFiles);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define se pode selecionar mais de um arquivo.
   *
   * > Se utilizada a `p-directory`, habilita-se automaticamente esta propriedade.
   */
  set isMultiple(value) {
    this._isMultiple = convertToBoolean(value);
  }
  get isMultiple() {
    return this.canHandleDirectory ? true : this._isMultiple;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel(this.currentFiles);
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  constructor(uploadService, languageService) {
    this.uploadService = uploadService;
    this.language = languageService.getShortLanguage();
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.onModelChange = fn;
  }
  registerOnTouched(fn) {
    this.onModelTouched = fn;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(abstractControl) {
    if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
  }
  writeValue(model) {
    if (model) {
      if (!isEquals(this.currentFiles, model)) {
        this.currentFiles = this.parseFiles(model);
      }
    } else {
      this.currentFiles = void 0;
    }
  }
  isExceededFileLimit(currentFilesLength) {
    return this.isMultiple && this.fileRestrictions && this.fileRestrictions.maxFiles > 0 && this.fileRestrictions.maxFiles <= currentFilesLength;
  }
  // Faz o parse dos arquivos selecionados para arquivos do formato PoUploadFile e atualiza os arquivos correntes.
  parseFiles(files) {
    let poUploadFiles = this.currentFiles || [];
    const filesLength = files.length;
    for (let i = 0; i < filesLength; i++) {
      if (this.isExceededFileLimit(poUploadFiles.length)) {
        this.quantityNotAllowed = filesLength - this.fileRestrictions.maxFiles;
        break;
      }
      const file = new PoUploadFile(files[i]);
      if (this.checkRestrictions(file)) {
        poUploadFiles = this.insertFileInFiles(file, poUploadFiles);
      }
    }
    this.sendFeedback();
    return poUploadFiles;
  }
  validateModel(model) {
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  // Verifica se o arquivo está de acordo com as restrições.
  checkRestrictions(file) {
    const restrictions = this.fileRestrictions;
    if (restrictions) {
      const allowedExtensions = restrictions.allowedExtensions;
      const minFileSize = restrictions.minFileSize;
      const maxFileSize = restrictions.maxFileSize;
      const isAccept = allowedExtensions ? this.isAllowedExtension(file.extension, allowedExtensions) : true;
      const isAcceptSize = file.size >= minFileSize && file.size <= maxFileSize;
      if (!isAcceptSize) {
        this.sizeNotAllowed = this.sizeNotAllowed + 1;
      }
      return isAccept && isAcceptSize;
    }
    return true;
  }
  existsFileSameName(file, files) {
    return files.some((currentFile) => file.name === currentFile.name);
  }
  getUploadService() {
    return this.uploadService;
  }
  insertFileInFiles(newFile, files) {
    if (this.existsFileSameName(newFile, files)) {
      return this.updateExistsFileInFiles(newFile, files);
    }
    if (this.isMultiple) {
      files.push(newFile);
    } else {
      files.splice(0, files.length, newFile);
    }
    return files;
  }
  isAllowedExtension(extension, allowedExtensions = []) {
    const isAllowed = allowedExtensions.some((ext) => ext.toLowerCase() === extension);
    if (!isAllowed) {
      this.extensionNotAllowed = this.extensionNotAllowed + 1;
    }
    return isAllowed;
  }
  setAllowedExtensions(restrictions = {}) {
    const _allowedExtensions = restrictions.allowedExtensions || [];
    this.allowedExtensions = _allowedExtensions.join(",");
  }
  initRestrictions(restrictions) {
    if (!restrictions) {
      return;
    }
    const minFileSize = restrictions.minFileSize || poUploadMinFileSize;
    const maxFileSize = restrictions.maxFileSize || poUploadMaxFileSize;
    return __spreadProps(__spreadValues({}, restrictions), {
      maxFileSize,
      minFileSize
    });
  }
  updateExistsFileInFiles(newFile, files) {
    const fileIndex = files.findIndex((currentFile) => newFile.name === currentFile.name && currentFile.status !== PoUploadStatus.Uploaded);
    if (fileIndex !== -1) {
      files.splice(fileIndex, 1, newFile);
    }
    return files;
  }
  static ɵfac = function PoUploadBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoUploadBaseComponent)(ɵɵdirectiveInject(PoUploadService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoUploadBaseComponent,
    hostVars: 1,
    hostBindings: function PoUploadBaseComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("p-required-url", ctx.requiredUrl);
      }
    },
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      dragDropHeight: [0, "p-drag-drop-height", "dragDropHeight"],
      label: [0, "p-label", "label"],
      help: [0, "p-help", "help"],
      url: [0, "p-url", "url"],
      name: "name",
      autoUpload: [0, "p-auto-upload", "autoUpload"],
      disabledRemoveFile: [2, "p-disabled-remove-file", "disabledRemoveFile", convertToBoolean],
      optional: [0, "p-optional", "optional"],
      headers: [0, "p-headers", "headers"],
      requiredUrl: [2, "p-required-url", "requiredUrl", convertToBoolean],
      customAction: [0, "p-custom-action", "customAction"],
      directory: [0, "p-directory", "directory"],
      dragDrop: [0, "p-drag-drop", "dragDrop"],
      hideRestrictionsInfo: [0, "p-hide-restrictions-info", "hideRestrictionsInfo"],
      hideSelectButton: [0, "p-hide-select-button", "hideSelectButton"],
      hideSendButton: [0, "p-hide-send-button", "hideSendButton"],
      literals: [0, "p-literals", "literals"],
      fileRestrictions: [0, "p-restrictions", "fileRestrictions"],
      formField: [0, "p-form-field", "formField"],
      disabled: [0, "p-disabled", "disabled"],
      isMultiple: [0, "p-multiple", "isMultiple"],
      required: [0, "p-required", "required"],
      showRequired: [0, "p-show-required", "showRequired"]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      customActionClick: "p-custom-action-click",
      keydown: "p-keydown",
      onUpload: "p-upload",
      onError: "p-error",
      onSuccess: "p-success",
      ngModelChange: "ngModelChange"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoUploadService
  }, {
    type: PoLanguageService
  }], {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    dragDropHeight: [{
      type: Input,
      args: ["p-drag-drop-height"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    url: [{
      type: Input,
      args: ["p-url"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    autoUpload: [{
      type: Input,
      args: ["p-auto-upload"]
    }],
    disabledRemoveFile: [{
      type: Input,
      args: [{
        alias: "p-disabled-remove-file",
        transform: convertToBoolean
      }]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    headers: [{
      type: Input,
      args: ["p-headers"]
    }],
    requiredUrl: [{
      type: HostBinding,
      args: ["attr.p-required-url"]
    }, {
      type: Input,
      args: [{
        alias: "p-required-url",
        transform: convertToBoolean
      }]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    customAction: [{
      type: Input,
      args: ["p-custom-action"]
    }],
    customActionClick: [{
      type: Output,
      args: ["p-custom-action-click"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    onUpload: [{
      type: Output,
      args: ["p-upload"]
    }],
    onError: [{
      type: Output,
      args: ["p-error"]
    }],
    onSuccess: [{
      type: Output,
      args: ["p-success"]
    }],
    ngModelChange: [{
      type: Output,
      args: ["ngModelChange"]
    }],
    directory: [{
      type: Input,
      args: ["p-directory"]
    }],
    dragDrop: [{
      type: Input,
      args: ["p-drag-drop"]
    }],
    hideRestrictionsInfo: [{
      type: Input,
      args: ["p-hide-restrictions-info"]
    }],
    hideSelectButton: [{
      type: Input,
      args: ["p-hide-select-button"]
    }],
    hideSendButton: [{
      type: Input,
      args: ["p-hide-send-button"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    fileRestrictions: [{
      type: Input,
      args: ["p-restrictions"]
    }],
    formField: [{
      type: Input,
      args: ["p-form-field"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    isMultiple: [{
      type: Input,
      args: ["p-multiple"]
    }],
    required: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }]
  });
})();
var _c0$N = ["selectFilesLink"];
var _c1$i = (a0) => ({
  "po-upload-drag-drop-area-disabled": a0
});
var _c2$8 = (a0) => ({
  "po-clickable": a0
});
function PoUploadDragDropAreaComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoUploadDragDropAreaComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 6);
    ɵɵelementStart(1, "div", 7);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.directoryCompatible ? ctx_r0.literals == null ? null : ctx_r0.literals.dropFoldersHere : ctx_r0.literals == null ? null : ctx_r0.literals.dropFilesHere, " ");
  }
}
function PoUploadDragDropAreaComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelement(0, "po-icon", 8);
    ɵɵelementStart(1, "div", 9);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "button", 10, 2);
    ɵɵlistener("click", function PoUploadDragDropAreaComponent_ng_template_5_Template_button_click_3_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.selectFiles.emit());
    });
    ɵɵtext(5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.directoryCompatible ? ctx_r0.literals == null ? null : ctx_r0.literals.dragFoldersHere : ctx_r0.literals == null ? null : ctx_r0.literals.dragFilesHere, " ");
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r0.disabled)("ngClass", ɵɵpureFunction1(4, _c2$8, !ctx_r0.disabled));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.directoryCompatible ? ctx_r0.literals == null ? null : ctx_r0.literals.selectFolderOnComputer : ctx_r0.literals == null ? null : ctx_r0.literals.selectFilesOnComputer, " ");
  }
}
var PoUploadDragDropAreaComponent = class _PoUploadDragDropAreaComponent {
  elementRef;
  directoryCompatible;
  disabled;
  height;
  literals;
  overlay;
  selectFiles = new EventEmitter();
  selectFilesLinkElement;
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
  focus() {
    this.selectFilesLinkElement.nativeElement.focus();
  }
  static ɵfac = function PoUploadDragDropAreaComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoUploadDragDropAreaComponent)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoUploadDragDropAreaComponent,
    selectors: [["po-upload-drag-drop-area"]],
    viewQuery: function PoUploadDragDropAreaComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$N, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.selectFilesLinkElement = _t.first);
      }
    },
    inputs: {
      directoryCompatible: [0, "p-directory-compatible", "directoryCompatible"],
      disabled: [0, "p-disabled", "disabled"],
      height: [0, "p-height", "height"],
      literals: [0, "p-literals", "literals"],
      overlay: [0, "p-overlay", "overlay"]
    },
    outputs: {
      selectFiles: "p-select-files"
    },
    standalone: false,
    decls: 7,
    vars: 8,
    consts: [["overlayTemplate", ""], ["defaultTemplate", ""], ["selectFilesLink", ""], [1, "po-upload-drag-drop-area", 3, "ngClass"], [1, "po-upload-drag-drop-area-container"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["p-icon", "ICON_UPLOAD_CLOUD", 1, "po-upload-drag-drop-area-overlay-icon"], [1, "po-upload-drag-drop-area-overlay-label"], ["p-icon", "ICON_UPLOAD_CLOUD", 1, "po-upload-drag-drop-area-icon"], [1, "po-upload-drag-drop-area-label"], [1, "po-upload-drag-drop-area-select-files", 3, "click", "disabled", "ngClass"]],
    template: function PoUploadDragDropAreaComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 3)(1, "div", 4);
        ɵɵtemplate(2, PoUploadDragDropAreaComponent_ng_container_2_Template, 1, 0, "ng-container", 5);
        ɵɵelementEnd()();
        ɵɵtemplate(3, PoUploadDragDropAreaComponent_ng_template_3_Template, 3, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, PoUploadDragDropAreaComponent_ng_template_5_Template, 6, 6, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const overlayTemplate_r3 = ɵɵreference(4);
        const defaultTemplate_r4 = ɵɵreference(6);
        ɵɵstyleProp("height", ctx.height, "px");
        ɵɵproperty("ngClass", ɵɵpureFunction1(6, _c1$i, ctx.disabled));
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.overlay && !ctx.disabled)("ngIfThen", overlayTemplate_r3)("ngIfElse", defaultTemplate_r4);
      }
    },
    dependencies: [NgClass, NgIf, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadDragDropAreaComponent, [{
    type: Component,
    args: [{
      selector: "po-upload-drag-drop-area",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<div
  class="po-upload-drag-drop-area"
  [ngClass]="{ 'po-upload-drag-drop-area-disabled': disabled }"
  [style.height.px]="height"
>
  <div class="po-upload-drag-drop-area-container">
    <ng-container *ngIf="overlay && !disabled; then overlayTemplate; else defaultTemplate"> </ng-container>
  </div>
</div>

<ng-template #overlayTemplate>
  <po-icon p-icon="ICON_UPLOAD_CLOUD" class="po-upload-drag-drop-area-overlay-icon"></po-icon>
  <div class="po-upload-drag-drop-area-overlay-label">
    {{ directoryCompatible ? literals?.dropFoldersHere : literals?.dropFilesHere }}
  </div>
</ng-template>

<ng-template #defaultTemplate>
  <po-icon p-icon="ICON_UPLOAD_CLOUD" class="po-upload-drag-drop-area-icon"></po-icon>
  <div class="po-upload-drag-drop-area-label">
    {{ directoryCompatible ? literals?.dragFoldersHere : literals?.dragFilesHere }}
  </div>

  <button
    #selectFilesLink
    class="po-upload-drag-drop-area-select-files"
    [disabled]="disabled"
    [ngClass]="{ 'po-clickable': !disabled }"
    (click)="selectFiles.emit()"
  >
    {{ directoryCompatible ? literals?.selectFolderOnComputer : literals?.selectFilesOnComputer }}
  </button>
</ng-template>
`
    }]
  }], () => [{
    type: ElementRef
  }], {
    directoryCompatible: [{
      type: Input,
      args: ["p-directory-compatible"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    height: [{
      type: Input,
      args: ["p-height"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    overlay: [{
      type: Input,
      args: ["p-overlay"]
    }],
    selectFiles: [{
      type: Output,
      args: ["p-select-files"]
    }],
    selectFilesLinkElement: [{
      type: ViewChild,
      args: ["selectFilesLink"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUploadDragDropAreaComponent, {
    className: "PoUploadDragDropAreaComponent",
    filePath: "lib/components/po-field/po-upload/po-upload-drag-drop/po-upload-drag-drop-area/po-upload-drag-drop-area.component.ts",
    lineNumber: 11
  });
})();
var PoUploadDragDropDirective = class _PoUploadDragDropDirective {
  i18nPipe;
  notification;
  areaElement;
  directoryCompatible;
  disabled;
  literals;
  dragLeave = new EventEmitter();
  dragOver = new EventEmitter();
  fileChange = new EventEmitter();
  timeout;
  files;
  invalidFileType;
  constructor(i18nPipe, notification) {
    this.i18nPipe = i18nPipe;
    this.notification = notification;
  }
  onDragLeave(event) {
    event.preventDefault();
    event.stopPropagation();
    this.timeout = setTimeout(() => this.dragLeave.emit(), 30);
  }
  onDragOver(event) {
    event.preventDefault();
    event.stopPropagation();
    clearTimeout(this.timeout);
    if (!this.disabled) {
      this.dragOver.emit();
    }
  }
  onDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    this.getFilesFromDataTransferItems(event);
    this.dragLeave.emit();
  }
  getFilesFromDataTransferItems(event) {
    if (!this.disabled) {
      this.invalidFileType = 0;
      if (this.directoryCompatible) {
        this.getOnlyDirectories(event.dataTransfer.items).then(() => {
          this.sendFiles(event, this.files);
        });
      } else {
        const files = this.getOnlyFiles(event.dataTransfer);
        this.sendFiles(event, files);
      }
    }
  }
  // analisa as entradas recursivamente
  getFilesFromEntry(entry) {
    return __async(this, null, function* () {
      if (entry.isFile) {
        const file = yield this.readFile(entry);
        return [file];
      } else if (entry.isDirectory) {
        return yield this.readDirectory(entry);
      }
    });
  }
  getOnlyDirectories(dataTransferItems) {
    return __async(this, null, function* () {
      const entries = [];
      for (const item of dataTransferItems) {
        entries.push(item.webkitGetAsEntry());
      }
      this.files = [];
      for (const entry of entries) {
        if (entry.isFile) {
          this.invalidFileType++;
        } else {
          const newFiles = yield this.getFilesFromEntry(entry);
          this.files = this.files.concat(newFiles);
        }
      }
    });
  }
  // return only files. If it is a directory, invalidFileType counts.
  getOnlyFiles(dataTransfer) {
    const fileList = Array.from(dataTransfer.files);
    const entriesFiles = Array.from(dataTransfer.items).map((item) => item.webkitGetAsEntry());
    return fileList.reduce((newFiles, file) => {
      const entryFile = entriesFiles.find((entry) => entry.name === file.name);
      if (entryFile.isFile) {
        return newFiles.concat(file);
      } else {
        this.invalidFileType++;
      }
      return newFiles;
    }, []);
  }
  readFile(entry) {
    return new Promise((resolve) => {
      entry.file((file) => {
        resolve(file);
      });
    });
  }
  readDirectory(entry) {
    return __async(this, null, function* () {
      const dirReader = entry.createReader();
      let files = [];
      const newFiles = yield this.readDirectoryEntries(dirReader);
      files = files.concat(newFiles);
      return files;
    });
  }
  readDirectoryEntries(dirReader) {
    return new Promise((resolve) => {
      dirReader.readEntries((entries) => __async(this, null, function* () {
        let files = [];
        for (const entry of entries) {
          const itemFiles = yield this.getFilesFromEntry(entry);
          files = files.concat(itemFiles);
        }
        resolve(files);
      }));
    });
  }
  sendFeedback(invalidFiles) {
    if (invalidFiles) {
      this.setPipeArguments("invalidFileType", invalidFiles);
    }
  }
  sendFiles(event, files) {
    if (this.areaElement.contains(event.target)) {
      if (files.length > 0) {
        this.fileChange.emit(files);
      }
      this.sendFeedback(this.invalidFileType);
    } else {
      const invalidDropAreaArg = this.directoryCompatible ? this.literals.folders : this.literals.files;
      this.setPipeArguments("invalidDropArea", invalidDropAreaArg);
    }
  }
  // método responsável por setar os argumentos do i18nPipe.
  setPipeArguments(literalAttributes, args) {
    const pipeArguments = this.i18nPipe.transform(this.literals[literalAttributes], args);
    this.notification.information(pipeArguments);
  }
  static ɵfac = function PoUploadDragDropDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoUploadDragDropDirective)(ɵɵdirectiveInject(PoI18nPipe), ɵɵdirectiveInject(PoNotificationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoUploadDragDropDirective,
    selectors: [["", "p-upload-drag-drop", ""]],
    hostBindings: function PoUploadDragDropDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("dragleave", function PoUploadDragDropDirective_dragleave_HostBindingHandler($event) {
          return ctx.onDragLeave($event);
        }, false, ɵɵresolveDocument)("dragover", function PoUploadDragDropDirective_dragover_HostBindingHandler($event) {
          return ctx.onDragOver($event);
        }, false, ɵɵresolveDocument)("drop", function PoUploadDragDropDirective_drop_HostBindingHandler($event) {
          return ctx.onDrop($event);
        }, false, ɵɵresolveDocument);
      }
    },
    inputs: {
      areaElement: [0, "p-area-element", "areaElement"],
      directoryCompatible: [0, "p-directory-compatible", "directoryCompatible"],
      disabled: [0, "p-disabled", "disabled"],
      literals: [0, "p-literals", "literals"]
    },
    outputs: {
      dragLeave: "p-drag-leave",
      dragOver: "p-drag-over",
      fileChange: "p-file-change"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoI18nPipe])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadDragDropDirective, [{
    type: Directive,
    args: [{
      selector: "[p-upload-drag-drop]",
      providers: [PoI18nPipe],
      standalone: false
    }]
  }], () => [{
    type: PoI18nPipe
  }, {
    type: PoNotificationService
  }], {
    areaElement: [{
      type: Input,
      args: ["p-area-element"]
    }],
    directoryCompatible: [{
      type: Input,
      args: ["p-directory-compatible"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    dragLeave: [{
      type: Output,
      args: ["p-drag-leave"]
    }],
    dragOver: [{
      type: Output,
      args: ["p-drag-over"]
    }],
    fileChange: [{
      type: Output,
      args: ["p-file-change"]
    }],
    onDragLeave: [{
      type: HostListener,
      args: ["document:dragleave", ["$event"]]
    }],
    onDragOver: [{
      type: HostListener,
      args: ["document:dragover", ["$event"]]
    }],
    onDrop: [{
      type: HostListener,
      args: ["document:drop", ["$event"]]
    }]
  });
})();
var _c0$M = ["DragDropAreaFixed"];
var PoUploadDragDropAreaOverlayComponent = class _PoUploadDragDropAreaOverlayComponent {
  renderer;
  DragDropAreaFixed;
  directoryCompatible;
  disabled;
  literals;
  target;
  areaElement = new EventEmitter();
  constructor(renderer) {
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    if (this.target) {
      this.setPosition(this.target);
    }
    this.areaElement.emit(this.DragDropAreaFixed.nativeElement);
  }
  setPosition(targetElement) {
    const boundingClientRect = targetElement.nativeElement.getBoundingClientRect();
    const clientRectKeys = ["bottom", "left", "height", "right", "top", "width"];
    clientRectKeys.forEach((clientRectKey) => {
      const clientRectValue = boundingClientRect[clientRectKey];
      this.renderer.setStyle(this.DragDropAreaFixed.nativeElement, clientRectKey, `${clientRectValue}px`);
    });
  }
  static ɵfac = function PoUploadDragDropAreaOverlayComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoUploadDragDropAreaOverlayComponent)(ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoUploadDragDropAreaOverlayComponent,
    selectors: [["po-upload-drag-drop-area-overlay"]],
    viewQuery: function PoUploadDragDropAreaOverlayComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$M, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.DragDropAreaFixed = _t.first);
      }
    },
    inputs: {
      directoryCompatible: [0, "p-directory-compatible", "directoryCompatible"],
      disabled: [0, "p-disabled", "disabled"],
      literals: [0, "p-literals", "literals"],
      target: [0, "p-target", "target"]
    },
    outputs: {
      areaElement: "p-area-element"
    },
    standalone: false,
    decls: 3,
    vars: 4,
    consts: [["DragDropAreaFixed", ""], [1, "po-overlay-fixed"], [1, "po-upload-drag-drop-area-overlay", 3, "p-directory-compatible", "p-disabled", "p-literals", "p-overlay"]],
    template: function PoUploadDragDropAreaOverlayComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 1);
        ɵɵelement(1, "po-upload-drag-drop-area", 2, 0);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("p-directory-compatible", ctx.directoryCompatible)("p-disabled", ctx.disabled)("p-literals", ctx.literals)("p-overlay", true);
      }
    },
    dependencies: [PoUploadDragDropAreaComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadDragDropAreaOverlayComponent, [{
    type: Component,
    args: [{
      selector: "po-upload-drag-drop-area-overlay",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div class="po-overlay-fixed">\n  <po-upload-drag-drop-area\n    #DragDropAreaFixed\n    class="po-upload-drag-drop-area-overlay"\n    [p-directory-compatible]="directoryCompatible"\n    [p-disabled]="disabled"\n    [p-literals]="literals"\n    [p-overlay]="true"\n  >\n  </po-upload-drag-drop-area>\n</div>\n'
    }]
  }], () => [{
    type: Renderer2
  }], {
    DragDropAreaFixed: [{
      type: ViewChild,
      args: ["DragDropAreaFixed", {
        read: ElementRef,
        static: true
      }]
    }],
    directoryCompatible: [{
      type: Input,
      args: ["p-directory-compatible"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    target: [{
      type: Input,
      args: ["p-target"]
    }],
    areaElement: [{
      type: Output,
      args: ["p-area-element"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUploadDragDropAreaOverlayComponent, {
    className: "PoUploadDragDropAreaOverlayComponent",
    filePath: "lib/components/po-field/po-upload/po-upload-drag-drop/po-upload-drag-drop-area-overlay/po-upload-drag-drop-area-overlay.component.ts",
    lineNumber: 21
  });
})();
var _c0$L = ["dragDropOverlay"];
function PoUploadDragDropComponent_po_upload_drag_drop_area_overlay_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-upload-drag-drop-area-overlay", 3, 0);
    ɵɵlistener("p-area-element", function PoUploadDragDropComponent_po_upload_drag_drop_area_overlay_0_Template_po_upload_drag_drop_area_overlay_p_area_element_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onAreaElement($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-directory-compatible", ctx_r1.directoryCompatible)("p-disabled", ctx_r1.disabled)("p-literals", ctx_r1.literals)("p-target", ctx_r1.dragDropAreaComponent.elementRef);
  }
}
var PoUploadDragDropHeightDefault = 320;
var PoUploadDragDropHeightMin = 160;
var PoUploadDragDropComponent = class _PoUploadDragDropComponent {
  changeDetector;
  dragDropOverlayElement;
  dragDropAreaComponent;
  directoryCompatible;
  disabled;
  literals;
  fileChange = new EventEmitter();
  selectFiles = new EventEmitter();
  areaElement;
  isDragOver = false;
  _dragDropHeight = PoUploadDragDropHeightDefault;
  set dragDropHeight(value) {
    const dragDropHeight = convertToInt(value, PoUploadDragDropHeightDefault);
    this._dragDropHeight = dragDropHeight < PoUploadDragDropHeightMin ? PoUploadDragDropHeightMin : dragDropHeight;
  }
  get dragDropHeight() {
    return this._dragDropHeight;
  }
  constructor(changeDetector) {
    this.changeDetector = changeDetector;
  }
  focus() {
    this.dragDropAreaComponent.focus();
  }
  onAreaElement(element) {
    this.areaElement = element;
    this.changeDetector.detectChanges();
  }
  onDragLeave() {
    this.isDragOver = false;
  }
  onDragOver() {
    this.isDragOver = true;
  }
  onFileChange(files) {
    this.isDragOver = false;
    this.fileChange.emit(files);
  }
  static ɵfac = function PoUploadDragDropComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoUploadDragDropComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoUploadDragDropComponent,
    selectors: [["po-upload-drag-drop"]],
    viewQuery: function PoUploadDragDropComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$L, 5, ElementRef);
        ɵɵviewQuery(PoUploadDragDropAreaComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragDropOverlayElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragDropAreaComponent = _t.first);
      }
    },
    inputs: {
      directoryCompatible: [0, "p-directory-compatible", "directoryCompatible"],
      disabled: [0, "p-disabled", "disabled"],
      literals: [0, "p-literals", "literals"],
      dragDropHeight: [0, "p-drag-drop-height", "dragDropHeight"]
    },
    outputs: {
      fileChange: "p-file-change",
      selectFiles: "p-select-files"
    },
    standalone: false,
    decls: 2,
    vars: 7,
    consts: [["dragDropOverlay", ""], [3, "p-directory-compatible", "p-disabled", "p-literals", "p-target", "p-area-element", 4, "ngIf"], ["p-upload-drag-drop", "", 3, "p-drag-leave", "p-drag-over", "p-file-change", "p-select-files", "p-area-element", "p-directory-compatible", "p-disabled", "p-height", "p-literals", "p-overlay"], [3, "p-area-element", "p-directory-compatible", "p-disabled", "p-literals", "p-target"]],
    template: function PoUploadDragDropComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoUploadDragDropComponent_po_upload_drag_drop_area_overlay_0_Template, 2, 4, "po-upload-drag-drop-area-overlay", 1);
        ɵɵelementStart(1, "po-upload-drag-drop-area", 2);
        ɵɵlistener("p-drag-leave", function PoUploadDragDropComponent_Template_po_upload_drag_drop_area_p_drag_leave_1_listener() {
          return ctx.onDragLeave();
        })("p-drag-over", function PoUploadDragDropComponent_Template_po_upload_drag_drop_area_p_drag_over_1_listener() {
          return ctx.onDragOver();
        })("p-file-change", function PoUploadDragDropComponent_Template_po_upload_drag_drop_area_p_file_change_1_listener($event) {
          return ctx.onFileChange($event);
        })("p-select-files", function PoUploadDragDropComponent_Template_po_upload_drag_drop_area_p_select_files_1_listener() {
          return ctx.selectFiles.emit();
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.isDragOver);
        ɵɵadvance();
        ɵɵproperty("p-area-element", ctx.areaElement)("p-directory-compatible", ctx.directoryCompatible)("p-disabled", ctx.disabled)("p-height", ctx.dragDropHeight)("p-literals", ctx.literals)("p-overlay", false);
      }
    },
    dependencies: [NgIf, PoUploadDragDropDirective, PoUploadDragDropAreaOverlayComponent, PoUploadDragDropAreaComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadDragDropComponent, [{
    type: Component,
    args: [{
      selector: "po-upload-drag-drop",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<po-upload-drag-drop-area-overlay\n  #dragDropOverlay\n  *ngIf="isDragOver"\n  [p-directory-compatible]="directoryCompatible"\n  [p-disabled]="disabled"\n  [p-literals]="literals"\n  [p-target]="dragDropAreaComponent.elementRef"\n  (p-area-element)="onAreaElement($event)"\n>\n</po-upload-drag-drop-area-overlay>\n\n<po-upload-drag-drop-area\n  p-upload-drag-drop\n  [p-area-element]="areaElement"\n  [p-directory-compatible]="directoryCompatible"\n  [p-disabled]="disabled"\n  [p-height]="dragDropHeight"\n  [p-literals]="literals"\n  [p-overlay]="false"\n  (p-drag-leave)="onDragLeave()"\n  (p-drag-over)="onDragOver()"\n  (p-file-change)="onFileChange($event)"\n  (p-select-files)="selectFiles.emit()"\n>\n</po-upload-drag-drop-area>\n'
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    dragDropOverlayElement: [{
      type: ViewChild,
      args: ["dragDropOverlay", {
        read: ElementRef
      }]
    }],
    dragDropAreaComponent: [{
      type: ViewChild,
      args: [PoUploadDragDropAreaComponent, {
        static: true
      }]
    }],
    directoryCompatible: [{
      type: Input,
      args: ["p-directory-compatible"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    fileChange: [{
      type: Output,
      args: ["p-file-change"]
    }],
    selectFiles: [{
      type: Output,
      args: ["p-select-files"]
    }],
    dragDropHeight: [{
      type: Input,
      args: ["p-drag-drop-height"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUploadDragDropComponent, {
    className: "PoUploadDragDropComponent",
    filePath: "lib/components/po-field/po-upload/po-upload-drag-drop/po-upload-drag-drop.component.ts",
    lineNumber: 26
  });
})();
var _c0$K = (a0, a1) => [a0, a1];
function PoUploadFileRestrictionsComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 1);
    ɵɵtext(1);
    ɵɵpipe(2, "poI18n");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r0.literals == null ? null : ctx_r0.literals.numberOfFilesAllowed, ctx_r0.maxFiles), "\n");
  }
}
function PoUploadFileRestrictionsComponent_p_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 1);
    ɵɵtext(1);
    ɵɵpipe(2, "poI18n");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r0.literals == null ? null : ctx_r0.literals.allowedFormats, ctx_r0.allowedExtensions), "\n");
  }
}
function PoUploadFileRestrictionsComponent_p_2_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "poI18n");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r0.literals == null ? null : ctx_r0.literals.allowedFileSizeRange, ɵɵpureFunction2(4, _c0$K, ctx_r0.minFileSize, ctx_r0.maxFileSize)), " ");
  }
}
function PoUploadFileRestrictionsComponent_p_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "poI18n");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r0.literals == null ? null : ctx_r0.literals.minFileSizeAllowed, ctx_r0.minFileSize), " ");
  }
}
function PoUploadFileRestrictionsComponent_p_2_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "poI18n");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r0.literals == null ? null : ctx_r0.literals.maxFileSizeAllowed, ctx_r0.maxFileSize), " ");
  }
}
function PoUploadFileRestrictionsComponent_p_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 1)(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, PoUploadFileRestrictionsComponent_p_2_span_3_Template, 3, 7, "span", 2)(4, PoUploadFileRestrictionsComponent_p_2_span_4_Template, 3, 4, "span", 2)(5, PoUploadFileRestrictionsComponent_p_2_span_5_Template, 3, 4, "span", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.literals == null ? null : ctx_r0.literals.allowedSizes);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.minFileSize && ctx_r0.maxFileSize);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.minFileSize && !ctx_r0.maxFileSize);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.maxFileSize && !ctx_r0.minFileSize);
  }
}
var PoUploadFileRestrictionsComponent = class _PoUploadFileRestrictionsComponent {
  changeDetector;
  maxFiles;
  literals;
  _allowedExtensions;
  _maxFileSize;
  _minFileSize;
  language;
  set allowedExtensions(value) {
    this._allowedExtensions = this.formatAllowedExtensions(value);
  }
  get allowedExtensions() {
    return this._allowedExtensions;
  }
  set maxFileSize(value) {
    this._maxFileSize = formatBytes(value);
  }
  get maxFileSize() {
    return this._maxFileSize;
  }
  set minFileSize(value) {
    this._minFileSize = formatBytes(value);
  }
  get minFileSize() {
    return this._minFileSize;
  }
  constructor(changeDetector, languageService) {
    this.changeDetector = changeDetector;
    this.language = languageService.getShortLanguage();
  }
  ngOnInit() {
    this.setLiterals();
  }
  formatAllowedExtensions(allowedExtensions) {
    const conjunction = {
      "pt": "e",
      "en": "and",
      "es": "y",
      "ru": "и"
    };
    return allowedExtensions ? allowedExtensions.join(", ").toUpperCase().replace(/,(?=[^,]*$)/, ` ${conjunction[this.language]}`) : void 0;
  }
  setLiterals() {
    this.literals = __spreadValues(__spreadValues({}, poUploadLiteralsDefault[poLocaleDefault]), poUploadLiteralsDefault[this.language]);
    this.changeDetector.detectChanges();
  }
  static ɵfac = function PoUploadFileRestrictionsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoUploadFileRestrictionsComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoUploadFileRestrictionsComponent,
    selectors: [["po-upload-file-restrictions"]],
    inputs: {
      maxFiles: [0, "p-max-files", "maxFiles"],
      allowedExtensions: [0, "p-allowed-extensions", "allowedExtensions"],
      maxFileSize: [0, "p-max-file-size", "maxFileSize"],
      minFileSize: [0, "p-min-file-size", "minFileSize"]
    },
    standalone: false,
    decls: 3,
    vars: 3,
    consts: [["class", "po-font-text-small", 4, "ngIf"], [1, "po-font-text-small"], [4, "ngIf"]],
    template: function PoUploadFileRestrictionsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoUploadFileRestrictionsComponent_p_0_Template, 3, 4, "p", 0)(1, PoUploadFileRestrictionsComponent_p_1_Template, 3, 4, "p", 0)(2, PoUploadFileRestrictionsComponent_p_2_Template, 6, 4, "p", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.maxFiles > 1);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.allowedExtensions);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.minFileSize || ctx.maxFileSize);
      }
    },
    dependencies: [NgIf, PoI18nPipe],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadFileRestrictionsComponent, [{
    type: Component,
    args: [{
      selector: "po-upload-file-restrictions",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<p class="po-font-text-small" *ngIf="maxFiles > 1">\n  {{ literals?.numberOfFilesAllowed | poI18n: maxFiles }}\n</p>\n\n<p class="po-font-text-small" *ngIf="allowedExtensions">\n  {{ literals?.allowedFormats | poI18n: allowedExtensions }}\n</p>\n\n<p class="po-font-text-small" *ngIf="minFileSize || maxFileSize">\n  <span>{{ literals?.allowedSizes }}</span>\n\n  <span *ngIf="minFileSize && maxFileSize">\n    {{ literals?.allowedFileSizeRange | poI18n: [minFileSize, maxFileSize] }}\n  </span>\n\n  <span *ngIf="minFileSize && !maxFileSize">\n    {{ literals?.minFileSizeAllowed | poI18n: minFileSize }}\n  </span>\n\n  <span *ngIf="maxFileSize && !minFileSize">\n    {{ literals?.maxFileSizeAllowed | poI18n: maxFileSize }}\n  </span>\n</p>\n'
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: PoLanguageService
  }], {
    maxFiles: [{
      type: Input,
      args: ["p-max-files"]
    }],
    allowedExtensions: [{
      type: Input,
      args: ["p-allowed-extensions"]
    }],
    maxFileSize: [{
      type: Input,
      args: ["p-max-file-size"]
    }],
    minFileSize: [{
      type: Input,
      args: ["p-min-file-size"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUploadFileRestrictionsComponent, {
    className: "PoUploadFileRestrictionsComponent",
    filePath: "lib/components/po-field/po-upload/po-upload-file-restrictions/po-upload-file-restrictions.component.ts",
    lineNumber: 15
  });
})();
var _c0$J = ["inputFile"];
var _c1$h = ["uploadButton"];
var _c2$7 = (a0) => ({
  "po-upload-file-restrictions-drag-drop": a0
});
var _c3$4 = (a0) => ({
  "po-upload-progress-container-area po-pt-2 po-pl-1": a0
});
function PoUploadComponent_po_upload_drag_drop_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-upload-drag-drop", 12);
    ɵɵlistener("p-file-change", function PoUploadComponent_po_upload_drag_drop_5_Template_po_upload_drag_drop_p_file_change_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onFileChangeDragDrop($event));
    })("p-select-files", function PoUploadComponent_po_upload_drag_drop_5_Template_po_upload_drag_drop_p_select_files_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.selectFiles());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-directory-compatible", ctx_r2.canHandleDirectory)("p-disabled", ctx_r2.isDisabled)("p-drag-drop-height", ctx_r2.dragDropHeight)("p-literals", ctx_r2.literals);
  }
}
function PoUploadComponent_po_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 13, 1);
    ɵɵlistener("p-blur", function PoUploadComponent_po_button_6_Template_po_button_p_blur_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onBlur());
    })("p-click", function PoUploadComponent_po_button_6_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.selectFiles());
    })("keydown", function PoUploadComponent_po_button_6_Template_po_button_keydown_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onKeyDown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r2.isDisabled)("p-label", ctx_r2.selectFileButtonLabel);
  }
}
function PoUploadComponent_po_upload_file_restrictions_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-upload-file-restrictions", 14);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(5, _c2$7, ctx_r2.displayDragDrop))("p-allowed-extensions", ctx_r2.fileRestrictions == null ? null : ctx_r2.fileRestrictions.allowedExtensions)("p-max-files", ctx_r2.maxFiles)("p-max-file-size", ctx_r2.fileRestrictions == null ? null : ctx_r2.fileRestrictions.maxFileSize)("p-min-file-size", ctx_r2.fileRestrictions == null ? null : ctx_r2.fileRestrictions.minFileSize);
  }
}
function PoUploadComponent_div_8_po_progress_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-progress", 19);
    ɵɵlistener("p-custom-action-click", function PoUploadComponent_div_8_po_progress_3_Template_po_progress_p_custom_action_click_0_listener() {
      const file_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.customClick(file_r6));
    })("p-cancel", function PoUploadComponent_div_8_po_progress_3_Template_po_progress_p_cancel_0_listener() {
      const file_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.cancel(file_r6));
    })("p-retry", function PoUploadComponent_div_8_po_progress_3_Template_po_progress_p_retry_0_listener() {
      const file_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.uploadFiles([file_r6]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const file_r6 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("p-disabled-cancel", ctx_r2.disabledRemoveFile)("p-info", ctx_r2.infoByUploadStatus[file_r6.status] == null ? null : ctx_r2.infoByUploadStatus[file_r6.status].text(file_r6.percent))("p-info-icon", ctx_r2.infoByUploadStatus[file_r6.status] == null ? null : ctx_r2.infoByUploadStatus[file_r6.status].icon)("p-status", ctx_r2.progressStatusByFileStatus[file_r6.status])("p-text", file_r6.displayName)("p-value", file_r6.percent)("p-custom-action", ctx_r2.customAction);
  }
}
function PoUploadComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15)(1, "po-container", 16)(2, "div", 17);
    ɵɵtemplate(3, PoUploadComponent_div_8_po_progress_3_Template, 1, 7, "po-progress", 18);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-height", ctx_r2.hasMoreThanFourItems ? 280 : "auto")("p-no-border", !ctx_r2.hasMoreThanFourItems)("p-no-padding", !ctx_r2.hasMoreThanFourItems);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(6, _c3$4, ctx_r2.hasMoreThanFourItems));
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.currentFiles)("ngForTrackBy", ctx_r2.trackByFn);
  }
}
function PoUploadComponent_po_button_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 20);
    ɵɵlistener("p-click", function PoUploadComponent_po_button_9_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.uploadFiles(ctx_r2.currentFiles));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("po-mt-3", ctx_r2.hasMoreThanFourItems);
    ɵɵproperty("p-disabled", ctx_r2.hasAnyFileUploading(ctx_r2.currentFiles))("p-label", ctx_r2.literals.startSending);
  }
}
var PoUploadComponent = class _PoUploadComponent extends PoUploadBaseComponent {
  renderer;
  i18nPipe;
  notification;
  cd;
  inputFile;
  poUploadDragDropComponent;
  uploadButton;
  id = `po-upload[${uuid()}]`;
  infoByUploadStatus = {
    [PoUploadStatus.Uploaded]: {
      text: () => this.literals.sentWithSuccess,
      icon: "ICON_OK"
    },
    [PoUploadStatus.Error]: {
      text: () => this.literals.errorOccurred
    },
    [PoUploadStatus.Uploading]: {
      text: (percent) => percent + "%"
    }
  };
  progressStatusByFileStatus = {
    [PoUploadStatus.Uploaded]: PoProgressStatus.Success,
    [PoUploadStatus.Error]: PoProgressStatus.Error
  };
  calledByCleanInputValue = false;
  constructor(uploadService, renderer, i18nPipe, notification, cd, languageService) {
    super(uploadService, languageService);
    this.renderer = renderer;
    this.i18nPipe = i18nPipe;
    this.notification = notification;
    this.cd = cd;
  }
  get displayDragDrop() {
    return this.dragDrop && !isMobile();
  }
  get displaySendButton() {
    const currentFiles = this.currentFiles || [];
    return !this.hideSendButton && !this.autoUpload && currentFiles.length > 0 && this.hasFileNotUploaded && this.requiredUrl;
  }
  get selectFileButtonLabel() {
    if (this.canHandleDirectory) {
      return this.literals.selectFolder;
    } else if (this.isMultiple) {
      return this.literals.selectFiles;
    } else {
      return this.literals.selectFile;
    }
  }
  get hasMoreThanFourItems() {
    return this.currentFiles && this.currentFiles.length > 4;
  }
  get hasMultipleFiles() {
    return this.currentFiles && this.currentFiles.length > 1;
  }
  get hasFileNotUploaded() {
    if (Array.isArray(this.currentFiles)) {
      return this.currentFiles.some((file) => file.status !== PoUploadStatus.Uploaded);
    }
    return false;
  }
  get isDisabled() {
    const currentFiles = this.currentFiles || [];
    return this.requiredUrl ? !!(this.hasAnyFileUploading(currentFiles) || !this.url || this.disabled || this.isExceededFileLimit(currentFiles.length)) : !!(this.hasAnyFileUploading(currentFiles) || this.autoUpload || this.disabled || this.isExceededFileLimit(currentFiles.length));
  }
  get maxFiles() {
    return this.isMultiple && this.fileRestrictions && this.fileRestrictions.maxFiles;
  }
  cancel(file) {
    if (file.status === PoUploadStatus.Uploading) {
      return this.stopUpload(file);
    }
    this.removeFile(file);
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  /** Método responsável por **limpar** o(s) arquivo(s) selecionado(s). */
  clear() {
    this.currentFiles = void 0;
    this.updateModel([]);
    this.cleanInputValue();
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoUploadComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoUploadComponent, { static: true }) upload: PoUploadComponent;
   *
   * focusUpload() {
   *   this.upload.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      if (this.uploadButton) {
        this.uploadButton.focus();
        return;
      }
      if (this.displayDragDrop) {
        this.poUploadDragDropComponent.focus();
      }
    }
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  // Verifica se existe algum arquivo sendo enviado ao serviço.
  hasAnyFileUploading(files) {
    if (files && files.length) {
      return files.some((file) => file.status === PoUploadStatus.Uploading);
    }
    return false;
  }
  // retorna se o status do arquivo é diferente de enviado
  isAllowCancelEvent(status) {
    return status !== PoUploadStatus.Uploaded;
  }
  onBlur() {
    if (!this.isUploadButtonFocused() && this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
  }
  // Função disparada ao selecionar algum arquivo.
  onFileChange(event) {
    if (this.calledByCleanInputValue) {
      this.calledByCleanInputValue = false;
      return event.preventDefault();
    }
    const files = event.target.files;
    this.updateFiles(files);
    this.cleanInputValue();
  }
  onFileChangeDragDrop(files) {
    this.updateFiles(files);
  }
  onKeyDown(event) {
    if (this.isUploadButtonFocused()) {
      this.keydown.emit(event);
    }
  }
  // Remove o arquivo passado por parâmetro da lista dos arquivos correntes.
  removeFile(file) {
    const index = this.currentFiles.indexOf(file);
    this.currentFiles.splice(index, 1);
    this.updateModel([...this.currentFiles]);
  }
  /** Método responsável por **abrir** a janela para seleção de arquivo(s). */
  selectFiles() {
    this.onModelTouched?.();
    this.calledByCleanInputValue = false;
    this.inputFile.nativeElement.click();
  }
  sendFeedback() {
    if (this.sizeNotAllowed > 0) {
      const minFileSize = formatBytes(this.fileRestrictions.minFileSize);
      const maxFileSize = formatBytes(this.fileRestrictions.maxFileSize);
      const args = [this.sizeNotAllowed, minFileSize || "0", maxFileSize];
      this.setPipeArguments("invalidSize", args);
      this.sizeNotAllowed = 0;
    }
    if (this.extensionNotAllowed > 0) {
      const allowedExtensionsFormatted = this.fileRestrictions.allowedExtensions.join(", ").toUpperCase();
      const args = [this.extensionNotAllowed, allowedExtensionsFormatted];
      this.setPipeArguments("invalidFormat", args);
      this.extensionNotAllowed = 0;
    }
    if (this.quantityNotAllowed > 0) {
      const args = [this.quantityNotAllowed];
      this.setPipeArguments("invalidAmount", args);
      this.quantityNotAllowed = 0;
    }
  }
  /** Método responsável por **enviar** o(s) arquivo(s) selecionado(s). */
  sendFiles() {
    if (this.currentFiles && this.currentFiles.length) {
      this.uploadFiles(this.currentFiles);
    }
  }
  setDirectoryAttribute(canHandleDirectory) {
    if (canHandleDirectory) {
      this.renderer.setAttribute(this.inputFile.nativeElement, "webkitdirectory", "true");
    } else {
      this.renderer.removeAttribute(this.inputFile.nativeElement, "webkitdirectory");
    }
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-upload
   *  #upload
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, upload)"
   * ></po-upload>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoUploadComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  // Caso o componente estiver no modo AutoUpload, o arquivo também será removido da lista.
  stopUpload(file) {
    this.uploadService.stopRequestByFile(file, () => {
      if (this.autoUpload) {
        this.removeFile(file);
      } else {
        this.stopUploadHandler(file);
      }
      this.cd.markForCheck();
    });
  }
  trackByFn(index, file) {
    return file.uid;
  }
  // Envia os arquivos passados por parâmetro, exceto os que já foram enviados ao serviço.
  uploadFiles(files) {
    const filesFiltered = files.filter((file) => file.status !== PoUploadStatus.Uploaded);
    this.uploadService.upload(this.url, filesFiltered, this.headers, this.onUpload, (file, percent) => {
      this.uploadingHandler(file, percent);
    }, (file, eventResponse) => {
      this.responseHandler(file, PoUploadStatus.Uploaded);
      this.onSuccess.emit(eventResponse);
    }, (file, eventError) => {
      this.responseHandler(file, PoUploadStatus.Error);
      this.onError.emit(eventError);
    });
  }
  customClick(file) {
    if (this.customAction) {
      this.customActionClick.emit(file);
    }
  }
  cleanInputValue() {
    this.calledByCleanInputValue = true;
    this.inputFile.nativeElement.value = "";
    this.cd.detectChanges();
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  isUploadButtonFocused() {
    return document.activeElement === this.uploadButton.buttonElement.nativeElement;
  }
  // função disparada na resposta do sucesso ou error
  responseHandler(file, status) {
    file.status = status;
    file.percent = 100;
    this.cd.markForCheck();
  }
  // método responsável por setar os argumentos do i18nPipe de acordo com a restrição.
  setPipeArguments(literalAttributes, literalArguments) {
    const pipeArguments = this.i18nPipe.transform(this.literals[literalAttributes], literalArguments);
    this.notification.information(pipeArguments);
  }
  // Função disparada ao parar um envio de arquivo.
  stopUploadHandler(file) {
    file.status = PoUploadStatus.None;
    file.percent = 0;
    this.cd.markForCheck();
  }
  updateFiles(files) {
    this.currentFiles = this.parseFiles(files);
    this.updateModel([...this.currentFiles]);
    if (this.autoUpload) {
      this.uploadFiles(this.currentFiles);
    }
  }
  // Atualiza o ngModel para os arquivos passados por parâmetro.
  updateModel(files) {
    const modelFiles = this.mapCleanUploadFiles(files);
    this.onModelChange ? this.onModelChange(modelFiles) : this.ngModelChange.emit(modelFiles);
  }
  // Função disparada enquanto o arquivo está sendo enviado ao serviço.
  uploadingHandler(file, percent) {
    file.status = PoUploadStatus.Uploading;
    file.percent = percent;
    this.cd.markForCheck();
  }
  // retorna os objetos do array sem as propriedades: percent e displayName
  mapCleanUploadFiles(files) {
    const mapedByUploadFile = (progressFile) => {
      const _a = progressFile, {
        percent,
        displayName
      } = _a, uploadFile = __objRest(_a, [
        "percent",
        "displayName"
      ]);
      return uploadFile;
    };
    return files.map(mapedByUploadFile);
  }
  static ɵfac = function PoUploadComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoUploadComponent)(ɵɵdirectiveInject(PoUploadService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoI18nPipe), ɵɵdirectiveInject(PoNotificationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoUploadComponent,
    selectors: [["po-upload"]],
    viewQuery: function PoUploadComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$J, 7, ElementRef);
        ɵɵviewQuery(PoUploadDragDropComponent, 5);
        ɵɵviewQuery(_c1$h, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputFile = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poUploadDragDropComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.uploadButton = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoI18nPipe, PoUploadService, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoUploadComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoUploadComponent),
      multi: true
    }]), ɵɵInheritDefinitionFeature],
    decls: 11,
    vars: 23,
    consts: [["inputFile", ""], ["uploadButton", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [1, "po-upload"], ["type", "file", 1, "po-upload-input", 3, "change", "accept", "id", "disabled", "multiple", "required"], [3, "p-directory-compatible", "p-disabled", "p-drag-drop-height", "p-literals", "p-file-change", "p-select-files", 4, "ngIf"], ["class", "po-upload-button", "for", "file", 3, "p-disabled", "p-label", "p-blur", "p-click", "keydown", 4, "ngIf"], ["class", "po-upload-file-restrictions", 3, "ngClass", "p-allowed-extensions", "p-max-files", "p-max-file-size", "p-min-file-size", 4, "ngIf"], ["class", "po-upload-progress-container", 4, "ngIf"], ["class", "po-upload-send-button", "p-kind", "primary", 3, "po-mt-3", "p-disabled", "p-label", "p-click", 4, "ngIf"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-show-additional-help", "p-show-additional-help-icon"], [3, "p-file-change", "p-select-files", "p-directory-compatible", "p-disabled", "p-drag-drop-height", "p-literals"], ["for", "file", 1, "po-upload-button", 3, "p-blur", "p-click", "keydown", "p-disabled", "p-label"], [1, "po-upload-file-restrictions", 3, "ngClass", "p-allowed-extensions", "p-max-files", "p-max-file-size", "p-min-file-size"], [1, "po-upload-progress-container"], [3, "p-height", "p-no-border", "p-no-padding"], [3, "ngClass"], [3, "p-disabled-cancel", "p-info", "p-info-icon", "p-status", "p-text", "p-value", "p-custom-action", "p-custom-action-click", "p-cancel", "p-retry", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-custom-action-click", "p-cancel", "p-retry", "p-disabled-cancel", "p-info", "p-info-icon", "p-status", "p-text", "p-value", "p-custom-action"], ["p-kind", "primary", 1, "po-upload-send-button", 3, "p-click", "p-disabled", "p-label"]],
    template: function PoUploadComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 2)(1, "div", 3)(2, "div", 4)(3, "input", 5, 0);
        ɵɵlistener("change", function PoUploadComponent_Template_input_change_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFileChange($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(5, PoUploadComponent_po_upload_drag_drop_5_Template, 1, 4, "po-upload-drag-drop", 6)(6, PoUploadComponent_po_button_6_Template, 2, 2, "po-button", 7)(7, PoUploadComponent_po_upload_file_restrictions_7_Template, 1, 7, "po-upload-file-restrictions", 8)(8, PoUploadComponent_div_8_Template, 4, 8, "div", 9)(9, PoUploadComponent_po_button_9_Template, 1, 4, "po-button", 10);
        ɵɵelementEnd()();
        ɵɵelementStart(10, "po-field-container-bottom", 11);
        ɵɵlistener("p-additional-help", function PoUploadComponent_Template_po_field_container_bottom_p_additional_help_10_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.emitAdditionalHelp());
        });
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.isDisabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(3);
        ɵɵproperty("accept", ctx.allowedExtensions)("id", ctx.id)("disabled", ctx.isDisabled)("multiple", ctx.isMultiple)("required", ctx.required);
        ɵɵattribute("name", ctx.name);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.displayDragDrop);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.hideSelectButton && !ctx.displayDragDrop);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.fileRestrictions && !ctx.hideRestrictionsInfo);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.currentFiles && ctx.currentFiles.length);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.displaySendButton);
        ɵɵadvance();
        ɵɵproperty("p-additional-help-tooltip", ctx.getAdditionalHelpTooltip())("p-append-in-body", ctx.appendBox)("p-help", ctx.help)("p-disabled", ctx.disabled)("p-show-additional-help", ctx.displayAdditionalHelp)("p-show-additional-help-icon", ctx.showAdditionalHelpIcon());
      }
    },
    dependencies: [NgClass, NgForOf, NgIf, PoButtonComponent, PoContainerComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoProgressComponent, PoUploadDragDropComponent, PoUploadFileRestrictionsComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadComponent, [{
    type: Component,
    args: [{
      selector: "po-upload",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [PoI18nPipe, PoUploadService, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoUploadComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoUploadComponent),
        multi: true
      }],
      standalone: false,
      template: `<po-field-container
  [p-disabled]="isDisabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div class="po-upload">
      <input
        #inputFile
        class="po-upload-input"
        type="file"
        [accept]="allowedExtensions"
        [attr.name]="name"
        [id]="id"
        [disabled]="isDisabled"
        [multiple]="isMultiple"
        [required]="required"
        (change)="onFileChange($event)"
      />

      <po-upload-drag-drop
        *ngIf="displayDragDrop"
        [p-directory-compatible]="canHandleDirectory"
        [p-disabled]="isDisabled"
        [p-drag-drop-height]="dragDropHeight"
        [p-literals]="literals"
        (p-file-change)="onFileChangeDragDrop($event)"
        (p-select-files)="selectFiles()"
      >
      </po-upload-drag-drop>

      <po-button
        *ngIf="!hideSelectButton && !displayDragDrop"
        #uploadButton
        class="po-upload-button"
        for="file"
        (p-blur)="onBlur()"
        [p-disabled]="isDisabled"
        [p-label]="selectFileButtonLabel"
        (p-click)="selectFiles()"
        (keydown)="onKeyDown($event)"
      >
      </po-button>

      <po-upload-file-restrictions
        *ngIf="fileRestrictions && !hideRestrictionsInfo"
        class="po-upload-file-restrictions"
        [ngClass]="{ 'po-upload-file-restrictions-drag-drop': displayDragDrop }"
        [p-allowed-extensions]="fileRestrictions?.allowedExtensions"
        [p-max-files]="maxFiles"
        [p-max-file-size]="fileRestrictions?.maxFileSize"
        [p-min-file-size]="fileRestrictions?.minFileSize"
      >
      </po-upload-file-restrictions>

      <div *ngIf="currentFiles && currentFiles.length" class="po-upload-progress-container">
        <po-container
          [p-height]="hasMoreThanFourItems ? 280 : 'auto'"
          [p-no-border]="!hasMoreThanFourItems"
          [p-no-padding]="!hasMoreThanFourItems"
        >
          <div [ngClass]="{ 'po-upload-progress-container-area po-pt-2 po-pl-1': hasMoreThanFourItems }">
            <po-progress
              *ngFor="let file of currentFiles; trackBy: trackByFn"
              [p-disabled-cancel]="disabledRemoveFile"
              [p-info]="infoByUploadStatus[file.status]?.text(file.percent)"
              [p-info-icon]="infoByUploadStatus[file.status]?.icon"
              [p-status]="progressStatusByFileStatus[file.status]"
              [p-text]="file.displayName"
              [p-value]="file.percent"
              [p-custom-action]="customAction"
              (p-custom-action-click)="customClick(file)"
              (p-cancel)="cancel(file)"
              (p-retry)="uploadFiles([file])"
            >
            </po-progress>
          </div>
        </po-container>
      </div>

      <po-button
        *ngIf="displaySendButton"
        class="po-upload-send-button"
        [class.po-mt-3]="hasMoreThanFourItems"
        p-kind="primary"
        [p-disabled]="hasAnyFileUploading(currentFiles)"
        [p-label]="literals.startSending"
        (p-click)="uploadFiles(currentFiles)"
      ></po-button>
    </div>
  </div>
  <po-field-container-bottom
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: PoUploadService
  }, {
    type: Renderer2
  }, {
    type: PoI18nPipe
  }, {
    type: PoNotificationService
  }, {
    type: ChangeDetectorRef
  }, {
    type: PoLanguageService
  }], {
    inputFile: [{
      type: ViewChild,
      args: ["inputFile", {
        read: ElementRef,
        static: true
      }]
    }],
    poUploadDragDropComponent: [{
      type: ViewChild,
      args: [PoUploadDragDropComponent]
    }],
    uploadButton: [{
      type: ViewChild,
      args: ["uploadButton"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUploadComponent, {
    className: "PoUploadComponent",
    filePath: "lib/components/po-field/po-upload/po-upload.component.ts",
    lineNumber: 76
  });
})();
function PoUrlComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵelement(1, "po-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMapInterpolate1("po-field-icon ", ctx_r1.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
    ɵɵclassProp("po-field-icon-disabled", ctx_r1.disabled);
    ɵɵproperty("p-icon", ctx_r1.icon);
  }
}
function PoUrlComponent_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 10);
    ɵɵlistener("p-change-event", function PoUrlComponent_po_clean_6_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.disabled ? "po-icon-input-disabled" : "po-icon-input");
    ɵɵproperty("p-element-ref", ctx_r1.inputEl);
  }
}
function PoUrlComponent_po_field_container_bottom_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 11);
    ɵɵlistener("p-additional-help", function PoUrlComponent_po_field_container_bottom_7_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitAdditionalHelp());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r1.getAdditionalHelpTooltip())("p-append-in-body", ctx_r1.appendBox)("p-help", ctx_r1.help)("p-disabled", ctx_r1.disabled)("p-error-pattern", ctx_r1.getErrorPattern())("p-error-limit", ctx_r1.errorLimit)("p-show-additional-help", ctx_r1.displayAdditionalHelp)("p-show-additional-help-icon", ctx_r1.showAdditionalHelpIcon());
  }
}
var PoUrlComponent = class _PoUrlComponent extends PoInputGeneric {
  id = `po-url[${uuid()}]`;
  icon = "ICON_WORLD";
  type = "url";
  pattern = "^((https|http):\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-A-Za-z\\d%_.~+]*)*(\\?[;&A-Za-z\\d%_.~+=-]*)?(\\#[-A-Za-z\\d_]*)?$";
  mask = "";
  listener = this.validateClassesForPattern.bind(this);
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
    this.maxlength = 254;
  }
  ngAfterViewInit() {
    setTimeout(() => {
      if (!this.onChangePropagate) {
        this.inputEl.nativeElement.addEventListener("keyup", this.listener);
      }
    });
    super.ngAfterViewInit();
  }
  ngOnDestroy() {
    if (!this.onChangePropagate) {
      this.inputEl.nativeElement.removeEventListener("keyup", this.listener);
    }
  }
  extraValidation(c) {
    return null;
  }
  static ɵfac = function PoUrlComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoUrlComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoUrlComponent,
    selectors: [["po-url"]],
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoUrlComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoUrlComponent),
      multi: true
    }]), ɵɵInheritDefinitionFeature],
    decls: 8,
    vars: 21,
    consts: [["inp", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["class", "po-field-icon-container-left", 4, "ngIf"], [1, "po-input", 3, "blur", "click", "focus", "input", "keydown", "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "type"], [1, "po-field-icon-container-right"], [3, "class", "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [1, "po-field-icon-container-left"], [3, "p-icon"], [3, "p-change-event", "p-element-ref"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon"]],
    template: function PoUrlComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2);
        ɵɵtemplate(2, PoUrlComponent_div_2_Template, 2, 6, "div", 3);
        ɵɵelementStart(3, "input", 4, 0);
        ɵɵlistener("blur", function PoUrlComponent_Template_input_blur_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnBlur($event));
        })("click", function PoUrlComponent_Template_input_click_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnClick($event));
        })("focus", function PoUrlComponent_Template_input_focus_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnFocus($event));
        })("input", function PoUrlComponent_Template_input_input_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnInput($event));
        })("keydown", function PoUrlComponent_Template_input_keydown_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(5, "div", 5);
        ɵɵtemplate(6, PoUrlComponent_po_clean_6_Template, 1, 4, "po-clean", 6);
        ɵɵelementEnd()();
        ɵɵtemplate(7, PoUrlComponent_po_field_container_bottom_7_Template, 1, 8, "po-field-container-bottom", 7);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.icon);
        ɵɵadvance();
        ɵɵclassProp("po-input-icon-left", ctx.icon)("po-input-icon-right", ctx.clean);
        ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("type", ctx.type);
        ɵɵattribute("name", ctx.name);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.readonly);
      }
    },
    dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUrlComponent, [{
    type: Component,
    args: [{
      selector: "po-url",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoUrlComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoUrlComponent),
        multi: true
      }],
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div *ngIf="icon" class="po-field-icon-container-left">
      <po-icon
        class="po-field-icon {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        [class.po-field-icon-disabled]="disabled"
        [p-icon]="icon"
      ></po-icon>
    </div>

    <input
      #inp
      class="po-input"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-icon-left]="icon"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [type]="type"
      (blur)="eventOnBlur($event)"
      (click)="eventOnClick($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
      (keydown)="onKeyDown($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="{{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom
    *ngIf="!readonly"
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
    [p-error-limit]="errorLimit"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUrlComponent, {
    className: "PoUrlComponent",
    filePath: "lib/components/po-field/po-url/po-url.component.ts",
    lineNumber: 58
  });
})();
var _c0$I = ["modal"];
var _c1$g = ["modalImageForm"];
var _c2$6 = ["upload"];
var uploadRestrictions = [".apng", ".bmp", ".gif", ".ico", ".jpeg", ".jpg", ".png", ".svg"];
var PoRichTextImageModalComponent = class _PoRichTextImageModalComponent {
  languageService;
  modal;
  modalImageForm;
  upload;
  command = new EventEmitter();
  savedCursorPosition;
  selection = document.getSelection();
  uploadModel;
  uploadRestrictions = {
    allowedExtensions: uploadRestrictions
  };
  urlImage;
  literals;
  modalCancelAction;
  modalConfirmAction;
  get isUploadValid() {
    return !!(this.uploadModel && this.uploadModel.length);
  }
  get isUrlValid() {
    return !!this.urlImage && this.modalImageForm && this.modalImageForm.valid;
  }
  constructor(languageService) {
    this.languageService = languageService;
    this.literals = __spreadValues({}, poRichTextLiteralsDefault[this.languageService.getShortLanguage()]);
    this.modalCancelAction = {
      label: this.literals.cancel,
      action: () => {
        this.modal.close();
        this.command.emit();
        this.retrieveCursorPosition();
        this.cleanUpFields();
      }
    };
    this.modalConfirmAction = {
      label: this.literals.insert,
      disabled: false,
      action: () => this.insertElementRef()
    };
  }
  openModal() {
    this.saveCursorPosition();
    this.modal.open();
  }
  cleanUpFields() {
    this.urlImage = void 0;
    this.uploadModel = void 0;
  }
  convertToBase64() {
    return __async(this, null, function* () {
      if (this.isUploadValid) {
        const uploadImage = this.uploadModel[0].rawFile;
        return yield convertImageToBase64(uploadImage);
      }
    });
  }
  emitCommand(value) {
    let command;
    if (value) {
      command = "insertImage";
      this.command.emit({
        command,
        value
      });
    }
  }
  insertElementRef() {
    return __async(this, null, function* () {
      let uploadImage;
      if (!this.urlImage) {
        uploadImage = yield this.convertToBase64();
      }
      this.retrieveCursorPosition();
      this.modal.close();
      if (this.isUrlValid || this.isUploadValid) {
        this.emitCommand(this.urlImage || uploadImage);
      }
      this.cleanUpFields();
    });
  }
  retrieveCursorPosition() {
    this.selection.collapse(this.savedCursorPosition[0], this.savedCursorPosition[1]);
  }
  saveCursorPosition() {
    this.savedCursorPosition = [this.selection.focusNode, this.selection.focusOffset];
  }
  static ɵfac = function PoRichTextImageModalComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRichTextImageModalComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoRichTextImageModalComponent,
    selectors: [["po-rich-text-image-modal"]],
    viewQuery: function PoRichTextImageModalComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$I, 7);
        ɵɵviewQuery(_c1$g, 5);
        ɵɵviewQuery(_c2$6, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modal = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalImageForm = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.upload = _t.first);
      }
    },
    outputs: {
      command: "p-command"
    },
    standalone: false,
    decls: 9,
    vars: 10,
    consts: [["modal", ""], ["modalImageForm", "ngForm"], ["upload", ""], ["p-hide-close", "", 3, "p-primary-action", "p-secondary-action", "p-title"], [1, "po-row"], ["name", "upload", "p-drag-drop-height", "160", "p-hide-restrictions-info", "", "p-hide-send-button", "", "p-url", "x", 1, "po-md-12", 3, "ngModelChange", "ngModel", "p-drag-drop", "p-disabled", "p-restrictions"], ["name", "url", 1, "po-md-12", "po-mt-3", 3, "ngModelChange", "ngModel", "p-label", "p-disabled"]],
    template: function PoRichTextImageModalComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-modal", 3, 0)(2, "form", null, 1)(4, "div", 4)(5, "po-upload", 5, 2);
        ɵɵtwoWayListener("ngModelChange", function PoRichTextImageModalComponent_Template_po_upload_ngModelChange_5_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.uploadModel, $event) || (ctx.uploadModel = $event);
          return ɵɵresetView($event);
        });
        ɵɵelementEnd()();
        ɵɵelementStart(7, "div", 4)(8, "po-url", 6);
        ɵɵtwoWayListener("ngModelChange", function PoRichTextImageModalComponent_Template_po_url_ngModelChange_8_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.urlImage, $event) || (ctx.urlImage = $event);
          return ɵɵresetView($event);
        });
        ɵɵelementEnd()()()();
      }
      if (rf & 2) {
        const modal_r2 = ɵɵreference(1);
        ɵɵproperty("p-primary-action", ctx.modalConfirmAction)("p-secondary-action", ctx.modalCancelAction)("p-title", ctx.literals.insertImage);
        ɵɵadvance(5);
        ɵɵtwoWayProperty("ngModel", ctx.uploadModel);
        ɵɵproperty("p-drag-drop", !modal_r2.isHidden)("p-disabled", ctx.isUrlValid)("p-restrictions", ctx.uploadRestrictions);
        ɵɵadvance(3);
        ɵɵtwoWayProperty("ngModel", ctx.urlImage);
        ɵɵproperty("p-label", ctx.literals.urlImage)("p-disabled", ctx.isUploadValid);
      }
    },
    dependencies: [ɵNgNoValidate, NgControlStatus, NgControlStatusGroup, NgModel, NgForm, PoModalComponent, PoUploadComponent, PoUrlComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextImageModalComponent, [{
    type: Component,
    args: [{
      selector: "po-rich-text-image-modal",
      standalone: false,
      template: '<po-modal\n  #modal\n  p-hide-close\n  [p-primary-action]="modalConfirmAction"\n  [p-secondary-action]="modalCancelAction"\n  [p-title]="literals.insertImage"\n>\n  <form #modalImageForm="ngForm">\n    <div class="po-row">\n      <!-- po-upload desabilita o drag drop caso não tenha valor atribuido para a propriedade p-url -->\n      <po-upload\n        #upload\n        class="po-md-12"\n        name="upload"\n        [(ngModel)]="uploadModel"\n        p-drag-drop-height="160"\n        p-hide-restrictions-info\n        p-hide-send-button\n        p-url="x"\n        [p-drag-drop]="!modal.isHidden"\n        [p-disabled]="isUrlValid"\n        [p-restrictions]="uploadRestrictions"\n      >\n      </po-upload>\n    </div>\n\n    <div class="po-row">\n      <po-url\n        class="po-md-12 po-mt-3"\n        name="url"\n        [(ngModel)]="urlImage"\n        [p-label]="literals.urlImage"\n        [p-disabled]="isUploadValid"\n      >\n      </po-url>\n    </div>\n  </form>\n</po-modal>\n'
    }]
  }], () => [{
    type: PoLanguageService
  }], {
    modal: [{
      type: ViewChild,
      args: ["modal", {
        static: true
      }]
    }],
    modalImageForm: [{
      type: ViewChild,
      args: ["modalImageForm"]
    }],
    upload: [{
      type: ViewChild,
      args: ["upload", {
        static: true
      }]
    }],
    command: [{
      type: Output,
      args: ["p-command"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRichTextImageModalComponent, {
    className: "PoRichTextImageModalComponent",
    filePath: "lib/components/po-field/po-rich-text/po-rich-text-image-modal/po-rich-text-image-modal.component.ts",
    lineNumber: 19
  });
})();
var _c0$H = ["modal"];
var _c1$f = ["modalLinkForm"];
var PoRichTextLinkModalComponent = class _PoRichTextLinkModalComponent {
  languageService;
  modal;
  modalLinkForm;
  command = new EventEmitter();
  linkEditing = new EventEmitter();
  savedCursorPosition;
  selection = document.getSelection();
  urlLink;
  urlLinkText;
  literals;
  modalCancelAction;
  modalConfirmAction;
  isLinkEditing;
  isSelectedLink;
  linkElement;
  savedSelection;
  constructor(languageService) {
    this.languageService = languageService;
    this.literals = __spreadValues({}, poRichTextLiteralsDefault[this.languageService?.getShortLanguage()]);
  }
  ngOnInit() {
    this.setModalCancelAction();
    this.setModalConfirmAction();
  }
  linkConfirmAction() {
    return this.isLinkEditing ? this.literals.editLink : this.literals.insertLink;
  }
  formModelValidate() {
    return this.modalConfirmAction.disabled = this.modalLinkForm?.invalid;
  }
  openModal(selectedLinkElement) {
    this.saveCursorPosition();
    this.prepareModalForLink(selectedLinkElement);
    this.modalConfirmAction.label = this.linkConfirmAction();
    this.modal.open();
  }
  selectedLink(linkElement) {
    this.isSelectedLink = !!linkElement;
    this.linkElement = linkElement;
  }
  checkIfIsEmpty(urlLink, urlLinkText) {
    return urlLinkText === void 0 || urlLinkText.trim() === "" ? urlLink : urlLinkText;
  }
  cleanUpFields() {
    this.urlLink = void 0;
    this.urlLinkText = void 0;
    this.isLinkEditing = false;
    this.isSelectedLink = false;
    this.linkElement = void 0;
  }
  formReset(control) {
    control.markAsPristine();
    control.markAsUntouched();
    control.updateValueAndValidity();
  }
  prepareModalForLink(selectedLinkElement) {
    this.saveSelectionText();
    if (this.modalLinkForm) {
      this.formReset(this.modalLinkForm.control);
    }
    setTimeout(() => {
      this.formModelValidate();
    });
    this.selectedLink(selectedLinkElement);
    if (this.isSelectedLink) {
      this.isLinkEditing = true;
      this.setLinkEditableForModal();
    }
    this.linkEditing.emit(this.isLinkEditing);
  }
  restoreSelection() {
    if (this.savedSelection) {
      if (this.selection) {
        this.selection.removeAllRanges();
        this.selection.addRange(this.savedSelection);
      }
      return true;
    } else {
      return false;
    }
  }
  retrieveCursorPosition() {
    this.selection.collapse(this.savedCursorPosition[0], this.savedCursorPosition[1]);
  }
  saveCursorPosition() {
    this.savedCursorPosition = [this.selection.focusNode, this.selection.focusOffset];
  }
  saveSelectionText() {
    if (this.selection.anchorNode !== null) {
      this.savedSelection = this.selection.getRangeAt(0);
      this.urlLinkText = this.selection.toString();
    } else {
      return null;
    }
  }
  setLinkEditableForModal() {
    this.urlLinkText = this.linkElement.innerText;
    this.urlLink = this.linkElement.getAttribute("href");
  }
  setModalCancelAction() {
    this.modalCancelAction = {
      label: this.literals.cancel,
      action: () => {
        this.modal.close();
        this.command.emit();
        this.retrieveCursorPosition();
        this.cleanUpFields();
      }
    };
  }
  setModalConfirmAction() {
    this.modalConfirmAction = {
      label: this.linkConfirmAction(),
      disabled: true,
      action: () => this.isLinkEditing ? this.toEditLink() : this.toInsertLink(this.urlLink, this.urlLinkText)
    };
  }
  toEditLink() {
    if (isIE()) {
      this.linkElement.parentNode.removeChild(this.linkElement);
    } else {
      this.linkElement.remove();
    }
    this.toInsertLink(this.urlLink, this.urlLinkText);
  }
  toInsertLink(urlLink, urlLinkText) {
    this.modal.close();
    this.restoreSelection();
    const urlLinkTextValue = this.checkIfIsEmpty(urlLink, urlLinkText);
    const urlAsExternalLink = isExternalLink(urlLink) ? urlLink : `http://${urlLink}`;
    const command = "InsertHTML";
    const value = {
      urlLink: urlAsExternalLink,
      urlLinkText: urlLinkTextValue
    };
    this.command.emit({
      command,
      value
    });
    this.cleanUpFields();
  }
  static ɵfac = function PoRichTextLinkModalComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRichTextLinkModalComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoRichTextLinkModalComponent,
    selectors: [["po-rich-text-link-modal"]],
    viewQuery: function PoRichTextLinkModalComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$H, 7);
        ɵɵviewQuery(_c1$f, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modal = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalLinkForm = _t.first);
      }
    },
    outputs: {
      command: "p-command",
      linkEditing: "p-link-editing"
    },
    standalone: false,
    decls: 7,
    vars: 9,
    consts: [["modal", ""], ["modalLinkForm", "ngForm"], ["p-hide-close", "", 3, "p-primary-action", "p-secondary-action", "p-title"], [1, "po-row"], ["name", "urlLinkText", "p-optional", "", 1, "po-md-12", "po-mb-2", 3, "ngModelChange", "ngModel", "p-label", "p-placeholder"], ["name", "urlLink", "p-label", "Link", "p-required", "", 1, "po-md-12", 3, "ngModelChange", "p-change-model", "ngModel", "p-help", "p-placeholder"]],
    template: function PoRichTextLinkModalComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-modal", 2, 0)(2, "form", null, 1)(4, "div", 3)(5, "po-input", 4);
        ɵɵtwoWayListener("ngModelChange", function PoRichTextLinkModalComponent_Template_po_input_ngModelChange_5_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.urlLinkText, $event) || (ctx.urlLinkText = $event);
          return ɵɵresetView($event);
        });
        ɵɵelementEnd();
        ɵɵelementStart(6, "po-url", 5);
        ɵɵtwoWayListener("ngModelChange", function PoRichTextLinkModalComponent_Template_po_url_ngModelChange_6_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.urlLink, $event) || (ctx.urlLink = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("p-change-model", function PoRichTextLinkModalComponent_Template_po_url_p_change_model_6_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.formModelValidate());
        });
        ɵɵelementEnd()()()();
      }
      if (rf & 2) {
        ɵɵproperty("p-primary-action", ctx.modalConfirmAction)("p-secondary-action", ctx.modalCancelAction)("p-title", ctx.linkConfirmAction());
        ɵɵadvance(5);
        ɵɵtwoWayProperty("ngModel", ctx.urlLinkText);
        ɵɵproperty("p-label", ctx.literals.linkTextLabel)("p-placeholder", ctx.literals.linkTextLabel);
        ɵɵadvance();
        ɵɵtwoWayProperty("ngModel", ctx.urlLink);
        ɵɵproperty("p-help", ctx.literals.linkUrlTextHelper)("p-placeholder", ctx.literals.linkUrlTextPlaceholder);
      }
    },
    dependencies: [ɵNgNoValidate, NgControlStatus, NgControlStatusGroup, NgModel, NgForm, PoModalComponent, PoInputComponent, PoUrlComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextLinkModalComponent, [{
    type: Component,
    args: [{
      selector: "po-rich-text-link-modal",
      standalone: false,
      template: '<po-modal\n  #modal\n  p-hide-close\n  [p-primary-action]="modalConfirmAction"\n  [p-secondary-action]="modalCancelAction"\n  [p-title]="linkConfirmAction()"\n>\n  <form #modalLinkForm="ngForm">\n    <div class="po-row">\n      <po-input\n        class="po-md-12 po-mb-2"\n        name="urlLinkText"\n        [(ngModel)]="urlLinkText"\n        p-optional\n        [p-label]="literals.linkTextLabel"\n        [p-placeholder]="literals.linkTextLabel"\n      >\n      </po-input>\n\n      <po-url\n        class="po-md-12"\n        name="urlLink"\n        [(ngModel)]="urlLink"\n        p-label="Link"\n        p-required\n        [p-help]="literals.linkUrlTextHelper"\n        [p-placeholder]="literals.linkUrlTextPlaceholder"\n        (p-change-model)="formModelValidate()"\n      >\n      </po-url>\n    </div>\n  </form>\n</po-modal>\n'
    }]
  }], () => [{
    type: PoLanguageService
  }], {
    modal: [{
      type: ViewChild,
      args: ["modal", {
        static: true
      }]
    }],
    modalLinkForm: [{
      type: ViewChild,
      args: ["modalLinkForm"]
    }],
    command: [{
      type: Output,
      args: ["p-command"]
    }],
    linkEditing: [{
      type: Output,
      args: ["p-link-editing"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRichTextLinkModalComponent, {
    className: "PoRichTextLinkModalComponent",
    filePath: "lib/components/po-field/po-rich-text/po-rich-text-link-modal/po-rich-text-link-modal.component.ts",
    lineNumber: 15
  });
})();
var _c0$G = ["colorPickerInput"];
var _c1$e = ["toolbarElement"];
function PoRichTextToolbarComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵelement(1, "po-button-group", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-buttons", ctx_r1.formatButtons);
  }
}
function PoRichTextToolbarComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 15)(1, "div", 16)(2, "button", 17)(3, "input", 18, 3);
    ɵɵlistener("change", function PoRichTextToolbarComponent_div_3_Template_input_change_3_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changeTextColor($event.target.value));
    });
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r1.readonly)("p-tooltip", ctx_r1.literals.textColor);
    ɵɵattribute("aria-label", ctx_r1.literals.textColor);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.readonly);
    ɵɵattribute("aria-label", ctx_r1.literals.textColor);
  }
}
function PoRichTextToolbarComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵelement(1, "po-button-group", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-buttons", ctx_r1.alignButtons);
  }
}
function PoRichTextToolbarComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21);
    ɵɵelement(1, "po-button-group", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-buttons", ctx_r1.listButtons);
  }
}
function PoRichTextToolbarComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 22);
    ɵɵelement(1, "po-button-group", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-buttons", ctx_r1.linkButtons);
  }
}
function PoRichTextToolbarComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 24);
    ɵɵelement(1, "po-button-group", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-buttons", ctx_r1.mediaButtons);
  }
}
var poRichTextDefaultColor = "#000000";
var PoRichTextToolbarComponent = class _PoRichTextToolbarComponent {
  languageService;
  colorPickerInput;
  toolbarElement;
  richTextImageModal;
  richTextLinkModal;
  command = new EventEmitter();
  modal = new EventEmitter();
  linkEditing = new EventEmitter();
  literals;
  alignButtons;
  formatButtons;
  listButtons;
  linkButtons;
  mediaButtons;
  _readonly;
  selectedLinkElement;
  _hideToolbarActions = [];
  formatToolbarAction = PoRichTextToolbarActions.Format;
  colorToolbarAction = PoRichTextToolbarActions.Color;
  alignToolbarAction = PoRichTextToolbarActions.Align;
  listToolbarAction = PoRichTextToolbarActions.List;
  linkToolbarAction = PoRichTextToolbarActions.Link;
  mediaToolbarAction = PoRichTextToolbarActions.Media;
  /**
   * @optional
   *
   * @description
   *
   * Define as ações da barra de ferramentas do `PoRichTextComponent` que serão ocultadas.
   * Aceita um único valor do tipo `PoRichTextToolbarActions` ou uma lista de valores.
   *
   * > Esta propriedade sobrepõe a configuração da propriedade `p-disabled-text-align` quando for passada como `false`, caso sejam definidas simultaneamente.
   *
   * @default `[]`
   *
   * @example
   * ```
   * // Oculta apenas o seletor de cores
   * component.hideToolbarActions = PoRichTextToolbarActions.Color;
   *
   * // Oculta as opções de alinhamento e link
   * component.hideToolbarActions = [PoRichTextToolbarActions.Align, PoRichTextToolbarActions.Link];
   * ```
   */
  set hideToolbarActions(actions) {
    this._hideToolbarActions = Array.isArray(actions) ? [...actions] : [actions];
  }
  get hideToolbarActions() {
    return this._hideToolbarActions;
  }
  set readonly(value) {
    this._readonly = value;
    this.toggleDisableButtons(this._readonly);
  }
  get readonly() {
    return this._readonly;
  }
  get isInternetExplorer() {
    return isIE();
  }
  constructor(languageService) {
    this.languageService = languageService;
    this.literals = __spreadValues({}, poRichTextLiteralsDefault[this.languageService?.getShortLanguage()]);
    this.alignButtons = [{
      command: "justifyleft",
      icon: "ICON_ALIGN_LEFT",
      tooltip: this.literals.left,
      action: this.emitAlignCommand.bind(this, "justifyleft"),
      selected: true
    }, {
      command: "justifycenter",
      icon: "ICON_ALIGN_CENTER",
      tooltip: this.literals.center,
      action: this.emitAlignCommand.bind(this, "justifycenter")
    }, {
      command: "justifyright",
      icon: "ICON_ALIGN_RIGHT",
      tooltip: this.literals.right,
      action: this.emitAlignCommand.bind(this, "justifyright")
    }, {
      command: "justifyfull",
      icon: "ICON_ALIGN_JUSTIFY",
      tooltip: this.literals.justify,
      action: this.emitAlignCommand.bind(this, "justifyfull")
    }];
    this.formatButtons = [{
      command: "bold",
      icon: "ICON_TEXT_BOLD",
      tooltip: this.literals.bold,
      action: this.emitCommand.bind(this, "bold")
    }, {
      command: "italic",
      icon: "ICON_TEXT_ITALIC",
      tooltip: this.literals.italic,
      action: this.emitCommand.bind(this, "italic")
    }, {
      command: "underline",
      icon: "ICON_TEXT_UNDERLINE",
      tooltip: this.literals.underline,
      action: this.emitCommand.bind(this, "underline")
    }];
    this.listButtons = [{
      command: "insertUnorderedList",
      icon: "ICON_LIST",
      tooltip: this.literals.unorderedList,
      action: this.emitCommand.bind(this, "insertUnorderedList")
    }];
    this.mediaButtons = [{
      tooltip: this.literals.insertImage,
      icon: "ICON_PICTURE",
      action: () => this.richTextImageModal.openModal()
    }];
    this.linkButtons = [{
      command: "Createlink",
      icon: "ICON_LINK",
      tooltip: `${this.literals.insertLink} (Ctrl + K)`,
      action: () => this.richTextLinkModal.openModal(this.selectedLinkElement)
    }];
  }
  ngAfterViewInit() {
    this.removeButtonFocus();
    if (this.showColor()) {
      this.setColorInColorPicker(poRichTextDefaultColor);
    }
  }
  changeTextColor(value) {
    const command = "foreColor";
    this.command.emit({
      command,
      value
    });
  }
  emitLinkEditing(isLinkEdit) {
    this.linkEditing.emit(isLinkEdit);
  }
  selectedLink(selectedLinkElement) {
    this.selectedLinkElement = selectedLinkElement;
  }
  setButtonsStates(obj) {
    if (!this.readonly) {
      this.alignButtons.forEach((button) => button.selected = obj.commands.includes(button.command));
      this.formatButtons.forEach((button) => button.selected = obj.commands.includes(button.command));
      this.listButtons[0].selected = obj.commands.includes(this.listButtons[0].command);
      this.linkButtons[0].selected = obj.commands.includes(this.linkButtons[0].command);
      this.setColorInColorPicker(obj.hexColor);
    }
  }
  // Verifica se uma ação específica do toolbar está oculta
  isActionHidden(action) {
    return this.hideToolbarActions.includes(action);
  }
  showColor() {
    return !this.isInternetExplorer && !this.isActionHidden(PoRichTextToolbarActions.Color);
  }
  shortcutTrigger() {
    this.richTextLinkModal.openModal(this.selectedLinkElement);
  }
  emitCommand(command) {
    this.command.emit(command);
  }
  emitAlignCommand(command) {
    const index = this.alignButtons.findIndex((btn) => btn.command === command);
    if (!this.alignButtons[index].selected) {
      this.alignButtons[index].selected = false;
    }
    this.command.emit(command);
  }
  removeButtonFocus() {
    const buttons = this.toolbarElement.nativeElement.querySelectorAll("button");
    buttons.forEach((button) => button.setAttribute("tabindex", "-1"));
  }
  setColorInColorPicker(color) {
    this.colorPickerInput.nativeElement.value = color;
  }
  toggleDisableButtons(state2) {
    this.alignButtons.forEach((button) => button.disabled = state2);
    this.formatButtons.forEach((button) => button.disabled = state2);
    this.listButtons[0].disabled = state2;
    this.linkButtons[0].disabled = state2;
    this.mediaButtons[0].disabled = state2;
  }
  static ɵfac = function PoRichTextToolbarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRichTextToolbarComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoRichTextToolbarComponent,
    selectors: [["po-rich-text-toolbar"]],
    viewQuery: function PoRichTextToolbarComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$G, 5, ElementRef);
        ɵɵviewQuery(_c1$e, 7);
        ɵɵviewQuery(PoRichTextImageModalComponent, 7);
        ɵɵviewQuery(PoRichTextLinkModalComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.colorPickerInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toolbarElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.richTextImageModal = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.richTextLinkModal = _t.first);
      }
    },
    inputs: {
      hideToolbarActions: [0, "p-hide-toolbar-actions", "hideToolbarActions"],
      readonly: [0, "p-readonly", "readonly"]
    },
    outputs: {
      command: "p-command",
      modal: "p-modal",
      linkEditing: "p-link-editing"
    },
    standalone: false,
    decls: 12,
    vars: 6,
    consts: [["toolbarElement", ""], ["richTextImageModal", ""], ["richTextLinkModal", ""], ["colorPickerInput", ""], [1, "po-rich-text-toolbar"], ["class", "po-rich-text-toolbar-button-align", "data-rich-text-toolbar", "format", 4, "ngIf"], ["class", "po-rich-text-toolbar-button-align", "data-rich-text-toolbar", "color", 4, "ngIf"], ["class", "po-rich-text-toolbar-button-align", "data-rich-text-toolbar", "align", 4, "ngIf"], ["class", "po-rich-text-toolbar-button-align", "data-rich-text-toolbar", "list", 4, "ngIf"], ["class", "po-rich-text-toolbar-button-align", "data-rich-text-toolbar", "link", 4, "ngIf"], ["class", "po-rich-text-toolbar-button-align", "data-rich-text-toolbar", "media", 4, "ngIf"], [3, "p-command"], [3, "p-command", "p-link-editing"], ["data-rich-text-toolbar", "format", 1, "po-rich-text-toolbar-button-align"], ["p-toggle", "multiple", 3, "p-buttons"], ["data-rich-text-toolbar", "color", 1, "po-rich-text-toolbar-button-align"], [1, "po-rich-text-toolbar-color-picker-container"], ["type", "button", 1, "po-button", "po-button-default", "po-rich-text-toolbar-color-picker-button", 3, "disabled", "p-tooltip"], ["type", "color", 1, "po-rich-text-toolbar-color-picker-input", 3, "change", "disabled"], ["data-rich-text-toolbar", "align", 1, "po-rich-text-toolbar-button-align"], ["p-toggle", "single", 3, "p-buttons"], ["data-rich-text-toolbar", "list", 1, "po-rich-text-toolbar-button-align"], ["data-rich-text-toolbar", "link", 1, "po-rich-text-toolbar-button-align"], [3, "p-buttons"], ["data-rich-text-toolbar", "media", 1, "po-rich-text-toolbar-button-align"]],
    template: function PoRichTextToolbarComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 4, 0);
        ɵɵtemplate(2, PoRichTextToolbarComponent_div_2_Template, 2, 1, "div", 5)(3, PoRichTextToolbarComponent_div_3_Template, 5, 5, "div", 6)(4, PoRichTextToolbarComponent_div_4_Template, 2, 1, "div", 7)(5, PoRichTextToolbarComponent_div_5_Template, 2, 1, "div", 8)(6, PoRichTextToolbarComponent_div_6_Template, 2, 1, "div", 9)(7, PoRichTextToolbarComponent_div_7_Template, 2, 1, "div", 10);
        ɵɵelementEnd();
        ɵɵelementStart(8, "po-rich-text-image-modal", 11, 1);
        ɵɵlistener("p-command", function PoRichTextToolbarComponent_Template_po_rich_text_image_modal_p_command_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.emitCommand($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(10, "po-rich-text-link-modal", 12, 2);
        ɵɵlistener("p-command", function PoRichTextToolbarComponent_Template_po_rich_text_link_modal_p_command_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.emitCommand($event));
        })("p-link-editing", function PoRichTextToolbarComponent_Template_po_rich_text_link_modal_p_link_editing_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.emitLinkEditing($event));
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.isActionHidden(ctx.formatToolbarAction));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showColor());
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.isActionHidden(ctx.alignToolbarAction));
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.isActionHidden(ctx.listToolbarAction));
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.isActionHidden(ctx.linkToolbarAction));
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.isActionHidden(ctx.mediaToolbarAction));
      }
    },
    dependencies: [NgIf, PoButtonGroupComponent, PoTooltipDirective, PoRichTextImageModalComponent, PoRichTextLinkModalComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextToolbarComponent, [{
    type: Component,
    args: [{
      selector: "po-rich-text-toolbar",
      standalone: false,
      template: '<div class="po-rich-text-toolbar" #toolbarElement>\n  <div\n    class="po-rich-text-toolbar-button-align"\n    data-rich-text-toolbar="format"\n    *ngIf="!isActionHidden(formatToolbarAction)"\n  >\n    <po-button-group p-toggle="multiple" [p-buttons]="formatButtons"> </po-button-group>\n  </div>\n\n  <div *ngIf="showColor()" class="po-rich-text-toolbar-button-align" data-rich-text-toolbar="color">\n    <div class="po-rich-text-toolbar-color-picker-container">\n      <button\n        type="button"\n        class="po-button po-button-default po-rich-text-toolbar-color-picker-button"\n        [disabled]="readonly"\n        [p-tooltip]="literals.textColor"\n        [attr.aria-label]="literals.textColor"\n      >\n        <input\n          #colorPickerInput\n          class="po-rich-text-toolbar-color-picker-input"\n          type="color"\n          [disabled]="readonly"\n          (change)="changeTextColor($event.target.value)"\n          [attr.aria-label]="literals.textColor"\n        />\n      </button>\n    </div>\n  </div>\n\n  <div\n    class="po-rich-text-toolbar-button-align"\n    data-rich-text-toolbar="align"\n    *ngIf="!isActionHidden(alignToolbarAction)"\n  >\n    <po-button-group p-toggle="single" [p-buttons]="alignButtons"> </po-button-group>\n  </div>\n\n  <div\n    class="po-rich-text-toolbar-button-align"\n    data-rich-text-toolbar="list"\n    *ngIf="!isActionHidden(listToolbarAction)"\n  >\n    <po-button-group p-toggle="single" [p-buttons]="listButtons"> </po-button-group>\n  </div>\n\n  <div\n    class="po-rich-text-toolbar-button-align"\n    data-rich-text-toolbar="link"\n    *ngIf="!isActionHidden(linkToolbarAction)"\n  >\n    <po-button-group [p-buttons]="linkButtons"> </po-button-group>\n  </div>\n\n  <div\n    class="po-rich-text-toolbar-button-align"\n    data-rich-text-toolbar="media"\n    *ngIf="!isActionHidden(mediaToolbarAction)"\n  >\n    <po-button-group [p-buttons]="mediaButtons"> </po-button-group>\n  </div>\n</div>\n\n<po-rich-text-image-modal #richTextImageModal (p-command)="emitCommand($event)"> </po-rich-text-image-modal>\n\n<po-rich-text-link-modal\n  #richTextLinkModal\n  (p-command)="emitCommand($event)"\n  (p-link-editing)="emitLinkEditing($event)"\n>\n</po-rich-text-link-modal>\n'
    }]
  }], () => [{
    type: PoLanguageService
  }], {
    colorPickerInput: [{
      type: ViewChild,
      args: ["colorPickerInput", {
        read: ElementRef
      }]
    }],
    toolbarElement: [{
      type: ViewChild,
      args: ["toolbarElement", {
        static: true
      }]
    }],
    richTextImageModal: [{
      type: ViewChild,
      args: [PoRichTextImageModalComponent, {
        static: true
      }]
    }],
    richTextLinkModal: [{
      type: ViewChild,
      args: [PoRichTextLinkModalComponent, {
        static: true
      }]
    }],
    command: [{
      type: Output,
      args: ["p-command"]
    }],
    modal: [{
      type: Output,
      args: ["p-modal"]
    }],
    linkEditing: [{
      type: Output,
      args: ["p-link-editing"]
    }],
    hideToolbarActions: [{
      type: Input,
      args: ["p-hide-toolbar-actions"]
    }],
    readonly: [{
      type: Input,
      args: ["p-readonly"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRichTextToolbarComponent, {
    className: "PoRichTextToolbarComponent",
    filePath: "lib/components/po-field/po-rich-text/po-rich-text-toolbar/po-rich-text-toolbar.component.ts",
    lineNumber: 20
  });
})();
function PoRichTextComponent_po_rich_text_toolbar_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-rich-text-toolbar", 7, 1);
    ɵɵlistener("p-link-editing", function PoRichTextComponent_po_rich_text_toolbar_4_Template_po_rich_text_toolbar_p_link_editing_0_listener($event) {
      ɵɵrestoreView(_r2);
      ɵɵnextContext();
      const richTextBody_r3 = ɵɵreference(3);
      return ɵɵresetView(richTextBody_r3.linkEditing($event));
    })("p-command", function PoRichTextComponent_po_rich_text_toolbar_4_Template_po_rich_text_toolbar_p_command_0_listener($event) {
      ɵɵrestoreView(_r2);
      ɵɵnextContext();
      const richTextBody_r3 = ɵɵreference(3);
      return ɵɵresetView(richTextBody_r3.executeCommand($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("p-readonly", ctx_r3.readonly)("p-hide-toolbar-actions", ctx_r3.toolbarActions);
  }
}
function PoRichTextComponent_po_field_container_bottom_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 8);
    ɵɵlistener("p-additional-help", function PoRichTextComponent_po_field_container_bottom_5_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.additionalHelp.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r3.additionalHelp.observed ? null : ctx_r3.additionalHelpTooltip)("p-append-in-body", ctx_r3.appendBox)("p-help", ctx_r3.help)("p-error-limit", ctx_r3.errorLimit)("p-error-pattern", ctx_r3.errorMsg)("p-show-additional-help", ctx_r3.displayAdditionalHelp)("p-show-additional-help-icon", !!ctx_r3.additionalHelpTooltip || ctx_r3.additionalHelp.observed);
  }
}
var providers = [{
  provide: NG_VALUE_ACCESSOR,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoRichTextComponent),
  multi: true
}, {
  provide: NG_VALIDATORS,
  // eslint-disable-next-line
  useExisting: forwardRef(() => PoRichTextComponent),
  multi: true
}, {
  provide: PoRichTextService
}];
var PoRichTextComponent = class _PoRichTextComponent extends PoRichTextBaseComponent {
  element;
  bodyElement;
  richTextToolbar;
  listener = this.validateClassesForRequired.bind(this);
  modelLastUpdate;
  toolbarActions = [];
  get errorMsg() {
    return this.errorMessage !== "" && !this.value && this.required && this.invalid ? this.errorMessage : "";
  }
  constructor(element, richTextService) {
    super(richTextService);
    this.element = element;
  }
  ngOnInit() {
    this.toolbarActions = [...this.hideToolbarActions];
  }
  ngOnChanges(changes) {
    if (changes.hideToolbarActions || changes.disabledTextAlign) {
      this.toolbarActions = [...this.hideToolbarActions];
      this.updateAlignOnHideToolbarActionsList();
    }
  }
  ngAfterViewInit() {
    this.addKeyListeners();
    this.verifyAutoFocus();
    this.updateAlignOnHideToolbarActionsList();
  }
  ngOnDestroy() {
    if (!this.onChangeModel) {
      this.element.nativeElement.removeEventListener("keyup", this.listener);
      this.element.nativeElement.removeEventListener("keydown", this.listener);
      this.element.nativeElement.removeEventListener("cut", this.listener);
      this.element.nativeElement.removeEventListener("paste", this.listener);
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoRichTextComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoRichTextComponent, { static: true }) richText: PoRichTextComponent;
   *
   * focusRichText() {
   *   this.richText.focus();
   * }
   * ```
   */
  focus() {
    this.bodyElement.focus();
  }
  onBlur() {
    this.onTouched?.();
    if (this.additionalHelp.observed ? null : this.additionalHelpTooltip && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
  }
  onChangeValue(value) {
    this.change.emit(value);
  }
  onKeyDown(event) {
    this.keydown.emit(event);
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-rich-text
   *  #richtext
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, richtext)"
   * ></po-rich-text>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoRichTextComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  updateValue(value) {
    this.value = value;
    this.invalid = !value;
    this.controlChangeModelEmitter(this.value);
    this.updateModel(this.value);
  }
  addKeyListeners() {
    if (!this.onChangeModel) {
      this.element.nativeElement.addEventListener("keyup", this.listener);
      this.element.nativeElement.addEventListener("keydown", this.listener);
      this.element.nativeElement.addEventListener("cut", this.listener);
      this.element.nativeElement.addEventListener("paste", this.listener);
    }
  }
  controlChangeModelEmitter(value) {
    if (this.modelLastUpdate !== value) {
      this.changeModel.emit(value);
      this.modelLastUpdate = value;
    }
  }
  verifyAutoFocus() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  validateClassesForRequired() {
    setTimeout(() => {
      const value = this.value;
      const element = this.element.nativeElement;
      if (!value && this.required) {
        element.classList.add("ng-invalid");
        element.classList.add("ng-dirty");
      } else {
        element.classList.remove("ng-invalid");
      }
    });
  }
  isAllActionsHidden() {
    return Object.values(PoRichTextToolbarActions).every((action) => this.toolbarActions.includes(action));
  }
  updateAlignOnHideToolbarActionsList() {
    if (this.disabledTextAlign && !this.toolbarActions.includes(PoRichTextToolbarActions.Align)) {
      this.toolbarActions.push(PoRichTextToolbarActions.Align);
    }
  }
  static ɵfac = function PoRichTextComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoRichTextComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoRichTextService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoRichTextComponent,
    selectors: [["po-rich-text"]],
    viewQuery: function PoRichTextComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoRichTextBodyComponent, 7);
        ɵɵviewQuery(PoRichTextToolbarComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.bodyElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.richTextToolbar = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature(providers), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 6,
    vars: 11,
    consts: [["richTextBody", ""], ["richTextToolbar", ""], [3, "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [3, "p-change", "p-commands", "p-selected-link", "p-shortcut-command", "p-value", "p-blur", "p-keydown", "p-height", "p-label", "p-model-value", "p-placeholder", "p-readonly"], [3, "p-readonly", "p-hide-toolbar-actions", "p-link-editing", "p-command", 4, "ngIf"], [3, "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-error-limit", "p-error-pattern", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [3, "p-link-editing", "p-command", "p-readonly", "p-hide-toolbar-actions"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-error-limit", "p-error-pattern", "p-show-additional-help", "p-show-additional-help-icon"]],
    template: function PoRichTextComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 2)(1, "div", 3)(2, "po-rich-text-body", 4, 0);
        ɵɵlistener("p-change", function PoRichTextComponent_Template_po_rich_text_body_p_change_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onChangeValue($event));
        })("p-commands", function PoRichTextComponent_Template_po_rich_text_body_p_commands_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.richTextToolbar == null ? null : ctx.richTextToolbar.setButtonsStates($event));
        })("p-selected-link", function PoRichTextComponent_Template_po_rich_text_body_p_selected_link_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.richTextToolbar == null ? null : ctx.richTextToolbar.selectedLink($event));
        })("p-shortcut-command", function PoRichTextComponent_Template_po_rich_text_body_p_shortcut_command_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.richTextToolbar == null ? null : ctx.richTextToolbar.shortcutTrigger());
        })("p-value", function PoRichTextComponent_Template_po_rich_text_body_p_value_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.updateValue($event));
        })("p-blur", function PoRichTextComponent_Template_po_rich_text_body_p_blur_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        })("p-keydown", function PoRichTextComponent_Template_po_rich_text_body_p_keydown_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(4, PoRichTextComponent_po_rich_text_toolbar_4_Template, 2, 2, "po-rich-text-toolbar", 5);
        ɵɵelementEnd();
        ɵɵtemplate(5, PoRichTextComponent_po_field_container_bottom_5_Template, 1, 7, "po-field-container-bottom", 6);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(2);
        ɵɵproperty("p-height", ctx.height)("p-label", ctx.label)("p-model-value", ctx.value)("p-placeholder", ctx.placeholder)("p-readonly", ctx.readonly);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.isAllActionsHidden());
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.readonly);
      }
    },
    dependencies: [NgIf, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoRichTextBodyComponent, PoRichTextToolbarComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextComponent, [{
    type: Component,
    args: [{
      selector: "po-rich-text",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers,
      standalone: false,
      template: '<po-field-container [p-label]="label" [p-optional]="optional" [p-required]="required" [p-show-required]="showRequired">\n  <div class="po-field-container-content">\n    <po-rich-text-body\n      #richTextBody\n      [p-height]="height"\n      [p-label]="label"\n      [p-model-value]="value"\n      [p-placeholder]="placeholder"\n      [p-readonly]="readonly"\n      (p-change)="onChangeValue($event)"\n      (p-commands)="richTextToolbar?.setButtonsStates($event)"\n      (p-selected-link)="richTextToolbar?.selectedLink($event)"\n      (p-shortcut-command)="richTextToolbar?.shortcutTrigger()"\n      (p-value)="updateValue($event)"\n      (p-blur)="onBlur()"\n      (p-keydown)="onKeyDown($event)"\n    >\n    </po-rich-text-body>\n\n    <po-rich-text-toolbar\n      #richTextToolbar\n      *ngIf="!isAllActionsHidden()"\n      [p-readonly]="readonly"\n      [p-hide-toolbar-actions]="toolbarActions"\n      (p-link-editing)="richTextBody.linkEditing($event)"\n      (p-command)="richTextBody.executeCommand($event)"\n    >\n    </po-rich-text-toolbar>\n  </div>\n\n  <po-field-container-bottom\n    *ngIf="!readonly"\n    [p-additional-help-tooltip]="additionalHelp.observed ? null : additionalHelpTooltip"\n    [p-append-in-body]="appendBox"\n    [p-help]="help"\n    [p-error-limit]="errorLimit"\n    [p-error-pattern]="errorMsg"\n    [p-show-additional-help]="displayAdditionalHelp"\n    [p-show-additional-help-icon]="!!additionalHelpTooltip || additionalHelp.observed"\n    (p-additional-help)="additionalHelp.emit()"\n  ></po-field-container-bottom>\n</po-field-container>\n'
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: PoRichTextService
  }], {
    bodyElement: [{
      type: ViewChild,
      args: [PoRichTextBodyComponent, {
        static: true
      }]
    }],
    richTextToolbar: [{
      type: ViewChild,
      args: [PoRichTextToolbarComponent, {
        static: false
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRichTextComponent, {
    className: "PoRichTextComponent",
    filePath: "lib/components/po-field/po-rich-text/po-rich-text.component.ts",
    lineNumber: 69
  });
})();
var PoFieldValidateModel = class _PoFieldValidateModel extends PoFieldModel {
  changeDetector;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional = false;
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  required = false;
  /**
   * @optional
   *
   * @description
   *
   * Exibe a mensagem setada se o campo estiver vazio e for requerido.
   *
   * > Necessário que a propriedade `p-required` esteja habilitada.
   *
   */
  fieldErrorMessage;
  /**
   * @optional
   *
   * @description
   *
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   *
   * > Caso essa propriedade seja definida como `true`, a mensagem de erro será limitada a duas linhas
   * e um tooltip será exibido ao passar o mouse sobre a mensagem para mostrar o conteúdo completo.
   *
   * @default `false`
   */
  errorLimit = false;
  /**
   *  Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  hasValidatorRequired = false;
  onValidatorChange;
  constructor(changeDetector) {
    super();
    this.changeDetector = changeDetector;
  }
  validate(abstractControl) {
    if (!this.hasValidatorRequired && this.fieldErrorMessage && abstractControl.hasValidator(Validators.required)) {
      this.hasValidatorRequired = true;
    }
    if (requiredFailed(this.required || this.hasValidatorRequired, this.disabled, abstractControl.value)) {
      this.changeDetector.markForCheck();
      return {
        required: {
          valid: false
        }
      };
    }
    return this.extraValidation(abstractControl);
  }
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  validateModel() {
    if (this.onValidatorChange) {
      this.onValidatorChange();
    }
  }
  static ɵfac = function PoFieldValidateModel_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoFieldValidateModel)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoFieldValidateModel,
    inputs: {
      optional: [2, "p-optional", "optional", convertToBoolean],
      required: [2, "p-required", "required", convertToBoolean],
      fieldErrorMessage: [0, "p-field-error-message", "fieldErrorMessage"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      showRequired: [0, "p-show-required", "showRequired"]
    },
    features: [ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldValidateModel, [{
    type: Directive
  }], () => [{
    type: ChangeDetectorRef
  }], {
    optional: [{
      type: Input,
      args: [{
        alias: "p-optional",
        transform: convertToBoolean
      }]
    }],
    required: [{
      type: Input,
      args: [{
        alias: "p-required",
        transform: convertToBoolean
      }]
    }],
    fieldErrorMessage: [{
      type: Input,
      args: ["p-field-error-message"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }]
  });
})();
var _c0$F = ["select"];
function PoSelectComponent_ng_container_4_option_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    let tmp_6_0;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("disabled", !!ctx_r1.placeholder)("hidden", !(ctx_r1.selectedValue == null ? null : ctx_r1.selectedValue.toString()) && !ctx_r1.placeholder)("selected", !(ctx_r1.selectedValue == null ? null : ctx_r1.selectedValue.toString()))("value", (tmp_6_0 = ctx_r1.placeholder) !== null && tmp_6_0 !== void 0 ? tmp_6_0 : "");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.placeholder, " ");
  }
}
function PoSelectComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoSelectComponent_ng_container_4_option_1_Template, 2, 5, "option", 6);
    ɵɵelementStart(2, "option", 7);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !(ctx_r1.selectedValue == null ? null : ctx_r1.selectedValue.toString()) || !!ctx_r1.placeholder);
    ɵɵadvance();
    ɵɵproperty("hidden", true);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.displayValue);
  }
}
function PoSelectComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "option");
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.displayValue || ctx_r1.placeholder);
  }
}
function PoSelectComponent_ng_container_6_option_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("disabled", ctx_r1.readonly)("value", item_r3 == null ? null : item_r3[ctx_r1.fieldValue]);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r3 == null ? null : item_r3[ctx_r1.fieldLabel], " ");
  }
}
function PoSelectComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoSelectComponent_ng_container_6_option_1_Template, 2, 3, "option", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.optionWithoutGroup);
  }
}
function PoSelectComponent_ng_container_7_ng_container_1_optgroup_1_option_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 15);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const subItem_r4 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("value", subItem_r4 == null ? null : subItem_r4[ctx_r1.fieldValue])("disabled", ctx_r1.readonly);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", subItem_r4 == null ? null : subItem_r4[ctx_r1.fieldLabel], " ");
  }
}
function PoSelectComponent_ng_container_7_ng_container_1_optgroup_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "optgroup", 13);
    ɵɵtemplate(1, PoSelectComponent_ng_container_7_ng_container_1_optgroup_1_option_1_Template, 2, 3, "option", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r5 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵpropertyInterpolate("label", item_r5 == null ? null : item_r5.label);
    ɵɵproperty("disabled", ctx_r1.readonly);
    ɵɵadvance();
    ɵɵproperty("ngForOf", item_r5.options);
  }
}
function PoSelectComponent_ng_container_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoSelectComponent_ng_container_7_ng_container_1_optgroup_1_Template, 2, 3, "optgroup", 12);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", (item_r5 == null ? null : item_r5.options.length) > 0);
  }
}
function PoSelectComponent_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoSelectComponent_ng_container_7_ng_container_1_Template, 2, 1, "ng-container", 11);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.listGroupOptions);
  }
}
function PoSelectComponent_po_field_container_bottom_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 16);
    ɵɵlistener("p-additional-help", function PoSelectComponent_po_field_container_bottom_8_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitAdditionalHelp());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r1.getAdditionalHelpTooltip())("p-append-in-body", ctx_r1.appendBox)("p-help", ctx_r1.help)("p-disabled", ctx_r1.disabled)("p-error-pattern", ctx_r1.getErrorPattern())("p-error-limit", ctx_r1.errorLimit)("p-show-additional-help", ctx_r1.displayAdditionalHelp)("p-show-additional-help-icon", ctx_r1.showAdditionalHelpIcon());
  }
}
var PO_SELECT_FIELD_LABEL_DEFAULT = "label";
var PO_SELECT_FIELD_VALUE_DEFAULT = "value";
var PoSelectComponent = class _PoSelectComponent extends PoFieldValidateModel {
  el;
  renderer;
  _iconToken;
  selectElement;
  /**
   * @optional
   *
   * @description
   *
   * Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da tag form.
   *
   * Na versão 12.2.0 do Angular a verificação `strictTemplates` vem true como default. Portanto, para utilizar
   * two-way binding no componente deve se utilizar da seguinte forma:
   *
   * ```
   * <po-select ... [ngModel]="selectModel" (ngModelChange)="selectModel = $event"> </po-select>
   * ```
   */
  ngModelChange = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será somente para leitura.
   *
   * @default `false`
   */
  readonly = false;
  /** Mensagem que aparecerá enquanto nenhuma opção estiver selecionada. */
  placeholder;
  displayValue;
  id = `po-select[${uuid()}]`;
  modelValue;
  selectedValue;
  optionsDefault = [];
  listGroupOptions = [];
  optionWithoutGroup = [];
  isSafari = isSafari();
  onModelTouched;
  _fieldLabel = PO_SELECT_FIELD_LABEL_DEFAULT;
  _fieldValue = PO_SELECT_FIELD_VALUE_DEFAULT;
  _options;
  /**
   * Nesta propriedade deve ser definido uma coleção de objetos que implementam a interface `PoSelectOption`,
   * ou uma coleção de objetos dentro de grupos diferentes, que seriam da interface `PoSelectOptionGroup`.
   *
   * Caso esta lista estiver vazia, o model será `undefined`.
   *
   * > Essa propriedade é imutável, ou seja, sempre que quiser atualizar a lista de opções disponíveis
   * atualize a referência do objeto:
   *
   * ```
   * // atualiza a referência do objeto garantindo a atualização do template
   * this.options = [...this.options, { value: 'x', label: 'Nova opção' }];
   *
   * // evite, pois não atualiza a referência do objeto podendo gerar atrasos na atualização do template
   * this.options.push({ value: 'x', label: 'Nova opção' });
   * ```
   *
   * > Para coleção de objetos dentro de grupos distintos será exibido a label e opções somente se a propriedade `options` possua valores.
   *  Sendo assim, a estrutura seguiria dessa forma:
   *
   * ```
   * this.options = [{
   *  label: 'Opções',
   *  options: [
   *    { value: 1, label: 'opção 1' },
   *    { value: 2, label: 'opção 2' }
   *  ],
   * }];
   * ```
   *
   * É possível a utilização de opções agrupadas e desagrupadas em conjunto, porém será feita a ordenação de exibir as opções
   * desagrupadas acima.
   *
   */
  set options(options) {
    this.listGroupOptions = [];
    this.optionWithoutGroup = [];
    if (this.fieldLabel && this.fieldValue && options) {
      options.map((option) => {
        if (this.isItemGroup(option)) {
          option.options.map((opt) => {
            opt.label = opt[this.fieldLabel];
            opt.value = opt[this.fieldValue];
          });
        } else {
          option.label = option[this.fieldLabel];
          option.value = option[this.fieldValue];
        }
      });
    }
    if (options) {
      this.optionsDefault = [...options];
      this.separateOptions();
      this.optionsDefault = [];
      this.optionsDefault = [...this.optionWithoutGroup, ...this.transformInArray(this.listGroupOptions)];
      this.onUpdateOptions();
      this._options = [...this.optionsDefault];
    }
  }
  get options() {
    return this._options;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo texto de apresentação de cada item da lista.
   *
   * @default `label`
   */
  set fieldLabel(value) {
    this._fieldLabel = value || PO_SELECT_FIELD_LABEL_DEFAULT;
    if (this.options && this.options.length > 0) {
      this.options = [...this.options];
    }
  }
  get fieldLabel() {
    return this._fieldLabel;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo valor de cada item da lista.
   *
   * @default `value`
   */
  set fieldValue(value) {
    this._fieldValue = value || PO_SELECT_FIELD_VALUE_DEFAULT;
    if (this.options && this.options.length > 0) {
      this.options = [...this.options];
    }
  }
  /**
   * @docsPrivate
   *
   * Determinar se o valor do compo deve retorna objeto do tipo {value: any, label: any}
   */
  controlValueWithLabel = false;
  get fieldValue() {
    return this._fieldValue;
  }
  get iconNameLib() {
    return this._iconToken.NAME_LIB;
  }
  /* istanbul ignore next */
  constructor(value, changeDetector, el, renderer) {
    super(changeDetector);
    this.el = el;
    this.renderer = renderer;
    this._iconToken = value ?? AnimaliaIconDictionary;
  }
  ngOnChanges(changes) {
    if (changes.options?.currentValue) {
      this.options = changes.options.currentValue;
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoSelectComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoSelectComponent, { static: true }) select: PoSelectComponent;
   *
   * focusSelect() {
   *   this.select.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.selectElement.nativeElement.focus();
    }
  }
  getErrorPattern() {
    return this.fieldErrorMessage && this.hasInvalidClass() ? this.fieldErrorMessage : "";
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty");
  }
  onBlur() {
    this.onModelTouched?.();
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
  }
  // Altera o valor ao selecionar um item.
  onSelectChange(value) {
    this.onModelTouched?.();
    if (value && this.options && this.options.length) {
      const optionFound = this.findOptionValue(value);
      if (optionFound) {
        this.updateValues(optionFound);
      }
    }
  }
  onUpdateOptions() {
    if (this.modelValue) {
      this.onSelectChange(this.modelValue);
    }
  }
  // Atualiza valores
  updateValues(option) {
    if (this.selectedValue !== option[this.fieldValue]) {
      this.selectedValue = option[this.fieldValue];
      this.selectElement.nativeElement.value = option[this.fieldValue];
      this.updateModel(this.getValueUpdate(option));
      this.displayValue = option[this.fieldLabel];
      this.emitChange(option[this.fieldValue]);
    }
  }
  // Recebe as alterações do model
  onWriteValue(value) {
    value = this.getValueWrite(value);
    const optionFound = this.findOptionValue(value);
    if (optionFound) {
      this.selectElement.nativeElement.value = optionFound.value;
      this.selectedValue = optionFound[this.fieldValue];
      this.displayValue = optionFound[this.fieldLabel];
    } else if (validValue(this.selectedValue)) {
      this.selectElement.nativeElement.value = void 0;
      this.updateModel(void 0);
      this.selectedValue = void 0;
      this.displayValue = void 0;
    }
    this.modelValue = value;
    this.changeDetector.detectChanges();
  }
  extraValidation(c) {
    return null;
  }
  isItemGroup(item) {
    if (item.options) {
      return Array.isArray(item.options) ? true : false;
    }
    return false;
  }
  onKeyDown(event) {
    const isFieldFocused = document.activeElement === this.selectElement.nativeElement;
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  registerOnTouched(fn) {
    this.onModelTouched = fn;
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```html
   * <po-select
   *  #select
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, select)"
   * ></po-select>
   * ```
   * ```typescript
   * onKeyDown(event: KeyboardEvent, inp: PoSelectComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    return super.showAdditionalHelp();
  }
  isEqual(value, inputValue) {
    if ((value || value === 0) && inputValue) {
      return value.toString() === inputValue.toString();
    }
    if (value === null && inputValue !== null || value === void 0 && inputValue !== void 0) {
      value = `${value}`;
    }
    return value === inputValue;
  }
  findOptionValue(value) {
    if (this.options) {
      return this.options.find((option) => this.isEqual(option.value, value));
    }
  }
  getValueUpdate(option) {
    if (this.controlValueWithLabel) {
      return {
        value: option[this.fieldValue],
        label: option[this.fieldLabel]
      };
    }
    return option[this.fieldValue];
  }
  getValueWrite(data) {
    if (this.controlValueWithLabel && data?.value) {
      return data?.value;
    }
    return data;
  }
  transformInArray(objectWithArray) {
    return objectWithArray.reduce((options, items) => {
      if (items.options) {
        return options.concat(items.options);
      }
      return [];
    }, []);
  }
  separateOptions() {
    this.optionsDefault.forEach((option) => {
      if (this.isItemGroup(option)) {
        this.validateOptions(option.options);
        this.listGroupOptions.push(option);
      } else {
        this.optionWithoutGroup.push(option);
      }
    });
    if (this.optionWithoutGroup.length > 0) {
      this.validateOptions(this.optionWithoutGroup);
    }
  }
  validateOptions(options) {
    removeDuplicatedOptions(options);
    removeUndefinedAndNullOptions(options);
  }
  static ɵfac = function PoSelectComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSelectComponent)(ɵɵdirectiveInject(ICONS_DICTIONARY, 8), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoSelectComponent,
    selectors: [["po-select"]],
    viewQuery: function PoSelectComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$F, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.selectElement = _t.first);
      }
    },
    inputs: {
      readonly: [2, "p-readonly", "readonly", convertToBoolean],
      placeholder: [0, "p-placeholder", "placeholder"],
      options: [0, "p-options", "options"],
      fieldLabel: [0, "p-field-label", "fieldLabel"],
      fieldValue: [0, "p-field-value", "fieldValue"],
      controlValueWithLabel: [2, "p-control-value-with-label", "controlValueWithLabel", convertToBoolean]
    },
    outputs: {
      ngModelChange: "ngModelChange"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoSelectComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoSelectComponent),
      multi: true
    }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 9,
    vars: 18,
    consts: [["select", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [1, "po-select", 3, "blur", "change", "keydown", "ngClass", "disabled", "id", "required"], [4, "ngIf"], [3, "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [3, "disabled", "hidden", "selected", "value", 4, "ngIf"], [3, "hidden"], [3, "disabled", "hidden", "selected", "value"], [3, "disabled", "value", 4, "ngFor", "ngForOf"], [3, "disabled", "value"], [4, "ngFor", "ngForOf"], [3, "label", "disabled", 4, "ngIf"], [3, "label", "disabled"], [3, "value", "disabled", 4, "ngFor", "ngForOf"], [3, "value", "disabled"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon"]],
    template: function PoSelectComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2)(2, "select", 3, 0);
        ɵɵlistener("blur", function PoSelectComponent_Template_select_blur_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        })("change", function PoSelectComponent_Template_select_change_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onSelectChange($event.target.value));
        })("keydown", function PoSelectComponent_Template_select_keydown_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵtemplate(4, PoSelectComponent_ng_container_4_Template, 4, 3, "ng-container", 4)(5, PoSelectComponent_ng_container_5_Template, 3, 1, "ng-container", 4)(6, PoSelectComponent_ng_container_6_Template, 2, 1, "ng-container", 4)(7, PoSelectComponent_ng_container_7_Template, 2, 1, "ng-container", 4);
        ɵɵelementEnd()();
        ɵɵtemplate(8, PoSelectComponent_po_field_container_bottom_8_Template, 1, 8, "po-field-container-bottom", 5);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(2);
        ɵɵclassProp("po-select-placeholder", !(ctx.selectedValue == null ? null : ctx.selectedValue.toString()) && !!ctx.placeholder);
        ɵɵproperty("ngClass", ctx.iconNameLib === "AnimaliaIcon" ? "po-select-phosphor" : "po-select-poicon")("disabled", ctx.disabled)("id", ctx.id)("required", ctx.required);
        ɵɵattribute("name", ctx.name);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.isSafari);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isSafari);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.optionWithoutGroup.length > 0);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.listGroupOptions.length > 0);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.readonly);
      }
    },
    dependencies: [NgClass, NgForOf, NgIf, NgSelectOption, ɵNgSelectMultipleOption, PoFieldContainerBottomComponent, PoFieldContainerComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSelectComponent, [{
    type: Component,
    args: [{
      selector: "po-select",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoSelectComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoSelectComponent),
        multi: true
      }],
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <select
      #select
      class="po-select"
      [ngClass]="iconNameLib === 'AnimaliaIcon' ? 'po-select-phosphor' : 'po-select-poicon'"
      [attr.name]="name"
      [class.po-select-placeholder]="!selectedValue?.toString() && !!placeholder"
      [disabled]="disabled"
      [id]="id"
      [required]="required"
      (blur)="onBlur()"
      (change)="onSelectChange($event.target.value)"
      (keydown)="onKeyDown($event)"
    >
      <ng-container *ngIf="!isSafari">
        <option
          *ngIf="!selectedValue?.toString() || !!placeholder"
          [disabled]="!!placeholder"
          [hidden]="!selectedValue?.toString() && !placeholder"
          [selected]="!selectedValue?.toString()"
          [value]="placeholder ?? ''"
        >
          {{ placeholder }}
        </option>
        <option [hidden]="true">{{ displayValue }}</option>
      </ng-container>

      <ng-container *ngIf="isSafari">
        <option>{{ displayValue || placeholder }}</option>
      </ng-container>

      <ng-container *ngIf="optionWithoutGroup.length > 0">
        <option *ngFor="let item of optionWithoutGroup" [disabled]="readonly" [value]="item?.[this.fieldValue]">
          {{ item?.[this.fieldLabel] }}
        </option>
      </ng-container>
      <ng-container *ngIf="listGroupOptions.length > 0">
        <ng-container *ngFor="let item of listGroupOptions">
          <optgroup *ngIf="item?.options.length > 0" label="{{ item?.label }}" [disabled]="readonly">
            <option *ngFor="let subItem of item.options" [value]="subItem?.[this.fieldValue]" [disabled]="readonly">
              {{ subItem?.[this.fieldLabel] }}
            </option>
          </optgroup>
        </ng-container>
      </ng-container>
    </select>
  </div>

  <po-field-container-bottom
    *ngIf="!readonly"
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
    [p-error-limit]="errorLimit"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ICONS_DICTIONARY]
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    selectElement: [{
      type: ViewChild,
      args: ["select", {
        read: ElementRef,
        static: true
      }]
    }],
    ngModelChange: [{
      type: Output,
      args: ["ngModelChange"]
    }],
    readonly: [{
      type: Input,
      args: [{
        alias: "p-readonly",
        transform: convertToBoolean
      }]
    }],
    placeholder: [{
      type: Input,
      args: ["p-placeholder"]
    }],
    options: [{
      type: Input,
      args: ["p-options"]
    }],
    fieldLabel: [{
      type: Input,
      args: ["p-field-label"]
    }],
    fieldValue: [{
      type: Input,
      args: ["p-field-value"]
    }],
    controlValueWithLabel: [{
      type: Input,
      args: [{
        alias: "p-control-value-with-label",
        transform: convertToBoolean
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSelectComponent, {
    className: "PoSelectComponent",
    filePath: "lib/components/po-field/po-select/po-select.component.ts",
    lineNumber: 124
  });
})();
var PoTextareaBaseComponent = class _PoTextareaBaseComponent {
  cd;
  // Propriedade interna que define se o ícone de ajuda adicional terá cursor clicável (evento) ou padrão (tooltip).
  additionalHelpEventTrigger;
  /**
   * @optional
   *
   * @description
   * Exibe um ícone de ajuda adicional ao `p-help`, com o texto desta propriedade no tooltip.
   * Se o evento `p-additional-help` estiver definido, o tooltip não será exibido.
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   * > Requer um recuo mínimo de 8px se o componente estiver próximo à lateral da tela.
   */
  additionalHelpTooltip;
  /**
   * @optional
   *
   * @description
   *
   * Define que o tooltip (`p-additional-help-tooltip` e/ou `p-error-limit`) será incluído no body da página e não
   * dentro do componente. Essa opção pode ser necessária em cenários com containers que possuem scroll ou overflow
   * escondido, garantindo o posicionamento correto do tooltip próximo ao elemento.
   *
   * > Quando utilizado com `p-additional-help-tooltip`, leitores de tela como o NVDA podem não ler o conteúdo do tooltip.
   *
   * @default `false`
   */
  appendBox = false;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Label do campo. */
  label;
  /** Texto de apoio do campo. */
  help;
  /** Nome e Id do componente. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * @optional
   *
   * @description
   *
   * Exibe a mensagem setada se o campo estiver vazio e for requerido.
   *
   * > Necessário que a propriedade `p-required` esteja habilitada.
   *
   */
  fieldErrorMessage;
  /**
   * @optional
   *
   * @description
   *
   * Limita a exibição da mensagem de erro a duas linhas e exibe um tooltip com o texto completo.
   *
   * > Caso essa propriedade seja definida como `true`, a mensagem de erro será limitada a duas linhas
   * e um tooltip será exibido ao passar o mouse sobre a mensagem para mostrar o conteúdo completo.
   *
   * @default `false`
   */
  errorLimit = false;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no ícone de ajuda adicional.
   * Este evento ativa automaticamente a exibição do ícone de ajuda adicional ao `p-help`.
   */
  additionalHelp = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao sair do campo.
   */
  blur = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao entrar do campo.
   */
  enter = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor e deixar o campo.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do model.
   */
  changeModel = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado quando uma tecla é pressionada enquanto o foco está no componente.
   * Retorna um objeto `KeyboardEvent` com informações sobre a tecla.
   */
  keydown = new EventEmitter();
  displayAdditionalHelp = false;
  _disabled = false;
  _maxlength;
  _minlength;
  _placeholder = "";
  _readonly = false;
  _required = false;
  _rows = 3;
  modelLastUpdate;
  onChangePropagate = null;
  validatorChange;
  // eslint-disable-next-line
  onTouched = null;
  hasValidatorRequired = false;
  /** Placeholder, mensagem que aparecerá enquanto o campo não estiver preenchido. */
  set placeholder(value) {
    this._placeholder = value || "";
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será desabilitado.
   *
   * @default `false`
   */
  set disabled(disabled) {
    this._disabled = convertToBoolean(disabled);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será somente leitura.
   *
   * @default `false`
   */
  set readonly(readonly) {
    this._readonly = convertToBoolean(readonly);
  }
  get readonly() {
    return this._readonly;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   * > Esta propriedade é desconsiderada quando o input está desabilitado `(p-disabled)`.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel();
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * @optional
   *
   * @description
   *
   * Indica a quantidade mínima de caracteres que o campo aceita.
   */
  set minlength(minlength) {
    this._minlength = convertToInt(minlength);
    this.validateModel();
  }
  get minlength() {
    return this._minlength;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica a quantidade máxima de caracteres que o campo aceita.
   */
  set maxlength(maxlength) {
    this._maxlength = convertToInt(maxlength);
    this.validateModel();
  }
  get maxlength() {
    return this._maxlength;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica a quantidade de linhas que serão exibidas.
   *
   * @default `3`
   */
  set rows(value) {
    this._rows = isNaN(parseInt(value, 10)) || value < 3 ? 3 : parseInt(value, 10);
  }
  get rows() {
    return this._rows;
  }
  constructor(cd) {
    this.cd = cd;
  }
  callOnChange(value) {
    if (this.onChangePropagate) {
      this.onChangePropagate(value);
    }
    this.controlChangeModelEmitter(value);
  }
  controlChangeModelEmitter(value) {
    if (this.modelLastUpdate !== value) {
      this.changeModel.emit(value);
      this.modelLastUpdate = value;
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd.markForCheck();
  }
  // Funções `registerOnChange`, `registerOnTouched` e `registerOnValidatorChange` implementadas referentes ao ControlValueAccessor
  // usadas para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnChange(func) {
    this.onChangePropagate = func;
  }
  registerOnTouched(func) {
    this.onTouched = func;
  }
  registerOnValidatorChange(func) {
    this.validatorChange = func;
  }
  validate(abstractControl) {
    if (!this.hasValidatorRequired && this.fieldErrorMessage && abstractControl.hasValidator(Validators.required)) {
      this.hasValidatorRequired = true;
    }
    if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
    if (minlengpoailed(this.minlength, abstractControl.value)) {
      return {
        minlength: {
          valid: false
        }
      };
    }
    if (maxlengpoailed(this.maxlength, abstractControl.value)) {
      return {
        maxlength: {
          valid: false
        }
      };
    }
  }
  // Função implementada do ControlValueAccessor
  writeValue(value) {
    this.writeValueModel(value);
    this.cd.markForCheck();
  }
  validateModel() {
    if (this.validatorChange) {
      this.validatorChange();
    }
  }
  static ɵfac = function PoTextareaBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTextareaBaseComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTextareaBaseComponent,
    inputs: {
      additionalHelpEventTrigger: "additionalHelpEventTrigger",
      additionalHelpTooltip: [0, "p-additional-help-tooltip", "additionalHelpTooltip"],
      appendBox: [2, "p-append-in-body", "appendBox", convertToBoolean],
      autoFocus: [2, "p-auto-focus", "autoFocus", convertToBoolean],
      label: [0, "p-label", "label"],
      help: [0, "p-help", "help"],
      name: "name",
      optional: [0, "p-optional", "optional"],
      fieldErrorMessage: [0, "p-field-error-message", "fieldErrorMessage"],
      errorLimit: [0, "p-error-limit", "errorLimit"],
      placeholder: [0, "p-placeholder", "placeholder"],
      disabled: [0, "p-disabled", "disabled"],
      readonly: [0, "p-readonly", "readonly"],
      required: [0, "p-required", "required"],
      showRequired: [0, "p-show-required", "showRequired"],
      minlength: [0, "p-minlength", "minlength"],
      maxlength: [0, "p-maxlength", "maxlength"],
      rows: [0, "p-rows", "rows"]
    },
    outputs: {
      additionalHelp: "p-additional-help",
      blur: "p-blur",
      enter: "p-enter",
      change: "p-change",
      changeModel: "p-change-model",
      keydown: "p-keydown"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTextareaBaseComponent, [{
    type: Directive
  }], () => [{
    type: ChangeDetectorRef
  }], {
    additionalHelpEventTrigger: [{
      type: Input
    }],
    additionalHelpTooltip: [{
      type: Input,
      args: ["p-additional-help-tooltip"]
    }],
    appendBox: [{
      type: Input,
      args: [{
        alias: "p-append-in-body",
        transform: convertToBoolean
      }]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        alias: "p-auto-focus",
        transform: convertToBoolean
      }]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    optional: [{
      type: Input,
      args: ["p-optional"]
    }],
    fieldErrorMessage: [{
      type: Input,
      args: ["p-field-error-message"]
    }],
    errorLimit: [{
      type: Input,
      args: ["p-error-limit"]
    }],
    additionalHelp: [{
      type: Output,
      args: ["p-additional-help"]
    }],
    blur: [{
      type: Output,
      args: ["p-blur"]
    }],
    enter: [{
      type: Output,
      args: ["p-enter"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    changeModel: [{
      type: Output,
      args: ["p-change-model"]
    }],
    keydown: [{
      type: Output,
      args: ["p-keydown"]
    }],
    placeholder: [{
      type: Input,
      args: ["p-placeholder"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    readonly: [{
      type: Input,
      args: ["p-readonly"]
    }],
    required: [{
      type: Input,
      args: ["p-required"]
    }],
    showRequired: [{
      type: Input,
      args: ["p-show-required"]
    }],
    minlength: [{
      type: Input,
      args: ["p-minlength"]
    }],
    maxlength: [{
      type: Input,
      args: ["p-maxlength"]
    }],
    rows: [{
      type: Input,
      args: ["p-rows"]
    }]
  });
})();
var _c0$E = ["inp"];
function PoTextareaComponent_po_field_container_bottom_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-field-container-bottom", 5);
    ɵɵlistener("p-additional-help", function PoTextareaComponent_po_field_container_bottom_4_Template_po_field_container_bottom_p_additional_help_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.emitAdditionalHelp());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-additional-help-tooltip", ctx_r2.getAdditionalHelpTooltip())("p-append-in-body", ctx_r2.appendBox)("p-help", ctx_r2.help)("p-disabled", ctx_r2.disabled)("p-error-pattern", ctx_r2.getErrorPattern())("p-error-limit", ctx_r2.errorLimit)("p-show-additional-help", ctx_r2.displayAdditionalHelp)("p-show-additional-help-icon", ctx_r2.showAdditionalHelpIcon());
  }
}
var PoTextareaComponent = class _PoTextareaComponent extends PoTextareaBaseComponent {
  el;
  inputEl;
  id = `po-textarea[${uuid()}]`;
  valueBeforeChange;
  fireChange = false;
  constructor(cd, el) {
    super(cd);
    this.el = el;
  }
  emitAdditionalHelp() {
    if (this.isAdditionalHelpEventTriggered()) {
      this.additionalHelp.emit();
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoTextareaComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoTextareaComponent, { static: true }) textarea: PoTextareaComponent;
   *
   * focusTextarea() {
   *   this.textarea.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  getAdditionalHelpTooltip() {
    return this.isAdditionalHelpEventTriggered() ? null : this.additionalHelpTooltip;
  }
  getErrorPattern() {
    return this.fieldErrorMessage && this.hasInvalidClass() ? this.fieldErrorMessage : "";
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty") && !this.inputEl.nativeElement.value && (this.required || this.hasValidatorRequired);
  }
  writeValueModel(value) {
    if (this.inputEl) {
      if (!value) {
        this.inputEl.nativeElement.value = "";
      } else {
        this.inputEl.nativeElement.value = value;
      }
    }
    if (value) {
      this.change.emit(value);
    }
  }
  validMaxLength(maxlength, value) {
    return maxlength && value.length > maxlength ? value.toString().substring(0, maxlength) : value;
  }
  eventOnInput(event) {
    const value = this.validMaxLength(this.maxlength, event.target.value);
    this.callOnChange(value);
    this.inputEl.nativeElement.value = value;
  }
  eventOnFocus() {
    this.valueBeforeChange = this.inputEl.nativeElement.value;
    this.enter.emit();
  }
  eventOnBlur() {
    this.onTouched?.();
    this.blur.emit();
    this.controlChangeEmitter();
    if (this.getAdditionalHelpTooltip() && this.displayAdditionalHelp) {
      this.showAdditionalHelp();
    }
  }
  controlChangeEmitter() {
    const elementValue = this.inputEl.nativeElement.value;
    if (elementValue !== this.valueBeforeChange) {
      this.change.emit(elementValue);
    }
  }
  onKeyDown(event) {
    const isFieldFocused = document.activeElement === this.inputEl.nativeElement;
    if (isFieldFocused) {
      this.keydown.emit(event);
    }
  }
  /**
   * Método que exibe `p-additionalHelpTooltip` ou executa a ação definida em `p-additionalHelp`.
   * Para isso, será necessário configurar uma tecla de atalho utilizando o evento `p-keydown`.
   *
   * ```
   * <po-textarea
   *  #textarea
   *  ...
   *  p-additional-help-tooltip="Mensagem de ajuda complementar"
   *  (p-keydown)="onKeyDown($event, textarea)"
   * ></po-textarea>
   * ```
   * ```
   * ...
   * onKeyDown(event: KeyboardEvent, inp: PoTextareaComponent): void {
   *  if (event.code === 'F9') {
   *    inp.showAdditionalHelp();
   *  }
   * }
   * ```
   */
  showAdditionalHelp() {
    this.displayAdditionalHelp = !this.displayAdditionalHelp;
    return this.displayAdditionalHelp;
  }
  showAdditionalHelpIcon() {
    return !!this.additionalHelpTooltip || this.isAdditionalHelpEventTriggered();
  }
  isAdditionalHelpEventTriggered() {
    return this.additionalHelpEventTrigger === "event" || this.additionalHelpEventTrigger === void 0 && this.additionalHelp.observed;
  }
  static ɵfac = function PoTextareaComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTextareaComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTextareaComponent,
    selectors: [["po-textarea"]],
    viewQuery: function PoTextareaComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$E, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoTextareaComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoTextareaComponent),
      multi: true
    }]), ɵɵInheritDefinitionFeature],
    decls: 5,
    vars: 14,
    consts: [["inp", ""], [3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [1, "po-textarea", 3, "blur", "focus", "input", "keydown", "disabled", "id", "placeholder", "readonly", "required", "rows"], [3, "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon", "p-additional-help", 4, "ngIf"], [3, "p-additional-help", "p-additional-help-tooltip", "p-append-in-body", "p-help", "p-disabled", "p-error-pattern", "p-error-limit", "p-show-additional-help", "p-show-additional-help-icon"]],
    template: function PoTextareaComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "po-field-container", 1)(1, "div", 2)(2, "textarea", 3, 0);
        ɵɵlistener("blur", function PoTextareaComponent_Template_textarea_blur_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnBlur());
        })("focus", function PoTextareaComponent_Template_textarea_focus_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnFocus());
        })("input", function PoTextareaComponent_Template_textarea_input_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.eventOnInput($event));
        })("keydown", function PoTextareaComponent_Template_textarea_keydown_2_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        });
        ɵɵelementEnd()();
        ɵɵtemplate(4, PoTextareaComponent_po_field_container_bottom_4_Template, 1, 8, "po-field-container-bottom", 4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
        ɵɵadvance(2);
        ɵɵproperty("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("rows", ctx.rows);
        ɵɵattribute("name", ctx.name);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.readonly);
      }
    },
    dependencies: [NgIf, PoFieldContainerBottomComponent, PoFieldContainerComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTextareaComponent, [{
    type: Component,
    args: [{
      selector: "po-textarea",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoTextareaComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoTextareaComponent),
        multi: true
      }],
      standalone: false,
      template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <textarea
      #inp
      class="po-textarea"
      (blur)="eventOnBlur()"
      (focus)="eventOnFocus()"
      (input)="eventOnInput($event)"
      (keydown)="onKeyDown($event)"
      [attr.name]="name"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [rows]="rows"
    ></textarea>
  </div>

  <po-field-container-bottom
    *ngIf="!readonly"
    [p-additional-help-tooltip]="getAdditionalHelpTooltip()"
    [p-append-in-body]="appendBox"
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
    [p-error-limit]="errorLimit"
    [p-show-additional-help]="displayAdditionalHelp"
    [p-show-additional-help-icon]="showAdditionalHelpIcon()"
    (p-additional-help)="emitAdditionalHelp()"
  ></po-field-container-bottom>
</po-field-container>
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }], {
    inputEl: [{
      type: ViewChild,
      args: ["inp", {
        read: ElementRef,
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTextareaComponent, {
    className: "PoTextareaComponent",
    filePath: "lib/components/po-field/po-textarea/po-textarea.component.ts",
    lineNumber: 60
  });
})();
var poSearchLiteralsDefault = {
  en: {
    search: "Search",
    clean: "Clean",
    all: "All"
  },
  es: {
    search: "Buscar",
    clean: "limpiar",
    all: "Todo"
  },
  pt: {
    search: "Pesquisar",
    clean: "Apagar",
    all: "Todos"
  },
  ru: {
    search: "Поиск",
    clean: "чистый",
    all: "Все"
  }
};
var PoSearchBaseComponent = class _PoSearchBaseComponent {
  _literals;
  _ariaLabel;
  language;
  _filterSelect;
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o po-search e não permite que o usuário interaja com o mesmo.
   *
   * @default `false`
   */
  disabled;
  /**
   * @optional
   *
   * @description
   *
   * Lista de itens que serão utilizados para pesquisa
   */
  items = [];
  /**
   * @optional
   *
   * @description
   *
   * Define um aria-label para o po-search.
   *
   * > Devido o componente não possuir uma label assim como outros campos de texto, o `aria-label` é utilizado para acessibilidade.
   */
  set ariaLabel(value) {
    this._ariaLabel = value;
    if (value !== this.literals.search) {
      this._ariaLabel = `${this._ariaLabel} ${this.literals.search}`;
    }
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  /**
   * @description
   *
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente (p-items), esta propriedade será responsável pelo texto de apresentação de cada item da lista.
   */
  filterKeys = [];
  /**
   * @optional
   *
   * @description
   *
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente (p-items), esta propriedade será responsável pelo texto de apresentação de cada item da lista.
   */
  icon;
  /**
   * @optional
   *
   * @description
   *
   * Determina a forma de realizar a pesquisa no componente
   *
   * Valores aceitos:
   * - `action`: Realiza a busca a cada caractere digitado.
   * - `trigger`: Realiza a busca ao pressionar `enter` ou clicar no ícone de busca.
   *
   * @default `action`
   */
  type = "action";
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-search`.
   *
   * Para utilizar basta passar a literal que deseja customizar:
   *
   * ```
   *  const customLiterals: PoSearchLiterals = {
   *    search: 'Pesquisar',
   *    clean: 'Limpar',
   *  };
   * ```
   *
   * E para carregar a literal customizada, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-search
   *   [p-literals]="customLiterals">
   * </po-search>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poSearchLiteralsDefault[poLocaleDefault]), poSearchLiteralsDefault[this.language]), value);
    } else {
      this._literals = poSearchLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poSearchLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o modo de pesquisa utilizado no campo de busca, quando habilitado. Valores definidos no enum: PoSearchFilterMode
   *
   * @default `startsWith`
   */
  filterType = PoSearchFilterMode.startsWith;
  /**
   * @optional
   *
   * @description
   *
   * Exibe uma lista (auto-complete) com as opções definidas no `p-filter-keys` enquanto realiza uma busca,
   * respeitando o `p-filter-type` como modo de pesquisa.
   *
   * @default `false`
   */
  showListbox = false;
  /**
   * @description
   *
   * Define os tipos de filtros (p-filter-keys) a serem aplicados na busca ou lista do componente (p-items).
   * Automaticamente adiciona a opção 'Todos', com um mapeamento de todas as opções passadas.
   *
   * > O uso desta propriedade torna a propriedade 'p-filter-keys' inválida.
   *
   * Exemplo de uso:
   * ```typescript
   * const filterSelect = [
   *   { label: 'personal', value: ['name', 'email', 'nickname'] },
   *   { label: 'address', value: ['country', 'state', 'city', 'street'] },
   *   { label: 'family', value: ['father', 'mother', 'dependents'] }
   * ];
   * ```
   */
  set filterSelect(values) {
    if (!Array.isArray(values) || values.length === 0 || values.every((value) => Object.keys(value).length === 0)) {
      this._filterSelect = void 0;
      return;
    }
    const _values = this.ensureFilterSelectOption(values);
    const allValues = _values.flatMap((e) => e.value);
    const uniqueValues = [...new Set(allValues)];
    const filterOptionAll = {
      label: this.literals.all,
      value: uniqueValues
    };
    this._filterSelect = [filterOptionAll, ..._values];
  }
  get filterSelect() {
    return this._filterSelect;
  }
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do model.
   */
  changeModel = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Pode ser informada uma função que será disparada quando houver alterações no input.
   */
  filteredItemsChange = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Pode ser informada uma função que será disparada quando houver alterações nos filtros.
   */
  filter = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Pode ser informada uma função que será disparada quando houver click no listbox.
   */
  listboxOnClick = new EventEmitter();
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  ensureFilterSelectOption(values) {
    const _values = Array.isArray(values) ? values : Array.of(values);
    return _values.map((value) => typeof value === "object" ? value : {
      label: value,
      value
    });
  }
  static ɵfac = function PoSearchBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSearchBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoSearchBaseComponent,
    inputs: {
      disabled: [2, "p-disabled", "disabled", convertToBoolean],
      items: [0, "p-items", "items"],
      ariaLabel: [0, "p-aria-label", "ariaLabel"],
      filterKeys: [0, "p-filter-keys", "filterKeys"],
      icon: [0, "p-icon", "icon"],
      type: [0, "p-search-type", "type"],
      literals: [0, "p-literals", "literals"],
      filterType: [0, "p-filter-type", "filterType"],
      showListbox: [2, "p-show-listbox", "showListbox", convertToBoolean],
      filterSelect: [0, "p-filter-select", "filterSelect"]
    },
    outputs: {
      changeModel: "p-change-model",
      filteredItemsChange: "p-filtered-items-change",
      filter: "p-filter",
      listboxOnClick: "p-listbox-onclick"
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSearchBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    disabled: [{
      type: Input,
      args: [{
        alias: "p-disabled",
        transform: convertToBoolean
      }]
    }],
    items: [{
      type: Input,
      args: ["p-items"]
    }],
    ariaLabel: [{
      type: Input,
      args: ["p-aria-label"]
    }],
    filterKeys: [{
      type: Input,
      args: ["p-filter-keys"]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }],
    type: [{
      type: Input,
      args: ["p-search-type"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    filterType: [{
      type: Input,
      args: ["p-filter-type"]
    }],
    showListbox: [{
      type: Input,
      args: [{
        alias: "p-show-listbox",
        transform: convertToBoolean
      }]
    }],
    filterSelect: [{
      type: Input,
      args: ["p-filter-select"]
    }],
    changeModel: [{
      type: Output,
      args: ["p-change-model"]
    }],
    filteredItemsChange: [{
      type: Output,
      args: ["p-filtered-items-change"]
    }],
    filter: [{
      type: Output,
      args: ["p-filter"]
    }],
    listboxOnClick: [{
      type: Output,
      args: ["p-listbox-onclick"]
    }]
  });
})();
var _c0$D = ["poSearchInput"];
var _c1$d = ["poListboxContainerElement"];
var _c2$5 = ["poListboxElement"];
var _c3$3 = ["poListbox"];
function PoSearchComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵelement(1, "po-dropdown", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-label", ctx_r1.searchFilterSelectLabel)("p-disabled", ctx_r1.disabled)("p-actions", ctx_r1.searchFilterSelectActions);
  }
}
function PoSearchComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 14);
    ɵɵelement(1, "po-icon", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-icon", ctx_r1.icon ? ctx_r1.icon : "ICON_SEARCH");
  }
}
function PoSearchComponent_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 16);
    ɵɵlistener("click", function PoSearchComponent_button_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearSearch());
    })("keydown.enter", function PoSearchComponent_button_6_Template_button_keydown_enter_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearSearch());
    });
    ɵɵelement(1, "po-clean", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ariaLabel", ctx_r1.literals.clean);
  }
}
function PoSearchComponent_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 18);
    ɵɵlistener("click", function PoSearchComponent_button_7_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      const poSearchInput_r5 = ɵɵreference(4);
      return ɵɵresetView(ctx_r1.onSearchChange(poSearchInput_r5.value, true, true));
    })("keydown.enter", function PoSearchComponent_button_7_Template_button_keydown_enter_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      const poSearchInput_r5 = ɵɵreference(4);
      return ɵɵresetView(ctx_r1.onSearchChange(poSearchInput_r5.value, true, true));
    });
    ɵɵelement(1, "po-icon", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ariaLabel", ctx_r1.literals.search)("disabled", ctx_r1.disabled);
    ɵɵadvance();
    ɵɵproperty("p-icon", ctx_r1.icon ? ctx_r1.icon : "ICON_SEARCH");
  }
}
var poSearchContainerOffset = 8;
var poSearchContainerPositionDefault = "bottom";
var PoSearchComponent = class _PoSearchComponent extends PoSearchBaseComponent {
  languageService;
  renderer;
  changeDetector;
  controlPosition;
  clickoutListener;
  eventResizeListener;
  poSearchInput;
  poListboxContainerElement;
  poListboxElement;
  poListbox;
  listboxFilteredItems = [];
  filteredItems = [];
  listboxOpen = false;
  shouldMarkLetters = true;
  isFiltering = false;
  listboxItemclicked = false;
  searchFilter = {};
  searchFilterSelectLabel;
  searchFilterSelectActions;
  constructor(languageService, renderer, changeDetector, controlPosition) {
    super(languageService);
    this.languageService = languageService;
    this.renderer = renderer;
    this.changeDetector = changeDetector;
    this.controlPosition = controlPosition;
  }
  ngOnInit() {
    this.filteredItems = this.items;
    if (this.showListbox) {
      this.listboxFilteredItems = this.listboxItems;
    }
    if (this.filterSelect) {
      this.createDropdownFilterSelect();
    }
  }
  ngOnChanges(changes) {
    if (changes.filterSelect && changes.filterSelect.currentValue) {
      this.createDropdownFilterSelect();
    }
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  clearSearch() {
    this.poSearchInput.nativeElement.value = "";
    this.onSearchChange("", true);
    this.filteredItemsChange.emit(this.items);
    this.onCloseListbox();
  }
  onSearchChange(searchText, activated, buttonClick) {
    const searchTextInitial = searchText;
    if (searchText !== void 0) {
      searchText = searchText.toLowerCase();
    }
    this.isFiltering = true;
    if (this.showListbox && !buttonClick && searchText.length > 0) {
      this.controlListboxVisibility(true);
      this.listboxFilteredItems = this.getListboxFilteredItems(searchText);
    } else {
      if (searchText.length === 0) {
        this.listboxFilteredItems = this.listboxItems;
      }
    }
    if (activated && !this.listboxItemclicked) {
      this.updateFilteredItems(searchText);
      this.filteredItemsChange.emit(this.filteredItems);
      if (this.filterSelect) {
        this.searchFilter = __spreadProps(__spreadValues({}, this.searchFilter), {
          value: searchTextInitial
        });
      } else {
        this.searchFilter = {
          filter: this.filterKeys,
          value: searchTextInitial
        };
      }
      this.filter.emit(this.searchFilter);
      this.changeModel.emit(searchText);
    }
    if (this.listboxItemclicked) {
      this.listboxItemclicked = false;
    }
    this.changeDetector.detectChanges();
  }
  updateFilteredItems(searchText) {
    if (this.items && this.items.length > 0) {
      this.filteredItems = this.getFilteredItems(searchText);
    } else {
      this.filteredItems = [];
    }
  }
  getFilteredItems(searchText) {
    return this.items.filter((item) => this.itemMatchesFilter(item, searchText));
  }
  itemMatchesFilter(item, searchText) {
    const valuesToSearch = this.filterKeys.map((key) => typeof item[key] !== "string" ? String(item[key]) : item[key]).map((value) => value ? value.toLowerCase() : "");
    return valuesToSearch.some((value) => this.filterValue(value, searchText));
  }
  getListboxFilteredItems(searchText) {
    return this.listboxItems.filter((item) => this.filterValue(item.value, searchText));
  }
  filterValue(value, searchText) {
    value = value?.toLowerCase();
    switch (this.filterType) {
      case PoSearchFilterMode.startsWith:
        return value?.startsWith(searchText);
      case PoSearchFilterMode.contains:
        return value?.includes(searchText);
      case PoSearchFilterMode.endsWith:
        return value?.endsWith(searchText);
      default:
        return false;
    }
  }
  get listboxItems() {
    return this.items.map((item) => this.filterKeys.map((key) => item[key]).map((item2) => typeof item2 !== "string" ? String(item2) : item2)).flat().map((value) => ({
      label: value,
      value
    })).filter((obj, index, self) => index === self.findIndex((o) => o.label === obj.label && o.value === obj.value));
  }
  onCloseListbox() {
    this.poSearchInput.nativeElement.focus();
    this.controlListboxVisibility(false);
    this.isFiltering = false;
  }
  onListboxClick(option, event) {
    if (event) {
      event.stopPropagation();
    }
    if (!event || event.code === "Enter") {
      this.listboxItemclicked = true;
    }
    this.poSearchInput.nativeElement.value = option.value;
    this.listboxOnClick.emit(option.value);
    this.onCloseListbox();
    if (this.type === "action") {
      this.listboxItemclicked = false;
      this.onSearchChange(option.value.toString(), true, true);
    }
  }
  onBlur() {
    if (this.listboxOpen) {
      if (!this.poListbox.items.length) {
        this.controlListboxVisibility(false);
      } else {
        this.focusItem();
      }
    }
  }
  onKeyDown(event) {
    const key = event.keyCode;
    if (event.shiftKey && key === PoKeyCodeEnum.tab) {
      this.controlListboxVisibility(false);
      return;
    }
    if (key === PoKeyCodeEnum.tab) {
      this.controlListboxVisibility(false);
      return;
    }
    if (key === PoKeyCodeEnum.arrowDown) {
      event.preventDefault();
      if (!this.listboxOpen) {
        return;
      }
      this.focusItem();
      this.controlListboxVisibility(true);
      return;
    }
    if (key === PoKeyCodeEnum.esc) {
      this.controlListboxVisibility(false);
      this.poSearchInput.nativeElement.focus();
    }
    if (key === PoKeyCodeEnum.enter && this.listboxOpen) {
      this.controlListboxVisibility(false);
      this.isFiltering = false;
    }
  }
  focusItem() {
    const listboxItemList = document.querySelectorAll(".po-listbox-item");
    setTimeout(() => {
      Array.from(listboxItemList).forEach((el) => {
        el.tabIndex = -1;
        el.classList.remove("cdk-option-active");
      });
      const firstOption = listboxItemList[0];
      firstOption.focus();
      firstOption.classList.add("cdk-option-active");
    });
  }
  setContainerPosition() {
    if (this.poListboxContainerElement && this.poSearchInput) {
      this.controlPosition.setElements(this.poListboxContainerElement.nativeElement, poSearchContainerOffset, this.poSearchInput, ["top", "bottom"], true);
      this.adjustContainerPosition();
    }
  }
  adjustContainerPosition() {
    if (this.poListboxContainerElement && this.poSearchInput) {
      this.controlPosition.adjustPosition(poSearchContainerPositionDefault);
    }
  }
  controlListboxVisibility(toOpen) {
    toOpen ? this.openListbox() : this.closeListbox();
  }
  openListbox() {
    this.listboxOpen = true;
    this.changeDetector.detectChanges();
    this.initializeListeners();
    this.poSearchInput.nativeElement.focus();
    this.setContainerPosition();
  }
  closeListbox() {
    this.listboxOpen = false;
    this.changeDetector.detectChanges();
    this.removeListeners();
  }
  clickedOutsideInput(event) {
    if (this.listboxOpen && !this.poSearchInput.nativeElement.contains(event.target) && (!this.poListboxElement || !this.poListboxElement.nativeElement.contains(event.target))) {
      this.controlListboxVisibility(false);
    }
  }
  initializeListeners() {
    this.removeListeners();
    this.clickoutListener = this.renderer.listen("document", "click", (event) => {
      this.clickedOutsideInput(event);
    });
    this.eventResizeListener = this.renderer.listen("window", "resize", () => {
      setTimeout(() => this.adjustContainerPosition(), 250);
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  removeListeners() {
    if (this.clickoutListener) {
      this.clickoutListener();
    }
    if (this.eventResizeListener) {
      this.eventResizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
  }
  onScroll = () => {
    this.adjustContainerPosition();
  };
  getInputValue() {
    return this.poSearchInput.nativeElement.value;
  }
  createDropdownFilterSelect() {
    this.searchFilterSelectActions = [];
    if (!this.filterSelect) {
      return;
    }
    this.filterSelect.forEach((filterOption) => {
      const selectOption = {
        label: filterOption.label,
        action: () => this.changeFilterSelect(filterOption),
        selected: this.isSelected(filterOption)
      };
      this.searchFilterSelectActions.push(selectOption);
    });
    this.changeFilterSelect(this.filterSelect[0]);
  }
  isSelected(filterOption) {
    return this.searchFilterSelectLabel === filterOption.label;
  }
  changeFilterSelect(filterOption) {
    this.searchFilterSelectLabel = filterOption.label;
    this.filterKeys = Array.isArray(filterOption.value) ? [...filterOption.value] : [filterOption.value];
    if (!this.searchFilterSelectActions) {
      return;
    }
    this.searchFilterSelectActions.map((action) => action.selected = false);
    const selectAction = this.searchFilterSelectActions.find((action) => action.label === this.searchFilterSelectLabel);
    selectAction.selected = true;
    this.searchFilter = {
      filter: filterOption.label === this.literals.all ? ["all"] : filterOption.value
    };
    this.poSearchInput.nativeElement.focus();
    if (this.type === "action") {
      this.onSearchChange(this.getInputValue(), true);
    }
  }
  static ɵfac = function PoSearchComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSearchComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoControlPositionService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoSearchComponent,
    selectors: [["po-search"]],
    viewQuery: function PoSearchComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$D, 7, ElementRef);
        ɵɵviewQuery(_c1$d, 5, ElementRef);
        ɵɵviewQuery(_c2$5, 5, ElementRef);
        ɵɵviewQuery(_c3$3, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poSearchInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poListboxContainerElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poListboxElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poListbox = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoControlPositionService]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 13,
    vars: 20,
    consts: [["poSearchInput", ""], ["poListboxContainerElement", ""], ["poListbox", "", "poListboxElement", ""], [1, "po-search"], ["class", "po-search-select", 4, "ngIf"], ["class", "po-search-icon", 4, "ngIf"], ["type", "text", 1, "po-search-input", 3, "input", "keyup.enter", "keydown", "blur", "ariaLabel", "disabled", "placeholder"], [1, "po-search-buttons"], ["class", "po-search-button po-search-button-clean", "type", "button", 3, "ariaLabel", "click", "keydown.enter", 4, "ngIf"], ["class", "po-search-button po-search-button-trigger", "type", "button", 3, "ariaLabel", "disabled", "click", "keydown.enter", 4, "ngIf"], [1, "po-search-listbox-container", 3, "hidden"], ["p-type", "option", 3, "p-selectcombo-item", "p-close", "p-items", "p-visible", "p-filter-mode", "p-should-mark-letter", "p-filtering", "p-search-value"], [1, "po-search-select"], [3, "p-label", "p-disabled", "p-actions"], [1, "po-search-icon"], [3, "p-icon"], ["type", "button", 1, "po-search-button", "po-search-button-clean", 3, "click", "keydown.enter", "ariaLabel"], [1, "po-icon-input"], ["type", "button", 1, "po-search-button", "po-search-button-trigger", 3, "click", "keydown.enter", "ariaLabel", "disabled"]],
    template: function PoSearchComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 3);
        ɵɵtemplate(1, PoSearchComponent_div_1_Template, 2, 3, "div", 4)(2, PoSearchComponent_div_2_Template, 2, 1, "div", 5);
        ɵɵelementStart(3, "input", 6, 0);
        ɵɵlistener("input", function PoSearchComponent_Template_input_input_3_listener($event) {
          ɵɵrestoreView(_r1);
          ctx.onSearchChange($event.target.value, false);
          return ɵɵresetView(ctx.onSearchChange($event.target.value, ctx.type === "action" ? true : false));
        })("keyup.enter", function PoSearchComponent_Template_input_keyup_enter_3_listener($event) {
          ɵɵrestoreView(_r1);
          ctx.listboxOpen ? ctx.closeListbox() : ctx.onSearchChange($event.target.value, ctx.type === "trigger" ? true : false, true);
          return ɵɵresetView(ctx.closeListbox());
        })("keydown", function PoSearchComponent_Template_input_keydown_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDown($event));
        })("blur", function PoSearchComponent_Template_input_blur_3_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onBlur());
        });
        ɵɵelementEnd();
        ɵɵelementStart(5, "div", 7);
        ɵɵtemplate(6, PoSearchComponent_button_6_Template, 2, 1, "button", 8)(7, PoSearchComponent_button_7_Template, 2, 3, "button", 9);
        ɵɵelementEnd()();
        ɵɵelementStart(8, "div", 10, 1)(10, "po-listbox", 11, 2);
        ɵɵlistener("p-selectcombo-item", function PoSearchComponent_Template_po_listbox_p_selectcombo_item_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onListboxClick($event, $event.event));
        })("p-close", function PoSearchComponent_Template_po_listbox_p_close_10_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onCloseListbox());
        });
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        const poSearchInput_r5 = ɵɵreference(4);
        ɵɵclassProp("po-search-disabled", ctx.disabled);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.filterSelect);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "action");
        ɵɵadvance();
        ɵɵclassProp("po-search-input-clean", !!poSearchInput_r5.value && !ctx.disabled)("po-search-input-trigger", ctx.type === "trigger");
        ɵɵproperty("ariaLabel", ctx.ariaLabel)("disabled", ctx.disabled)("placeholder", ctx.literals.search);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", !!poSearchInput_r5.value && !ctx.disabled);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "trigger");
        ɵɵadvance();
        ɵɵproperty("hidden", !ctx.listboxOpen);
        ɵɵadvance(2);
        ɵɵproperty("p-items", ctx.listboxFilteredItems)("p-visible", ctx.listboxOpen)("p-filter-mode", ctx.filterType)("p-should-mark-letter", ctx.shouldMarkLetters)("p-filtering", ctx.isFiltering)("p-search-value", ctx.getInputValue());
      }
    },
    dependencies: [NgIf, PoCleanComponent, PoIconComponent, PoListBoxComponent, PoDropdownComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSearchComponent, [{
    type: Component,
    args: [{
      selector: "po-search",
      providers: [PoControlPositionService],
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<div class="po-search" [class.po-search-disabled]="disabled">
  <div class="po-search-select" *ngIf="filterSelect">
    <po-dropdown [p-label]="searchFilterSelectLabel" [p-disabled]="disabled" [p-actions]="searchFilterSelectActions">
    </po-dropdown>
  </div>

  <div *ngIf="type === 'action'" class="po-search-icon">
    <po-icon [p-icon]="icon ? icon : 'ICON_SEARCH'"></po-icon>
  </div>

  <input
    #poSearchInput
    class="po-search-input"
    type="text"
    [ariaLabel]="ariaLabel"
    [class.po-search-input-clean]="!!poSearchInput.value && !disabled"
    [class.po-search-input-trigger]="type === 'trigger'"
    [disabled]="disabled"
    [placeholder]="literals.search"
    (input)="
      onSearchChange($event.target.value, false); onSearchChange($event.target.value, type === 'action' ? true : false)
    "
    (keyup.enter)="
      listboxOpen ? closeListbox() : onSearchChange($event.target.value, type === 'trigger' ? true : false, true);
      closeListbox()
    "
    (keydown)="onKeyDown($event)"
    (blur)="onBlur()"
  />

  <div class="po-search-buttons">
    <button
      *ngIf="!!poSearchInput.value && !disabled"
      class="po-search-button po-search-button-clean"
      type="button"
      [ariaLabel]="literals.clean"
      (click)="clearSearch()"
      (keydown.enter)="clearSearch()"
    >
      <po-clean class="po-icon-input"></po-clean>
    </button>

    <button
      *ngIf="type === 'trigger'"
      class="po-search-button po-search-button-trigger"
      type="button"
      [ariaLabel]="literals.search"
      (click)="onSearchChange(poSearchInput.value, true, true)"
      (keydown.enter)="onSearchChange(poSearchInput.value, true, true)"
      [disabled]="disabled"
    >
      <po-icon [p-icon]="icon ? icon : 'ICON_SEARCH'"> </po-icon>
    </button>
  </div>
</div>

<div #poListboxContainerElement class="po-search-listbox-container" [hidden]="!listboxOpen">
  <po-listbox
    #poListbox
    #poListboxElement
    p-type="option"
    [p-items]="listboxFilteredItems"
    (p-selectcombo-item)="onListboxClick($event, $event.event)"
    [p-visible]="listboxOpen"
    [p-filter-mode]="filterType"
    [p-should-mark-letter]="shouldMarkLetters"
    [p-filtering]="isFiltering"
    [p-search-value]="getInputValue()"
    (p-close)="onCloseListbox()"
  ></po-listbox>
</div>
`
    }]
  }], () => [{
    type: PoLanguageService
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: PoControlPositionService
  }], {
    poSearchInput: [{
      type: ViewChild,
      args: ["poSearchInput", {
        read: ElementRef,
        static: true
      }]
    }],
    poListboxContainerElement: [{
      type: ViewChild,
      args: ["poListboxContainerElement", {
        read: ElementRef
      }]
    }],
    poListboxElement: [{
      type: ViewChild,
      args: ["poListboxElement", {
        read: ElementRef
      }]
    }],
    poListbox: [{
      type: ViewChild,
      args: ["poListbox"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSearchComponent, {
    className: "PoSearchComponent",
    filePath: "lib/components/po-search/po-search.component.ts",
    lineNumber: 65
  });
})();
var PoSearchModule = class _PoSearchModule {
  static ɵfac = function PoSearchModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSearchModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoSearchModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoCleanModule, PoIconModule, PoLoadingModule, PoAccordionModule, FormsModule, PoListBoxModule, PoDropdownModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSearchModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoCleanModule, PoIconModule, PoLoadingModule, PoAccordionModule, FormsModule, PoListBoxModule, PoDropdownModule],
      declarations: [PoSearchComponent],
      exports: [PoSearchComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoSearchModule, {
    declarations: [PoSearchComponent],
    imports: [CommonModule, PoCleanModule, PoIconModule, PoLoadingModule, PoAccordionModule, FormsModule, PoListBoxModule, PoDropdownModule],
    exports: [PoSearchComponent]
  });
})();
var PoTableModule = class _PoTableModule {
  static ɵfac = function PoTableModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTableModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoTableModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [DecimalPipe],
    imports: [CommonModule, FormsModule, ScrollingModule, DragDropModule, RouterModule, PoButtonModule, PoCheckboxGroupModule, PoContainerModule, PoLoadingModule, PoModalModule, PoPopoverModule, PoPopupModule, PoTagModule, PoTimeModule, PoTooltipModule, PoIconModule, PoCheckboxModule, PoRadioModule, PoLinkModule, PoPageSlideModule, PoSwitchModule, PoSearchModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ScrollingModule, DragDropModule, RouterModule, PoButtonModule, PoCheckboxGroupModule, PoContainerModule, PoLoadingModule, PoModalModule, PoPopoverModule, PoPopupModule, PoTagModule, PoTimeModule, PoTooltipModule, PoIconModule, PoCheckboxModule, PoRadioModule, PoLinkModule, PoPageSlideModule, PoSwitchModule, PoSearchModule],
      declarations: [PoTableComponent, PoTableColumnIconComponent, PoTableColumnLabelComponent, PoTableColumnLinkComponent, PoTableColumnManagerComponent, PoTableListManagerComponent, PoTableDetailComponent, PoTableIconComponent, PoTableRowTemplateDirective, PoTableShowSubtitleComponent, PoTableSubtitleCircleComponent, PoTableSubtitleFooterComponent, PoTableCellTemplateDirective, PoTableColumnTemplateDirective, PoTableColumnFrozenDirective],
      exports: [PoTableComponent, PoTableRowTemplateDirective, PoTableCellTemplateDirective, PoTableColumnTemplateDirective],
      providers: [DecimalPipe]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTableModule, {
    declarations: [PoTableComponent, PoTableColumnIconComponent, PoTableColumnLabelComponent, PoTableColumnLinkComponent, PoTableColumnManagerComponent, PoTableListManagerComponent, PoTableDetailComponent, PoTableIconComponent, PoTableRowTemplateDirective, PoTableShowSubtitleComponent, PoTableSubtitleCircleComponent, PoTableSubtitleFooterComponent, PoTableCellTemplateDirective, PoTableColumnTemplateDirective, PoTableColumnFrozenDirective],
    imports: [CommonModule, FormsModule, ScrollingModule, DragDropModule, RouterModule, PoButtonModule, PoCheckboxGroupModule, PoContainerModule, PoLoadingModule, PoModalModule, PoPopoverModule, PoPopupModule, PoTagModule, PoTimeModule, PoTooltipModule, PoIconModule, PoCheckboxModule, PoRadioModule, PoLinkModule, PoPageSlideModule, PoSwitchModule, PoSearchModule],
    exports: [PoTableComponent, PoTableRowTemplateDirective, PoTableCellTemplateDirective, PoTableColumnTemplateDirective]
  });
})();
ɵɵsetComponentScope(PoTableComponent, [NgClass, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkDropList, CdkDrag, CdkDragHandle, PoButtonComponent, PoContainerComponent, PoLoadingOverlayComponent, PoModalComponent, PoPopupComponent, PoTooltipDirective, PoIconComponent, PoCheckboxComponent, PoRadioComponent, PoSearchComponent, PoTableColumnIconComponent, PoTableColumnLabelComponent, PoTableColumnLinkComponent, PoTableColumnManagerComponent, PoTableDetailComponent, PoTableSubtitleCircleComponent, PoTableSubtitleFooterComponent, PoTableColumnFrozenDirective], [LowerCasePipe, TitleCasePipe, CurrencyPipe, DatePipe, PoTimePipe]);
var _c0$C = ["container"];
var _c1$c = ["divElement"];
var _c2$4 = ["listbox"];
var PoMultiselectDropdownComponent = class _PoMultiselectDropdownComponent {
  cd;
  /** Propriedade que indica se deve exibir o loading. */
  isServerSearching = false;
  /** Propriedade que indica se o campo de pesquisa deverá ser escondido. */
  hideSearch = false;
  /** Propriedade que que recebe as literais definidas no componente `po-multiselect`. */
  literals;
  /** Placeholder do campo de pesquisa. */
  placeholderSearch;
  /** Propriedade que recebe a lista de opções selecionadas. */
  selectedOptions = [];
  /** Propriedade que recebe a lista com todas as opções. */
  options = [];
  /** Propriedade que recebe a lista de opções que deverão ser criadas no dropdown. */
  visibleOptions = [];
  /** Propriedade que indica se o campo "Selecionar todos" deverá ser escondido. */
  hideSelectAll = false;
  fieldValue;
  fieldLabel;
  multiselectTemplate;
  containerWidth;
  /** Evento disparado a cada tecla digitada na pesquisa. */
  changeSearch = new EventEmitter();
  /** Evento disparado a cada alteração na lista das opções selecionadas. */
  change = new EventEmitter();
  /**
   * Evento disparado quando for detectada uma ação que necessite fechar o dropdown.
   * Por exemplo, no caso de ser teclado TAB dentro do dropdown, então é disparado este evento
   * para notificar o componente principal que deve fechar o dropdown.
   */
  closeDropdown = new EventEmitter();
  container;
  divElement;
  listbox;
  scrollTop = 0;
  show = false;
  constructor(cd) {
    this.cd = cd;
  }
  get hasOptions() {
    return !!this.options?.length;
  }
  scrollTo(index) {
    this.scrollTop = index <= 2 ? 0 : index * 44 - 88;
    this.cd.markForCheck();
  }
  isSelectedItem(option) {
    return this.selectedOptions.some((selectedItem) => selectedItem[this.fieldValue] === option[this.fieldValue]);
  }
  clickItem(check, options) {
    if (options) {
      this.updateSelectedValues(check, options);
    } else {
      const {
        selected,
        option
      } = check;
      this.updateSelectedValues(selected, option);
    }
  }
  onClickSelectAll() {
    const selectedValues = this.selectedOptions.map(({
      [this.fieldValue]: value
    }) => value);
    if (this.everyVisibleOptionsSelected(selectedValues)) {
      this.selectedOptions = [];
    } else {
      this.selectedOptions = this.uniqueSelectedOptions(selectedValues);
    }
    this.change.emit(this.selectedOptions);
  }
  updateSelectedValues(checked, option) {
    if (checked) {
      this.selectedOptions.push(option);
    } else {
      this.selectedOptions = this.selectedOptions.filter((selectedOption) => selectedOption[this.fieldValue] !== option[this.fieldValue]);
    }
    this.change.emit(this.selectedOptions);
  }
  everyVisibleOptionsSelected(selectedValues) {
    return this.visibleOptions.every((visibleOption) => selectedValues.includes(visibleOption[this.fieldValue]));
  }
  someVisibleOptionsSelected(selectedValues) {
    return this.visibleOptions.some((visibleOption) => selectedValues.includes(visibleOption[this.fieldValue]));
  }
  getStateSelectAll() {
    const selectedValues = this.selectedOptions.map(({
      [this.fieldValue]: value
    }) => value);
    if (this.everyVisibleOptionsSelected(selectedValues)) {
      return true;
    } else if (this.someVisibleOptionsSelected(selectedValues)) {
      return null;
    } else {
      return false;
    }
  }
  callChangeSearch(event) {
    this.changeSearch.emit(event);
  }
  controlVisibility(toOpen) {
    this.show = toOpen;
    setTimeout(() => {
      if (toOpen && this.listbox?.searchElement && !this.hideSearch) {
        this.listbox.searchElement.setFocus();
        this.listbox.searchElement.clean();
      }
    });
    this.cd.markForCheck();
  }
  uniqueSelectedOptions(selectedValues) {
    const newSelectedOptions = [...this.selectedOptions];
    for (const visibleOption of this.visibleOptions) {
      if (!selectedValues.includes(visibleOption[this.fieldValue])) {
        newSelectedOptions.push(visibleOption);
      }
    }
    return newSelectedOptions;
  }
  static ɵfac = function PoMultiselectDropdownComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMultiselectDropdownComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoMultiselectDropdownComponent,
    selectors: [["po-multiselect-dropdown"]],
    viewQuery: function PoMultiselectDropdownComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$C, 7, ElementRef);
        ɵɵviewQuery(_c1$c, 7, ElementRef);
        ɵɵviewQuery(_c2$4, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.divElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listbox = _t.first);
      }
    },
    inputs: {
      isServerSearching: [0, "p-searching", "isServerSearching"],
      hideSearch: [0, "p-hide-search", "hideSearch"],
      literals: [0, "p-literals", "literals"],
      placeholderSearch: [0, "p-placeholder-search", "placeholderSearch"],
      selectedOptions: [0, "p-selected-options", "selectedOptions"],
      options: [0, "p-options", "options"],
      visibleOptions: [0, "p-visible-options", "visibleOptions"],
      hideSelectAll: [0, "p-hide-select-all", "hideSelectAll"],
      fieldValue: [0, "p-field-value", "fieldValue"],
      fieldLabel: [0, "p-field-label", "fieldLabel"],
      multiselectTemplate: [0, "p-multiselect-template", "multiselectTemplate"],
      containerWidth: [0, "p-container-width", "containerWidth"]
    },
    outputs: {
      changeSearch: "p-change-search",
      change: "p-change",
      closeDropdown: "p-close-dropdown"
    },
    standalone: false,
    decls: 7,
    vars: 16,
    consts: [["container", ""], ["divElement", ""], ["listbox", ""], [1, "po-multiselect-container", 3, "hidden"], [3, "scrollTop"], ["p-type", "check", 3, "p-change", "p-change-all", "p-change-search", "p-close", "p-items", "p-selected-options", "p-checkboxAllValue", "p-field-value", "p-field-value-search", "p-field-label", "p-literal-search", "p-literals", "p-is-searching", "p-hide-search", "p-hide-select-all", "p-template", "p-placeholder-search", "p-container-width"]],
    template: function PoMultiselectDropdownComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 3, 0)(2, "div", 4, 1);
        ɵɵelementContainerStart(4);
        ɵɵelementStart(5, "po-listbox", 5, 2);
        ɵɵlistener("p-change", function PoMultiselectDropdownComponent_Template_po_listbox_p_change_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.clickItem($event));
        })("p-change-all", function PoMultiselectDropdownComponent_Template_po_listbox_p_change_all_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onClickSelectAll());
        })("p-change-search", function PoMultiselectDropdownComponent_Template_po_listbox_p_change_search_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.callChangeSearch($event));
        })("p-close", function PoMultiselectDropdownComponent_Template_po_listbox_p_close_5_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.closeDropdown.emit());
        });
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("hidden", !ctx.show);
        ɵɵadvance(2);
        ɵɵproperty("scrollTop", ctx.scrollTop);
        ɵɵadvance(3);
        ɵɵproperty("p-items", ctx.visibleOptions)("p-selected-options", ctx.selectedOptions)("p-checkboxAllValue", ctx.getStateSelectAll())("p-field-value", ctx.fieldValue)("p-field-value-search", ctx.fieldValue)("p-field-label", ctx.fieldLabel)("p-literal-search", ctx.literals)("p-literals", ctx.literals)("p-is-searching", ctx.isServerSearching)("p-hide-search", ctx.hideSearch)("p-hide-select-all", ctx.hideSelectAll)("p-template", ctx.multiselectTemplate)("p-placeholder-search", ctx.placeholderSearch)("p-container-width", ctx.containerWidth);
      }
    },
    dependencies: [PoListBoxComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMultiselectDropdownComponent, [{
    type: Component,
    args: [{
      selector: "po-multiselect-dropdown",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div #container class="po-multiselect-container" [hidden]="!show">\n  <div [scrollTop]="scrollTop" #divElement>\n    <ng-container>\n      <po-listbox\n        #listbox\n        p-type="check"\n        [p-items]="visibleOptions"\n        [p-selected-options]="selectedOptions"\n        [p-checkboxAllValue]="getStateSelectAll()"\n        [p-field-value]="fieldValue"\n        [p-field-value-search]="fieldValue"\n        [p-field-label]="fieldLabel"\n        [p-literal-search]="literals"\n        [p-literals]="literals"\n        [p-is-searching]="isServerSearching"\n        [p-hide-search]="hideSearch"\n        [p-hide-select-all]="hideSelectAll"\n        [p-template]="multiselectTemplate"\n        [p-placeholder-search]="placeholderSearch"\n        (p-change)="clickItem($event)"\n        (p-change-all)="onClickSelectAll()"\n        (p-change-search)="callChangeSearch($event)"\n        (p-close)="closeDropdown.emit()"\n        [p-container-width]="containerWidth"\n      >\n      </po-listbox>\n    </ng-container>\n  </div>\n</div>\n'
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    isServerSearching: [{
      type: Input,
      args: ["p-searching"]
    }],
    hideSearch: [{
      type: Input,
      args: ["p-hide-search"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    placeholderSearch: [{
      type: Input,
      args: ["p-placeholder-search"]
    }],
    selectedOptions: [{
      type: Input,
      args: ["p-selected-options"]
    }],
    options: [{
      type: Input,
      args: ["p-options"]
    }],
    visibleOptions: [{
      type: Input,
      args: ["p-visible-options"]
    }],
    hideSelectAll: [{
      type: Input,
      args: ["p-hide-select-all"]
    }],
    fieldValue: [{
      type: Input,
      args: ["p-field-value"]
    }],
    fieldLabel: [{
      type: Input,
      args: ["p-field-label"]
    }],
    multiselectTemplate: [{
      type: Input,
      args: ["p-multiselect-template"]
    }],
    containerWidth: [{
      type: Input,
      args: ["p-container-width"]
    }],
    changeSearch: [{
      type: Output,
      args: ["p-change-search"]
    }],
    change: [{
      type: Output,
      args: ["p-change"]
    }],
    closeDropdown: [{
      type: Output,
      args: ["p-close-dropdown"]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ElementRef,
        static: true
      }]
    }],
    divElement: [{
      type: ViewChild,
      args: ["divElement", {
        read: ElementRef,
        static: true
      }]
    }],
    listbox: [{
      type: ViewChild,
      args: ["listbox"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMultiselectDropdownComponent, {
    className: "PoMultiselectDropdownComponent",
    filePath: "lib/components/po-field/po-multiselect/po-multiselect-dropdown/po-multiselect-dropdown.component.ts",
    lineNumber: 30
  });
})();
var PoFieldModule = class _PoFieldModule {
  static ɵfac = function PoFieldModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoFieldModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoFieldModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, FormsModule.withConfig({
      callSetDisabledState: "whenDisabledForLegacyCode"
    }), OverlayModule, PoButtonGroupModule, PoButtonModule, PoCleanModule, PoCalendarModule, PoCheckboxGroupModule, PoRadioGroupModule, PoContainerModule, PoDatepickerModule, PoDisclaimerGroupModule, PoDisclaimerModule, PoFieldContainerModule, PoLoadingModule, PoModalModule, PoProgressModule, PoServicesModule, PoTableModule, PoTooltipModule, PoIconModule, PoCheckboxModule, PoRadioModule, PoLabelModule, PoListBoxModule, PoSwitchModule, PoTagModule, PoCheckboxGroupModule, PoRadioGroupModule, PoCleanModule, PoDatepickerModule, PoFieldContainerModule, PoCheckboxModule, PoRadioModule, PoLabelModule, PoSwitchModule, PoTagModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, FormsModule.withConfig({
        callSetDisabledState: "whenDisabledForLegacyCode"
      }), OverlayModule, PoButtonGroupModule, PoButtonModule, PoCleanModule, PoCalendarModule, PoCheckboxGroupModule, PoRadioGroupModule, PoContainerModule, PoDatepickerModule, PoDisclaimerGroupModule, PoDisclaimerModule, PoFieldContainerModule, PoLoadingModule, PoModalModule, PoProgressModule, PoServicesModule, PoTableModule, PoTooltipModule, PoIconModule, PoCheckboxModule, PoRadioModule, PoLabelModule, PoListBoxModule, PoSwitchModule, PoTagModule],
      exports: [PoCheckboxGroupModule, PoRadioGroupModule, PoCleanModule, PoDatepickerModule, PoComboComponent, PoComboOptionTemplateDirective, PoMultiselectOptionTemplateDirective, PoDecimalComponent, PoDatepickerRangeComponent, PoEmailComponent, PoFieldContainerModule, PoInputComponent, PoLoginComponent, PoLookupComponent, PoLookupModalComponent, PoMultiselectComponent, PoNumberComponent, PoPasswordComponent, PoRichTextComponent, PoSelectComponent, PoTextareaComponent, PoUploadComponent, PoUrlComponent, PoCheckboxModule, PoRadioModule, PoLabelModule, PoSwitchModule, PoTagModule],
      declarations: [PoComboComponent, PoComboOptionTemplateDirective, PoMultiselectOptionTemplateDirective, PoDecimalComponent, PoDatepickerRangeComponent, PoEmailComponent, PoInputComponent, PoLoginComponent, PoLookupComponent, PoLookupModalComponent, PoMultiselectComponent, PoMultiselectDropdownComponent, PoNumberComponent, PoPasswordComponent, PoRichTextBodyComponent, PoRichTextComponent, PoRichTextImageModalComponent, PoRichTextLinkModalComponent, PoRichTextToolbarComponent, PoSelectComponent, PoTextareaComponent, PoUploadComponent, PoUploadDragDropComponent, PoUploadDragDropDirective, PoUploadDragDropAreaOverlayComponent, PoUploadDragDropAreaComponent, PoUploadFileRestrictionsComponent, PoUrlComponent],
      providers: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoFieldModule, {
    declarations: [PoComboComponent, PoComboOptionTemplateDirective, PoMultiselectOptionTemplateDirective, PoDecimalComponent, PoDatepickerRangeComponent, PoEmailComponent, PoInputComponent, PoLoginComponent, PoLookupComponent, PoLookupModalComponent, PoMultiselectComponent, PoMultiselectDropdownComponent, PoNumberComponent, PoPasswordComponent, PoRichTextBodyComponent, PoRichTextComponent, PoRichTextImageModalComponent, PoRichTextLinkModalComponent, PoRichTextToolbarComponent, PoSelectComponent, PoTextareaComponent, PoUploadComponent, PoUploadDragDropComponent, PoUploadDragDropDirective, PoUploadDragDropAreaOverlayComponent, PoUploadDragDropAreaComponent, PoUploadFileRestrictionsComponent, PoUrlComponent],
    imports: [CommonModule, FormsModule, FormsModule, OverlayModule, PoButtonGroupModule, PoButtonModule, PoCleanModule, PoCalendarModule, PoCheckboxGroupModule, PoRadioGroupModule, PoContainerModule, PoDatepickerModule, PoDisclaimerGroupModule, PoDisclaimerModule, PoFieldContainerModule, PoLoadingModule, PoModalModule, PoProgressModule, PoServicesModule, PoTableModule, PoTooltipModule, PoIconModule, PoCheckboxModule, PoRadioModule, PoLabelModule, PoListBoxModule, PoSwitchModule, PoTagModule],
    exports: [PoCheckboxGroupModule, PoRadioGroupModule, PoCleanModule, PoDatepickerModule, PoComboComponent, PoComboOptionTemplateDirective, PoMultiselectOptionTemplateDirective, PoDecimalComponent, PoDatepickerRangeComponent, PoEmailComponent, PoFieldContainerModule, PoInputComponent, PoLoginComponent, PoLookupComponent, PoLookupModalComponent, PoMultiselectComponent, PoNumberComponent, PoPasswordComponent, PoRichTextComponent, PoSelectComponent, PoTextareaComponent, PoUploadComponent, PoUrlComponent, PoCheckboxModule, PoRadioModule, PoLabelModule, PoSwitchModule, PoTagModule]
  });
})();
ɵɵsetComponentScope(PoMultiselectComponent, function() {
  return [NgClass, NgForOf, NgIf, NgTemplateOutlet, CdkConnectedOverlay, CdkOverlayOrigin, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent, PoTagComponent, PoMultiselectDropdownComponent];
}, []);
var PoInfoOrientation;
(function(PoInfoOrientation2) {
  PoInfoOrientation2["Horizontal"] = "horizontal";
  PoInfoOrientation2["Vertical"] = "vertical";
})(PoInfoOrientation || (PoInfoOrientation = {}));
var poInfoOrientationDefault = PoInfoOrientation.Vertical;
var PoInfoBaseComponent = class _PoInfoBaseComponent {
  /** Valor do rótulo a ser exibido. */
  label;
  /**
   * Ao informar uma URL, o conteúdo será exibido na forma de um *link* e ao ser clicado será redirecionado para a URL informada.
   *
   * > Caso informar `http://` será aberto uma nova aba.
   * Caso informar um caminho relativo, exemplo: `/customers`, será aberto na aba atual.
   *
   */
  url;
  /** Valor do conteúdo a ser exibido. */
  value;
  poInfoOrientation = PoInfoOrientation;
  _labelSize;
  _orientation = poInfoOrientationDefault;
  /**
   * @optional
   *
   * @description
   *
   * Quantidade de [colunas](/guides/grid-system) usadas para a exibição da `p-label` quando o componente for
   * utilizado na orientação horizontal.
   *
   * Valores válidos:
   *  - `[1 .. 11]`
   *
   * > A propriedade `p-value` recebe o número de colunas restantes, por exemplo, se definido 3 colunas a mesma assume 9 colunas.
   */
  set labelSize(value) {
    if (isNaN(parseInt(value, 10))) {
      this._labelSize = void 0;
    } else {
      value = parseInt(value, 10);
      this._labelSize = value < 1 || value > 11 ? void 0 : value;
    }
  }
  get labelSize() {
    return this._labelSize;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o layout de exibição.
   *
   * > Quando definido na horizontal, pode-se utilizar a propriedade `p-label-size` para um maior controle das informações exibidas.
   *
   * @default `vertical`
   */
  set orientation(value) {
    this._orientation = Object.values(PoInfoOrientation).includes(value) ? value : poInfoOrientationDefault;
  }
  get orientation() {
    return this._orientation;
  }
  static ɵfac = function PoInfoBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoInfoBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoInfoBaseComponent,
    inputs: {
      label: [0, "p-label", "label"],
      url: [0, "p-url", "url"],
      value: [0, "p-value", "value"],
      labelSize: [0, "p-label-size", "labelSize"],
      orientation: [0, "p-orientation", "orientation"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInfoBaseComponent, [{
    type: Directive
  }], null, {
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    url: [{
      type: Input,
      args: ["p-url"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }],
    labelSize: [{
      type: Input,
      args: ["p-label-size"]
    }],
    orientation: [{
      type: Input,
      args: ["p-orientation"]
    }]
  });
})();
function PoInfoComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoInfoComponent_ng_template_6_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoInfoComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoInfoComponent_ng_template_6_ng_container_0_Template, 1, 0, "ng-container", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const externalLink_r2 = ɵɵreference(11);
    const internalLink_r3 = ɵɵreference(13);
    ɵɵproperty("ngIf", ctx_r0.isExternalLink)("ngIfThen", externalLink_r2)("ngIfElse", internalLink_r3);
  }
}
function PoInfoComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.value);
  }
}
function PoInfoComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("href", ctx_r0.url, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.value);
  }
}
function PoInfoComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("routerLink", ctx_r0.url);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.value);
  }
}
var PoInfoComponent = class _PoInfoComponent extends PoInfoBaseComponent {
  get isExternalLink() {
    return isExternalLink(this.url);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoInfoComponent_BaseFactory;
    return function PoInfoComponent_Factory(__ngFactoryType__) {
      return (ɵPoInfoComponent_BaseFactory || (ɵPoInfoComponent_BaseFactory = ɵɵgetInheritedFactory(_PoInfoComponent)))(__ngFactoryType__ || _PoInfoComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoInfoComponent,
    selectors: [["po-info"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 14,
    vars: 16,
    consts: [["infoLink", ""], ["infoValue", ""], ["externalLink", ""], ["internalLink", ""], [1, "po-info"], [1, "po-info-container-title", 3, "ngClass"], [1, "po-info-label"], [3, "ngClass"], [4, "ngIf", "ngIfThen", "ngIfElse"], [1, "po-info-value"], ["target", "_blank", 1, "po-info-value", "po-info-link", 3, "href"], [1, "po-info-value", "po-info-link", 3, "routerLink"]],
    template: function PoInfoComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 4)(1, "div", 5)(2, "span", 6);
        ɵɵtext(3);
        ɵɵelementEnd()();
        ɵɵelementStart(4, "div", 7);
        ɵɵtemplate(5, PoInfoComponent_ng_container_5_Template, 1, 0, "ng-container", 8);
        ɵɵelementEnd()();
        ɵɵtemplate(6, PoInfoComponent_ng_template_6_Template, 1, 3, "ng-template", null, 0, ɵɵtemplateRefExtractor)(8, PoInfoComponent_ng_template_8_Template, 2, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor)(10, PoInfoComponent_ng_template_10_Template, 2, 2, "ng-template", null, 2, ɵɵtemplateRefExtractor)(12, PoInfoComponent_ng_template_12_Template, 2, 2, "ng-template", null, 3, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const infoLink_r4 = ɵɵreference(7);
        const infoValue_r5 = ɵɵreference(9);
        ɵɵclassProp("po-row", ctx.orientation === ctx.poInfoOrientation.Horizontal && ctx.labelSize);
        ɵɵadvance();
        ɵɵclassProp("po-info-label-horizontal", ctx.orientation === ctx.poInfoOrientation.Horizontal)("po-text-nowrap", ctx.orientation === ctx.poInfoOrientation.Horizontal && !ctx.labelSize);
        ɵɵproperty("ngClass", ctx.labelSize && ctx.orientation === ctx.poInfoOrientation.Horizontal ? "po-sm-" + ctx.labelSize : "");
        ɵɵadvance(2);
        ɵɵtextInterpolate1(" ", ctx.orientation === ctx.poInfoOrientation.Horizontal ? ctx.label + ":" : ctx.label, " ");
        ɵɵadvance();
        ɵɵclassProp("po-info-container-content", ctx.orientation !== ctx.poInfoOrientation.Horizontal)("po-info-value-horizontal", ctx.orientation === ctx.poInfoOrientation.Horizontal);
        ɵɵproperty("ngClass", ctx.labelSize && ctx.orientation === ctx.poInfoOrientation.Horizontal ? "po-sm-" + (12 - ctx.labelSize) : "");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.url)("ngIfThen", infoLink_r4)("ngIfElse", infoValue_r5);
      }
    },
    dependencies: [NgClass, NgIf, RouterLink],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInfoComponent, [{
    type: Component,
    args: [{
      selector: "po-info",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: `<div class="po-info" [class.po-row]="orientation === poInfoOrientation.Horizontal && labelSize">
  <div
    class="po-info-container-title"
    [ngClass]="labelSize && orientation === poInfoOrientation.Horizontal ? 'po-sm-' + labelSize : ''"
    [class.po-info-label-horizontal]="orientation === poInfoOrientation.Horizontal"
    [class.po-text-nowrap]="orientation === poInfoOrientation.Horizontal && !labelSize"
  >
    <span class="po-info-label">
      {{ orientation === poInfoOrientation.Horizontal ? label + ':' : label }}
    </span>
  </div>

  <div
    [ngClass]="labelSize && orientation === poInfoOrientation.Horizontal ? 'po-sm-' + (12 - labelSize) : ''"
    [class.po-info-container-content]="orientation !== poInfoOrientation.Horizontal"
    [class.po-info-value-horizontal]="orientation === poInfoOrientation.Horizontal"
  >
    <ng-container *ngIf="url; then infoLink; else infoValue"></ng-container>
  </div>
</div>

<ng-template #infoLink>
  <ng-container *ngIf="isExternalLink; then externalLink; else internalLink"> </ng-container>
</ng-template>

<ng-template #infoValue>
  <span class="po-info-value">{{ value }}</span>
</ng-template>

<ng-template #externalLink>
  <a class="po-info-value po-info-link" [href]="url" target="_blank">{{ value }}</a>
</ng-template>

<ng-template #internalLink>
  <a class="po-info-value po-info-link" [routerLink]="url">{{ value }}</a>
</ng-template>
`
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoInfoComponent, {
    className: "PoInfoComponent",
    filePath: "lib/components/po-info/po-info.component.ts",
    lineNumber: 33
  });
})();
var PoInfoModule = class _PoInfoModule {
  static ɵfac = function PoInfoModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoInfoModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoInfoModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, RouterModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInfoModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule],
      declarations: [PoInfoComponent],
      exports: [PoInfoComponent],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoInfoModule, {
    declarations: [PoInfoComponent],
    imports: [CommonModule, RouterModule],
    exports: [PoInfoComponent]
  });
})();
function getGridColumnsClasses(gridColumns, offsetColumns, grid, offset, pull) {
  const systemGrid = {
    gridSm: grid?.smGrid || gridColumns || 12,
    gridMd: grid?.mdGrid || gridColumns || 6,
    gridLg: grid?.lgGrid || gridColumns || 4,
    gridXl: grid?.xlGrid || gridColumns || 3,
    offsetSm: offset?.smOffset || offsetColumns || 0,
    offsetMd: offset?.mdOffset || offsetColumns || 0,
    offsetLg: offset?.lgOffset || offsetColumns || 0,
    offsetXl: offset?.xlOffset || offsetColumns || 0,
    pullSm: pull?.smPull || 0,
    pullMd: pull?.mdPull || 0,
    pullLg: pull?.lgPull || 0,
    pullXl: pull?.xlPull || 0
  };
  return `po-sm-${systemGrid.gridSm} po-offset-sm-${systemGrid.offsetSm} po-pull-sm-${systemGrid.pullSm} po-md-${systemGrid.gridMd} po-offset-md-${systemGrid.offsetMd} po-pull-md-${systemGrid.pullMd} po-lg-${systemGrid.gridLg} po-offset-lg-${systemGrid.offsetLg} po-pull-lg-${systemGrid.pullLg} po-xl-${systemGrid.gridXl} po-offset-xl-${systemGrid.offsetXl} po-pull-xl-${systemGrid.pullXl}`;
}
function isVisibleField(field) {
  const containsVisible = "visible" in field;
  return containsVisible ? field.visible : true;
}
var PoDynamicFieldType;
(function(PoDynamicFieldType2) {
  PoDynamicFieldType2["Boolean"] = "boolean";
  PoDynamicFieldType2["Currency"] = "currency";
  PoDynamicFieldType2["Decimal"] = "decimal";
  PoDynamicFieldType2["Date"] = "date";
  PoDynamicFieldType2["DateTime"] = "datetime";
  PoDynamicFieldType2["Time"] = "time";
  PoDynamicFieldType2["Number"] = "number";
  PoDynamicFieldType2["String"] = "string";
  PoDynamicFieldType2["Upload"] = "upload";
})(PoDynamicFieldType || (PoDynamicFieldType = {}));
var PoDynamicSharedBase = class _PoDynamicSharedBase {
  visibleFields = [];
  containerFields = [];
  hasContainers = false;
  ensureFieldHasContainer(fields) {
    if (fields && fields.some((field) => field?.container)) {
      const firstFieldIndex = fields.findIndex((field) => field.order === 1);
      if (firstFieldIndex !== -1 && !fields[firstFieldIndex].container) {
        fields[firstFieldIndex].container = "";
      }
    }
  }
  setContainerFields() {
    this.hasContainers = this.visibleFields && this.visibleFields.some((field) => field.container);
    if (this.hasContainers) {
      this.containerFields = this.groupFieldsIntoContainers(this.visibleFields);
    }
  }
  groupFieldsIntoContainers(fields) {
    const groups = [[]];
    return fields.reduce((acc, field) => {
      if (field.container && acc[acc.length - 1].length > 0) acc.push([]);
      acc[acc.length - 1].push(field);
      return acc;
    }, groups);
  }
  static ɵfac = function PoDynamicSharedBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicSharedBase)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoDynamicSharedBase
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicSharedBase, [{
    type: Directive
  }], null, null);
})();
var PoDynamicFormFieldsBaseComponent = class _PoDynamicFormFieldsBaseComponent extends PoDynamicSharedBase {
  titleCasePipe;
  autoFocus;
  disabledForm;
  validate;
  formValidate = new EventEmitter();
  fieldsChange = new EventEmitter();
  // Evento disparado se existir optionsService em visibleField. Necessário resgatar referência do objeto selecionado para quando se tratar de recebimento de opções via serviço.
  objectValue = new EventEmitter();
  validateOnInput;
  _fields;
  _validateFields;
  _value = {};
  // array de objetos que implementam a interface PoDynamicFormField, que serão exibidos no componente.
  set fields(value) {
    this._fields = Array.isArray(value) ? [...value] : [];
  }
  get fields() {
    return this._fields;
  }
  // valor que será utilizado para iniciar valor no componente.
  set value(value) {
    this._value = value && isTypeof(value, "object") ? value : {};
  }
  get value() {
    return this._value;
  }
  set validateFields(value) {
    this._validateFields = Array.isArray(value) ? [...value] : [];
  }
  get validateFields() {
    return this._validateFields;
  }
  constructor(titleCasePipe) {
    super();
    this.titleCasePipe = titleCasePipe;
  }
  compareTo(value, compareTo) {
    return value === compareTo;
  }
  // retorna um array com os objetos configurados e visíveis.
  getVisibleFields() {
    const visibleFields = [];
    this.fields.forEach((field) => {
      if (this.existsProperty(visibleFields, field.property)) {
        this.printError(`"po-dynamic-form" property "${field.property}" está duplicado. Interface: PoDynamicFormField.`);
        return;
      }
      if (!field["property"]) {
        this.printError('"po-dynamic-form" É obrigatório ser especificado um property.');
        return;
      }
      if (isVisibleField(field)) {
        visibleFields.push(this.createField(field));
      }
    });
    const _visibleFields = sortFields(visibleFields);
    this.ensureFieldHasContainer(_visibleFields);
    return _visibleFields;
  }
  // converte um array em string para um array de objetos que contem label e value.
  convertOptions(options) {
    const everyOptionString = options.every((option) => typeof option === "string");
    if (everyOptionString) {
      return options.map((value) => ({
        label: value,
        value
      }));
    }
    return options;
  }
  // cria um novo objeto com as classes de grid system, com control (tipo do componente) e label default.
  createField(field) {
    const control = this.getComponentControl(field);
    const options = !!field.options ? this.convertOptions(field.options) : void 0;
    const focus = this.hasFocus(field);
    const type = field && field.type ? field.type.toLocaleLowerCase() : "string";
    const componentClass = getGridColumnsClasses(field.gridColumns, field.offsetColumns, {
      smGrid: field.gridSmColumns,
      mdGrid: field.gridMdColumns,
      lgGrid: field.gridLgColumns,
      xlGrid: field.gridXlColumns
    }, {
      smOffset: field.offsetSmColumns,
      mdOffset: field.offsetMdColumns,
      lgOffset: field.offsetLgColumns,
      xlOffset: field.offsetXlColumns
    }, {
      smPull: field.gridSmPull,
      mdPull: field.gridMdPull,
      lgPull: field.gridLgPull,
      xlPull: field.gridXlPull
    });
    return __spreadProps(__spreadValues({
      label: this.titleCasePipe.transform(field.property),
      maskFormatModel: this.compareTo(type, PoDynamicFieldType.Time)
    }, field), {
      componentClass,
      control,
      focus,
      options
    });
  }
  existsProperty(fields, property) {
    return fields.some((field) => field.property === property);
  }
  // recupera o componente de acordo com algumas regras do field.
  getComponentControl(field = {}) {
    const type = field && field.type ? field.type.toLocaleLowerCase() : "string";
    const {
      forceBooleanComponentType
    } = field;
    const forceOptionComponent = this.verifyForceOptionComponent(field);
    if (forceBooleanComponentType) {
      return forceBooleanComponentType;
    }
    if (forceOptionComponent) {
      const {
        forceOptionsComponentType
      } = field;
      return forceOptionsComponentType;
    }
    if (this.isNumberType(field, type)) {
      return "number";
    } else if (this.isCurrencyType(field, type) || type === PoDynamicFieldType.Decimal) {
      return "decimal";
    } else if (this.isSelect(field)) {
      return "select";
    } else if (this.isRadioGroup(field)) {
      return "radioGroup";
    } else if (this.isCheckboxGroup(field)) {
      return "checkboxGroup";
    } else if (this.isMultiselect(field)) {
      return "multiselect";
    } else if (this.compareTo(type, PoDynamicFieldType.Boolean)) {
      return "switch";
    } else if (this.compareTo(type, PoDynamicFieldType.Date) || this.compareTo(type, PoDynamicFieldType.DateTime)) {
      return field.range ? "datepickerrange" : "datepicker";
    } else if (this.compareTo(type, PoDynamicFieldType.Time)) {
      field.mask = field.mask || "99:99";
      return "input";
    } else if (this.isCombo(field)) {
      return "combo";
    } else if (this.isLookup(field)) {
      return "lookup";
    } else if (this.isTextarea(field)) {
      return "textarea";
    } else if (this.isPassword(field)) {
      return "password";
    } else if (this.isUpload(field)) {
      return "upload";
    }
    return "input";
  }
  hasFocus(field) {
    return !!this.autoFocus && this.autoFocus === field.property;
  }
  isCheckboxGroup(field) {
    const {
      optionsService,
      optionsMulti,
      options
    } = field;
    return !optionsService && optionsMulti && !!options && options.length <= 3;
  }
  isCombo(field) {
    const {
      optionsService
    } = field;
    return !!optionsService && (isTypeof(optionsService, "string") || this.isComboFilter(optionsService));
  }
  isCurrencyType(field, type) {
    const {
      mask,
      pattern
    } = field;
    return this.compareTo(type, PoDynamicFieldType.Currency) && !mask && !pattern;
  }
  isLookupFilter(object) {
    return object && object.getObjectByValue !== void 0;
  }
  isComboFilter(object) {
    return object && object.getFilteredData !== void 0;
  }
  isLookup(field) {
    const {
      searchService
    } = field;
    return !!searchService && (isTypeof(searchService, "string") || this.isLookupFilter(searchService));
  }
  isMultiselect(field) {
    const {
      optionsService,
      optionsMulti,
      options
    } = field;
    return optionsMulti && (!!optionsService || !!options && options.length > 3);
  }
  isNumberType(field, type) {
    const {
      mask,
      pattern
    } = field;
    return this.compareTo(type, PoDynamicFieldType.Number) && !mask && !pattern;
  }
  isPassword(field) {
    const {
      secret
    } = field;
    return secret;
  }
  isRadioGroup(field) {
    const {
      optionsMulti,
      options
    } = field;
    return !optionsMulti && !!options && options.length <= 3;
  }
  isUpload(field) {
    const {
      url,
      type
    } = field;
    return url && type === "upload";
  }
  verifyForceOptionComponent(field) {
    const {
      optionsMulti,
      optionsService,
      forceOptionsComponentType
    } = field;
    if (forceOptionsComponentType && !optionsMulti && !optionsService) {
      return true;
    }
    return false;
  }
  isSelect(field) {
    const {
      optionsMulti,
      options
    } = field;
    return !optionsMulti && !!options && options.length > 3;
  }
  isTextarea(field) {
    const {
      rows
    } = field;
    return rows && rows >= 3;
  }
  printError(error) {
    console.error(error);
  }
  static ɵfac = function PoDynamicFormFieldsBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicFormFieldsBaseComponent)(ɵɵdirectiveInject(TitleCasePipe));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoDynamicFormFieldsBaseComponent,
    inputs: {
      autoFocus: [0, "p-auto-focus", "autoFocus"],
      disabledForm: [0, "p-disabled-form", "disabledForm"],
      validate: [0, "p-validate", "validate"],
      validateOnInput: [0, "p-validate-on-input", "validateOnInput"],
      fields: [0, "p-fields", "fields"],
      value: [0, "p-value", "value"],
      validateFields: [0, "p-validate-fields", "validateFields"]
    },
    outputs: {
      formValidate: "p-form-validate",
      fieldsChange: "p-fieldsChange",
      objectValue: "p-object-value"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormFieldsBaseComponent, [{
    type: Directive
  }], () => [{
    type: TitleCasePipe
  }], {
    autoFocus: [{
      type: Input,
      args: ["p-auto-focus"]
    }],
    disabledForm: [{
      type: Input,
      args: ["p-disabled-form"]
    }],
    validate: [{
      type: Input,
      args: ["p-validate"]
    }],
    formValidate: [{
      type: Output,
      args: ["p-form-validate"]
    }],
    fieldsChange: [{
      type: Output,
      args: ["p-fieldsChange"]
    }],
    objectValue: [{
      type: Output,
      args: ["p-object-value"]
    }],
    validateOnInput: [{
      type: Input,
      args: ["p-validate-on-input"]
    }],
    fields: [{
      type: Input,
      args: ["p-fields"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }],
    validateFields: [{
      type: Input,
      args: ["p-validate-fields"]
    }]
  });
})();
var _c0$B = (a0) => ({
  $implicit: a0
});
function PoDynamicContainerComponent_ng_template_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoDynamicContainerComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "po-container", 2)(2, "div", 3);
    ɵɵtemplate(3, PoDynamicContainerComponent_ng_template_1_ng_container_3_Template, 1, 0, "ng-container", 4);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const fieldsInContainer_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-title", fieldsInContainer_r1[0].container);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.content)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c0$B, fieldsInContainer_r1));
  }
}
var PoDynamicContainerComponent = class _PoDynamicContainerComponent {
  content;
  fields;
  static ɵfac = function PoDynamicContainerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicContainerComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDynamicContainerComponent,
    selectors: [["po-dynamic-container"]],
    inputs: {
      content: [0, "p-content", "content"],
      fields: [0, "p-fields", "fields"]
    },
    standalone: false,
    decls: 2,
    vars: 1,
    consts: [[1, "po-dynamic-container"], ["ngFor", "", 3, "ngForOf"], [3, "p-title"], [1, "po-row"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function PoDynamicContainerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoDynamicContainerComponent_ng_template_1_Template, 4, 5, "ng-template", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.fields);
      }
    },
    dependencies: [NgForOf, NgTemplateOutlet, PoContainerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicContainerComponent, [{
    type: Component,
    args: [{
      selector: "po-dynamic-container",
      standalone: false,
      template: '<div class="po-dynamic-container">\n  <ng-template ngFor let-fieldsInContainer [ngForOf]="fields">\n    <div>\n      <po-container [p-title]="fieldsInContainer[0].container">\n        <div class="po-row">\n          <ng-container *ngTemplateOutlet="content; context: { $implicit: fieldsInContainer }"> </ng-container>\n        </div>\n      </po-container>\n    </div>\n  </ng-template>\n</div>\n'
    }]
  }], null, {
    content: [{
      type: Input,
      args: ["p-content"]
    }],
    fields: [{
      type: Input,
      args: ["p-fields"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDynamicContainerComponent, {
    className: "PoDynamicContainerComponent",
    filePath: "lib/components/po-dynamic/po-dynamic-container/po-dynamic-container.component.ts",
    lineNumber: 8
  });
})();
var _c0$A = ["component"];
var _c1$b = (a0) => ({
  $implicit: a0
});
function PoDynamicFormFieldsComponent_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoDynamicFormFieldsComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtemplate(1, PoDynamicFormFieldsComponent_div_0_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const poContent_r2 = ɵɵreference(2);
    const poContentContainer_r3 = ɵɵreference(4);
    ɵɵclassProp("po-dynamic", ctx_r0.hasContainers);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.hasContainers ? poContentContainer_r3 : poContent_r2)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c1$b, ctx_r0.hasContainers ? ctx_r0.containerFields : ctx_r0.visibleFields));
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_divider_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-divider", 24);
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    ɵɵproperty("p-label", field_r4.divider);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-datepicker", 25, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_2_Template_po_datepicker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_2_Template_po_datepicker_p_change_0_listener() {
      ɵɵrestoreView(_r5);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_2_Template_po_datepicker_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r5);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_2_Template_po_datepicker_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r5);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-clean", field_r4.clean)("p-disabled", ctx_r0.isDisabled(field_r4))("p-error-pattern", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-error-async", field_r4.errorAsyncFunction)("p-auto-focus", field_r4.focus)("p-format", field_r4.format)("p-help", field_r4.help)("p-iso-format", field_r4.isoFormat)("p-label", field_r4.label)("p-locale", field_r4.locale)("p-max-date", field_r4.maxValue)("p-min-date", field_r4.minValue)("p-no-autocomplete", field_r4.noAutocomplete)("p-optional", field_r4.optional)("p-readonly", field_r4.readonly)("p-required", field_r4.required)("p-required-field-error-message", field_r4.requiredFieldErrorMessage)("p-show-required", field_r4.showRequired)("p-placeholder", field_r4.placeholder);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_range_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-datepicker-range", 26, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_range_3_Template_po_datepicker_range_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_range_3_Template_po_datepicker_range_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r6);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_range_3_Template_po_datepicker_range_p_change_0_listener() {
      ɵɵrestoreView(_r6);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_range_3_Template_po_datepicker_range_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r6);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-clean", field_r4.clean)("p-disabled", ctx_r0.isDisabled(field_r4))("p-auto-focus", field_r4.focus)("p-help", field_r4.help)("p-label", field_r4.label)("p-literals", field_r4.literals)("p-max-date", field_r4.maxValue)("p-min-date", field_r4.minValue)("p-no-autocomplete", field_r4.noAutocomplete)("p-optional", field_r4.optional)("p-readonly", field_r4.readonly)("p-required", field_r4.required)("p-field-error-message", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-show-required", field_r4.showRequired);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_input_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-input", 27, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_input_4_Template_po_input_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r7);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_input_4_Template_po_input_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r7);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_input_4_Template_po_input_p_change_0_listener() {
      ɵɵrestoreView(_r7);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-change-model", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_input_4_Template_po_input_p_change_model_0_listener() {
      ɵɵrestoreView(_r7);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeFieldModel(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_input_4_Template_po_input_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r7);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-clean", field_r4.clean)("p-disabled", ctx_r0.isDisabled(field_r4))("p-error-pattern", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-error-async-properties", field_r4.errorAsyncProperties)("p-auto-focus", field_r4.focus)("p-help", field_r4.help)("p-label", field_r4.label)("p-mask-format-model", field_r4.maskFormatModel)("p-mask", field_r4.mask)("p-maxlength", field_r4.maxLength)("p-minlength", field_r4.minLength)("p-no-autocomplete", field_r4.noAutocomplete)("p-optional", field_r4.optional)("p-pattern", field_r4.pattern)("p-required", field_r4.required)("p-required-field-error-message", field_r4.requiredFieldErrorMessage)("p-show-required", field_r4.showRequired)("p-icon", field_r4.icon)("p-placeholder", field_r4.placeholder)("p-readonly", field_r4.readonly);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_number_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-number", 28, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_number_5_Template_po_number_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r8);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_number_5_Template_po_number_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r8);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_number_5_Template_po_number_p_change_0_listener() {
      ɵɵrestoreView(_r8);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-change-model", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_number_5_Template_po_number_p_change_model_0_listener() {
      ɵɵrestoreView(_r8);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeFieldModel(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_number_5_Template_po_number_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r8);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-clean", field_r4.clean)("p-disabled", ctx_r0.isDisabled(field_r4))("p-error-pattern", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-error-async-properties", field_r4.errorAsyncProperties)("p-auto-focus", field_r4.focus)("p-help", field_r4.help)("p-label", field_r4.label)("p-min", field_r4.minValue)("p-max", field_r4.maxValue)("p-maxlength", field_r4.maxLength)("p-minlength", field_r4.minLength)("p-no-autocomplete", field_r4.noAutocomplete)("p-optional", field_r4.optional)("p-step", field_r4.step)("p-readonly", field_r4.readonly)("p-required", field_r4.required)("p-required-field-error-message", field_r4.requiredFieldErrorMessage)("p-show-required", field_r4.showRequired)("p-icon", field_r4.icon)("p-placeholder", field_r4.placeholder);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_decimal_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-decimal", 29, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_decimal_6_Template_po_decimal_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r9);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_decimal_6_Template_po_decimal_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r9);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_decimal_6_Template_po_decimal_p_change_0_listener() {
      ɵɵrestoreView(_r9);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-change-model", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_decimal_6_Template_po_decimal_p_change_model_0_listener() {
      ɵɵrestoreView(_r9);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeFieldModel(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_decimal_6_Template_po_decimal_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r9);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-clean", field_r4.clean)("p-error-pattern", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-error-async-properties", field_r4.errorAsyncProperties)("p-disabled", ctx_r0.isDisabled(field_r4))("p-decimals-length", field_r4.decimalsLength)("p-thousand-maxlength", field_r4.thousandMaxlength)("p-icon", field_r4.icon)("p-auto-focus", field_r4.focus)("p-help", field_r4.help)("p-label", field_r4.label)("p-locale", field_r4.locale)("p-min", field_r4.minValue)("p-max", field_r4.maxValue)("p-maxlength", field_r4.maxLength)("p-minlength", field_r4.minLength)("p-no-autocomplete", field_r4.noAutocomplete)("p-optional", field_r4.optional)("p-readonly", field_r4.readonly)("p-required", field_r4.required)("p-required-field-error-message", field_r4.requiredFieldErrorMessage)("p-show-required", field_r4.showRequired)("p-placeholder", field_r4.placeholder);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_select_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-select", 30, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_select_7_Template_po_select_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r10);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_select_7_Template_po_select_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r10);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_select_7_Template_po_select_p_change_0_listener() {
      ɵɵrestoreView(_r10);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_select_7_Template_po_select_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r10);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-field-label", field_r4.fieldLabel)("p-field-value", field_r4.fieldValue)("p-disabled", ctx_r0.isDisabled(field_r4))("p-help", field_r4.help)("p-label", field_r4.label)("p-optional", field_r4.optional)("p-options", field_r4.options)("p-required", field_r4.required)("p-field-error-message", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-show-required", field_r4.showRequired)("p-placeholder", field_r4.placeholder)("p-readonly", field_r4.readonly);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_radio_group_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-radio-group", 31, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_radio_group_8_Template_po_radio_group_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r11);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_radio_group_8_Template_po_radio_group_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r11);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_radio_group_8_Template_po_radio_group_p_change_0_listener() {
      ɵɵrestoreView(_r11);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_radio_group_8_Template_po_radio_group_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r11);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-columns", field_r4.columns || 3)("p-auto-focus", field_r4.focus)("p-disabled", ctx_r0.isDisabled(field_r4))("p-help", field_r4.help)("p-label", field_r4.label)("p-optional", field_r4.optional)("p-options", field_r4.options)("p-required", field_r4.required)("p-field-error-message", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-show-required", field_r4.showRequired);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_switch_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-switch", 32, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_switch_9_Template_po_switch_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r12);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_switch_9_Template_po_switch_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r12);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_switch_9_Template_po_switch_p_change_0_listener() {
      ɵɵrestoreView(_r12);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_switch_9_Template_po_switch_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r12);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-disabled", ctx_r0.isDisabled(field_r4))("p-format-model", field_r4.formatModel)("p-help", field_r4.help)("p-label", field_r4.label)("p-label-off", field_r4.booleanFalse)("p-label-on", field_r4.booleanTrue)("p-label-position", field_r4.labelPosition)("p-hide-label-status", field_r4.hideLabelStatus);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox", 33, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_10_Template_po_checkbox_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r13);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_10_Template_po_checkbox_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r13);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_10_Template_po_checkbox_p_change_0_listener() {
      ɵɵrestoreView(_r13);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_10_Template_po_checkbox_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r13);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-auto-focus", field_r4.focus)("p-disabled", ctx_r0.isDisabled(field_r4))("p-label", field_r4.label)("p-size", field_r4.size);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_combo_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-combo", 34, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_combo_11_Template_po_combo_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r14);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_combo_11_Template_po_combo_p_change_0_listener($event) {
      ɵɵrestoreView(_r14);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4, $event));
    })("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_combo_11_Template_po_combo_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r14);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_combo_11_Template_po_combo_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r14);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-auto-focus", field_r4.focus)("p-clean", field_r4.clean)("p-disabled", ctx_r0.isDisabled(field_r4))("p-field-label", field_r4.fieldLabel)("p-field-value", field_r4.fieldValue)("p-filter-params", field_r4.params)("p-filter-service", field_r4.optionsService)("p-help", field_r4.help)("p-infinite-scroll", field_r4.infiniteScroll)("p-infinite-scroll-distance", field_r4.infiniteScrollDistance || 100)("p-label", field_r4.label)("p-literals", field_r4.literals)("p-options", field_r4.options)("p-optional", field_r4.optional)("p-sort", field_r4.sort)("p-required", field_r4.required)("p-field-error-message", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-show-required", field_r4.showRequired)("p-icon", field_r4.icon)("p-placeholder", field_r4.placeholder)("p-filter-minlength", field_r4.filterMinlength)("p-filter-mode", field_r4.filterMode)("p-disabled-init-filter", field_r4.disabledInitFilter)("p-disabled-tab-filter", field_r4.disabledTabFilter)("p-debounce-time", field_r4.debounceTime)("p-change-on-enter", field_r4.changeOnEnter)("p-remove-initial-filter", field_r4.removeInitialFilter);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_lookup_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-lookup", 35, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_lookup_12_Template_po_lookup_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r15);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_lookup_12_Template_po_lookup_p_change_0_listener() {
      ɵɵrestoreView(_r15);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_lookup_12_Template_po_lookup_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r15);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change-visible-columns", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_lookup_12_Template_po_lookup_p_change_visible_columns_0_listener($event) {
      ɵɵrestoreView(_r15);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.changeVisibleColumns == null ? null : field_r4.changeVisibleColumns($event));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_lookup_12_Template_po_lookup_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r15);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    })("p-restore-column-manager", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_lookup_12_Template_po_lookup_p_restore_column_manager_0_listener($event) {
      ɵɵrestoreView(_r15);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.columnRestoreManager == null ? null : field_r4.columnRestoreManager($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-clean", field_r4.clean)("p-columns", field_r4.columns)("p-disabled", ctx_r0.isDisabled(field_r4))("p-field-label", field_r4.fieldLabel || "label")("p-field-value", field_r4.fieldValue || "value")("p-filter-params", field_r4.params)("p-filter-service", field_r4.searchService)("p-auto-focus", field_r4.focus)("p-auto-height", field_r4.autoHeight)("p-help", field_r4.help)("p-field-format", field_r4.format)("p-infinite-scroll", field_r4.infiniteScroll)("p-label", field_r4.label)("p-literals", field_r4.literals)("p-multiple", field_r4.multiple)("p-no-autocomplete", field_r4.noAutocomplete)("p-optional", field_r4.optional)("p-required", field_r4.required)("p-field-error-message", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-show-required", field_r4.showRequired)("p-placeholder", field_r4.placeholder)("p-advanced-filters", field_r4.advancedFilters);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_group_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox-group", 36, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_group_13_Template_po_checkbox_group_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r16);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_group_13_Template_po_checkbox_group_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r16);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_group_13_Template_po_checkbox_group_p_change_0_listener() {
      ɵɵrestoreView(_r16);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_group_13_Template_po_checkbox_group_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r16);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-columns", field_r4.columns || 3)("p-auto-focus", field_r4.focus)("p-disabled", ctx_r0.isDisabled(field_r4))("p-help", field_r4.help)("p-label", field_r4.label)("p-optional", field_r4.optional)("p-options", field_r4.options)("p-required", field_r4.required)("p-show-required", field_r4.showRequired)("p-field-error-message", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_multiselect_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-multiselect", 37, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_multiselect_14_Template_po_multiselect_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r17);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_multiselect_14_Template_po_multiselect_p_change_0_listener() {
      ɵɵrestoreView(_r17);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_multiselect_14_Template_po_multiselect_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r17);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_multiselect_14_Template_po_multiselect_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r17);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-disabled", ctx_r0.isDisabled(field_r4))("p-auto-focus", field_r4.focus)("p-auto-height", field_r4.autoHeight)("p-help", field_r4.help)("p-label", field_r4.label)("p-literals", field_r4.literals)("p-optional", field_r4.optional)("p-options", field_r4.options)("p-required", field_r4.required)("p-field-error-message", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-show-required", field_r4.showRequired)("p-placeholder", field_r4.placeholder)("p-field-label", field_r4.fieldLabel)("p-field-value", field_r4.fieldValue)("p-filter-service", field_r4.optionsService)("p-filter-mode", field_r4.filterMode)("p-debounce-time", field_r4.debounceTime)("p-sort", field_r4.sort)("p-placeholder-search", field_r4.placeholderSearch)("p-hide-search", field_r4.hideSearch)("p-hide-select-all", field_r4.hideSelectAll);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_textarea_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-textarea", 38, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_textarea_15_Template_po_textarea_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r18);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_textarea_15_Template_po_textarea_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r18);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_textarea_15_Template_po_textarea_p_change_0_listener() {
      ɵɵrestoreView(_r18);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-change-model", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_textarea_15_Template_po_textarea_p_change_model_0_listener() {
      ɵɵrestoreView(_r18);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeFieldModel(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_textarea_15_Template_po_textarea_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r18);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-disabled", ctx_r0.isDisabled(field_r4))("p-auto-focus", field_r4.focus)("p-help", field_r4.help)("p-label", field_r4.label)("p-maxlength", field_r4.maxLength)("p-minlength", field_r4.minLength)("p-optional", field_r4.optional)("p-readonly", field_r4.readonly)("p-required", field_r4.required)("p-field-error-message", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-show-required", field_r4.showRequired)("p-rows", field_r4.rows)("p-placeholder", field_r4.placeholder);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_password_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r19 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-password", 39, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_password_16_Template_po_password_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r19);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_password_16_Template_po_password_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r19);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_password_16_Template_po_password_p_change_0_listener() {
      ɵɵrestoreView(_r19);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-change-model", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_password_16_Template_po_password_p_change_model_0_listener() {
      ɵɵrestoreView(_r19);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeFieldModel(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_password_16_Template_po_password_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r19);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r4.property);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-clean", field_r4.clean)("p-disabled", ctx_r0.isDisabled(field_r4))("p-error-pattern", field_r4.errorMessage)("p-error-limit", field_r4.errorLimit)("p-error-async-properties", field_r4.errorAsyncProperties)("p-auto-focus", field_r4.focus)("p-help", field_r4.help)("p-hide-password-peek", field_r4.hidePasswordPeek)("p-icon", field_r4.icon)("p-label", field_r4.label)("p-maxlength", field_r4.maxLength)("p-minlength", field_r4.minLength)("p-no-autocomplete", field_r4.noAutocomplete)("p-optional", field_r4.optional)("p-pattern", field_r4.pattern)("p-readonly", field_r4.readonly)("p-required", field_r4.required)("p-required-field-error-message", field_r4.requiredFieldErrorMessage)("p-show-required", field_r4.showRequired)("p-placeholder", field_r4.placeholder);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_upload_17_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-upload", 40, 2);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_upload_17_Template_po_upload_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r20);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r0.value[field_r4.property], $event) || (ctx_r0.value[field_r4.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-custom-action-click", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_upload_17_Template_po_upload_p_custom_action_click_0_listener($event) {
      ɵɵrestoreView(_r20);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.customActionClick($event));
    })("p-error", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_upload_17_Template_po_upload_p_error_0_listener($event) {
      ɵɵrestoreView(_r20);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.onError($event));
    })("p-success", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_upload_17_Template_po_upload_p_success_0_listener($event) {
      ɵɵrestoreView(_r20);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.onSuccess($event));
    })("p-upload", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_upload_17_Template_po_upload_p_upload_0_listener($event) {
      ɵɵrestoreView(_r20);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.onUpload($event));
    })("p-additional-help", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_upload_17_Template_po_upload_p_additional_help_0_listener($event) {
      ɵɵrestoreView(_r20);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.additionalHelp == null ? null : field_r4.additionalHelp($event));
    })("p-change", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_upload_17_Template_po_upload_p_change_0_listener() {
      ɵɵrestoreView(_r20);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeField(field_r4));
    })("p-change-model", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_upload_17_Template_po_upload_p_change_model_0_listener() {
      ɵɵrestoreView(_r20);
      const field_r4 = ɵɵnextContext().$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.onChangeFieldModel(field_r4));
    })("p-keydown", function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_upload_17_Template_po_upload_p_keydown_0_listener($event) {
      ɵɵrestoreView(_r20);
      const field_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r4.keydown == null ? null : field_r4.keydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵtwoWayProperty("ngModel", ctx_r0.value[field_r4.property]);
    ɵɵproperty("ngClass", field_r4.componentClass)("additionalHelpEventTrigger", field_r4.additionalHelp ? "event" : "noEvent")("p-additional-help-tooltip", field_r4.additionalHelpTooltip)("p-auto-upload", field_r4.autoUpload)("p-directory", field_r4.directory)("p-disabled", ctx_r0.isDisabled(field_r4))("p-drag-drop", field_r4.dragDrop)("p-drag-drop-height", field_r4.dragDropHeight)("p-restrictions", field_r4.restrictions)("p-form-field", field_r4.formField)("p-headers", field_r4.headers)("p-help", field_r4.help)("p-hide-restrictions-info", field_r4.hideRestrictionsInfo)("p-hide-select-button", field_r4.hideSelectButton)("p-hide-send-button", field_r4.hideSendButton)("p-multiple", field_r4.multiple)("p-label", field_r4.label)("p-literals", field_r4.literals)("name", field_r4.property)("p-custom-action", field_r4.customAction)("p-optional", field_r4.optional)("p-required", field_r4.required)("p-show-required", field_r4.showRequired)("p-url", field_r4.url);
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_divider_1_Template, 1, 1, "po-divider", 7)(2, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_2_Template, 2, 25, "po-datepicker", 8)(3, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_datepicker_range_3_Template, 2, 20, "po-datepicker-range", 9)(4, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_input_4_Template, 2, 26, "po-input", 10)(5, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_number_5_Template, 2, 26, "po-number", 11)(6, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_decimal_6_Template, 2, 28, "po-decimal", 12)(7, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_select_7_Template, 2, 18, "po-select", 13)(8, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_radio_group_8_Template, 2, 16, "po-radio-group", 14)(9, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_switch_9_Template, 2, 13, "po-switch", 15)(10, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_10_Template, 2, 9, "po-checkbox", 16)(11, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_combo_11_Template, 2, 33, "po-combo", 17)(12, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_lookup_12_Template, 2, 28, "po-lookup", 18)(13, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_checkbox_group_13_Template, 2, 16, "po-checkbox-group", 19)(14, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_multiselect_14_Template, 2, 27, "po-multiselect", 20)(15, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_textarea_15_Template, 2, 19, "po-textarea", 21)(16, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_password_16_Template, 2, 25, "po-password", 22)(17, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_po_upload_17_Template, 2, 25, "po-upload", 23);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const field_r4 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", field_r4 == null ? null : field_r4.divider == null ? null : field_r4.divider.trim());
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "datepicker"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "datepickerrange"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "input"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "number"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "decimal"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "select"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "radioGroup"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "switch"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "checkbox"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "combo"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "lookup"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "checkboxGroup"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "multiselect"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "textarea"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "password"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.compareTo(field_r4.control, "upload"));
  }
}
function PoDynamicFormFieldsComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoDynamicFormFieldsComponent_ng_template_1_ng_container_0_Template, 18, 17, "ng-container", 6);
  }
  if (rf & 2) {
    const fields_r21 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngForOf", fields_r21)("ngForTrackBy", ctx_r0.trackBy);
  }
}
function PoDynamicFormFieldsComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-dynamic-container", 41);
  }
  if (rf & 2) {
    const fields_r22 = ctx.$implicit;
    ɵɵnextContext();
    const poContent_r2 = ɵɵreference(2);
    ɵɵproperty("p-fields", fields_r22)("p-content", poContent_r2);
  }
}
var PoDynamicFormFieldsComponent = class _PoDynamicFormFieldsComponent extends PoDynamicFormFieldsBaseComponent {
  validationService;
  changes;
  form;
  components;
  previousValue = {};
  constructor(titleCasePipe, validationService, changes, form) {
    super(titleCasePipe);
    this.validationService = validationService;
    this.changes = changes;
    this.form = form;
  }
  ngOnChanges(changes) {
    if (changes.fields) {
      this.visibleFields = this.getVisibleFields();
      if (changes.fields.previousValue && this.hasContainer()) {
        this.hasChangeContainer(changes.fields.previousValue, changes.fields.currentValue);
      }
      if (!changes.fields.previousValue || !changes.fields.currentValue) {
        this.setContainerFields();
      }
    }
    if (changes.value) {
      this.updatePreviousValue();
    }
  }
  focus(property) {
    const foundComponent = this.components.find((component) => component.name === property);
    if (foundComponent) {
      foundComponent.focus();
    }
  }
  isDisabled(field) {
    return field.disabled || this.disabledForm;
  }
  onChangeField(visibleField, objectValue) {
    return __async(this, null, function* () {
      const {
        property
      } = visibleField;
      const isBooleanType = visibleField.type === "boolean";
      const isChangedValueField = this.previousValue[property] !== this.value[property];
      if (visibleField.optionsService) {
        this.objectValue.emit(objectValue);
      }
      if ((this.form.dirty || isBooleanType) && isChangedValueField) {
        const {
          changedField,
          changedFieldIndex
        } = this.getField(property);
        if (changedField.validate) {
          yield this.validateField(changedField, changedFieldIndex, visibleField);
        }
        this.triggerValidationOnForm(changedFieldIndex);
      }
      this.updatePreviousValue();
    });
  }
  //emite o valor a cada caractere digitado no input
  onChangeFieldModel(visibleField) {
    if (this.validateOnInput) {
      const {
        property
      } = visibleField;
      const {
        changedFieldIndex
      } = this.getField(property);
      this.triggerValidationOnForm(changedFieldIndex);
    }
  }
  showAdditionalHelp(property) {
    const foundComponent = this.components.find((component) => component.name === property);
    if (foundComponent) {
      foundComponent.showAdditionalHelp();
    }
  }
  updatePreviousValue() {
    this.previousValue = JSON.parse(JSON.stringify(this.value));
  }
  trackBy(index) {
    return index;
  }
  applyFieldValidation(index, validatedField) {
    const field = this.fields[index];
    this.fields[index] = __spreadValues(__spreadValues({}, field), validatedField.field);
    this.updateFields();
    if (validatedField.hasOwnProperty("value")) {
      this.value[field.property] = validatedField.value;
    }
    this.changes.detectChanges();
    if (validatedField.focus) {
      this.focus(field.property);
    }
  }
  getField(property) {
    const changedFieldIndex = this.fields.findIndex((field) => field.property === property);
    const changedField = this.fields[changedFieldIndex];
    return {
      changedField,
      changedFieldIndex
    };
  }
  triggerValidationOnForm(changedFieldIndex) {
    const isValidatableField = this.validateFields?.length ? this.validateFieldsChecker(this.validateFields, this.fields[changedFieldIndex].property) : true;
    const hasValidationForm = this.validate && isValidatableField && this.formValidate.observers.length;
    if (hasValidationForm) {
      const updatedField = this.fields[changedFieldIndex];
      this.formValidate.emit(updatedField);
    }
  }
  updateFields() {
    this.fieldsChange.emit(this.fields);
    this.visibleFields = this.getVisibleFields();
    this.setContainerFields();
  }
  validateFieldsChecker(validateFields, propertyField) {
    return validateFields.some((validateFieldItem) => validateFieldItem === propertyField);
  }
  validateField(field, fieldIndex, visibleField) {
    return __async(this, null, function* () {
      const value = this.value[field.property];
      const previousDisabled = visibleField.disabled;
      visibleField.disabled = true;
      this.changes.detectChanges();
      try {
        const validatedField = yield this.validationService.sendFieldChange(field, value).toPromise();
        this.applyFieldValidation(fieldIndex, validatedField);
      } catch {
        visibleField.disabled = previousDisabled;
      }
    });
  }
  hasChangeContainer(previous, current) {
    const prevArray = previous.map((item, index) => ({
      container: item.container || null,
      property: item.property,
      index,
      order: item.order,
      visible: item.visible ?? true
    }));
    const currArray = current.map((item, index) => ({
      container: item.container || null,
      property: item.property,
      index,
      order: item.order,
      visible: item.visible ?? true
    }));
    const prevContainers = prevArray.filter((item) => item.container);
    const currContainers = currArray.filter((item) => item.container);
    const prevOrder = prevArray.filter((item) => item.order);
    const currOrder = currArray.filter((item) => item.order);
    const prevVisibleTrue = prevArray.filter((item) => item.visible === true);
    const currVisibleTrue = currArray.filter((item) => item.visible === true);
    const prevVisibleFalse = prevArray.filter((item) => !item.visible);
    const currVisibleFalse = currArray.filter((item) => !item.visible);
    if (prevContainers.length !== currContainers.length) {
      this.setContainerFields();
      return;
    }
    if (prevOrder.length !== currOrder.length) {
      this.setContainerFields();
      return;
    }
    if (prevVisibleTrue.length !== currVisibleTrue.length) {
      this.setContainerFields();
      return;
    }
    if (prevVisibleFalse.length !== currVisibleFalse.length) {
      this.setContainerFields();
      return;
    }
    if (currContainers.length) {
      this.handleChangesContainer(prevContainers, currContainers, "container");
    }
    if (currOrder.length) {
      this.handleChangesContainer(prevOrder, currOrder, "order");
    }
    if (currVisibleTrue.length) {
      this.handleChangesContainer(prevVisibleTrue, currVisibleTrue, "visible");
    }
    if (currVisibleFalse.length) {
      this.handleChangesContainer(prevVisibleFalse, currVisibleFalse, "visible");
    }
    const result = this.diffObjectsArray(previous, this.getVisibleFields());
    this.containerFields = this.updateFieldContainer(result, this.containerFields);
  }
  updateFieldContainer(changes, containerFields) {
    const mapchanges = new Map(changes.map((obj) => [obj.property, obj]));
    containerFields.forEach((subArray) => {
      subArray.forEach((subItem, index) => {
        const item = mapchanges.get(subItem.property);
        if (item) {
          subArray[index] = __spreadValues(__spreadValues({}, subItem), item);
        }
      });
    });
    return containerFields;
  }
  diffObjectsArray(oldArray, newArray) {
    const differences = [];
    newArray.forEach((newObj) => {
      const oldObj = oldArray.find((o) => o.property === newObj.property);
      if (!oldObj) {
        differences.push(__spreadValues({}, newObj));
      } else {
        const diff = {
          property: newObj.property
        };
        let hasDifferences = false;
        for (const key in newObj) {
          if (newObj[key] !== oldObj[key]) {
            diff[key] = newObj[key];
            hasDifferences = true;
          }
        }
        if (hasDifferences) {
          differences.push(diff);
        }
      }
    });
    return differences;
  }
  hasContainer() {
    return this.visibleFields && this.visibleFields.some((field) => field.container);
  }
  handleChangesContainer(prevContainers, currContainers, key) {
    for (let i = 0; i < prevContainers.length; i++) {
      const prev = prevContainers[i];
      const curr = currContainers[i];
      if (prev[key] === curr[key] && prev.index !== curr.index) {
        this.setContainerFields();
        return;
      }
      if (prev[key] !== curr[key] && prev.index === curr.index) {
        if (key === "order") {
          this.setContainerFields();
          return;
        }
        this.containerFields.forEach((subItem) => subItem.forEach((item) => {
          if (item.property === curr.property) {
            item[key] = curr[key];
          }
        }));
      }
      if (prev[key] !== curr[key] && prev.property !== curr.property) {
        this.setContainerFields();
        return;
      }
    }
  }
  static ɵfac = function PoDynamicFormFieldsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicFormFieldsComponent)(ɵɵdirectiveInject(TitleCasePipe), ɵɵdirectiveInject(PoDynamicFormValidationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgForm));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDynamicFormFieldsComponent,
    selectors: [["po-dynamic-form-fields"]],
    viewQuery: function PoDynamicFormFieldsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$A, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.components = _t);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoDynamicFormValidationService], [{
      provide: ControlContainer,
      useExisting: NgForm
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 5,
    vars: 1,
    consts: [["poContent", ""], ["poContentContainer", ""], ["component", ""], ["class", "po-row", 3, "po-dynamic", 4, "ngIf"], [1, "po-row"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "po-sm-12", 3, "p-label", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-disabled", "p-error-pattern", "p-error-limit", "p-error-async", "p-auto-focus", "p-format", "p-help", "p-iso-format", "p-label", "p-locale", "p-max-date", "p-min-date", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-required-field-error-message", "p-show-required", "p-placeholder", "ngModelChange", "p-change", "p-additional-help", "p-keydown", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-disabled", "p-auto-focus", "p-help", "p-label", "p-literals", "p-max-date", "p-min-date", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "ngModelChange", "p-additional-help", "p-change", "p-keydown", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-disabled", "p-error-pattern", "p-error-limit", "p-error-async-properties", "p-auto-focus", "p-help", "p-label", "p-mask-format-model", "p-mask", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-pattern", "p-required", "p-required-field-error-message", "p-show-required", "p-icon", "p-placeholder", "p-readonly", "ngModelChange", "p-additional-help", "p-change", "p-change-model", "p-keydown", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-disabled", "p-error-pattern", "p-error-limit", "p-error-async-properties", "p-auto-focus", "p-help", "p-label", "p-min", "p-max", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-step", "p-readonly", "p-required", "p-required-field-error-message", "p-show-required", "p-icon", "p-placeholder", "ngModelChange", "p-additional-help", "p-change", "p-change-model", "p-keydown", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-error-pattern", "p-error-limit", "p-error-async-properties", "p-disabled", "p-decimals-length", "p-thousand-maxlength", "p-icon", "p-auto-focus", "p-help", "p-label", "p-locale", "p-min", "p-max", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-required-field-error-message", "p-show-required", "p-placeholder", "ngModelChange", "p-additional-help", "p-change", "p-change-model", "p-keydown", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-field-label", "p-field-value", "p-disabled", "p-help", "p-label", "p-optional", "p-options", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "p-placeholder", "p-readonly", "ngModelChange", "p-additional-help", "p-change", "p-keydown", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-columns", "p-auto-focus", "p-disabled", "p-help", "p-label", "p-optional", "p-options", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "ngModelChange", "p-additional-help", "p-change", "p-keydown", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-disabled", "p-format-model", "p-help", "p-label", "p-label-off", "p-label-on", "p-label-position", "p-hide-label-status", "ngModelChange", "p-additional-help", "p-change", "p-keydown", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-auto-focus", "p-disabled", "p-label", "p-size", "ngModelChange", "p-additional-help", "p-change", "p-keydown", 4, "ngIf"], ["p-emit-object-value", "", 3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-auto-focus", "p-clean", "p-disabled", "p-field-label", "p-field-value", "p-filter-params", "p-filter-service", "p-help", "p-infinite-scroll", "p-infinite-scroll-distance", "p-label", "p-literals", "p-options", "p-optional", "p-sort", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "p-icon", "p-placeholder", "p-filter-minlength", "p-filter-mode", "p-disabled-init-filter", "p-disabled-tab-filter", "p-debounce-time", "p-change-on-enter", "p-remove-initial-filter", "ngModelChange", "p-change", "p-additional-help", "p-keydown", 4, "ngIf"], ["p-field-label", "label", "p-field-value", "value", 3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-columns", "p-disabled", "p-field-label", "p-field-value", "p-filter-params", "p-filter-service", "p-auto-focus", "p-auto-height", "p-help", "p-field-format", "p-infinite-scroll", "p-label", "p-literals", "p-multiple", "p-no-autocomplete", "p-optional", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "p-placeholder", "p-advanced-filters", "ngModelChange", "p-change", "p-additional-help", "p-change-visible-columns", "p-keydown", "p-restore-column-manager", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-columns", "p-auto-focus", "p-disabled", "p-help", "p-label", "p-optional", "p-options", "p-required", "p-show-required", "p-field-error-message", "p-error-limit", "ngModelChange", "p-additional-help", "p-change", "p-keydown", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-disabled", "p-auto-focus", "p-auto-height", "p-help", "p-label", "p-literals", "p-optional", "p-options", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "p-placeholder", "p-field-label", "p-field-value", "p-filter-service", "p-filter-mode", "p-debounce-time", "p-sort", "p-placeholder-search", "p-hide-search", "p-hide-select-all", "ngModelChange", "p-change", "p-additional-help", "p-keydown", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-disabled", "p-auto-focus", "p-help", "p-label", "p-maxlength", "p-minlength", "p-optional", "p-readonly", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "p-rows", "p-placeholder", "ngModelChange", "p-additional-help", "p-change", "p-change-model", "p-keydown", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-disabled", "p-error-pattern", "p-error-limit", "p-error-async-properties", "p-auto-focus", "p-help", "p-hide-password-peek", "p-icon", "p-label", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-pattern", "p-readonly", "p-required", "p-required-field-error-message", "p-show-required", "p-placeholder", "ngModelChange", "p-additional-help", "p-change", "p-change-model", "p-keydown", 4, "ngIf"], [3, "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-auto-upload", "p-directory", "p-disabled", "p-drag-drop", "p-drag-drop-height", "p-restrictions", "p-form-field", "p-headers", "p-help", "p-hide-restrictions-info", "p-hide-select-button", "p-hide-send-button", "p-multiple", "p-label", "p-literals", "name", "p-custom-action", "p-optional", "p-required", "p-show-required", "p-url", "ngModelChange", "p-custom-action-click", "p-error", "p-success", "p-upload", "p-additional-help", "p-change", "p-change-model", "p-keydown", 4, "ngIf"], [1, "po-sm-12", 3, "p-label"], [3, "ngModelChange", "p-change", "p-additional-help", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-disabled", "p-error-pattern", "p-error-limit", "p-error-async", "p-auto-focus", "p-format", "p-help", "p-iso-format", "p-label", "p-locale", "p-max-date", "p-min-date", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-required-field-error-message", "p-show-required", "p-placeholder"], [3, "ngModelChange", "p-additional-help", "p-change", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-disabled", "p-auto-focus", "p-help", "p-label", "p-literals", "p-max-date", "p-min-date", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-field-error-message", "p-error-limit", "p-show-required"], [3, "ngModelChange", "p-additional-help", "p-change", "p-change-model", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-disabled", "p-error-pattern", "p-error-limit", "p-error-async-properties", "p-auto-focus", "p-help", "p-label", "p-mask-format-model", "p-mask", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-pattern", "p-required", "p-required-field-error-message", "p-show-required", "p-icon", "p-placeholder", "p-readonly"], [3, "ngModelChange", "p-additional-help", "p-change", "p-change-model", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-disabled", "p-error-pattern", "p-error-limit", "p-error-async-properties", "p-auto-focus", "p-help", "p-label", "p-min", "p-max", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-step", "p-readonly", "p-required", "p-required-field-error-message", "p-show-required", "p-icon", "p-placeholder"], [3, "ngModelChange", "p-additional-help", "p-change", "p-change-model", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-error-pattern", "p-error-limit", "p-error-async-properties", "p-disabled", "p-decimals-length", "p-thousand-maxlength", "p-icon", "p-auto-focus", "p-help", "p-label", "p-locale", "p-min", "p-max", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-required-field-error-message", "p-show-required", "p-placeholder"], [3, "ngModelChange", "p-additional-help", "p-change", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-field-label", "p-field-value", "p-disabled", "p-help", "p-label", "p-optional", "p-options", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "p-placeholder", "p-readonly"], [3, "ngModelChange", "p-additional-help", "p-change", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-columns", "p-auto-focus", "p-disabled", "p-help", "p-label", "p-optional", "p-options", "p-required", "p-field-error-message", "p-error-limit", "p-show-required"], [3, "ngModelChange", "p-additional-help", "p-change", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-disabled", "p-format-model", "p-help", "p-label", "p-label-off", "p-label-on", "p-label-position", "p-hide-label-status"], [3, "ngModelChange", "p-additional-help", "p-change", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-auto-focus", "p-disabled", "p-label", "p-size"], ["p-emit-object-value", "", 3, "ngModelChange", "p-change", "p-additional-help", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-auto-focus", "p-clean", "p-disabled", "p-field-label", "p-field-value", "p-filter-params", "p-filter-service", "p-help", "p-infinite-scroll", "p-infinite-scroll-distance", "p-label", "p-literals", "p-options", "p-optional", "p-sort", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "p-icon", "p-placeholder", "p-filter-minlength", "p-filter-mode", "p-disabled-init-filter", "p-disabled-tab-filter", "p-debounce-time", "p-change-on-enter", "p-remove-initial-filter"], ["p-field-label", "label", "p-field-value", "value", 3, "ngModelChange", "p-change", "p-additional-help", "p-change-visible-columns", "p-keydown", "p-restore-column-manager", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-columns", "p-disabled", "p-field-label", "p-field-value", "p-filter-params", "p-filter-service", "p-auto-focus", "p-auto-height", "p-help", "p-field-format", "p-infinite-scroll", "p-label", "p-literals", "p-multiple", "p-no-autocomplete", "p-optional", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "p-placeholder", "p-advanced-filters"], [3, "ngModelChange", "p-additional-help", "p-change", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-columns", "p-auto-focus", "p-disabled", "p-help", "p-label", "p-optional", "p-options", "p-required", "p-show-required", "p-field-error-message", "p-error-limit"], [3, "ngModelChange", "p-change", "p-additional-help", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-disabled", "p-auto-focus", "p-auto-height", "p-help", "p-label", "p-literals", "p-optional", "p-options", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "p-placeholder", "p-field-label", "p-field-value", "p-filter-service", "p-filter-mode", "p-debounce-time", "p-sort", "p-placeholder-search", "p-hide-search", "p-hide-select-all"], [3, "ngModelChange", "p-additional-help", "p-change", "p-change-model", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-disabled", "p-auto-focus", "p-help", "p-label", "p-maxlength", "p-minlength", "p-optional", "p-readonly", "p-required", "p-field-error-message", "p-error-limit", "p-show-required", "p-rows", "p-placeholder"], [3, "ngModelChange", "p-additional-help", "p-change", "p-change-model", "p-keydown", "name", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-clean", "p-disabled", "p-error-pattern", "p-error-limit", "p-error-async-properties", "p-auto-focus", "p-help", "p-hide-password-peek", "p-icon", "p-label", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-pattern", "p-readonly", "p-required", "p-required-field-error-message", "p-show-required", "p-placeholder"], [3, "ngModelChange", "p-custom-action-click", "p-error", "p-success", "p-upload", "p-additional-help", "p-change", "p-change-model", "p-keydown", "ngModel", "ngClass", "additionalHelpEventTrigger", "p-additional-help-tooltip", "p-auto-upload", "p-directory", "p-disabled", "p-drag-drop", "p-drag-drop-height", "p-restrictions", "p-form-field", "p-headers", "p-help", "p-hide-restrictions-info", "p-hide-select-button", "p-hide-send-button", "p-multiple", "p-label", "p-literals", "name", "p-custom-action", "p-optional", "p-required", "p-show-required", "p-url"], [3, "p-fields", "p-content"]],
    template: function PoDynamicFormFieldsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoDynamicFormFieldsComponent_div_0_Template, 2, 6, "div", 3)(1, PoDynamicFormFieldsComponent_ng_template_1_Template, 1, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor)(3, PoDynamicFormFieldsComponent_ng_template_3_Template, 1, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.visibleFields && ctx.visibleFields.length > 0);
      }
    },
    dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, NgControlStatus, NgModel, PoDividerComponent, PoCheckboxGroupComponent, PoRadioGroupComponent, PoDatepickerComponent, PoComboComponent, PoDecimalComponent, PoDatepickerRangeComponent, PoInputComponent, PoLookupComponent, PoMultiselectComponent, PoNumberComponent, PoPasswordComponent, PoSelectComponent, PoTextareaComponent, PoUploadComponent, PoCheckboxComponent, PoSwitchComponent, PoDynamicContainerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormFieldsComponent, [{
    type: Component,
    args: [{
      selector: "po-dynamic-form-fields",
      viewProviders: [{
        provide: ControlContainer,
        useExisting: NgForm
      }],
      providers: [PoDynamicFormValidationService],
      standalone: false,
      template: `<div class="po-row" [class.po-dynamic]="hasContainers" *ngIf="visibleFields && visibleFields.length > 0">
  <ng-container
    *ngTemplateOutlet="
      hasContainers ? poContentContainer : poContent;
      context: { $implicit: hasContainers ? containerFields : visibleFields }
    "
  ></ng-container>
</div>

<ng-template #poContent let-fields>
  <ng-container *ngFor="let field of fields; trackBy: trackBy">
    <po-divider *ngIf="field?.divider?.trim()" class="po-sm-12" [p-label]="field.divider"> </po-divider>
    <po-datepicker
      #component
      *ngIf="compareTo(field.control, 'datepicker')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-error-pattern]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-error-async]="field.errorAsyncFunction"
      [p-auto-focus]="field.focus"
      [p-format]="field.format"
      [p-help]="field.help"
      [p-iso-format]="field.isoFormat"
      [p-label]="field.label"
      [p-locale]="field.locale"
      [p-max-date]="field.maxValue"
      [p-min-date]="field.minValue"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-required-field-error-message]="field.requiredFieldErrorMessage"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      [p-placeholder]="field.placeholder"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-keydown)="field.keydown?.($event)"
    >
    </po-datepicker>

    <po-datepicker-range
      #component
      *ngIf="compareTo(field.control, 'datepickerrange')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-literals]="field.literals"
      [p-max-date]="field.maxValue"
      [p-min-date]="field.minValue"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-field-error-message]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-show-required]="field.showRequired"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-keydown)="field.keydown?.($event)"
    >
    </po-datepicker-range>

    <po-input
      #component
      *ngIf="compareTo(field.control, 'input')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-error-pattern]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-error-async-properties]="field.errorAsyncProperties"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-mask-format-model]="field.maskFormatModel"
      [p-mask]="field.mask"
      [p-maxlength]="field.maxLength"
      [p-minlength]="field.minLength"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-pattern]="field.pattern"
      [p-required]="field.required"
      [p-required-field-error-message]="field.requiredFieldErrorMessage"
      [p-show-required]="field.showRequired"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      (p-keydown)="field.keydown?.($event)"
      [p-icon]="field.icon"
      [p-placeholder]="field.placeholder"
      [p-readonly]="field.readonly"
    >
    </po-input>

    <po-number
      #component
      *ngIf="compareTo(field.control, 'number')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-error-pattern]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-error-async-properties]="field.errorAsyncProperties"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-min]="field.minValue"
      [p-max]="field.maxValue"
      [p-maxlength]="field.maxLength"
      [p-minlength]="field.minLength"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-step]="field.step"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-required-field-error-message]="field.requiredFieldErrorMessage"
      [p-show-required]="field.showRequired"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      (p-keydown)="field.keydown?.($event)"
      [p-icon]="field.icon"
      [p-placeholder]="field.placeholder"
    >
    </po-number>

    <po-decimal
      #component
      *ngIf="compareTo(field.control, 'decimal')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-clean]="field.clean"
      [p-error-pattern]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-error-async-properties]="field.errorAsyncProperties"
      [p-disabled]="isDisabled(field)"
      [p-decimals-length]="field.decimalsLength"
      [p-thousand-maxlength]="field.thousandMaxlength"
      [p-icon]="field.icon"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-locale]="field.locale"
      [p-min]="field.minValue"
      [p-max]="field.maxValue"
      [p-maxlength]="field.maxLength"
      [p-minlength]="field.minLength"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-required-field-error-message]="field.requiredFieldErrorMessage"
      [p-show-required]="field.showRequired"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      (p-keydown)="field.keydown?.($event)"
      [p-placeholder]="field.placeholder"
    >
    </po-decimal>

    <po-select
      #component
      *ngIf="compareTo(field.control, 'select')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-field-label]="field.fieldLabel"
      [p-field-value]="field.fieldValue"
      [p-disabled]="isDisabled(field)"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-optional]="field.optional"
      [p-options]="field.options"
      [p-required]="field.required"
      [p-field-error-message]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-show-required]="field.showRequired"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-keydown)="field.keydown?.($event)"
      [p-placeholder]="field.placeholder"
      [p-readonly]="field.readonly"
    >
    </po-select>

    <po-radio-group
      #component
      *ngIf="compareTo(field.control, 'radioGroup')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-columns]="field.columns || 3"
      [p-auto-focus]="field.focus"
      [p-disabled]="isDisabled(field)"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-optional]="field.optional"
      [p-options]="field.options"
      [p-required]="field.required"
      [p-field-error-message]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-show-required]="field.showRequired"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-keydown)="field.keydown?.($event)"
    >
    </po-radio-group>

    <po-switch
      #component
      *ngIf="compareTo(field.control, 'switch')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-disabled]="isDisabled(field)"
      [p-format-model]="field.formatModel"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-label-off]="field.booleanFalse"
      [p-label-on]="field.booleanTrue"
      [p-label-position]="field.labelPosition"
      [p-hide-label-status]="field.hideLabelStatus"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-keydown)="field.keydown?.($event)"
    >
    </po-switch>

    <po-checkbox
      #component
      *ngIf="compareTo(field.control, 'checkbox')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-auto-focus]="field.focus"
      [p-disabled]="isDisabled(field)"
      [p-label]="field.label"
      [p-size]="field.size"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-keydown)="field.keydown?.($event)"
    >
    </po-checkbox>

    <po-combo
      #component
      *ngIf="compareTo(field.control, 'combo')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      p-emit-object-value
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-auto-focus]="field.focus"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-field-label]="field.fieldLabel"
      [p-field-value]="field.fieldValue"
      [p-filter-params]="field.params"
      [p-filter-service]="field.optionsService"
      [p-help]="field.help"
      [p-infinite-scroll]="field.infiniteScroll"
      [p-infinite-scroll-distance]="field.infiniteScrollDistance || 100"
      [p-label]="field.label"
      [p-literals]="field.literals"
      [p-options]="field.options"
      [p-optional]="field.optional"
      [p-sort]="field.sort"
      [p-required]="field.required"
      [p-field-error-message]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field, $event)"
      [p-icon]="field.icon"
      [p-placeholder]="field.placeholder"
      [p-filter-minlength]="field.filterMinlength"
      [p-filter-mode]="field.filterMode"
      [p-disabled-init-filter]="field.disabledInitFilter"
      [p-disabled-tab-filter]="field.disabledTabFilter"
      [p-debounce-time]="field.debounceTime"
      [p-change-on-enter]="field.changeOnEnter"
      (p-additional-help)="field.additionalHelp?.($event)"
      [p-remove-initial-filter]="field.removeInitialFilter"
      (p-keydown)="field.keydown?.($event)"
    >
    </po-combo>

    <po-lookup
      #component
      *ngIf="compareTo(field.control, 'lookup')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      p-field-label="label"
      p-field-value="value"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-clean]="field.clean"
      [p-columns]="field.columns"
      [p-disabled]="isDisabled(field)"
      [p-field-label]="field.fieldLabel || 'label'"
      [p-field-value]="field.fieldValue || 'value'"
      [p-filter-params]="field.params"
      [p-filter-service]="field.searchService"
      [p-auto-focus]="field.focus"
      [p-auto-height]="field.autoHeight"
      [p-help]="field.help"
      [p-field-format]="field.format"
      [p-infinite-scroll]="field.infiniteScroll"
      [p-label]="field.label"
      [p-literals]="field.literals"
      [p-multiple]="field.multiple"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-required]="field.required"
      [p-field-error-message]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      [p-placeholder]="field.placeholder"
      [p-advanced-filters]="field.advancedFilters"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change-visible-columns)="field.changeVisibleColumns?.($event)"
      (p-keydown)="field.keydown?.($event)"
      (p-restore-column-manager)="field.columnRestoreManager?.($event)"
    >
    </po-lookup>

    <po-checkbox-group
      #component
      *ngIf="compareTo(field.control, 'checkboxGroup')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-columns]="field.columns || 3"
      [p-auto-focus]="field.focus"
      [p-disabled]="isDisabled(field)"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-optional]="field.optional"
      [p-options]="field.options"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      [p-field-error-message]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-keydown)="field.keydown?.($event)"
    >
    </po-checkbox-group>

    <po-multiselect
      #component
      *ngIf="compareTo(field.control, 'multiselect')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-disabled]="isDisabled(field)"
      [p-auto-focus]="field.focus"
      [p-auto-height]="field.autoHeight"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-literals]="field.literals"
      [p-optional]="field.optional"
      [p-options]="field.options"
      [p-required]="field.required"
      [p-field-error-message]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      [p-placeholder]="field.placeholder"
      [p-field-label]="field.fieldLabel"
      [p-field-value]="field.fieldValue"
      [p-filter-service]="field.optionsService"
      [p-filter-mode]="field.filterMode"
      [p-debounce-time]="field.debounceTime"
      [p-sort]="field.sort"
      [p-placeholder-search]="field.placeholderSearch"
      [p-hide-search]="field.hideSearch"
      [p-hide-select-all]="field.hideSelectAll"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-keydown)="field.keydown?.($event)"
    >
    </po-multiselect>

    <po-textarea
      #component
      *ngIf="compareTo(field.control, 'textarea')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-disabled]="isDisabled(field)"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-maxlength]="field.maxLength"
      [p-minlength]="field.minLength"
      [p-optional]="field.optional"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-field-error-message]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-show-required]="field.showRequired"
      [p-rows]="field.rows"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      (p-keydown)="field.keydown?.($event)"
      [p-placeholder]="field.placeholder"
    >
    </po-textarea>

    <po-password
      #component
      *ngIf="compareTo(field.control, 'password')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-error-pattern]="field.errorMessage"
      [p-error-limit]="field.errorLimit"
      [p-error-async-properties]="field.errorAsyncProperties"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-hide-password-peek]="field.hidePasswordPeek"
      [p-icon]="field.icon"
      [p-label]="field.label"
      [p-maxlength]="field.maxLength"
      [p-minlength]="field.minLength"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-pattern]="field.pattern"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-required-field-error-message]="field.requiredFieldErrorMessage"
      [p-show-required]="field.showRequired"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      (p-keydown)="field.keydown?.($event)"
      [p-placeholder]="field.placeholder"
    >
    </po-password>

    <po-upload
      #component
      *ngIf="compareTo(field.control, 'upload')"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [additionalHelpEventTrigger]="field.additionalHelp ? 'event' : 'noEvent'"
      [p-additional-help-tooltip]="field.additionalHelpTooltip"
      [p-auto-upload]="field.autoUpload"
      [p-directory]="field.directory"
      [p-disabled]="isDisabled(field)"
      [p-drag-drop]="field.dragDrop"
      [p-drag-drop-height]="field.dragDropHeight"
      [p-restrictions]="field.restrictions"
      [p-form-field]="field.formField"
      [p-headers]="field.headers"
      [p-help]="field.help"
      [p-hide-restrictions-info]="field.hideRestrictionsInfo"
      [p-hide-select-button]="field.hideSelectButton"
      [p-hide-send-button]="field.hideSendButton"
      [p-multiple]="field.multiple"
      [p-label]="field.label"
      [p-literals]="field.literals"
      [name]="field.property"
      [p-custom-action]="field.customAction"
      (p-custom-action-click)="field.customActionClick($event)"
      (p-error)="field.onError($event)"
      (p-success)="field.onSuccess($event)"
      (p-upload)="field.onUpload($event)"
      [p-optional]="field.optional"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-additional-help)="field.additionalHelp?.($event)"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      (p-keydown)="field.keydown?.($event)"
      [p-url]="field.url"
    >
    </po-upload>
  </ng-container>
</ng-template>

<ng-template #poContentContainer let-fields>
  <po-dynamic-container [p-fields]="fields" [p-content]="poContent"></po-dynamic-container>
</ng-template>
`
    }]
  }], () => [{
    type: TitleCasePipe
  }, {
    type: PoDynamicFormValidationService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgForm
  }], {
    components: [{
      type: ViewChildren,
      args: ["component"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDynamicFormFieldsComponent, {
    className: "PoDynamicFormFieldsComponent",
    filePath: "lib/components/po-dynamic/po-dynamic-form/po-dynamic-form-fields/po-dynamic-form-fields.component.ts",
    lineNumber: 24
  });
})();
var PoDynamicViewService = class _PoDynamicViewService {
  httpClient;
  headers = new HttpHeaders({
    "X-PO-No-Message": "true"
  });
  url;
  constructor(httpClient) {
    this.httpClient = httpClient;
  }
  getObjectByValue(value, filterParams) {
    const validatedFilterParams = this.validateParams(filterParams);
    const encodedValue = encodeURIComponent(value);
    const newURL = `${this.url}/${encodedValue}`;
    return this.httpClient.get(newURL, {
      headers: this.headers,
      params: validatedFilterParams
    }).pipe(map((response) => "items" in response ? response.items : response));
  }
  onLoad(url, value) {
    return this.httpClient.post(url, value).toPromise();
  }
  setConfig(url) {
    this.url = url;
  }
  validateParams(params) {
    return isTypeof(params, "object") && !Array.isArray(params) ? params : void 0;
  }
  static ɵfac = function PoDynamicViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicViewService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoDynamicViewService,
    factory: _PoDynamicViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }], null);
})();
var PoDynamicViewBaseComponent = class _PoDynamicViewBaseComponent extends PoDynamicSharedBase {
  currencyPipe;
  datePipe;
  decimalPipe;
  timePipe;
  titleCasePipe;
  dynamicViewService;
  comboFilterService;
  multiselectFilterService;
  /**
   * @optional
   *
   * @description
   *
   * Possibilita executar uma função quando o componente é inicializado.
   *
   * A propriedade aceita os seguintes tipos:
   * - **String**: Endpoint usado pelo componente para requisição via `POST`.
   * - **Function**: Método que será executado na inicialização do componente.
   *
   * Para os dois tipos de utilização da propriedade espera-se o seguinte retorno:
   *
   * ```
   * {
   *   value: {
   *     cnpj: '**************', // altera valor do campo
   *     updated: (new Date()).toString() // atribui valor ao campo novo
   *   },
   *   fields: [
   *     { property: 'updated', tag: true } // inclui campo novo
   *   ]
   * }
   * ```
   * > **value**: any = atribui novo valor do model.
   *
   * > **fields**: `Array<PoDynamicViewField>` = Lista de campos que deseja alterar as propriedades,
   * caso enviar um campo a mais será criado um novo campo.
   *
   * - Para esconder/remover campos precisa informar no field a propriedade `visible = false`.
   *
   */
  load;
  service;
  _fields = [];
  _showAllValue = false;
  _value = {};
  /**
   * @optional
   *
   * @description
   *
   * Lista de objetos que implementam a interface `PoDynamicView`.
   *
   * > Ex: `[ { property: 'age' } ]`
   *
   * Regras de tipagem e formatação dos valores exibidos:
   *
   * - Caso o *type* informado seja *currency* e não seja informado o *format* o mesmo recebe "'BRL', 'symbol', '1.2-2'"
   * como formato padrão.
   * - Caso o *type* informado seja *date* e não seja informado o *format* o mesmo recebe 'dd/MM/yyyy' como formato padrão.
   * - Caso o *type* informado seja *dateTime* e não seja informado o *format* o mesmo recebe 'dd/MM/yyyy HH:mm:ss' como formato padrão.
   * - Caso o *type* informado seja *number* e não seja informado o *format* o mesmo não será formatado.
   * - Caso o *type* informado seja *time* e não seja informado o *format* o mesmo recebe 'HH:mm:ss.ffffff' como formato padrão.
   *
   * > As propriedades informadas serão exibidas mesmo não contendo valor de referência no objeto da propriedade `p-value`.
   *
   * @default `[]`
   */
  set fields(fields) {
    this._fields = Array.isArray(fields) ? [...fields] : [];
  }
  get fields() {
    return this._fields;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica se exibirá todas as informações contidas dentro do objeto informado na propriedade `p-value`.
   *
   * @default `false`
   */
  set showAllValue(value) {
    this._showAllValue = convertToBoolean(value);
  }
  get showAllValue() {
    return this._showAllValue;
  }
  /**
   * @optional
   *
   * @description
   *
   * Permite a quebra de linha no texto do `p-value`, aplicando-a onde há `\n`.
   *
   * ```
   * <po-dynamic-view
   *   [p-value]="{ description: 'Primeira linha\nSegunda linha' }"
   *   [p-text-wrap]="true"
   * ></po-dynamic-view>
   * ```
   *
   * Saída:
   * ```
   * Primeira linha
   * Segunda linha
   * ```
   * @default `false`
   */
  textWrap = false;
  /**
   * @description
   *
   * Objeto que será utilizado para exibir as informações dinâmicas, o valor será recuperado através do atributo *property*
   * dos objetos contidos na propridade `p-fields`.
   *
   * > Ex: `{ age: '35' }`
   */
  set value(value) {
    this._value = value && isTypeof(value, "object") ? value : {};
  }
  get value() {
    return this._value;
  }
  constructor(currencyPipe, datePipe, decimalPipe, timePipe, titleCasePipe, dynamicViewService, comboFilterService, multiselectFilterService) {
    super();
    this.currencyPipe = currencyPipe;
    this.datePipe = datePipe;
    this.decimalPipe = decimalPipe;
    this.timePipe = timePipe;
    this.titleCasePipe = titleCasePipe;
    this.dynamicViewService = dynamicViewService;
    this.comboFilterService = comboFilterService;
    this.multiselectFilterService = multiselectFilterService;
  }
  getFieldOrderRetroactive(position, index = 1) {
    if (position === index) {
      return position;
    }
    return this.fields.findIndex((field) => field.order === index) > -1 ? this.getFieldOrderRetroactive(position, index + 1) : index;
  }
  getFieldOrder(field, index) {
    const position = this.getFieldOrderRetroactive(index + 1);
    return this.fields.findIndex((e) => e.order === position) > -1 ? this.getFieldOrder(field, position) : position;
  }
  getConfiguredFields(useSearchService = true) {
    const newFields = [];
    this.fields.forEach((field, index) => {
      field.order = field.order || this.getFieldOrder(field, index);
      if (!isVisibleField(field)) {
        return;
      }
      if (!field.searchService && !field.optionsService) {
        newFields.push(this.createField(field));
        return;
      }
      const hasValue = this.value[field.property]?.length || !Array.isArray(this.value[field.property]) && this.value[field.property] && useSearchService || field.container;
      if (hasValue) {
        const _field = this.returnValues(__spreadValues({}, field), "");
        newFields.push(_field);
        if (field.searchService) {
          if (typeof field.searchService === "object") {
            this.service = field.searchService;
          } else if (typeof field.searchService === "string") {
            this.service = this.dynamicViewService;
            this.service.setConfig(field.searchService);
          }
        } else if (field.optionsService) {
          if (field.optionsMulti) {
            if (typeof field.optionsService === "object") {
              this.service = field.optionsService;
            } else {
              this.service = this.multiselectFilterService;
              this.service.configProperties(field.optionsService, field.fieldLabel, field.fieldValue);
            }
          } else {
            if (typeof field.optionsService === "object") {
              this.service = field.optionsService;
            } else {
              this.service = this.comboFilterService;
              this.service.configProperties(field.optionsService, field.fieldLabel, field.fieldValue);
            }
          }
        }
        this.createFieldWithService(field, newFields, _field);
      }
    });
    const _sortedField = sortFields(newFields);
    this.ensureFieldHasContainer(_sortedField);
    return _sortedField;
  }
  // retorna fields ligado ao value mais os atributos do value que não possuiam fields.
  getMergedFields() {
    const mergedFields = [...this.getConfiguredFields()];
    this.getValueFields().forEach((valueField) => {
      const fieldIndex = mergedFields.findIndex((field) => field.property === valueField.property);
      const property = valueField.property;
      if (fieldIndex === -1) {
        mergedFields.push(this.createField({
          property
        }));
      }
    });
    return mergedFields;
  }
  // retorna o objeto value como fields.
  getValueFields() {
    return Object.keys(this.value).map((property) => this.createField({
      property
    }));
  }
  createField(field) {
    const property = field.property;
    let value;
    if (field.isArrayOrObject && this.value[property]) {
      value = this.transformArrayValue(this.value[property], field);
    } else if (field.fieldLabel) {
      value = this.transformFieldLabel(property, field);
    }
    if (!value) {
      value = this.transformValue(field.type, this.value[property], field.format);
    }
    return this.returnValues(field, value);
  }
  createFieldWithService(field, newFields, oldField) {
    const property = field.property;
    this.searchById(this.value[property], field).subscribe((response) => {
      const value = response;
      const allValues = this.returnValues(field, value);
      const oldFieldIndex = newFields.indexOf(newFields.find((field2) => field2 === oldField));
      newFields.splice(oldFieldIndex, 1, allValues);
      sortFields(newFields);
    });
  }
  returnValues(field, value) {
    const property = field.property;
    const classesGridColumns = getGridColumnsClasses(field.gridColumns, field.offsetColumns, {
      smGrid: field.gridSmColumns,
      mdGrid: field.gridMdColumns,
      lgGrid: field.gridLgColumns,
      xlGrid: field.gridXlColumns
    }, {
      smOffset: field.offsetSmColumns,
      mdOffset: field.offsetMdColumns,
      lgOffset: field.offsetLgColumns,
      xlOffset: field.offsetXlColumns
    }, {
      smPull: field.gridSmPull,
      mdPull: field.gridMdPull,
      lgPull: field.gridLgPull,
      xlPull: field.gridXlPull
    });
    return __spreadValues({
      property,
      value,
      label: this.titleCasePipe.transform(property),
      cssClass: classesGridColumns
    }, field);
  }
  searchById(value, field) {
    if (typeof value === "string") {
      value = value.trim();
    }
    if (value !== "") {
      if (field.optionsMulti) {
        return this.service.getObjectsByValues(value, field.params).pipe(map((res) => this.transformArrayValue(res, field))).pipe(catchError(() => of(null)));
      } else {
        return this.service.getObjectByValue(value, field.params).pipe(map((res) => this.transformArrayValue(res, field))).pipe(catchError(() => of(null)));
      }
    } else {
      return of(null);
    }
  }
  transformArrayValue(valueProperty, field) {
    const valueArray = Array.isArray(valueProperty) ? valueProperty : [valueProperty];
    let labels;
    if (Array.isArray(field.format)) {
      labels = valueArray.map((objectData) => this.formatField(objectData, field.format));
    } else {
      const arrayWithLabel = valueArray.map((item) => ({
        value: item[field.fieldValue] || item.value,
        label: item[field.fieldLabel] || item.label
      }));
      labels = arrayWithLabel.map((optionValue) => {
        if (optionValue.label) {
          const labelTranformed = this.transformValue(field.type, optionValue.label, field.format);
          if (field.concatLabelValue && optionValue.value) {
            return `${labelTranformed} - ${optionValue.value}`;
          } else {
            return labelTranformed;
          }
        }
      });
    }
    if (labels[0] !== void 0 && labels.join()) {
      return labels.join(", ");
    } else {
      valueProperty = "";
      return void 0;
    }
  }
  transformFieldLabel(property, field) {
    if (field.concatLabelValue && field.fieldLabel && field.fieldValue && !field.isArrayOrObject) {
      const transformedValue = this.transformValue(field.type, this.value[field.fieldLabel], field.format);
      return `${transformedValue} - ${this.value[field.fieldValue]}`;
    }
    if (field.fieldLabel && !field.concatLabelValue && !field.isArrayOrObject) {
      this.value[property] = this.value[field.fieldLabel];
    }
    return void 0;
  }
  transformValue(type, value, format) {
    let transformedValue = value;
    switch (type) {
      case "currency":
        transformedValue = this.currencyPipe.transform(value, format || "BRL", "symbol", "1.2-2");
        break;
      case "date":
        transformedValue = this.datePipe.transform(value, format || "dd/MM/yyyy");
        break;
      case "dateTime":
        transformedValue = this.datePipe.transform(value, format || "dd/MM/yyyy HH:mm:ss");
        break;
      case "number":
        transformedValue = this.decimalPipe.transform(value, format);
        break;
      case "time":
        transformedValue = this.timePipe.transform(value, format || "HH:mm:ss.ffffff");
        break;
    }
    return transformedValue;
  }
  formatField(objectSelected, properties) {
    let formattedField;
    if (Array.isArray(properties)) {
      for (const property of properties) {
        if (objectSelected && objectSelected[property]) {
          if (!formattedField) {
            formattedField = objectSelected[property];
          } else {
            formattedField += " - " + objectSelected[property];
          }
        }
      }
    }
    return formattedField;
  }
  static ɵfac = function PoDynamicViewBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicViewBaseComponent)(ɵɵdirectiveInject(CurrencyPipe), ɵɵdirectiveInject(DatePipe), ɵɵdirectiveInject(DecimalPipe), ɵɵdirectiveInject(PoTimePipe), ɵɵdirectiveInject(TitleCasePipe), ɵɵdirectiveInject(PoDynamicViewService), ɵɵdirectiveInject(PoComboFilterService), ɵɵdirectiveInject(PoMultiselectFilterService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoDynamicViewBaseComponent,
    inputs: {
      load: [0, "p-load", "load"],
      fields: [0, "p-fields", "fields"],
      showAllValue: [0, "p-show-all-value", "showAllValue"],
      textWrap: [0, "p-text-wrap", "textWrap"],
      value: [0, "p-value", "value"]
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicViewBaseComponent, [{
    type: Directive
  }], () => [{
    type: CurrencyPipe
  }, {
    type: DatePipe
  }, {
    type: DecimalPipe
  }, {
    type: PoTimePipe
  }, {
    type: TitleCasePipe
  }, {
    type: PoDynamicViewService
  }, {
    type: PoComboFilterService
  }, {
    type: PoMultiselectFilterService
  }], {
    load: [{
      type: Input,
      args: ["p-load"]
    }],
    fields: [{
      type: Input,
      args: ["p-fields"]
    }],
    showAllValue: [{
      type: Input,
      args: ["p-show-all-value"]
    }],
    textWrap: [{
      type: Input,
      args: ["p-text-wrap"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }]
  });
})();
var PoImageBaseComponent = class _PoImageBaseComponent {
  isBase64 = false;
  _source;
  /**
   * @optional
   *
   * @description
   *
   * Define a altura da imagem em *pixels*. Caso não seja definida,
   * atribui o tamanho da imagem
   */
  height;
  /**
   * @optional
   *
   * @description
   *
   * Defini o texto alternativo descrevendo a imagem.
   */
  alternate;
  /**
   * @optional
   *
   * @description
   *
   * Fonte da imagem que pode ser um caminho local (`./assets/images/logo-black-small.png`)
   * ou um servidor externo (`https://po-ui.io/assets/images/logo-black-small.png`).
   */
  set source(value) {
    if (isValidImageBase64(value)) {
      this.isBase64 = true;
    }
    this._source = value;
  }
  get source() {
    return this._source;
  }
  /**
   * @optional
   *
   * @description
   *
   * Defini a prioridade de carregamento da imagem.
   * > Para as imagens com carregamento prioritátio ativo é necessário incluir
   * > uma tag link no head do arquivo index.html da sua aplicação.
   *
   * ```
   * <link rel="preconnect" href="<url_base_da_imagem>">
   * ```
   *
   * @default `false`
   */
  priority = false;
  /**
   * @optional
   *
   * @description
   *
   * Defini o carregamento que pode ser dos tipo:
   *
   * — lazy
   * — eager
   * — auto
   *
   * > Não é permitido definir esta propriedade em conjunto com a propriedade `p-priority`.
   */
  loading;
  static ɵfac = function PoImageBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoImageBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoImageBaseComponent,
    inputs: {
      height: [0, "p-height", "height"],
      alternate: [0, "p-alt", "alternate"],
      source: [0, "p-src", "source"],
      priority: [0, "p-priority", "priority"],
      loading: [0, "p-loading", "loading"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoImageBaseComponent, [{
    type: Directive
  }], null, {
    height: [{
      type: Input,
      args: ["p-height"]
    }],
    alternate: [{
      type: Input,
      args: ["p-alt"]
    }],
    source: [{
      type: Input,
      args: ["p-src"]
    }],
    priority: [{
      type: Input,
      args: ["p-priority"]
    }],
    loading: [{
      type: Input,
      args: ["p-loading"]
    }]
  });
})();
function PoImageComponent_po_container_0_img_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("priority", ctx_r0.priority)("loading", ctx_r0.loading)("fill", true)("ngSrc", ctx_r0.source);
    ɵɵattribute("alt", ctx_r0.alternate);
  }
}
function PoImageComponent_po_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-container", 2);
    ɵɵtemplate(1, PoImageComponent_po_container_0_img_1_Template, 1, 5, "img", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const imageBase64_r2 = ɵɵreference(2);
    ɵɵproperty("p-height", ctx_r0.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isBase64)("ngIfElse", imageBase64_r2);
  }
}
function PoImageComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("loading", ctx_r0.loading)("src", ctx_r0.source, ɵɵsanitizeUrl);
    ɵɵattribute("alt", ctx_r0.alternate);
  }
}
var PoImageComponent = class _PoImageComponent extends PoImageBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoImageComponent_BaseFactory;
    return function PoImageComponent_Factory(__ngFactoryType__) {
      return (ɵPoImageComponent_BaseFactory || (ɵPoImageComponent_BaseFactory = ɵɵgetInheritedFactory(_PoImageComponent)))(__ngFactoryType__ || _PoImageComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoImageComponent,
    selectors: [["po-image"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 1,
    consts: [["imageBase64", ""], ["class", "po-container-image", 3, "p-height", 4, "ngIf"], [1, "po-container-image", 3, "p-height"], ["class", "po-image", 3, "priority", "loading", "fill", "ngSrc", 4, "ngIf", "ngIfElse"], [1, "po-image", 3, "priority", "loading", "fill", "ngSrc"], [1, "po-image", 3, "loading", "src"]],
    template: function PoImageComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoImageComponent_po_container_0_Template, 2, 3, "po-container", 1)(1, PoImageComponent_ng_template_1_Template, 1, 3, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.source);
      }
    },
    dependencies: [NgIf, PoContainerComponent, NgOptimizedImage],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoImageComponent, [{
    type: Component,
    args: [{
      selector: "po-image",
      standalone: false,
      template: '<po-container class="po-container-image" *ngIf="source" [p-height]="height">\n  <img\n    *ngIf="!isBase64; else imageBase64"\n    class="po-image"\n    [attr.alt]="alternate"\n    [priority]="priority"\n    [loading]="loading"\n    [fill]="true"\n    [ngSrc]="source"\n  />\n</po-container>\n\n<ng-template #imageBase64>\n  <img class="po-image" [attr.alt]="alternate" [loading]="loading" [src]="source" />\n</ng-template>\n'
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoImageComponent, {
    className: "PoImageComponent",
    filePath: "lib/components/po-image/po-image.component.ts",
    lineNumber: 31
  });
})();
var _c0$z = (a0) => ({
  $implicit: a0
});
function PoDynamicViewComponent_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoDynamicViewComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, PoDynamicViewComponent_div_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const poContent_r2 = ɵɵreference(2);
    const poContentContainer_r3 = ɵɵreference(4);
    ɵɵclassProp("po-dynamic", ctx_r0.hasContainers);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.hasContainers ? poContentContainer_r3 : poContent_r2)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c0$z, ctx_r0.hasContainers ? ctx_r0.containerFields : ctx_r0.visibleFields));
  }
}
function PoDynamicViewComponent_ng_template_1_ng_template_0_po_divider_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-divider", 10);
  }
  if (rf & 2) {
    const field_r4 = ɵɵnextContext().$implicit;
    ɵɵproperty("p-label", field_r4.divider);
  }
}
function PoDynamicViewComponent_ng_template_1_ng_template_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoDynamicViewComponent_ng_template_1_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoDynamicViewComponent_ng_template_1_ng_template_0_po_divider_0_Template, 1, 1, "po-divider", 9)(1, PoDynamicViewComponent_ng_template_1_ng_template_0_ng_container_1_Template, 1, 0, "ng-container", 7);
  }
  if (rf & 2) {
    const field_r4 = ctx.$implicit;
    ɵɵnextContext(2);
    const poInfo_r5 = ɵɵreference(6);
    const poTag_r6 = ɵɵreference(8);
    const poImage_r7 = ɵɵreference(10);
    ɵɵproperty("ngIf", field_r4 == null ? null : field_r4.divider == null ? null : field_r4.divider.trim());
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", !field_r4.tag && !field_r4.image ? poInfo_r5 : !field_r4.image ? poTag_r6 : poImage_r7)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c0$z, field_r4));
  }
}
function PoDynamicViewComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoDynamicViewComponent_ng_template_1_ng_template_0_Template, 2, 5, "ng-template", 8);
  }
  if (rf & 2) {
    const fields_r8 = ctx.$implicit;
    ɵɵproperty("ngForOf", fields_r8);
  }
}
function PoDynamicViewComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-dynamic-container", 11);
  }
  if (rf & 2) {
    const fields_r9 = ctx.$implicit;
    ɵɵnextContext();
    const poContent_r2 = ɵɵreference(2);
    ɵɵproperty("p-fields", fields_r9)("p-content", poContent_r2);
  }
}
function PoDynamicViewComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-info", 12);
  }
  if (rf & 2) {
    const field_r10 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-info-value-pre", ctx_r0.textWrap && ctx_r0.containsLineBreak(ctx_r0.setFieldValue(field_r10)));
    ɵɵproperty("ngClass", field_r10.cssClass)("p-label", field_r10.label)("p-value", ctx_r0.setFieldValue(field_r10));
  }
}
function PoDynamicViewComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-tag", 13);
  }
  if (rf & 2) {
    const field_r11 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", field_r11.cssClass)("p-color", field_r11.color)("p-icon", field_r11.icon)("p-label", field_r11.label)("p-text-color", field_r11.textColor)("p-value", ctx_r0.setFieldValue(field_r11));
  }
}
function PoDynamicViewComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-image", 14);
  }
  if (rf & 2) {
    const field_r12 = ctx.$implicit;
    ɵɵproperty("p-alt", field_r12.alt)("p-height", field_r12.height)("p-src", field_r12.value);
  }
}
var PoDynamicViewComponent = class _PoDynamicViewComponent extends PoDynamicViewBaseComponent {
  initChanges;
  constructor(currencyPipe, datePipe, decimalPipe, timePipe, titleCasePipe, dynamicViewService, comboFilterService, multiselectFilterService) {
    super(currencyPipe, datePipe, decimalPipe, timePipe, titleCasePipe, dynamicViewService, comboFilterService, multiselectFilterService);
  }
  ngOnChanges(changes) {
    if (this.load && !this.initChanges) {
      this.initChanges = false;
    } else {
      this.initChanges = true;
    }
    if ((changes.fields || changes.value || changes.showAllValue) && this.initChanges) {
      this.visibleFields = this.getVisibleFields();
      this.setContainerFields();
    }
  }
  ngOnInit() {
    if (this.load) {
      this.updateValuesAndFieldsOnLoad().finally(() => {
        this.setContainerFields();
      });
    }
  }
  setFieldValue(field) {
    if (field.options) {
      if (field.optionsMulti) {
        const selectedOptions = field.options.filter((option) => Array.isArray(field.value) && field.value.some((value) => value === option.value));
        return selectedOptions.length ? selectedOptions.map((option) => option.label) : field.value;
      } else {
        const selectedOption = field.options.find((option) => option.value === field.value);
        return selectedOption ? selectedOption.label : field.value;
      }
    } else if (field.type === "boolean" && "booleanTrue" in field && "booleanFalse" in field) {
      return field.value ? field.booleanTrue : field.booleanFalse;
    } else {
      return field.value;
    }
  }
  containsLineBreak(value) {
    return value && value.includes("\n");
  }
  getValuesAndFieldsFromLoad() {
    return __async(this, null, function* () {
      let valueAndFieldsFromLoad;
      if (typeof this.load === "string") {
        valueAndFieldsFromLoad = yield this.dynamicViewService.onLoad(this.load, this.value);
      } else if (typeof this.load === "function") {
        valueAndFieldsFromLoad = this.load();
      }
      return valueAndFieldsFromLoad || {};
    });
  }
  getVisibleFields() {
    if (this.showAllValue) {
      return this.getMergedFields();
    }
    return this.value && this.fields.length ? this.getConfiguredFields() : this.getValueFields();
  }
  setFieldOnLoad(fieldOnLoad) {
    const index = this.fields.findIndex((field) => field.property === fieldOnLoad.property);
    if (index >= 0) {
      this.fields[index] = __spreadValues(__spreadValues({}, this.fields[index]), fieldOnLoad);
    } else {
      this.fields.push(__spreadValues({}, fieldOnLoad));
    }
  }
  setFieldsOnLoad(fields) {
    if (fields) {
      fields.forEach((fieldOnLoad) => {
        this.setFieldOnLoad(fieldOnLoad);
      });
    }
  }
  setValueOnLoad(newValue) {
    Object.assign(this.value, newValue);
  }
  updateValuesAndFieldsOnLoad() {
    return __async(this, null, function* () {
      const {
        value,
        fields
      } = yield this.getValuesAndFieldsFromLoad();
      this.setValueOnLoad(value);
      this.setFieldsOnLoad(fields);
      this.visibleFields = this.getVisibleFields();
      this.initChanges = true;
    });
  }
  static ɵfac = function PoDynamicViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicViewComponent)(ɵɵdirectiveInject(CurrencyPipe), ɵɵdirectiveInject(DatePipe), ɵɵdirectiveInject(DecimalPipe), ɵɵdirectiveInject(PoTimePipe), ɵɵdirectiveInject(TitleCasePipe), ɵɵdirectiveInject(PoDynamicViewService), ɵɵdirectiveInject(PoComboFilterService), ɵɵdirectiveInject(PoMultiselectFilterService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoDynamicViewComponent,
    selectors: [["po-dynamic-view"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 11,
    vars: 1,
    consts: [["poContent", ""], ["poContentContainer", ""], ["poInfo", ""], ["poTag", ""], ["poImage", ""], ["class", "po-row", 3, "po-dynamic", 4, "ngIf"], [1, "po-row"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["ngFor", "", 3, "ngForOf"], ["class", "po-sm-12", 3, "p-label", 4, "ngIf"], [1, "po-sm-12", 3, "p-label"], [3, "p-fields", "p-content"], [3, "ngClass", "p-label", "p-value"], [3, "ngClass", "p-color", "p-icon", "p-label", "p-text-color", "p-value"], [3, "p-alt", "p-height", "p-src"]],
    template: function PoDynamicViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoDynamicViewComponent_div_0_Template, 2, 6, "div", 5)(1, PoDynamicViewComponent_ng_template_1_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(3, PoDynamicViewComponent_ng_template_3_Template, 1, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor)(5, PoDynamicViewComponent_ng_template_5_Template, 1, 5, "ng-template", null, 2, ɵɵtemplateRefExtractor)(7, PoDynamicViewComponent_ng_template_7_Template, 1, 6, "ng-template", null, 3, ɵɵtemplateRefExtractor)(9, PoDynamicViewComponent_ng_template_9_Template, 1, 3, "ng-template", null, 4, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.visibleFields.length);
      }
    },
    dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, PoDividerComponent, PoInfoComponent, PoTagComponent, PoImageComponent, PoDynamicContainerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicViewComponent, [{
    type: Component,
    args: [{
      selector: "po-dynamic-view",
      standalone: false,
      template: '<div class="po-row" [class.po-dynamic]="hasContainers" *ngIf="visibleFields.length">\n  <ng-container\n    *ngTemplateOutlet="\n      hasContainers ? poContentContainer : poContent;\n      context: { $implicit: hasContainers ? containerFields : visibleFields }\n    "\n  ></ng-container>\n</div>\n\n<ng-template #poContent let-fields>\n  <ng-template ngFor let-field [ngForOf]="fields">\n    <po-divider *ngIf="field?.divider?.trim()" class="po-sm-12" [p-label]="field.divider"> </po-divider>\n    <ng-container\n      *ngTemplateOutlet="\n        !field.tag && !field.image ? poInfo : !field.image ? poTag : poImage;\n        context: { $implicit: field }\n      "\n    >\n    </ng-container>\n  </ng-template>\n</ng-template>\n\n<ng-template #poContentContainer let-fields>\n  <po-dynamic-container [p-fields]="fields" [p-content]="poContent"></po-dynamic-container>\n</ng-template>\n\n<ng-template #poInfo let-field>\n  <po-info\n    [ngClass]="field.cssClass"\n    [class.po-info-value-pre]="textWrap && containsLineBreak(setFieldValue(field))"\n    [p-label]="field.label"\n    [p-value]="setFieldValue(field)"\n  >\n  </po-info\n></ng-template>\n\n<ng-template #poTag let-field>\n  <po-tag\n    [ngClass]="field.cssClass"\n    [p-color]="field.color"\n    [p-icon]="field.icon"\n    [p-label]="field.label"\n    [p-text-color]="field.textColor"\n    [p-value]="setFieldValue(field)"\n  >\n  </po-tag>\n</ng-template>\n\n<ng-template #poImage let-field>\n  <po-image [p-alt]="field.alt" [p-height]="field.height" [p-src]="field.value"> </po-image>\n</ng-template>\n'
    }]
  }], () => [{
    type: CurrencyPipe
  }, {
    type: DatePipe
  }, {
    type: DecimalPipe
  }, {
    type: PoTimePipe
  }, {
    type: TitleCasePipe
  }, {
    type: PoDynamicViewService
  }, {
    type: PoComboFilterService
  }, {
    type: PoMultiselectFilterService
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDynamicViewComponent, {
    className: "PoDynamicViewComponent",
    filePath: "lib/components/po-dynamic/po-dynamic-view/po-dynamic-view.component.ts",
    lineNumber: 43
  });
})();
var PoImageModule = class _PoImageModule {
  static ɵfac = function PoImageModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoImageModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoImageModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoContainerModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoImageModule, [{
    type: NgModule,
    args: [{
      declarations: [PoImageComponent],
      imports: [CommonModule, PoContainerModule, NgOptimizedImage],
      exports: [PoImageComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoImageModule, {
    declarations: [PoImageComponent],
    imports: [CommonModule, PoContainerModule, NgOptimizedImage],
    exports: [PoImageComponent]
  });
})();
var PoDynamicModule = class _PoDynamicModule {
  static ɵfac = function PoDynamicModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoDynamicModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoDynamicModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [CurrencyPipe, DatePipe, DecimalPipe, PoTimePipe, TitleCasePipe, PoDynamicFormLoadService, PoDynamicFormValidationService, PoDynamicViewService, PoComboFilterService, PoMultiselectFilterService],
    imports: [CommonModule, FormsModule, PoDividerModule, PoInfoModule, PoFieldModule, PoTagModule, PoTimeModule, PoImageModule, PoContainerModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, PoDividerModule, PoInfoModule, PoFieldModule, PoTagModule, PoTimeModule, PoImageModule, PoContainerModule],
      declarations: [PoDynamicFormComponent, PoDynamicFormFieldsComponent, PoDynamicViewComponent, PoDynamicContainerComponent],
      exports: [PoDynamicFormComponent, PoDynamicViewComponent, PoDynamicContainerComponent],
      providers: [CurrencyPipe, DatePipe, DecimalPipe, PoTimePipe, TitleCasePipe, PoDynamicFormLoadService, PoDynamicFormValidationService, PoDynamicViewService, PoComboFilterService, PoMultiselectFilterService]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDynamicModule, {
    declarations: [PoDynamicFormComponent, PoDynamicFormFieldsComponent, PoDynamicViewComponent, PoDynamicContainerComponent],
    imports: [CommonModule, FormsModule, PoDividerModule, PoInfoModule, PoFieldModule, PoTagModule, PoTimeModule, PoImageModule, PoContainerModule],
    exports: [PoDynamicFormComponent, PoDynamicViewComponent, PoDynamicContainerComponent]
  });
})();
ɵɵsetComponentScope(PoDynamicFormComponent, [NgIf, ɵNgNoValidate, NgControlStatusGroup, NgForm, PoDynamicFormFieldsComponent], []);
var PoGaugePadding = 24;
var poGaugeMinHeight = 300;
var PoGaugeThickness = 16;
var PoGaugePointerEnd = 4;
var poGaugeTotalValueDefault = 100;
var PoGaugeBaseComponent = class _PoGaugeBaseComponent {
  colorService;
  _description;
  _height = poGaugeMinHeight;
  _ranges = [];
  _title;
  _value;
  /**
   * @optional
   *
   * @description
   *
   * Define o texto que será exibido no gauge.
   * Há dois posicionamentos para ele:
   * - Se houver definição para `p-ranges`, o descritivo será exibido no topo do container, ficando acima do gauge;
   * - Na ausência de `p-ranges`, será incorporado dentro do arco do gauge, e abaixo de `p-value`.
   *
   * Para ambos os casos, se o conteúdo ultrapassar a área designada, serão geradas automaticamente reticências.
   * No entanto, será possível visualizar a mensagem através de um tooltip no passar do mouse sobre o texto.
   *
   * > Para uma melhor experiência do usuário, é recomendado um descritivo breve e com poucas palavras.
   * Desta forma evita-se o *overflow* do texto.
   */
  set description(value) {
    this._description = value;
    this.svgContainerSize();
  }
  get description() {
    return this._description;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a altura do gauge.
   *
   * O valor mínimo aceito é 300px.
   *
   * @default `300px`
   */
  set height(value) {
    this._height = this.setGaugeHeight(value);
    this.svgContainerSize();
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Definição para o alcance de cores. Ao adicionar pelo menos um item na lista,
   * incorpora-se o ponteiro que assinala o valor passado em `p-value`.
   * Se o valor de `p-value` for inferior ao mínimo valor definido em `PoGaugeRanges.from`, o domínio mínimo do gauge será `p-value`.
   * A mesma regra prevalece para valores máximos.
   */
  set ranges(value) {
    this._ranges = Array.isArray(value) ? this.verifyColors(value) : [];
    this.svgContainerSize();
  }
  get ranges() {
    return this._ranges;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o título do gauge.
   */
  set title(value) {
    this._title = value;
    this.svgContainerSize();
  }
  get title() {
    return this._title;
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor referente ao valor da série. Seu comportamento segue a seguintes regras:
   *
   * - Sem `p-ranges`: Os valores passados para `p-value` e `p-description` serão centralizados no interior do arco.
   * A base do valor será percentual tendo como base os alcances entre zero e 100%. Se passado um valor superior a 100,
   * A colorização do gauge será completa e o valor passado será exibido no interior do arco.
   * - Com `p-ranges`: A descrição será exibida acima do gauge e haverá um ponteiro marcando o valor passado em `p-value`.
   * Considerando que o alcance em `ranges` é aberto, então a escala de `p-value` será em relação ao menor/maior alcance
   * absoluto definido em `p-ranges`.
   * Se passado um `p-value` inferior em relação ao mínimo valor definido em `p-ranges`, o domínio mínimo do gauge partirá de `p-value`.
   * A mesma regra prevalece para valores máximos.
   *
   */
  set value(gaugeValue) {
    if (typeof gaugeValue === "number" || typeof gaugeValue === "string" && gaugeValue.trim()) {
      const value = !isNaN(gaugeValue) ? Number(gaugeValue) : void 0;
      this._value = value;
    } else {
      this._value = void 0;
    }
  }
  get value() {
    return this._value;
  }
  constructor(colorService) {
    this.colorService = colorService;
  }
  verifyColors(ranges) {
    return this.colorService.getColors(ranges);
  }
  setGaugeHeight(height) {
    const gaugeHeight = convertToInt(height);
    return gaugeHeight && gaugeHeight > poGaugeMinHeight ? gaugeHeight : poGaugeMinHeight;
  }
  static ɵfac = function PoGaugeBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGaugeBaseComponent)(ɵɵdirectiveInject(PoColorService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoGaugeBaseComponent,
    inputs: {
      description: [0, "p-description", "description"],
      height: [0, "p-height", "height"],
      ranges: [0, "p-ranges", "ranges"],
      title: [0, "p-title", "title"],
      value: [0, "p-value", "value"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoColorService
  }], {
    description: [{
      type: Input,
      args: ["p-description"]
    }],
    height: [{
      type: Input,
      args: ["p-height"]
    }],
    ranges: [{
      type: Input,
      args: ["p-ranges"]
    }],
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }]
  });
})();
function PoGaugeTitleComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
var PoGaugeTitleComponent = class _PoGaugeTitleComponent {
  title;
  static ɵfac = function PoGaugeTitleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGaugeTitleComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoGaugeTitleComponent,
    selectors: [["po-gauge-title"]],
    inputs: {
      title: [0, "p-title", "title"]
    },
    standalone: false,
    decls: 1,
    vars: 1,
    consts: [["class", "po-gauge-title", 4, "ngIf"], [1, "po-gauge-title"]],
    template: function PoGaugeTitleComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoGaugeTitleComponent_div_0_Template, 2, 1, "div", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.title);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeTitleComponent, [{
    type: Component,
    args: [{
      selector: "po-gauge-title",
      standalone: false,
      template: '<div *ngIf="title" class="po-gauge-title">{{ title }}</div>\n'
    }]
  }], null, {
    title: [{
      type: Input,
      args: ["p-title"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugeTitleComponent, {
    className: "PoGaugeTitleComponent",
    filePath: "lib/components/po-gauge/po-gauge-title/po-gauge-title.component.ts",
    lineNumber: 8
  });
})();
var _c0$y = (a0) => ({
  $implicit: a0
});
function PoGaugeLegendComponent_li_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoGaugeLegendComponent_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 4);
    ɵɵtemplate(1, PoGaugeLegendComponent_li_1_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementStart(2, "p", 6);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const range_r1 = ctx.$implicit;
    ɵɵnextContext();
    const colorpalette_r2 = ɵɵreference(3);
    const colorstyle_r3 = ɵɵreference(5);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", (range_r1.color == null ? null : range_r1.color.includes("po-color")) ? colorpalette_r2 : colorstyle_r3)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c0$y, range_r1));
    ɵɵadvance(2);
    ɵɵtextInterpolate(range_r1.label);
  }
}
function PoGaugeLegendComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const range_r4 = ctx.$implicit;
    ɵɵclassMap(range_r4.color);
  }
}
function PoGaugeLegendComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const range_r5 = ctx.$implicit;
    ɵɵstyleProp("background", range_r5.color);
  }
}
var PoGaugeLegendComponent = class _PoGaugeLegendComponent {
  _ranges;
  set ranges(value) {
    this._ranges = value.length ? this.filterLabel(value) : [];
  }
  get ranges() {
    return this._ranges;
  }
  constructor() {
  }
  trackBy(index) {
    return index;
  }
  filterLabel(ranges) {
    return ranges.filter((range) => range.label);
  }
  static ɵfac = function PoGaugeLegendComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGaugeLegendComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoGaugeLegendComponent,
    selectors: [["po-gauge-legend"]],
    inputs: {
      ranges: [0, "p-ranges", "ranges"]
    },
    standalone: false,
    decls: 6,
    vars: 2,
    consts: [["colorpalette", ""], ["colorstyle", ""], [1, "po-gauge-legend"], ["class", "po-gauge-legend-item", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-gauge-legend-item"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "po-gauge-legend-text"], [1, "po-gauge-legend-square"]],
    template: function PoGaugeLegendComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "ul", 2);
        ɵɵtemplate(1, PoGaugeLegendComponent_li_1_Template, 4, 5, "li", 3);
        ɵɵelementEnd();
        ɵɵtemplate(2, PoGaugeLegendComponent_ng_template_2_Template, 1, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor)(4, PoGaugeLegendComponent_ng_template_4_Template, 1, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.ranges)("ngForTrackBy", ctx.trackBy);
      }
    },
    dependencies: [NgForOf, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeLegendComponent, [{
    type: Component,
    args: [{
      selector: "po-gauge-legend",
      standalone: false,
      template: `<ul class="po-gauge-legend">
  <li class="po-gauge-legend-item" *ngFor="let range of ranges; trackBy: trackBy">
    <ng-container
      *ngTemplateOutlet="range.color?.includes('po-color') ? colorpalette : colorstyle; context: { $implicit: range }"
    ></ng-container>
    <p class="po-gauge-legend-text">{{ range.label }}</p>
  </li>
</ul>

<ng-template #colorpalette let-range>
  <span class="po-gauge-legend-square" [class]="range.color"></span>
</ng-template>

<ng-template #colorstyle let-range>
  <span class="po-gauge-legend-square" [style.background]="range.color"></span>
</ng-template>
`
    }]
  }], () => [], {
    ranges: [{
      type: Input,
      args: ["p-ranges"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugeLegendComponent, {
    className: "PoGaugeLegendComponent",
    filePath: "lib/components/po-gauge/po-gauge-legend/po-gauge-legend.component.ts",
    lineNumber: 10
  });
})();
var _c0$x = ["po-gauge-path", ""];
function PoGaugePathComponent__svg_path_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path");
  }
  if (rf & 2) {
    const range_r1 = ctx.$implicit;
    ɵɵclassMap((range_r1 == null ? null : range_r1.color == null ? null : range_r1.color.includes("po-color")) ? range_r1.color : "");
    ɵɵattribute("d", range_r1 == null ? null : range_r1.coordinates)("fill", range_r1 == null ? null : range_r1.color);
  }
}
var PoGaugePathComponent = class _PoGaugePathComponent {
  baseCoordinates;
  rangesCoordinates;
  constructor() {
  }
  trackBy(index) {
    return index;
  }
  static ɵfac = function PoGaugePathComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGaugePathComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoGaugePathComponent,
    selectors: [["", "po-gauge-path", ""]],
    inputs: {
      baseCoordinates: [0, "p-base-coordinates", "baseCoordinates"],
      rangesCoordinates: [0, "p-ranges-coordinates", "rangesCoordinates"]
    },
    standalone: false,
    attrs: _c0$x,
    decls: 3,
    vars: 3,
    consts: [[1, "po-gauge-base"], [3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"]],
    template: function PoGaugePathComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "g");
        ɵɵelement(1, "path", 0);
        ɵɵtemplate(2, PoGaugePathComponent__svg_path_2_Template, 1, 4, "path", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵattribute("d", ctx.baseCoordinates == null ? null : ctx.baseCoordinates.coordinates);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.rangesCoordinates)("ngForTrackBy", ctx.trackBy);
      }
    },
    dependencies: [NgForOf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugePathComponent, [{
    type: Component,
    args: [{
      selector: "[po-gauge-path]",
      standalone: false,
      template: `<svg:g>
  <svg:path
    class="po-gauge-base"
    [attr.d]="baseCoordinates?.coordinates">
  </svg:path> 

  <svg:path *ngFor="let range of rangesCoordinates; trackBy: trackBy"
    [class]="range?.color?.includes('po-color') ? range.color : ''"
    [attr.d]="range?.coordinates"
    [attr.fill]="range?.color">
  </svg:path> 
</svg:g>
`
    }]
  }], () => [], {
    baseCoordinates: [{
      type: Input,
      args: ["p-base-coordinates"]
    }],
    rangesCoordinates: [{
      type: Input,
      args: ["p-ranges-coordinates"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugePathComponent, {
    className: "PoGaugePathComponent",
    filePath: "lib/components/po-gauge/po-gauge-svg/po-gauge-path/po-gauge-path.component.ts",
    lineNumber: 10
  });
})();
var _c0$w = ["pointer"];
var _c1$a = ["po-gauge-pointer", ""];
var PoGaugePointerComponent = class _PoGaugePointerComponent {
  renderer;
  pointer;
  radiusScale;
  _coordinates;
  afterViewInit = false;
  set coordinates(value) {
    this._coordinates = value;
    if (this._coordinates?.radius) {
      this.calculateRadiusScale(this.coordinates.radius);
    }
    if (this._coordinates?.hasOwnProperty("pointerDegrees") && this.afterViewInit) {
      this.applyPointerRotation(this.coordinates.pointerDegrees);
    }
  }
  get coordinates() {
    return this._coordinates;
  }
  constructor(renderer) {
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    if (this._coordinates?.pointerDegrees) {
      this.applyPointerRotation(this.coordinates.pointerDegrees);
    }
    this.afterViewInit = true;
  }
  calculateRadiusScale(radius) {
    const scale = radius / 20;
    const maxScaleValue = 24;
    this.radiusScale = scale < maxScaleValue ? scale : maxScaleValue;
  }
  applyPointerRotation(degrees) {
    this.renderer.setStyle(this.pointer.nativeElement, "transformOrigin", `${this.coordinates.radius}px ${this.coordinates.radius}px`);
    this.renderer.setStyle(this.pointer.nativeElement, "transform", `rotate(${degrees}deg)`);
  }
  static ɵfac = function PoGaugePointerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGaugePointerComponent)(ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoGaugePointerComponent,
    selectors: [["", "po-gauge-pointer", ""]],
    viewQuery: function PoGaugePointerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$w, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pointer = _t.first);
      }
    },
    inputs: {
      coordinates: [0, "p-coordinates", "coordinates"]
    },
    standalone: false,
    attrs: _c1$a,
    decls: 4,
    vars: 4,
    consts: [["pointer", ""], [1, "po-gauge-pointer"], [1, "po-gauge-pointer-circle"]],
    template: function PoGaugePointerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵnamespaceSVG();
        ɵɵelementStart(0, "g");
        ɵɵelement(1, "path", 1, 0)(3, "circle", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵattribute("d", ctx.coordinates == null ? null : ctx.coordinates.coordinates);
        ɵɵadvance(2);
        ɵɵattribute("cx", ctx.coordinates == null ? null : ctx.coordinates.radius)("cy", ctx.coordinates == null ? null : ctx.coordinates.radius)("r", ctx.radiusScale);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugePointerComponent, [{
    type: Component,
    args: [{
      selector: "[po-gauge-pointer]",
      standalone: false,
      template: '<svg:g>\n  <svg:path #pointer\n    class="po-gauge-pointer"\n    [attr.d]="coordinates?.coordinates"\n  >\n  </svg:path> \n\n  <svg:circle \n    class="po-gauge-pointer-circle" \n    [attr.cx]="coordinates?.radius" \n    [attr.cy]="coordinates?.radius" \n    [attr.r]="radiusScale"\n  >\n  </svg:circle>\n</svg:g>'
    }]
  }], () => [{
    type: Renderer2
  }], {
    pointer: [{
      type: ViewChild,
      args: ["pointer"]
    }],
    coordinates: [{
      type: Input,
      args: ["p-coordinates"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugePointerComponent, {
    className: "PoGaugePointerComponent",
    filePath: "lib/components/po-gauge/po-gauge-svg/po-gauge-pointer/po-gauge-pointer.component.ts",
    lineNumber: 9
  });
})();
function PoGaugeSvgComponent__svg_svg_0__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "g", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("p-coordinates", ctx_r0.pointerCoordinates);
  }
}
function PoGaugeSvgComponent__svg_svg_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 1);
    ɵɵelement(1, "g", 2);
    ɵɵtemplate(2, PoGaugeSvgComponent__svg_svg_0__svg_g_2_Template, 1, 1, "g", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("viewBox", ctx_r0.viewBox)("height", ctx_r0.container == null ? null : ctx_r0.container.height);
    ɵɵadvance();
    ɵɵproperty("p-base-coordinates", ctx_r0.baseCoordinates)("p-ranges-coordinates", ctx_r0.coordinates);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.hasRanges);
  }
}
var poGaugeStartAngle = -Math.PI;
var PoGaugeSvgComponent = class _PoGaugeSvgComponent {
  container;
  ranges;
  value;
  addSvgElement = false;
  baseCoordinates;
  coordinates;
  pointerCoordinates;
  viewBox;
  get hasRanges() {
    return this.ranges.length > 0;
  }
  ngOnChanges(changes) {
    if (this.container && changes.value || this.container && changes.ranges || this.container) {
      this.setCoordinates(this.value, this.ranges, this.container);
    }
  }
  setCoordinates(value, ranges, container) {
    const {
      height
    } = container;
    this.addSvgElement = true;
    this.setViewBox(height);
    this.setBaseCoordinates(height);
    if (!ranges.length) {
      this.setSingleRangeCoordinates(height, value);
      return;
    }
    this.setRangesCoordinates(height, value, ranges);
  }
  setBaseCoordinates(height) {
    const endAngleRadian = 0;
    const coordinates = this.calculateCoordinates(height, poGaugeStartAngle, endAngleRadian);
    this.baseCoordinates = {
      coordinates
    };
  }
  setRangesCoordinates(height, value = 0, ranges) {
    const {
      minRange,
      maxRange
    } = this.calculateMinAndMaxValues(ranges);
    const minValue = value < minRange ? value : minRange;
    const maxValue = value > maxRange ? value : maxRange;
    this.setPointerCoordinates(height, value, maxValue, minValue);
    const rangesCoordinates = ranges.map((range) => {
      const from2 = range.from ?? 0;
      const to = range.to ?? maxRange;
      const startAngleRadian = poGaugeStartAngle + this.calculateAngleRadius(from2, maxValue, minValue);
      const endAngleRadian = poGaugeStartAngle + this.calculateAngleRadius(to, maxValue, minValue);
      const coordinates = this.calculateCoordinates(height, startAngleRadian, endAngleRadian);
      return {
        coordinates,
        color: range.color
      };
    }).reverse();
    this.coordinates = rangesCoordinates;
  }
  setSingleRangeCoordinates(height, value) {
    const verifiedValue = value > 100 ? 100 : value;
    const endAngleRadian = poGaugeStartAngle + this.calculateAngleRadius(verifiedValue, poGaugeTotalValueDefault);
    const coordinates = value > 0 ? this.calculateCoordinates(height, poGaugeStartAngle, endAngleRadian) : void 0;
    const color = PoDefaultColors[0][0];
    this.coordinates = [{
      coordinates,
      color
    }];
  }
  setPointerCoordinates(height, value, maxValue, minValue) {
    const coordinates = this.calculatePointerInitialCoordinates(height, poGaugeStartAngle);
    const pointerDegrees = this.pointerRotation(value, maxValue, minValue);
    this.pointerCoordinates = __spreadProps(__spreadValues({}, coordinates), {
      pointerDegrees
    });
  }
  pointerRotation(value, maxValue, minValue) {
    const percent = this.convertValueToPercentage(value, maxValue, minValue);
    const minRotation = 0;
    const maxRotation = 180;
    return percent * (maxRotation - minRotation) / 100 + minRotation;
  }
  calculatePointerInitialCoordinates(height, startAngleRadian) {
    const radius = height - PoGaugePointerEnd - PoGaugeThickness / 2;
    const scale = 40;
    const pointerScaledWidth = radius / scale;
    const pointerScaledBorderRadius = radius / (scale * 2);
    const sinAlpha = Math.sin(startAngleRadian);
    const cosAlpha = Math.cos(startAngleRadian);
    const targetX = radius + cosAlpha * radius;
    const targetY = radius + sinAlpha * radius;
    const startX = radius;
    const startY = radius + pointerScaledWidth;
    const endX = radius;
    const endY = radius - pointerScaledWidth;
    const coordinates = ["M", startX, startY, "L", targetX, targetY + pointerScaledBorderRadius, "A", 1, 1, 0, "0,1", targetX, targetY - pointerScaledBorderRadius, "L", endX, endY, "Z"].join(" ");
    return {
      coordinates,
      radius
    };
  }
  calculateCoordinates(height, startAngleRadian, endAngleRadian) {
    const radius = height - PoGaugePointerEnd - PoGaugeThickness / 2;
    const innerRadius = radius - PoGaugeThickness;
    const sinAlpha = Math.sin(startAngleRadian);
    const cosAlpha = Math.cos(startAngleRadian);
    const sinBeta = Math.sin(endAngleRadian);
    const cosBeta = Math.cos(endAngleRadian);
    const startX = Math.round(radius + cosAlpha * radius);
    const startY = Math.round(radius + sinAlpha * radius);
    const endX = Math.round(radius + cosBeta * radius);
    const endY = Math.round(radius + sinBeta * radius);
    const startInnerX = Math.round(radius + cosAlpha * innerRadius);
    const startInnerY = Math.round(radius + sinAlpha * innerRadius);
    const endInnerX = Math.round(radius + cosBeta * innerRadius);
    const endInnerY = Math.round(radius + sinBeta * innerRadius);
    return ["M", startX, startY, "A", radius, radius, 0, "0,1", endX, endY, "A", 1, 1, 0, "0,1", endInnerX, endInnerY, "A", innerRadius, innerRadius, 0, "0,0", startInnerX, startInnerY, "A", 1, 1, 0, "0,1", startX, startY, "Z"].join(" ");
  }
  calculateAngleRadius(value, maxValue, minValue = 0) {
    const angle = (value - minValue) / (maxValue - minValue) * (Math.PI * 2);
    return angle / 2;
  }
  convertValueToPercentage(value, maxValue, minValue) {
    return (value - minValue) / (maxValue - minValue) * 100;
  }
  setViewBox(height) {
    const width = this.calculateDiameter(height);
    this.viewBox = `0 ${-PoGaugePointerEnd} ${width} ${height}`;
  }
  calculateDiameter(height) {
    const radius = height - PoGaugePointerEnd - PoGaugeThickness / 2;
    return radius + Math.cos(0) * radius;
  }
  calculateMinAndMaxValues(ranges) {
    const minRange = this.getDomain(ranges, "min");
    const maxRange = this.getDomain(ranges, "max");
    return {
      minRange: this.verifyIfFloatOrInteger(minRange) ? minRange : 0,
      maxRange: this.verifyIfFloatOrInteger(maxRange) ? maxRange : 100
    };
  }
  verifyIfFloatOrInteger(number) {
    const notABoolean = typeof number !== "boolean";
    const notInfinity = number !== Infinity;
    const isInteger = Number(number) === number && number % 1 === 0 && notInfinity;
    const isFloat = Number(number) === number && number % 1 !== 0 && notInfinity;
    return notABoolean && isInteger || notABoolean && isFloat;
  }
  getDomain(ranges, type) {
    const rangeType = {
      min: "from",
      max: "to"
    };
    return Math[type](...ranges.map((range) => range[rangeType[type]]));
  }
  static ɵfac = function PoGaugeSvgComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGaugeSvgComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoGaugeSvgComponent,
    selectors: [["po-gauge-svg"]],
    inputs: {
      container: [0, "p-container", "container"],
      ranges: [0, "p-ranges", "ranges"],
      value: [0, "p-value", "value"]
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature],
    decls: 1,
    vars: 1,
    consts: [["class", "po-gauge-svg", "preserveAspectRatio", "xMidYMax meet", "width", "100%", 4, "ngIf"], ["preserveAspectRatio", "xMidYMax meet", "width", "100%", 1, "po-gauge-svg"], ["po-gauge-path", "", 3, "p-base-coordinates", "p-ranges-coordinates"], ["po-gauge-pointer", "", 3, "p-coordinates", 4, "ngIf"], ["po-gauge-pointer", "", 3, "p-coordinates"]],
    template: function PoGaugeSvgComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoGaugeSvgComponent__svg_svg_0_Template, 3, 5, "svg", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.addSvgElement);
      }
    },
    dependencies: [NgIf, PoGaugePathComponent, PoGaugePointerComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeSvgComponent, [{
    type: Component,
    args: [{
      selector: "po-gauge-svg",
      standalone: false,
      template: '<svg:svg\n  *ngIf="addSvgElement"\n  class="po-gauge-svg"\n  preserveAspectRatio="xMidYMax meet"\n  width="100%"\n  [attr.viewBox]="viewBox"\n  [attr.height]="container?.height"\n>\n  <!-- GAUGE PATHS -->\n  <svg:g po-gauge-path [p-base-coordinates]="baseCoordinates" [p-ranges-coordinates]="coordinates"></svg:g>\n\n  <!-- GAUGE POINTER -->\n  <svg:g *ngIf="hasRanges" po-gauge-pointer [p-coordinates]="pointerCoordinates"></svg:g>\n</svg:svg>\n'
    }]
  }], null, {
    container: [{
      type: Input,
      args: ["p-container"]
    }],
    ranges: [{
      type: Input,
      args: ["p-ranges"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugeSvgComponent, {
    className: "PoGaugeSvgComponent",
    filePath: "lib/components/po-gauge/po-gauge-svg/po-gauge-svg.component.ts",
    lineNumber: 18
  });
})();
var _c0$v = ["descriptionText"];
function PoGaugeDescriptionComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoGaugeDescriptionComponent_ng_template_2_p_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "p", 6, 2);
    ɵɵlistener("mouseenter", function PoGaugeDescriptionComponent_ng_template_2_p_0_Template_p_mouseenter_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.verifyIfHasEllipsis());
    });
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-tooltip", ctx_r1.tooltip);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.description, " ");
  }
}
function PoGaugeDescriptionComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoGaugeDescriptionComponent_ng_template_2_p_0_Template, 3, 2, "p", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.description);
  }
}
function PoGaugeDescriptionComponent_ng_template_4_p_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r1.value, "%");
  }
}
function PoGaugeDescriptionComponent_ng_template_4_p_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "p", 11, 2);
    ɵɵlistener("mouseenter", function PoGaugeDescriptionComponent_ng_template_4_p_2_Template_p_mouseenter_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.verifyIfHasEllipsis());
    });
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-tooltip", ctx_r1.tooltip);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.description, " ");
  }
}
function PoGaugeDescriptionComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, PoGaugeDescriptionComponent_ng_template_4_p_1_Template, 2, 1, "p", 8)(2, PoGaugeDescriptionComponent_ng_template_4_p_2_Template, 3, 2, "p", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r1.descriptionWidth, "px");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isValidValue);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.description);
  }
}
var PoGaugeDescriptionComponent = class _PoGaugeDescriptionComponent {
  description;
  hasRanges;
  descriptionWidth;
  value;
  descriptionText;
  tooltip;
  get isValidValue() {
    return this.value || this.value === 0;
  }
  verifyIfHasEllipsis() {
    const {
      offsetWidth,
      scrollWidth
    } = this.descriptionText.nativeElement;
    setTimeout(() => {
      this.tooltip = offsetWidth < scrollWidth ? this.description : void 0;
    });
  }
  static ɵfac = function PoGaugeDescriptionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGaugeDescriptionComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoGaugeDescriptionComponent,
    selectors: [["po-gauge-description"]],
    viewQuery: function PoGaugeDescriptionComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$v, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.descriptionText = _t.first);
      }
    },
    inputs: {
      description: [0, "p-description", "description"],
      hasRanges: [0, "p-has-ranges", "hasRanges"],
      descriptionWidth: [0, "p-description-width", "descriptionWidth"],
      value: [0, "p-value", "value"]
    },
    standalone: false,
    decls: 6,
    vars: 1,
    consts: [["rangesDescription", ""], ["percentageDescription", ""], ["descriptionText", ""], [1, "po-gauge-description"], [4, "ngTemplateOutlet"], ["class", "po-gauge-description-text po-gauge-description-upper-text", 3, "p-tooltip", "mouseenter", 4, "ngIf"], [1, "po-gauge-description-text", "po-gauge-description-upper-text", 3, "mouseenter", "p-tooltip"], ["tabindex", "0", 1, "po-gauge-description-bottom"], ["class", "po-gauge-description-bottom-value", 4, "ngIf"], ["class", "po-gauge-description-text po-gauge-description-bottom-text", 3, "p-tooltip", "mouseenter", 4, "ngIf"], [1, "po-gauge-description-bottom-value"], [1, "po-gauge-description-text", "po-gauge-description-bottom-text", 3, "mouseenter", "p-tooltip"]],
    template: function PoGaugeDescriptionComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 3);
        ɵɵtemplate(1, PoGaugeDescriptionComponent_ng_container_1_Template, 1, 0, "ng-container", 4);
        ɵɵelementEnd();
        ɵɵtemplate(2, PoGaugeDescriptionComponent_ng_template_2_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(4, PoGaugeDescriptionComponent_ng_template_4_Template, 3, 4, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const rangesDescription_r4 = ɵɵreference(3);
        const percentageDescription_r5 = ɵɵreference(5);
        ɵɵadvance();
        ɵɵproperty("ngTemplateOutlet", ctx.hasRanges ? rangesDescription_r4 : percentageDescription_r5);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, PoTooltipDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeDescriptionComponent, [{
    type: Component,
    args: [{
      selector: "po-gauge-description",
      standalone: false,
      template: '<div class="po-gauge-description">\n  <ng-container *ngTemplateOutlet="hasRanges ? rangesDescription : percentageDescription"> </ng-container>\n</div>\n\n<ng-template #rangesDescription>\n  <p\n    #descriptionText\n    *ngIf="description"\n    class="po-gauge-description-text po-gauge-description-upper-text"\n    [p-tooltip]="tooltip"\n    (mouseenter)="verifyIfHasEllipsis()"\n  >\n    {{ description }}\n  </p>\n</ng-template>\n\n<ng-template #percentageDescription>\n  <div class="po-gauge-description-bottom" tabindex="0" [style.width.px]="descriptionWidth">\n    <p *ngIf="isValidValue" class="po-gauge-description-bottom-value">{{ value }}%</p>\n    <p\n      #descriptionText\n      *ngIf="description"\n      class="po-gauge-description-text po-gauge-description-bottom-text"\n      [p-tooltip]="tooltip"\n      (mouseenter)="verifyIfHasEllipsis()"\n    >\n      {{ description }}\n    </p>\n  </div>\n</ng-template>\n'
    }]
  }], null, {
    description: [{
      type: Input,
      args: ["p-description"]
    }],
    hasRanges: [{
      type: Input,
      args: ["p-has-ranges"]
    }],
    descriptionWidth: [{
      type: Input,
      args: ["p-description-width"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }],
    descriptionText: [{
      type: ViewChild,
      args: ["descriptionText"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugeDescriptionComponent, {
    className: "PoGaugeDescriptionComponent",
    filePath: "lib/components/po-gauge/po-gauge-description/po-gauge-description.component.ts",
    lineNumber: 8
  });
})();
var _c0$u = ["descriptionEl"];
var _c1$9 = ["legendEl"];
var _c2$3 = ["titleEl"];
var _c3$2 = ["svgEl"];
var PoGaugeComponent = class _PoGaugeComponent extends PoGaugeBaseComponent {
  colorService;
  changeDetector;
  descriptionEl;
  legendEl;
  titleEl;
  svgEl;
  svgContainer;
  isLoaded = false;
  constructor(colorService, changeDetector) {
    super(colorService);
    this.colorService = colorService;
    this.changeDetector = changeDetector;
  }
  get hasElementRef() {
    return !!this.svgEl?.nativeElement.offsetWidth;
  }
  get hasRanges() {
    return this.ranges.length > 0;
  }
  ngDoCheck() {
    if (!this.isLoaded && this.hasElementRef) {
      this.isLoaded = true;
      this.svgContainerSize();
    }
  }
  svgContainerSize() {
    if (this.svgEl?.nativeElement.offsetWidth) {
      this.changeDetector.detectChanges();
      const titleHeight = this.titleEl.nativeElement?.offsetHeight ?? 0;
      const legendHeight = this.legendEl.nativeElement?.offsetHeight ?? 0;
      const descriptionHeight = this.descriptionEl.nativeElement?.offsetHeight ?? 0;
      const height = this.height - titleHeight - legendHeight - descriptionHeight - PoGaugePadding * 2;
      const width = this.svgEl.nativeElement.offsetWidth;
      this.svgContainer = {
        width,
        height
      };
    }
  }
  static ɵfac = function PoGaugeComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGaugeComponent)(ɵɵdirectiveInject(PoColorService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoGaugeComponent,
    selectors: [["po-gauge"]],
    viewQuery: function PoGaugeComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$u, 5, ElementRef);
        ɵɵviewQuery(_c1$9, 5, ElementRef);
        ɵɵviewQuery(_c2$3, 5, ElementRef);
        ɵɵviewQuery(_c3$2, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.descriptionEl = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.legendEl = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titleEl = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgEl = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 9,
    vars: 11,
    consts: [["titleEl", ""], ["descriptionEl", ""], ["svgEl", ""], ["legendEl", ""], [1, "po-gauge-wrapper"], [3, "p-title"], [3, "p-description", "p-description-width", "p-has-ranges", "p-value"], [3, "p-container", "p-ranges", "p-value"], [3, "p-ranges"]],
    template: function PoGaugeComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 4);
        ɵɵelement(1, "po-gauge-title", 5, 0)(3, "po-gauge-description", 6, 1)(5, "po-gauge-svg", 7, 2)(7, "po-gauge-legend", 8, 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵstyleProp("height", ctx.height, "px");
        ɵɵadvance();
        ɵɵproperty("p-title", ctx.title);
        ɵɵadvance(2);
        ɵɵproperty("p-description", ctx.description)("p-description-width", ctx.height)("p-has-ranges", ctx.hasRanges)("p-value", ctx.value);
        ɵɵadvance(2);
        ɵɵproperty("p-container", ctx.svgContainer)("p-ranges", ctx.ranges)("p-value", ctx.value);
        ɵɵadvance(2);
        ɵɵproperty("p-ranges", ctx.ranges);
      }
    },
    dependencies: [PoGaugeTitleComponent, PoGaugeLegendComponent, PoGaugeSvgComponent, PoGaugeDescriptionComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeComponent, [{
    type: Component,
    args: [{
      selector: "po-gauge",
      standalone: false,
      template: '<div class="po-gauge-wrapper" [style.height.px]="height">\n  <po-gauge-title #titleEl [p-title]="title"></po-gauge-title>\n\n  <po-gauge-description\n    #descriptionEl\n    [p-description]="description"\n    [p-description-width]="height"\n    [p-has-ranges]="hasRanges"\n    [p-value]="value"\n  ></po-gauge-description>\n\n  <po-gauge-svg #svgEl [p-container]="svgContainer" [p-ranges]="ranges" [p-value]="value"></po-gauge-svg>\n\n  <po-gauge-legend #legendEl [p-ranges]="ranges"> </po-gauge-legend>\n</div>\n'
    }]
  }], () => [{
    type: PoColorService
  }, {
    type: ChangeDetectorRef
  }], {
    descriptionEl: [{
      type: ViewChild,
      args: ["descriptionEl", {
        read: ElementRef
      }]
    }],
    legendEl: [{
      type: ViewChild,
      args: ["legendEl", {
        read: ElementRef
      }]
    }],
    titleEl: [{
      type: ViewChild,
      args: ["titleEl", {
        read: ElementRef
      }]
    }],
    svgEl: [{
      type: ViewChild,
      args: ["svgEl", {
        read: ElementRef
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugeComponent, {
    className: "PoGaugeComponent",
    filePath: "lib/components/po-gauge/po-gauge.component.ts",
    lineNumber: 33
  });
})();
var PoGaugeModule = class _PoGaugeModule {
  static ɵfac = function PoGaugeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGaugeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoGaugeModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoTooltipModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoTooltipModule],
      declarations: [PoGaugeComponent, PoGaugeTitleComponent, PoGaugeLegendComponent, PoGaugeSvgComponent, PoGaugePathComponent, PoGaugeDescriptionComponent, PoGaugePointerComponent],
      exports: [PoGaugeComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoGaugeModule, {
    declarations: [PoGaugeComponent, PoGaugeTitleComponent, PoGaugeLegendComponent, PoGaugeSvgComponent, PoGaugePathComponent, PoGaugeDescriptionComponent, PoGaugePointerComponent],
    imports: [CommonModule, PoTooltipModule],
    exports: [PoGaugeComponent]
  });
})();
var PoGridCellActionComponent = class _PoGridCellActionComponent {
  position = "";
  value;
  constructor() {
  }
  onKeyDownContent(event) {
    if (event.keyCode === 13) {
      event.preventDefault();
    }
  }
  static ɵfac = function PoGridCellActionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGridCellActionComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoGridCellActionComponent,
    selectors: [["po-grid-cell-action"]],
    inputs: {
      position: [0, "p-position", "position"],
      value: [0, "p-value", "value"]
    },
    standalone: false,
    decls: 5,
    vars: 2,
    consts: [["contentElement", ""], ["tabindex", "0", 1, "po-grid-cell-action-content", 3, "keydown", "id"]],
    template: function PoGridCellActionComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div")(1, "div", 1, 0);
        ɵɵlistener("keydown", function PoGridCellActionComponent_Template_div_keydown_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onKeyDownContent($event));
        });
        ɵɵelementStart(3, "span");
        ɵɵtext(4);
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("id", ctx.position);
        ɵɵadvance(3);
        ɵɵtextInterpolate(ctx.value || " ");
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGridCellActionComponent, [{
    type: Component,
    args: [{
      selector: "po-grid-cell-action",
      standalone: false,
      template: `<div>
  <div
    #contentElement
    [id]="position"
    class="po-grid-cell-action-content"
    tabindex="0"
    (keydown)="onKeyDownContent($event)"
  >
    <span>{{ value || '&nbsp;' }}</span>
  </div>
</div>
`
    }]
  }], () => [], {
    position: [{
      type: Input,
      args: ["p-position"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGridCellActionComponent, {
    className: "PoGridCellActionComponent",
    filePath: "lib/components/po-grid/po-grid-cell-action/po-grid-cell-action.component.ts",
    lineNumber: 8
  });
})();
var _c0$t = ["inputElement"];
var _c1$8 = ["contentElement"];
function PoGridCellComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoGridCellComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 5, 2);
    ɵɵlistener("keydown", function PoGridCellComponent_ng_template_2_Template_div_keydown_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onKeyDownContent($event));
    })("dblclick", function PoGridCellComponent_ng_template_2_Template_div_dblclick_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.dblclick($event));
    });
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMapInterpolate2("po-grid-cell-content po-grid-cell-", ctx_r1.align, " ", !ctx_r1.value && ctx_r1.required ? "po-grid-cell-required" : "", "");
    ɵɵpropertyInterpolate("tabindex", ctx_r1.readonly ? -1 : 0);
    ɵɵproperty("id", ctx_r1.position);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r1.value || " ");
  }
}
function PoGridCellComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 6, 3);
    ɵɵtwoWayListener("ngModelChange", function PoGridCellComponent_ng_template_4_Template_input_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.editValue, $event) || (ctx_r1.editValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("keydown.arrowup", function PoGridCellComponent_ng_template_4_Template_input_keydown_arrowup_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.stopPropagation());
    })("keydown.arrowdown", function PoGridCellComponent_ng_template_4_Template_input_keydown_arrowdown_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.stopPropagation());
    })("keydown.arrowleft", function PoGridCellComponent_ng_template_4_Template_input_keydown_arrowleft_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.stopPropagation());
    })("keydown.arrowright", function PoGridCellComponent_ng_template_4_Template_input_keydown_arrowright_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.stopPropagation());
    })("keydown", function PoGridCellComponent_ng_template_4_Template_input_keydown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onKeyDownInput($event));
    })("blur", function PoGridCellComponent_ng_template_4_Template_input_blur_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onBlurInput());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r1.position);
    ɵɵtwoWayProperty("ngModel", ctx_r1.editValue);
  }
}
var PoGridCellComponent = class _PoGridCellComponent {
  changeDetectorRef;
  align = "left";
  freeze = false;
  tabIndex = -1;
  position = "";
  readonly = false;
  required = false;
  valueChange = new EventEmitter();
  inputElement;
  contentElement;
  _value = "";
  edit = false;
  editValue = "";
  _width;
  set width(value) {
    this._width = value;
    if (this.freeze && !this._width) {
      this._width = 100;
    }
  }
  get width() {
    return this._width ? `${this._width}px` : "100%";
  }
  set value(value) {
    this._value = value;
    this.valueChange.emit(this._value);
  }
  get value() {
    return this._value;
  }
  constructor(changeDetectorRef) {
    this.changeDetectorRef = changeDetectorRef;
  }
  onKeyDownContent(event) {
    if (!event.ctrlKey && (event.keyCode === 8 || event.keyCode === 46)) {
      if (this.readonly) {
        return;
      }
      event.preventDefault();
      this.value = "";
      return;
    }
    if (event.keyCode === 13) {
      event.preventDefault();
      this.onEditCell(this.value);
      return;
    }
    if (event.keyCode >= 65 && event.keyCode <= 90 || event.keyCode >= 48 && event.keyCode <= 57) {
      event.preventDefault();
      this.onEditCell(event.key);
    }
  }
  dblclick(event) {
    event.preventDefault();
    this.onEditCell(this.value);
  }
  onBlurInput() {
    this.value = this.editValue;
    this.editValue = void 0;
    this.edit = false;
  }
  onKeyDownInput(event) {
    if (event.keyCode === 13) {
      event.target.blur();
      this.changeDetectorRef.detectChanges();
      this.contentElement.nativeElement.focus();
    }
    if (event.keyCode === 27) {
      this.editValue = void 0;
      this.edit = false;
      this.changeDetectorRef.detectChanges();
      this.contentElement.nativeElement.focus();
      event.stopPropagation();
    }
  }
  onEditCell(value) {
    if (this.readonly) {
      return;
    }
    this.editValue = value;
    this.edit = true;
    this.changeDetectorRef.detectChanges();
    this.inputElement.nativeElement.focus();
  }
  static ɵfac = function PoGridCellComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGridCellComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoGridCellComponent,
    selectors: [["po-grid-cell"]],
    viewQuery: function PoGridCellComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$t, 5);
        ɵɵviewQuery(_c1$8, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentElement = _t.first);
      }
    },
    inputs: {
      align: [0, "p-align", "align"],
      freeze: [0, "p-freeze", "freeze"],
      tabIndex: [0, "p-tab-index", "tabIndex"],
      position: [0, "p-position", "position"],
      readonly: [0, "p-readonly", "readonly"],
      required: [0, "p-required", "required"],
      width: [0, "p-width", "width"],
      value: [0, "p-value", "value"]
    },
    outputs: {
      valueChange: "p-valueChange"
    },
    standalone: false,
    decls: 6,
    vars: 3,
    consts: [["content", ""], ["input", ""], ["contentElement", ""], ["inputElement", ""], [4, "ngIf", "ngIfThen", "ngIfElse"], [3, "keydown", "dblclick", "id", "tabindex"], [1, "po-grid-cell-input", 3, "ngModelChange", "keydown.arrowup", "keydown.arrowdown", "keydown.arrowleft", "keydown.arrowright", "keydown", "blur", "id", "ngModel"]],
    template: function PoGridCellComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div");
        ɵɵtemplate(1, PoGridCellComponent_ng_container_1_Template, 1, 0, "ng-container", 4)(2, PoGridCellComponent_ng_template_2_Template, 4, 7, "ng-template", null, 0, ɵɵtemplateRefExtractor)(4, PoGridCellComponent_ng_template_4_Template, 2, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        const content_r4 = ɵɵreference(3);
        const input_r5 = ɵɵreference(5);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.edit)("ngIfThen", input_r5)("ngIfElse", content_r4);
      }
    },
    dependencies: [NgIf, DefaultValueAccessor, NgControlStatus, NgModel],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGridCellComponent, [{
    type: Component,
    args: [{
      selector: "po-grid-cell",
      standalone: false,
      template: `<div>
  <ng-container *ngIf="edit; then input; else content"></ng-container>

  <ng-template #content>
    <div
      #contentElement
      [id]="position"
      class="po-grid-cell-content po-grid-cell-{{ align }} {{ !value && required ? 'po-grid-cell-required' : '' }}"
      (keydown)="onKeyDownContent($event)"
      tabindex="{{ readonly ? -1 : 0 }}"
      (dblclick)="dblclick($event)"
    >
      <span>{{ value || '&nbsp;' }}</span>
    </div>
  </ng-template>

  <ng-template #input>
    <input
      [id]="position"
      #inputElement
      class="po-grid-cell-input"
      [(ngModel)]="editValue"
      (keydown.arrowup)="$event.stopPropagation()"
      (keydown.arrowdown)="$event.stopPropagation()"
      (keydown.arrowleft)="$event.stopPropagation()"
      (keydown.arrowright)="$event.stopPropagation()"
      (keydown)="onKeyDownInput($event)"
      (blur)="onBlurInput()"
    />
  </ng-template>
</div>
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    align: [{
      type: Input,
      args: ["p-align"]
    }],
    freeze: [{
      type: Input,
      args: ["p-freeze"]
    }],
    tabIndex: [{
      type: Input,
      args: ["p-tab-index"]
    }],
    position: [{
      type: Input,
      args: ["p-position"]
    }],
    readonly: [{
      type: Input,
      args: ["p-readonly"]
    }],
    required: [{
      type: Input,
      args: ["p-required"]
    }],
    valueChange: [{
      type: Output,
      args: ["p-valueChange"]
    }],
    inputElement: [{
      type: ViewChild,
      args: ["inputElement"]
    }],
    contentElement: [{
      type: ViewChild,
      args: ["contentElement"]
    }],
    width: [{
      type: Input,
      args: ["p-width"]
    }],
    value: [{
      type: Input,
      args: ["p-value"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGridCellComponent, {
    className: "PoGridCellComponent",
    filePath: "lib/components/po-grid/po-grid-cell/po-grid-cell.component.ts",
    lineNumber: 8
  });
})();
var PoGridHeadComponent = class _PoGridHeadComponent {
  align = "left";
  boolean = false;
  position = "";
  tabIndex = -1;
  title;
  _width;
  set width(value) {
    this._width = value;
  }
  get width() {
    return this._width ? `${this._width}px` : "100%";
  }
  static ɵfac = function PoGridHeadComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGridHeadComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoGridHeadComponent,
    selectors: [["po-grid-head"]],
    inputs: {
      align: [0, "p-align", "align"],
      boolean: [0, "p-freeze", "boolean"],
      position: [0, "p-position", "position"],
      tabIndex: [0, "p-tab-index", "tabIndex"],
      title: [0, "p-title", "title"],
      width: [0, "p-width", "width"]
    },
    standalone: false,
    decls: 4,
    vars: 6,
    consts: [[3, "id", "tabindex"]],
    template: function PoGridHeadComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div")(1, "div", 0)(2, "span");
        ɵɵtext(3);
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵclassMapInterpolate1("po-grid-head-content po-grid-head-", ctx.align, "");
        ɵɵpropertyInterpolate("tabindex", ctx.title ? 0 : -1);
        ɵɵproperty("id", ctx.position);
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.title || " ");
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGridHeadComponent, [{
    type: Component,
    args: [{
      selector: "po-grid-head",
      standalone: false,
      template: `<div>
  <div [id]="position" class="po-grid-head-content po-grid-head-{{ align }}" tabindex="{{ title ? 0 : -1 }}">
    <span>{{ title || '&nbsp;' }}</span>
  </div>
</div>
`
    }]
  }], null, {
    align: [{
      type: Input,
      args: ["p-align"]
    }],
    boolean: [{
      type: Input,
      args: ["p-freeze"]
    }],
    position: [{
      type: Input,
      args: ["p-position"]
    }],
    tabIndex: [{
      type: Input,
      args: ["p-tab-index"]
    }],
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    width: [{
      type: Input,
      args: ["p-width"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGridHeadComponent, {
    className: "PoGridHeadComponent",
    filePath: "lib/components/po-grid/po-grid-head/po-grid-head.component.ts",
    lineNumber: 8
  });
})();
var _c0$s = ["table"];
var _c1$7 = ["wrapper"];
function PoGridComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelement(2, "br");
    ɵɵtext(3);
    ɵɵelement(4, "br");
    ɵɵtext(5);
    ɵɵelement(6, "br")(7, "hr");
    ɵɵtext(8);
    ɵɵpipe(9, "json");
    ɵɵelement(10, "hr");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate2(" lastCell: ", ctx_r1.lastCell, " | currencyCell: ", ctx_r1.currencyCell, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate2(" lastRow: ", ctx_r1.lastRow, " | currencyRow: ", ctx_r1.currencyRow, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate2(" lastColumn: ", ctx_r1.lastColumn, " | currencyColumn: ", ctx_r1.currencyColumn, " ");
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" currencyObj: ", ɵɵpipeBind1(9, 7, ctx_r1.currencyObj), " ");
  }
}
function PoGridComponent_div_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoGridComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 14);
    ɵɵtemplate(1, PoGridComponent_div_7_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const divFreezeColumns_r3 = ɵɵreference(12);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", divFreezeColumns_r3);
  }
}
function PoGridComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoGridComponent_div_10_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoGridComponent_div_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtemplate(1, PoGridComponent_div_10_ng_container_1_Template, 1, 0, "ng-container", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const divActionColumns_r4 = ɵɵreference(16);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", divActionColumns_r4);
  }
}
function PoGridComponent_ng_template_11_po_grid_head_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-grid-head", 21);
  }
  if (rf & 2) {
    const column_r5 = ctx.$implicit;
    const i_r6 = ctx.index;
    ɵɵstyleProp("width", column_r5.cssWidth)("max-width", column_r5.cssWidth)("min-width", column_r5.cssWidth);
    ɵɵpropertyInterpolate("p-position", "0-" + i_r6);
    ɵɵproperty("p-width", column_r5.width)("p-align", column_r5.align)("p-title", column_r5.label);
  }
}
function PoGridComponent_ng_template_11_div_5_po_grid_cell_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-grid-cell", 24);
    ɵɵtwoWayListener("p-valueChange", function PoGridComponent_ng_template_11_div_5_po_grid_cell_1_Template_po_grid_cell_p_valueChange_0_listener($event) {
      const column_r10 = ɵɵrestoreView(_r9).$implicit;
      const row_r8 = ɵɵnextContext().$implicit;
      ɵɵtwoWayBindingSet(row_r8[column_r10.property], $event) || (row_r8[column_r10.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r10 = ctx.$implicit;
    const i_r11 = ctx.index;
    const ctx_r11 = ɵɵnextContext();
    const row_r8 = ctx_r11.$implicit;
    const j_r13 = ctx_r11.index;
    ɵɵstyleProp("width", column_r10.cssWidth)("max-width", column_r10.cssWidth)("min-width", column_r10.cssWidth);
    ɵɵpropertyInterpolate("p-position", j_r13 + 1 + "-" + i_r11);
    ɵɵproperty("p-align", column_r10.align)("p-readonly", column_r10.readonly)("p-required", column_r10.required)("p-width", column_r10.width);
    ɵɵtwoWayProperty("p-value", row_r8[column_r10.property]);
  }
}
function PoGridComponent_ng_template_11_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 22);
    ɵɵlistener("keydown.control.delete", function PoGridComponent_ng_template_11_div_5_Template_div_keydown_control_delete_0_listener($event) {
      const row_r8 = ɵɵrestoreView(_r7).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.removeRow($event, row_r8));
    })("keydown.esc", function PoGridComponent_ng_template_11_div_5_Template_div_keydown_esc_0_listener($event) {
      const row_r8 = ɵɵrestoreView(_r7).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.cancelRow($event, row_r8));
    });
    ɵɵtemplate(1, PoGridComponent_ng_template_11_div_5_po_grid_cell_1_Template, 1, 12, "po-grid-cell", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.freezeColumns);
  }
}
function PoGridComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 16)(1, "div", 17)(2, "div", 18);
    ɵɵtemplate(3, PoGridComponent_ng_template_11_po_grid_head_3_Template, 1, 10, "po-grid-head", 19);
    ɵɵelementEnd()();
    ɵɵelementStart(4, "div", 8);
    ɵɵtemplate(5, PoGridComponent_ng_template_11_div_5_Template, 2, 1, "div", 20);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r1.freezeColumns);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.data);
  }
}
function PoGridComponent_ng_template_13_po_grid_head_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-grid-head", 27);
  }
  if (rf & 2) {
    const column_r14 = ctx.$implicit;
    const i_r15 = ctx.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("width", column_r14.cssWidth)("max-width", column_r14.cssWidth)("min-width", column_r14.cssWidth);
    ɵɵpropertyInterpolate("p-position", "0-" + (i_r15 + ctx_r1.freezeColumns.length));
    ɵɵproperty("p-align", column_r14.align)("p-title", column_r14.label)("p-width", column_r14.width);
  }
}
function PoGridComponent_ng_template_13_div_5_po_grid_cell_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-grid-cell", 29);
    ɵɵtwoWayListener("p-valueChange", function PoGridComponent_ng_template_13_div_5_po_grid_cell_1_Template_po_grid_cell_p_valueChange_0_listener($event) {
      const column_r19 = ɵɵrestoreView(_r18).$implicit;
      const row_r17 = ɵɵnextContext().$implicit;
      ɵɵtwoWayBindingSet(row_r17[column_r19.property], $event) || (row_r17[column_r19.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r19 = ctx.$implicit;
    const i_r20 = ctx.index;
    const ctx_r20 = ɵɵnextContext();
    const row_r17 = ctx_r20.$implicit;
    const j_r22 = ctx_r20.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("width", column_r19.cssWidth)("max-width", column_r19.cssWidth)("min-width", column_r19.cssWidth);
    ɵɵpropertyInterpolate("p-position", j_r22 + 1 + "-" + (i_r20 + ctx_r1.freezeColumns.length));
    ɵɵproperty("p-align", column_r19.align)("p-readonly", column_r19.readonly)("p-required", column_r19.required);
    ɵɵtwoWayProperty("p-value", row_r17[column_r19.property]);
    ɵɵproperty("p-width", column_r19.width);
  }
}
function PoGridComponent_ng_template_13_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 22);
    ɵɵlistener("keydown.control.delete", function PoGridComponent_ng_template_13_div_5_Template_div_keydown_control_delete_0_listener($event) {
      const row_r17 = ɵɵrestoreView(_r16).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.removeRow($event, row_r17));
    })("keydown.esc", function PoGridComponent_ng_template_13_div_5_Template_div_keydown_esc_0_listener($event) {
      const row_r17 = ɵɵrestoreView(_r16).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.cancelRow($event, row_r17));
    });
    ɵɵtemplate(1, PoGridComponent_ng_template_13_div_5_po_grid_cell_1_Template, 1, 12, "po-grid-cell", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.columns);
  }
}
function PoGridComponent_ng_template_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25)(1, "div", 17)(2, "div", 18);
    ɵɵtemplate(3, PoGridComponent_ng_template_13_po_grid_head_3_Template, 1, 10, "po-grid-head", 26);
    ɵɵelementEnd()();
    ɵɵelementStart(4, "div", 8);
    ɵɵtemplate(5, PoGridComponent_ng_template_13_div_5_Template, 2, 1, "div", 20);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r1.columns);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.data);
  }
}
function PoGridComponent_ng_template_15_po_grid_head_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-grid-head", 32);
  }
  if (rf & 2) {
    const column_r23 = ctx.$implicit;
    const i_r24 = ctx.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵpropertyInterpolate("p-position", "0-" + (i_r24 + ctx_r1.freezeColumns.length + ctx_r1.columns.length));
    ɵɵproperty("p-title", column_r23.label)("p-align", column_r23.align);
  }
}
function PoGridComponent_ng_template_15_div_5_po_grid_cell_action_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-grid-cell-action", 34);
  }
  if (rf & 2) {
    const column_r27 = ctx.$implicit;
    const i_r28 = ctx.index;
    const ctx_r28 = ɵɵnextContext();
    const row_r26 = ctx_r28.$implicit;
    const j_r30 = ctx_r28.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵpropertyInterpolate("p-position", j_r30 + 1 + "-" + (i_r28 + ctx_r1.freezeColumns.length + ctx_r1.columns.length));
    ɵɵproperty("p-value", row_r26[column_r27.property]);
  }
}
function PoGridComponent_ng_template_15_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r25 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 22);
    ɵɵlistener("keydown.control.delete", function PoGridComponent_ng_template_15_div_5_Template_div_keydown_control_delete_0_listener($event) {
      const row_r26 = ɵɵrestoreView(_r25).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.removeRow($event, row_r26));
    })("keydown.esc", function PoGridComponent_ng_template_15_div_5_Template_div_keydown_esc_0_listener($event) {
      const row_r26 = ɵɵrestoreView(_r25).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.cancelRow($event, row_r26));
    });
    ɵɵtemplate(1, PoGridComponent_ng_template_15_div_5_po_grid_cell_action_1_Template, 1, 2, "po-grid-cell-action", 33);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.actionColumns);
  }
}
function PoGridComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 30)(1, "div", 17)(2, "div", 18);
    ɵɵtemplate(3, PoGridComponent_ng_template_15_po_grid_head_3_Template, 1, 3, "po-grid-head", 31);
    ɵɵelementEnd()();
    ɵɵelementStart(4, "div", 8);
    ɵɵtemplate(5, PoGridComponent_ng_template_15_div_5_Template, 2, 1, "div", 20);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r1.actionColumns);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.data);
  }
}
var PoGridComponent = class _PoGridComponent {
  changeDetectorRef;
  elRef;
  tableElement;
  tableWrapper;
  /**
   * @description
   *
   * Ações disparadas quando uma linha do grid é manipulada.
   */
  rowActions = {};
  /**
   * Lista com os dados que serão exibidos no grid.
   */
  data = [];
  lastCell = "0-0";
  lastRow = 0;
  lastColumn = 0;
  currencyCell = "0-0";
  currencyRow = 0;
  currencyColumn = 0;
  currencyObj;
  logger = false;
  width = "100%";
  widporeeze = 0;
  widthActions = 0;
  resizeListener;
  timeoutResize;
  _columns = [];
  /**
   * Colunas exibidas no grid.
   */
  set columns(value) {
    this._columns = [...value];
    this._columns.forEach((column) => {
      column.label = column.label || column.property;
      if (column.freeze === true) {
        column.cssWidth = `${column.width || 100}px`;
      } else {
        column.cssWidth = column.width ? `${column.width}px` : "100%";
      }
    });
  }
  get columns() {
    return this._columns.filter((column) => column.freeze !== true && column.action !== true);
  }
  constructor(changeDetectorRef, elRef, renderer) {
    this.changeDetectorRef = changeDetectorRef;
    this.elRef = elRef;
    this.debounceResize();
    this.resizeListener = renderer.listen("window", "resize", (event) => {
      this.debounceResize();
    });
  }
  ngOnDestroy() {
    if (this.resizeListener) {
      this.resizeListener();
    }
  }
  get freezeColumns() {
    const freezeColumns = this._columns.filter((column) => column.freeze === true);
    this.widporeeze = freezeColumns.reduce((prev, current) => prev + (current.width || 100), 0);
    return freezeColumns;
  }
  get actionColumns() {
    const actionsColumns = this._columns.filter((column) => column.action === true);
    this.widthActions = actionsColumns.length > 0 ? 56 : 0;
    return actionsColumns;
  }
  cancelRow(event, row) {
    const el = this.getEventPath(event).find((element) => element.id);
    if (!el) {
      return;
    }
    const [x] = el.id.split("-");
    if (this.isEmptyRow(x)) {
      if (!this.removeRow(event, row)) {
        return;
      }
      this.currencyObj = Object.assign({}, this.data[this.currencyRow - 1]);
    } else {
      this.data[+x - 1] = Object.assign({}, this.currencyObj);
      setTimeout(() => this.selectCell(this.currencyRow, this.currencyColumn));
    }
  }
  removeRow(event, row) {
    if (this.rowActions.beforeRemove && !this.rowActions.beforeRemove(Object.assign({}, row))) {
      return false;
    }
    const index = this.data.indexOf(row);
    this.data.splice(index, 1);
    this.changeDetectorRef.detectChanges();
    if (this.data.length === 0 || index === this.data.length) {
      this.selectCell(this.currencyRow - 1, this.currencyColumn);
    } else {
      this.selectCell(this.currencyRow, this.currencyColumn);
    }
    return true;
  }
  tableKeydown(event, direction) {
    let [row, col] = event.target.id.split("-");
    row = +row;
    col = +col;
    let prow = +row;
    let pcol = +col;
    if (direction === "down") {
      if (row <= this.data.length) {
        prow++;
      }
      if (row === this.data.length) {
        if (row === 0 || !this.isEmptyRow(row)) {
          if (this.saveRow(row)) {
            if (!this.insertRow()) {
              return;
            }
          } else {
            return;
          }
        } else {
          prow--;
        }
      }
    } else if (direction === "up" && row > 0) {
      prow--;
    } else if (direction === "left" && col > 0) {
      pcol--;
    } else if (direction === "right" && col < this._columns.length - 1) {
      pcol++;
    } else if (direction === "next") {
      if (col < this._columns.length - 1) {
        pcol++;
        event.preventDefault();
      } else if (row < this.data.length) {
        pcol = 0;
        prow++;
        event.preventDefault();
      }
    } else if (direction === "prior") {
      if (col > 0) {
        pcol--;
        event.preventDefault();
      } else if (row > 0) {
        pcol = this._columns.length - 1;
        prow--;
        event.preventDefault();
      }
    }
    if (this.currencyCell === `${prow}-${pcol}`) {
      return;
    }
    if (prow !== this.currencyRow && row > 0 && this.data.length >= row) {
      if (!this.isEmptyRow(row)) {
        if (!this.saveRow(row)) {
          return;
        }
      } else {
        if (!this.removeRow(event, row)) {
          return;
        }
      }
    }
    if (this.currencyRow !== prow) {
      this.currencyObj = Object.assign({}, this.data[prow - 1]);
    }
    this.lastCell = event.target.id;
    this.lastRow = row;
    this.lastColumn = col;
    this.selectCell(prow, pcol);
  }
  tableClick(event) {
    const el = this.getEventPath(event).find((element) => element.id);
    if (!el) {
      this.selectCell(this.currencyRow, this.currencyColumn);
      return;
    }
    if (this.currencyCell === el.id) {
      return;
    }
    const [row, col] = el.id.split("-");
    const prow = +row;
    const pcol = +col;
    if (prow !== this.currencyRow) {
      if (this.currencyRow > 0) {
        if (!this.isEmptyRow(this.currencyRow)) {
          if (!this.saveRow(this.currencyRow)) {
            this.selectCell(this.currencyRow, this.currencyColumn);
            return;
          }
        } else {
          if (!this.removeRow(event, row)) {
            return;
          }
        }
      }
      this.currencyObj = Object.assign({}, this.data[prow - 1]);
    }
    this.lastCell = this.currencyCell;
    this.lastRow = this.currencyRow;
    this.lastColumn = this.currencyColumn;
    this.currencyCell = el.id;
    this.currencyRow = prow;
    this.currencyColumn = pcol;
  }
  saveRow(row) {
    const obj = this.data[row - 1];
    if (!Object.keys(obj).some((prop) => obj[prop] !== this.currencyObj[prop])) {
      return true;
    }
    if (this.rowActions.beforeSave && !this.rowActions.beforeSave(obj, this.currencyObj)) {
      return false;
    }
    const requireds = [];
    this.columns.forEach((column) => {
      if (column.required === true && !obj[column.property]) {
        requireds.push(column.property);
      }
    });
    return requireds.length === 0;
  }
  insertRow() {
    const obj = {};
    if (this.rowActions.beforeInsert && !this.rowActions.beforeInsert(obj)) {
      return false;
    }
    this.data.push(obj);
    this.changeDetectorRef.detectChanges();
    return true;
  }
  isEmptyRow(row) {
    const obj = this.data[row - 1];
    if (!obj) {
      return false;
    }
    const filled = Object.keys(obj).some((property) => obj[property]);
    return !filled;
  }
  selectCell(row, col) {
    const nextCell = this.elRef.nativeElement.querySelector(`[id='${row}-${col}']`);
    if (nextCell) {
      this.currencyCell = `${row}-${col}`;
      this.currencyRow = row;
      this.currencyColumn = col;
      nextCell.focus();
    }
  }
  debounceResize() {
    clearTimeout(this.timeoutResize);
    this.timeoutResize = setTimeout(() => {
      const widthTableWrapper = this.tableWrapper.nativeElement.offsetWidth;
      this.width = `${widthTableWrapper - (this.widporeeze + 8) - this.widthActions}px`;
    }, 100);
  }
  getEventPath(event) {
    return event.path || event.composedPath();
  }
  static ɵfac = function PoGridComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGridComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoGridComponent,
    selectors: [["po-grid"]],
    viewQuery: function PoGridComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$s, 7);
        ɵɵviewQuery(_c1$7, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableWrapper = _t.first);
      }
    },
    inputs: {
      rowActions: [0, "p-row-actions", "rowActions"],
      data: [0, "p-data", "data"],
      columns: [0, "p-columns", "columns"]
    },
    standalone: false,
    decls: 17,
    vars: 10,
    consts: [["wrapper", ""], ["table", ""], ["divFreezeColumns", ""], ["divColumns", ""], ["divActionColumns", ""], [1, "po-grid-wrapper", "po-grid-row-wrapper"], [4, "ngIf"], [1, "po-grid"], [1, "po-grid-body"], [1, "po-grid-row", 3, "keydown.arrowup", "keydown.arrowdown", "keydown.arrowleft", "keydown.arrowright", "keydown.tab", "keydown.shift.tab", "click", "contextmenu", "dblclick"], ["class", "po-grid-cell po-grid-cell-freeze", 4, "ngIf"], [1, "po-grid-cell", "po-grid-cell-normal"], [4, "ngTemplateOutlet"], ["class", "po-grid-cell po-grid-cell-action", 4, "ngIf"], [1, "po-grid-cell", "po-grid-cell-freeze"], [1, "po-grid-cell", "po-grid-cell-action"], [1, "po-grid", "po-grid-freeze"], [1, "po-grid-header-group"], [1, "po-grid-row"], ["class", "po-grid-title", "p-freeze", "true", 3, "width", "max-width", "min-width", "p-position", "p-width", "p-align", "p-title", 4, "ngFor", "ngForOf"], ["class", "po-grid-row", 3, "keydown.control.delete", "keydown.esc", 4, "ngFor", "ngForOf"], ["p-freeze", "true", 1, "po-grid-title", 3, "p-position", "p-width", "p-align", "p-title"], [1, "po-grid-row", 3, "keydown.control.delete", "keydown.esc"], ["class", "po-grid-cell", "p-freeze", "true", 3, "width", "max-width", "min-width", "p-align", "p-readonly", "p-required", "p-position", "p-width", "p-value", "p-valueChange", 4, "ngFor", "ngForOf"], ["p-freeze", "true", 1, "po-grid-cell", 3, "p-valueChange", "p-align", "p-readonly", "p-required", "p-position", "p-width", "p-value"], [1, "po-grid", "po-grid-normal"], ["class", "po-grid-title", 3, "width", "max-width", "min-width", "p-align", "p-position", "p-title", "p-width", 4, "ngFor", "ngForOf"], [1, "po-grid-title", 3, "p-align", "p-position", "p-title", "p-width"], ["class", "po-grid-cell", 3, "width", "max-width", "min-width", "p-align", "p-readonly", "p-required", "p-position", "p-value", "p-width", "p-valueChange", 4, "ngFor", "ngForOf"], [1, "po-grid-cell", 3, "p-valueChange", "p-align", "p-readonly", "p-required", "p-position", "p-value", "p-width"], [1, "po-grid", "po-grid-actions"], ["class", "po-grid-title", 3, "p-position", "p-title", "p-align", 4, "ngFor", "ngForOf"], [1, "po-grid-title", 3, "p-position", "p-title", "p-align"], ["class", "po-grid-cell", 3, "p-position", "p-value", 4, "ngFor", "ngForOf"], [1, "po-grid-cell", 3, "p-position", "p-value"]],
    template: function PoGridComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 5, 0);
        ɵɵtemplate(2, PoGridComponent_div_2_Template, 11, 9, "div", 6);
        ɵɵelementStart(3, "div", 7)(4, "div", 8)(5, "div", 9, 1);
        ɵɵlistener("keydown.arrowup", function PoGridComponent_Template_div_keydown_arrowup_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.tableKeydown($event, "up"));
        })("keydown.arrowdown", function PoGridComponent_Template_div_keydown_arrowdown_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.tableKeydown($event, "down"));
        })("keydown.arrowleft", function PoGridComponent_Template_div_keydown_arrowleft_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.tableKeydown($event, "left"));
        })("keydown.arrowright", function PoGridComponent_Template_div_keydown_arrowright_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.tableKeydown($event, "right"));
        })("keydown.tab", function PoGridComponent_Template_div_keydown_tab_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.tableKeydown($event, "next"));
        })("keydown.shift.tab", function PoGridComponent_Template_div_keydown_shift_tab_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.tableKeydown($event, "prior"));
        })("click", function PoGridComponent_Template_div_click_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.tableClick($event));
        })("contextmenu", function PoGridComponent_Template_div_contextmenu_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.tableClick($event));
        })("dblclick", function PoGridComponent_Template_div_dblclick_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.tableClick($event));
        });
        ɵɵtemplate(7, PoGridComponent_div_7_Template, 2, 1, "div", 10);
        ɵɵelementStart(8, "div", 11);
        ɵɵtemplate(9, PoGridComponent_ng_container_9_Template, 1, 0, "ng-container", 12);
        ɵɵelementEnd();
        ɵɵtemplate(10, PoGridComponent_div_10_Template, 2, 1, "div", 13);
        ɵɵelementEnd()()()();
        ɵɵtemplate(11, PoGridComponent_ng_template_11_Template, 6, 2, "ng-template", null, 2, ɵɵtemplateRefExtractor)(13, PoGridComponent_ng_template_13_Template, 6, 2, "ng-template", null, 3, ɵɵtemplateRefExtractor)(15, PoGridComponent_ng_template_15_Template, 6, 2, "ng-template", null, 4, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const divColumns_r31 = ɵɵreference(14);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.logger);
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx.freezeColumns.length > 0);
        ɵɵadvance();
        ɵɵstyleProp("width", ctx.width)("max-width", ctx.width)("min-width", ctx.width);
        ɵɵadvance();
        ɵɵproperty("ngTemplateOutlet", divColumns_r31);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.actionColumns.length > 0);
      }
    },
    dependencies: [NgForOf, NgIf, NgTemplateOutlet, PoGridCellActionComponent, PoGridCellComponent, PoGridHeadComponent, JsonPipe],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGridComponent, [{
    type: Component,
    args: [{
      selector: "po-grid",
      standalone: false,
      template: `<div class="po-grid-wrapper po-grid-row-wrapper" #wrapper>
  <div *ngIf="logger">
    lastCell: {{ lastCell }} | currencyCell: {{ currencyCell }} <br />
    lastRow: {{ lastRow }} | currencyRow: {{ currencyRow }} <br />
    lastColumn: {{ lastColumn }} | currencyColumn: {{ currencyColumn }} <br />
    <hr />
    currencyObj: {{ currencyObj | json }}
    <hr />
  </div>

  <div class="po-grid">
    <div class="po-grid-body">
      <div
        class="po-grid-row"
        #table
        (keydown.arrowup)="tableKeydown($event, 'up')"
        (keydown.arrowdown)="tableKeydown($event, 'down')"
        (keydown.arrowleft)="tableKeydown($event, 'left')"
        (keydown.arrowright)="tableKeydown($event, 'right')"
        (keydown.tab)="tableKeydown($event, 'next')"
        (keydown.shift.tab)="tableKeydown($event, 'prior')"
        (click)="tableClick($event)"
        (contextmenu)="tableClick($event)"
        (dblclick)="tableClick($event)"
      >
        <div class="po-grid-cell po-grid-cell-freeze" *ngIf="freezeColumns.length > 0">
          <ng-container *ngTemplateOutlet="divFreezeColumns"></ng-container>
        </div>

        <div
          class="po-grid-cell po-grid-cell-normal"
          [style.width]="width"
          [style.max-width]="width"
          [style.min-width]="width"
        >
          <ng-container *ngTemplateOutlet="divColumns"></ng-container>
        </div>

        <div class="po-grid-cell po-grid-cell-action" *ngIf="actionColumns.length > 0">
          <ng-container *ngTemplateOutlet="divActionColumns"></ng-container>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Coluna com as colunas congeladas -->
<ng-template #divFreezeColumns>
  <div class="po-grid po-grid-freeze">
    <div class="po-grid-header-group">
      <div class="po-grid-row">
        <po-grid-head
          *ngFor="let column of freezeColumns; index as i"
          class="po-grid-title"
          [style.width]="column.cssWidth"
          [style.max-width]="column.cssWidth"
          [style.min-width]="column.cssWidth"
          p-freeze="true"
          p-position="{{ '0-' + i }}"
          [p-width]="column.width"
          [p-align]="column.align"
          [p-title]="column.label"
        >
        </po-grid-head>
      </div>
    </div>

    <div class="po-grid-body">
      <div
        class="po-grid-row"
        *ngFor="let row of data; index as j"
        (keydown.control.delete)="removeRow($event, row)"
        (keydown.esc)="cancelRow($event, row)"
      >
        <po-grid-cell
          *ngFor="let column of freezeColumns; index as i"
          class="po-grid-cell"
          [style.width]="column.cssWidth"
          [style.max-width]="column.cssWidth"
          [style.min-width]="column.cssWidth"
          p-freeze="true"
          [p-align]="column.align"
          [p-readonly]="column.readonly"
          [p-required]="column.required"
          p-position="{{ j + 1 + '-' + i }}"
          [p-width]="column.width"
          [(p-value)]="row[column.property]"
        >
        </po-grid-cell>
      </div>
    </div>
  </div>
</ng-template>
<!-- FIM: Coluna com as colunas congeladas -->

<!-- Coluna com as colunas nornais -->
<ng-template #divColumns>
  <div class="po-grid po-grid-normal">
    <div class="po-grid-header-group">
      <div class="po-grid-row">
        <po-grid-head
          *ngFor="let column of columns; index as i"
          class="po-grid-title"
          [style.width]="column.cssWidth"
          [style.max-width]="column.cssWidth"
          [style.min-width]="column.cssWidth"
          [p-align]="column.align"
          p-position="{{ '0-' + (i + freezeColumns.length) }}"
          [p-title]="column.label"
          [p-width]="column.width"
        >
        </po-grid-head>
      </div>
    </div>

    <div class="po-grid-body">
      <div
        class="po-grid-row"
        *ngFor="let row of data; index as j"
        (keydown.control.delete)="removeRow($event, row)"
        (keydown.esc)="cancelRow($event, row)"
      >
        <po-grid-cell
          *ngFor="let column of columns; index as i"
          class="po-grid-cell"
          [style.width]="column.cssWidth"
          [style.max-width]="column.cssWidth"
          [style.min-width]="column.cssWidth"
          [p-align]="column.align"
          [p-readonly]="column.readonly"
          [p-required]="column.required"
          p-position="{{ j + 1 + '-' + (i + freezeColumns.length) }}"
          [(p-value)]="row[column.property]"
          [p-width]="column.width"
        >
        </po-grid-cell>
      </div>
    </div>
  </div>
</ng-template>
<!-- FIM: Coluna com as colunas nornais -->

<!-- Coluna com as colunas de ação -->
<ng-template #divActionColumns>
  <div class="po-grid po-grid-actions">
    <div class="po-grid-header-group">
      <div class="po-grid-row">
        <po-grid-head
          *ngFor="let column of actionColumns; index as i"
          class="po-grid-title"
          p-position="{{ '0-' + (i + freezeColumns.length + columns.length) }}"
          [p-title]="column.label"
          [p-align]="column.align"
        >
        </po-grid-head>
      </div>
    </div>

    <div class="po-grid-body">
      <div
        class="po-grid-row"
        *ngFor="let row of data; index as j"
        (keydown.control.delete)="removeRow($event, row)"
        (keydown.esc)="cancelRow($event, row)"
      >
        <po-grid-cell-action
          *ngFor="let column of actionColumns; index as i"
          class="po-grid-cell"
          p-position="{{ j + 1 + '-' + (i + freezeColumns.length + columns.length) }}"
          [p-value]="row[column.property]"
        >
        </po-grid-cell-action>
      </div>
    </div>
  </div>
</ng-template>
<!-- FIM: Coluna com as colunas de ação -->
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    tableElement: [{
      type: ViewChild,
      args: ["table", {
        static: true
      }]
    }],
    tableWrapper: [{
      type: ViewChild,
      args: ["wrapper", {
        static: true
      }]
    }],
    rowActions: [{
      type: Input,
      args: ["p-row-actions"]
    }],
    data: [{
      type: Input,
      args: ["p-data"]
    }],
    columns: [{
      type: Input,
      args: ["p-columns"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGridComponent, {
    className: "PoGridComponent",
    filePath: "lib/components/po-grid/po-grid.component.ts",
    lineNumber: 39
  });
})();
var PoGridModule = class _PoGridModule {
  static ɵfac = function PoGridModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGridModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoGridModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, PoFieldModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGridModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, PoFieldModule],
      declarations: [PoGridCellActionComponent, PoGridCellComponent, PoGridComponent, PoGridHeadComponent],
      exports: [PoGridComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoGridModule, {
    declarations: [PoGridCellActionComponent, PoGridCellComponent, PoGridComponent, PoGridHeadComponent],
    imports: [CommonModule, FormsModule, PoFieldModule],
    exports: [PoGridComponent]
  });
})();
var poListViewLiteralsDefault = {
  en: {
    hideDetails: "Hide details",
    loadMoreData: "Load more data",
    noData: "No data found",
    selectAll: "Select all",
    showDetails: "Show details"
  },
  es: {
    hideDetails: "Ocultar detalles",
    loadMoreData: "Cargar más resultados",
    noData: "Datos no encontrados",
    selectAll: "Seleccionar todos",
    showDetails: "Mostrar detalles"
  },
  pt: {
    hideDetails: "Ocultar detalhes",
    loadMoreData: "Carregar mais resultados",
    noData: "Nenhum dado encontrado",
    selectAll: "Selecionar todos",
    showDetails: "Exibir detalhes"
  },
  ru: {
    hideDetails: "Скрыть детали",
    loadMoreData: "Загрузить больше результатов",
    noData: "Данные не найдены",
    selectAll: "Выбрать все",
    showDetails: "Посмотреть детали"
  }
};
var PoListViewBaseComponent = class _PoListViewBaseComponent {
  /** Recebe uma propriedade que será utilizada para recuperar o valor do objeto que será usado como link para o título. */
  propertyLink;
  /** Recebe uma propriedade que será utilizada para recuperar o valor do objeto que será exibido como o título de cada item. */
  propertyTitle;
  /**
   * @optional
   *
   * @description
   *
   * Recebe uma ação, que será executada quando clicar no botão "Carregar mais resultados".
   *
   * > Caso nenhuma ação for definida o mesmo não ficará visível.
   */
  showMore = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que será executada ao clicar no título.
   *
   * Ao ser disparado, o método inserido na ação irá receber como parâmetro o item da lista clicado.
   */
  titleAction = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que será executada ao clicar no botão exibir detalhes.
   *
   * Ao ser disparado, o método passa como parâmetros os detalhes que serão exibidos.
   */
  showDetail = new EventEmitter();
  popupTarget;
  selectAll = false;
  showHeader = false;
  _actions;
  _height;
  _hideSelectAll;
  _items;
  _literals;
  _select;
  _showMoreDisabled;
  language = poLocaleDefault;
  /**
   * @optional
   *
   * @description
   *
   * Lista de ações que serão exibidas no componente.
   */
  set actions(value) {
    this._actions = Array.isArray(value) ? value : [];
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a altura do `po-list-view` em *pixels*.
   */
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  /**
   * @description
   *
   * Esconde o *checkbox* para seleção de todos os itens.
   *
   * @default `false`
   */
  set hideSelectAll(hideSelectAll) {
    this._hideSelectAll = convertToBoolean(hideSelectAll);
    this.showMainHeader();
  }
  get hideSelectAll() {
    return this._hideSelectAll;
  }
  /** Lista de itens que serão exibidos no componente. */
  set items(value) {
    this._items = Array.isArray(value) ? value : [];
  }
  get items() {
    return this._items;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-list-view`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoListViewLiterals = {
   *    hideDetail: 'Ocultar detalhes completamente',
   *    loadMoreData: 'Mais dados',
   *    showDetail: 'Mostrar mais detalhes',
   *    selectAll: 'Selecionar todos os itens'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoListViewLiterals = {
   *    showDetail: 'Mostrar mais detalhes'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-list-view
   *   [p-literals]="customLiterals">
   * </po-list-view>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poListViewLiteralsDefault[poLocaleDefault]), poListViewLiteralsDefault[this.language]), value);
    } else {
      this._literals = poListViewLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poListViewLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita um *checkbox* para cada item da lista. Todos os items possuem a propriedade dinâmica `$selected` para identificar se o
   * item está selecionado, por exemplo:
   *
   * ```
   *  item.$selected
   *
   *  // ou
   *
   *  item['$selected']
   * ```
   *
   * @default `false`
   */
  set select(select) {
    this._select = convertToBoolean(select);
    this.showMainHeader();
  }
  get select() {
    return this._select;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o botão `Carregar Mais Resultados` será desabilitado.
   */
  set showMoreDisabled(value) {
    this._showMoreDisabled = convertToBoolean(value);
  }
  get showMoreDisabled() {
    return this._showMoreDisabled;
  }
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  onClickAction(listViewAction, item) {
    const cleanItem = this.deleteInternalAttrs(item);
    if (listViewAction.action) {
      listViewAction.action(cleanItem);
    }
  }
  onShowMore() {
    this.showMore.emit();
  }
  runTitleAction(listItem) {
    const itemWithPublicProperties = this.deleteInternalAttrs(listItem);
    this.titleAction.emit(itemWithPublicProperties);
  }
  selectAllListItems() {
    if (!this.hideSelectAll) {
      this.selectAll = !this.selectAll;
      this.items.forEach((item) => {
        item.$selected = this.selectAll;
      });
    }
  }
  selectListItem(row) {
    row.$selected = !row.$selected;
    this.selectAll = this.checkIfItemsAreSelected(this.items);
  }
  deleteInternalAttrs(item) {
    const itemCopy = item ? __spreadValues({}, item) : void 0;
    for (const key in itemCopy) {
      if (itemCopy.hasOwnProperty(key) && key.startsWith("$")) {
        delete itemCopy[key];
      }
    }
    return itemCopy;
  }
  checkIfItemsAreSelected(items) {
    const someCheckedOrIndeterminate = (item) => item.$selected || item.$selected === null;
    const everyChecked = (item) => item.$selected;
    if (items.every(everyChecked)) {
      return true;
    }
    if (items.some(someCheckedOrIndeterminate)) {
      return null;
    }
    return false;
  }
  showMainHeader() {
    this.showHeader = !!(this.select && !this.hideSelectAll && this.items && this.items.length);
  }
  static ɵfac = function PoListViewBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoListViewBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoListViewBaseComponent,
    inputs: {
      propertyLink: [0, "p-property-link", "propertyLink"],
      propertyTitle: [0, "p-property-title", "propertyTitle"],
      actions: [0, "p-actions", "actions"],
      height: [0, "p-height", "height"],
      hideSelectAll: [0, "p-hide-select-all", "hideSelectAll"],
      items: [0, "p-items", "items"],
      literals: [0, "p-literals", "literals"],
      select: [0, "p-select", "select"],
      showMoreDisabled: [0, "p-show-more-disabled", "showMoreDisabled"]
    },
    outputs: {
      showMore: "p-show-more",
      titleAction: "p-title-action",
      showDetail: "p-show-detail"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListViewBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    propertyLink: [{
      type: Input,
      args: ["p-property-link"]
    }],
    propertyTitle: [{
      type: Input,
      args: ["p-property-title"]
    }],
    showMore: [{
      type: Output,
      args: ["p-show-more"]
    }],
    titleAction: [{
      type: Output,
      args: ["p-title-action"]
    }],
    showDetail: [{
      type: Output,
      args: ["p-show-detail"]
    }],
    actions: [{
      type: Input,
      args: ["p-actions"]
    }],
    height: [{
      type: Input,
      args: ["p-height"]
    }],
    hideSelectAll: [{
      type: Input,
      args: ["p-hide-select-all"]
    }],
    items: [{
      type: Input,
      args: ["p-items"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    select: [{
      type: Input,
      args: ["p-select"]
    }],
    showMoreDisabled: [{
      type: Input,
      args: ["p-show-more-disabled"]
    }]
  });
})();
var PoListViewContentTemplateDirective = class _PoListViewContentTemplateDirective {
  templateRef;
  /**
   * @optional
   *
   * @description
   *
   * Função que deve retornar um valor do tipo `string`, que será utilizado como o título de cada item da lista.
   *
   * > Por parâmetro será enviado o item corrente, onde poderá utilizá-lo para recuperar dados sobre o mesmo.
   */
  title;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoListViewContentTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoListViewContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoListViewContentTemplateDirective,
    selectors: [["", "p-list-view-content-template", ""]],
    inputs: {
      title: [0, "p-title", "title"]
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListViewContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-list-view-content-template]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], {
    title: [{
      type: Input,
      args: ["p-title"]
    }]
  });
})();
var PoListViewDetailTemplateDirective = class _PoListViewDetailTemplateDirective {
  templateRef;
  /**
   * @optional
   *
   * @description
   *
   * Função que deve retornar um valor do tipo `boolean`, que será utilizado como a validação para que o detalhe de item
   * da lista inicie aberto ou fechado.
   *
   */
  showDetail;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoListViewDetailTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoListViewDetailTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoListViewDetailTemplateDirective,
    selectors: [["", "p-list-view-detail-template", ""]],
    inputs: {
      showDetail: [0, "p-show-detail", "showDetail"]
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListViewDetailTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-list-view-detail-template]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], {
    showDetail: [{
      type: Input,
      args: ["p-show-detail"]
    }]
  });
})();
var _c0$r = ["popup"];
var _c1$6 = (a0, a1) => ({
  $implicit: a0,
  index: a1
});
function PoListViewComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 8)(1, "div", 9)(2, "div", 10)(3, "po-checkbox", 11);
    ɵɵtwoWayListener("ngModelChange", function PoListViewComponent_div_1_Template_po_checkbox_ngModelChange_3_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.selectAll, $event) || (ctx_r1.selectAll = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoListViewComponent_div_1_Template_po_checkbox_p_change_3_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectAllListItems());
    })("click", function PoListViewComponent_div_1_Template_po_checkbox_click_3_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectAllListItems());
    });
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtwoWayProperty("ngModel", ctx_r1.selectAll);
    ɵɵproperty("p-label", ctx_r1.literals.selectAll);
  }
}
function PoListViewComponent_po_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-container", 12)(1, "div", 13)(2, "span");
    ɵɵtext(3);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-no-padding", true);
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ctx_r1.literals.noData, " ");
  }
}
function PoListViewComponent_ng_container_4_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 26)(1, "po-checkbox", 27);
    ɵɵtwoWayListener("ngModelChange", function PoListViewComponent_ng_container_4_div_5_Template_po_checkbox_ngModelChange_1_listener($event) {
      ɵɵrestoreView(_r3);
      const item_r4 = ɵɵnextContext().$implicit;
      ɵɵtwoWayBindingSet(item_r4.$selected, $event) || (item_r4.$selected = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoListViewComponent_ng_container_4_div_5_Template_po_checkbox_p_change_1_listener() {
      ɵɵrestoreView(_r3);
      const item_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectListItem(item_r4));
    })("click", function PoListViewComponent_ng_container_4_div_5_Template_po_checkbox_click_1_listener() {
      ɵɵrestoreView(_r3);
      const item_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectListItem(item_r4));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtwoWayProperty("ngModel", item_r4.$selected);
  }
}
function PoListViewComponent_ng_container_4_a_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 28);
    ɵɵlistener("click", function PoListViewComponent_ng_container_4_a_6_Template_a_click_0_listener() {
      ɵɵrestoreView(_r5);
      const item_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.runTitleAction(item_r4));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("href", item_r4[ctx_r1.propertyLink], ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.getItemTitle(item_r4), " ");
  }
}
function PoListViewComponent_ng_container_4_a_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 29);
    ɵɵlistener("click", function PoListViewComponent_ng_container_4_a_7_Template_a_click_0_listener() {
      ɵɵrestoreView(_r6);
      const item_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.runTitleAction(item_r4));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("routerLink", item_r4[ctx_r1.propertyLink]);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.getItemTitle(item_r4), " ");
  }
}
function PoListViewComponent_ng_container_4_span_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 30);
    ɵɵlistener("click", function PoListViewComponent_ng_container_4_span_8_Template_span_click_0_listener() {
      ɵɵrestoreView(_r7);
      const item_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.titleHasAction && ctx_r1.runTitleAction(item_r4));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-list-view-title-link", ctx_r1.titleHasAction);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.getItemTitle(item_r4), " ");
  }
}
function PoListViewComponent_ng_container_4_div_9_po_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 33);
    ɵɵlistener("p-click", function PoListViewComponent_ng_container_4_div_9_po_button_1_Template_po_button_p_click_0_listener() {
      const action_r9 = ɵɵrestoreView(_r8).$implicit;
      const item_r4 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClickAction(action_r9, item_r4));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r9 = ctx.$implicit;
    const item_r4 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r1.returnBooleanValue(action_r9, item_r4, "disabled"))("p-icon", action_r9.icon)("p-label", action_r9.label)("p-danger", action_r9.type === "danger");
  }
}
function PoListViewComponent_ng_container_4_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 31);
    ɵɵtemplate(1, PoListViewComponent_ng_container_4_div_9_po_button_1_Template, 1, 4, "po-button", 32);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.visibleActions);
  }
}
function PoListViewComponent_ng_container_4_div_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 34)(1, "div", 35, 1);
    ɵɵlistener("click", function PoListViewComponent_ng_container_4_div_10_Template_div_click_1_listener() {
      ɵɵrestoreView(_r10);
      const popupTarget_r11 = ɵɵreference(2);
      const item_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.togglePopup(item_r4, popupTarget_r11));
    });
    ɵɵelement(3, "po-icon", 36);
    ɵɵelementEnd()();
  }
}
function PoListViewComponent_ng_container_4_div_11_ng_template_1_Template(rf, ctx) {
}
function PoListViewComponent_ng_container_4_div_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 37);
    ɵɵtemplate(1, PoListViewComponent_ng_container_4_div_11_ng_template_1_Template, 0, 0, "ng-template", 38);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r11 = ɵɵnextContext();
    const item_r4 = ctx_r11.$implicit;
    const index_r13 = ctx_r11.index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.listViewContentTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c1$6, item_r4, index_r13));
  }
}
function PoListViewComponent_ng_container_4_div_12_ng_template_1_Template(rf, ctx) {
}
function PoListViewComponent_ng_container_4_div_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 39);
    ɵɵlistener("@showHideDetail.start", function PoListViewComponent_ng_container_4_div_12_Template_div_animation_showHideDetail_start_0_listener($event) {
      ɵɵrestoreView(_r14);
      const item_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(item_r4.$showDetail ? ctx_r1.onAnimationEvent($event, item_r4) : "undefined");
    });
    ɵɵtemplate(1, PoListViewComponent_ng_container_4_div_12_ng_template_1_Template, 0, 0, "ng-template", 38);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r11 = ɵɵnextContext();
    const item_r4 = ctx_r11.$implicit;
    const index_r13 = ctx_r11.index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("@showHideDetail", void 0);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.listViewDetailTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(3, _c1$6, item_r4, index_r13));
  }
}
function PoListViewComponent_ng_container_4_div_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 40)(1, "po-button", 41);
    ɵɵlistener("p-click", function PoListViewComponent_ng_container_4_div_13_Template_po_button_p_click_1_listener() {
      ɵɵrestoreView(_r15);
      const item_r4 = ɵɵnextContext().$implicit;
      return ɵɵresetView(item_r4.$showDetail = !item_r4.$showDetail);
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-label", item_r4.$showDetail ? ctx_r1.literals.hideDetails : ctx_r1.literals.showDetails);
  }
}
function PoListViewComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "po-container", 12)(2, "div", 14)(3, "div", 15)(4, "div", 16);
    ɵɵtemplate(5, PoListViewComponent_ng_container_4_div_5_Template, 2, 1, "div", 17)(6, PoListViewComponent_ng_container_4_a_6_Template, 2, 2, "a", 18)(7, PoListViewComponent_ng_container_4_a_7_Template, 2, 2, "a", 19)(8, PoListViewComponent_ng_container_4_span_8_Template, 2, 3, "span", 20);
    ɵɵelementEnd();
    ɵɵtemplate(9, PoListViewComponent_ng_container_4_div_9_Template, 2, 1, "div", 21)(10, PoListViewComponent_ng_container_4_div_10_Template, 4, 0, "div", 22);
    ɵɵelementEnd();
    ɵɵtemplate(11, PoListViewComponent_ng_container_4_div_11_Template, 2, 5, "div", 23)(12, PoListViewComponent_ng_container_4_div_12_Template, 2, 6, "div", 24);
    ɵɵelementEnd();
    ɵɵtemplate(13, PoListViewComponent_ng_container_4_div_13_Template, 2, 1, "div", 25);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-no-padding", true);
    ɵɵadvance(3);
    ɵɵproperty("ngSwitch", ctx_r1.checkTitleType(item_r4));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.select);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "externalLink");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "internalLink");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "noLink");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showButtonsActions);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showPopupActions);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasContentTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasDetailTemplate && item_r4.$showDetail);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasDetailTemplate);
  }
}
function PoListViewComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 42)(1, "po-button", 43);
    ɵɵlistener("p-click", function PoListViewComponent_div_5_Template_po_button_p_click_1_listener() {
      ɵɵrestoreView(_r16);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onShowMore());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-disabled", ctx_r1.showMoreDisabled)("p-label", ctx_r1.literals.loadMoreData);
  }
}
var PoListViewComponent = class _PoListViewComponent extends PoListViewBaseComponent {
  changeDetector;
  listViewContentTemplate;
  listViewDetailTemplate;
  poPopupComponent;
  differ;
  constructor(changeDetector, differs, languageService) {
    super(languageService);
    this.changeDetector = changeDetector;
    this.differ = differs.find([]).create(null);
  }
  get hasContentTemplate() {
    return !!this.listViewContentTemplate;
  }
  get hasDetailTemplate() {
    return !!this.listViewDetailTemplate;
  }
  get displayShowMoreButton() {
    return this.items && this.items.length > 0 && this.showMore.observers.length > 0;
  }
  get showButtonsActions() {
    return this.visibleActions && this.visibleActions.length > 0 && this.visibleActions.length <= 2;
  }
  get showPopupActions() {
    return this.visibleActions && this.visibleActions.length > 2;
  }
  get titleHasAction() {
    return this.titleAction.observers.length > 0;
  }
  get visibleActions() {
    return this.actions && this.actions.filter((action) => this.returnBooleanValue(action, action.visible, "visible") !== false);
  }
  ngAfterContentInit() {
    this.initShowDetail();
  }
  ngDoCheck() {
    this.checkItemsChange();
  }
  checkTitleType(item) {
    if (this.propertyLink && item[this.propertyLink]) {
      return item[this.propertyLink].startsWith("http") ? "externalLink" : "internalLink";
    }
    return "noLink";
  }
  getItemTitle(item) {
    return this.hasContentTemplate && this.listViewContentTemplate.title ? this.listViewContentTemplate.title(item) : item[this.propertyTitle];
  }
  hasItems() {
    return this.items && this.items.length > 0;
  }
  returnBooleanValue(listViewAction, item, property) {
    return isTypeof(listViewAction[property], "function") ? listViewAction[property](item) : listViewAction[property];
  }
  trackBy(index) {
    return index;
  }
  togglePopup(item, targetRef) {
    this.popupTarget = targetRef;
    this.changeDetector.detectChanges();
    this.poPopupComponent.toggle(item);
  }
  onAnimationEvent(event, detail) {
    this.showDetail.emit(detail);
  }
  checkItemsChange() {
    const changesItems = this.differ.diff(this.items);
    if (changesItems && this.selectAll) {
      this.selectAll = null;
    }
    if (changesItems && this.items && this.items.length && this.select && !this.hideSelectAll) {
      this.showHeader = true;
    }
  }
  initShowDetail() {
    if (this.items && this.items.length > 0 && this.hasDetailTemplate && this.listViewDetailTemplate.showDetail) {
      this.items.forEach((item) => item.$showDetail = this.listViewDetailTemplate.showDetail(item));
    }
  }
  static ɵfac = function PoListViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoListViewComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoListViewComponent,
    selectors: [["po-list-view"]],
    contentQueries: function PoListViewComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PoListViewContentTemplateDirective, 7);
        ɵɵcontentQuery(dirIndex, PoListViewDetailTemplateDirective, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listViewContentTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listViewDetailTemplate = _t.first);
      }
    },
    viewQuery: function PoListViewComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$r, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPopupComponent = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 8,
    vars: 13,
    consts: [["popup", ""], ["popupTarget", ""], ["class", "po-list-view-main-header", 4, "ngIf"], [1, "po-list-view-main-content"], [3, "p-no-padding", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "po-mb-2 po-text-center", 4, "ngIf"], [3, "p-actions", "p-target"], [1, "po-list-view-main-header"], [1, "po-checkbox-group-item"], [1, "po-list-view-main-select"], ["name", "selectAll", 3, "ngModelChange", "p-change", "click", "ngModel", "p-label"], [3, "p-no-padding"], [1, "po-list-view-container-no-data", "po-text-center"], [1, "po-list-view-container"], [1, "po-list-view-header"], [1, "po-list-view-title", 3, "ngSwitch"], ["class", "po-list-view-select", 4, "ngIf"], ["class", "po-list-view-title-link", "target", "_blank", 3, "href", "click", 4, "ngSwitchCase"], ["class", "po-list-view-title-link", 3, "routerLink", "click", 4, "ngSwitchCase"], ["class", "po-list-view-title-no-link", 3, "po-list-view-title-link", "click", 4, "ngSwitchCase"], ["class", "po-list-view-actions", 4, "ngIf"], ["class", "po-list-view-more-actions", 4, "ngIf"], ["class", "po-list-view-content", 4, "ngIf"], ["class", "po-list-view-detail", 4, "ngIf"], ["class", "po-list-view-detail-button", 4, "ngIf"], [1, "po-list-view-select"], ["name", "checkbox", 3, "ngModelChange", "p-change", "click", "ngModel"], ["target", "_blank", 1, "po-list-view-title-link", 3, "click", "href"], [1, "po-list-view-title-link", 3, "click", "routerLink"], [1, "po-list-view-title-no-link", 3, "click"], [1, "po-list-view-actions"], [3, "p-disabled", "p-icon", "p-label", "p-danger", "p-click", 4, "ngFor", "ngForOf"], [3, "p-click", "p-disabled", "p-icon", "p-label", "p-danger"], [1, "po-list-view-more-actions"], [1, "po-list-view-more-icon", "po-clickable", 3, "click"], ["p-icon", "ICON_MORE"], [1, "po-list-view-content"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "po-list-view-detail"], [1, "po-list-view-detail-button"], ["p-kind", "tertiary", 3, "p-click", "p-label"], [1, "po-mb-2", "po-text-center"], [3, "p-click", "p-disabled", "p-label"]],
    template: function PoListViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div");
        ɵɵtemplate(1, PoListViewComponent_div_1_Template, 4, 2, "div", 2);
        ɵɵelementStart(2, "div", 3);
        ɵɵtemplate(3, PoListViewComponent_po_container_3_Template, 4, 2, "po-container", 4)(4, PoListViewComponent_ng_container_4_Template, 14, 11, "ng-container", 5);
        ɵɵelementEnd()();
        ɵɵtemplate(5, PoListViewComponent_div_5_Template, 2, 2, "div", 6);
        ɵɵelement(6, "po-popup", 7, 0);
      }
      if (rf & 2) {
        ɵɵstyleProp("height", ctx.height, "px");
        ɵɵclassProp("po-list-view-main-container-header", ctx.showHeader)("po-list-view-main-container", !ctx.showHeader);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showHeader);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.hasItems());
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.items)("ngForTrackBy", ctx.trackBy);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.displayShowMoreButton);
        ɵɵadvance();
        ɵɵproperty("p-actions", ctx.actions)("p-target", ctx.popupTarget);
      }
    },
    dependencies: [NgForOf, NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgControlStatus, NgModel, RouterLink, PoButtonComponent, PoIconComponent, PoPopupComponent, PoCheckboxComponent, PoContainerComponent],
    encapsulation: 2,
    data: {
      animation: [trigger("showHideDetail", [state("*", style({
        "overflow-y": "visible"
      })), state("void", style({
        "overflow-y": "hidden"
      })), transition("* => void", [style({
        height: "*",
        "overflow-y": "hidden"
      }), animate(100, style({
        height: 0
      }))]), transition("void => *", [style({
        height: "0"
      }), animate(100, style({
        height: "*"
      }))])])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListViewComponent, [{
    type: Component,
    args: [{
      selector: "po-list-view",
      animations: [trigger("showHideDetail", [state("*", style({
        "overflow-y": "visible"
      })), state("void", style({
        "overflow-y": "hidden"
      })), transition("* => void", [style({
        height: "*",
        "overflow-y": "hidden"
      }), animate(100, style({
        height: 0
      }))]), transition("void => *", [style({
        height: "0"
      }), animate(100, style({
        height: "*"
      }))])])],
      standalone: false,
      template: `<div
  [class.po-list-view-main-container-header]="showHeader"
  [class.po-list-view-main-container]="!showHeader"
  [style.height.px]="height"
>
  <div *ngIf="showHeader" class="po-list-view-main-header">
    <div class="po-checkbox-group-item">
      <div class="po-list-view-main-select">
        <po-checkbox
          name="selectAll"
          [(ngModel)]="selectAll"
          [p-label]="literals.selectAll"
          (p-change)="selectAllListItems()"
          (click)="selectAllListItems()"
        ></po-checkbox>
      </div>
    </div>
  </div>

  <div class="po-list-view-main-content">
    <po-container [p-no-padding]="true" *ngIf="!hasItems()">
      <div class="po-list-view-container-no-data po-text-center">
        <span> {{ literals.noData }} </span>
      </div>
    </po-container>

    <ng-container *ngFor="let item of items; let index = index; trackBy: trackBy">
      <po-container [p-no-padding]="true">
        <div class="po-list-view-container">
          <div class="po-list-view-header">
            <div class="po-list-view-title" [ngSwitch]="checkTitleType(item)">
              <div *ngIf="select" class="po-list-view-select">
                <po-checkbox
                  [(ngModel)]="item.$selected"
                  name="checkbox"
                  (p-change)="selectListItem(item)"
                  (click)="selectListItem(item)"
                ></po-checkbox>
              </div>
              <a
                *ngSwitchCase="'externalLink'"
                class="po-list-view-title-link"
                target="_blank"
                [href]="item[propertyLink]"
                (click)="runTitleAction(item)"
              >
                {{ getItemTitle(item) }}
              </a>
              <a
                *ngSwitchCase="'internalLink'"
                class="po-list-view-title-link"
                [routerLink]="item[propertyLink]"
                (click)="runTitleAction(item)"
              >
                {{ getItemTitle(item) }}
              </a>
              <span
                *ngSwitchCase="'noLink'"
                class="po-list-view-title-no-link"
                [class.po-list-view-title-link]="titleHasAction"
                (click)="titleHasAction && runTitleAction(item)"
              >
                {{ getItemTitle(item) }}
              </span>
            </div>

            <div *ngIf="showButtonsActions" class="po-list-view-actions">
              <po-button
                *ngFor="let action of visibleActions"
                [p-disabled]="returnBooleanValue(action, item, 'disabled')"
                [p-icon]="action.icon"
                [p-label]="action.label"
                [p-danger]="action.type === 'danger'"
                (p-click)="onClickAction(action, item)"
              >
              </po-button>
            </div>

            <div *ngIf="showPopupActions" class="po-list-view-more-actions">
              <div #popupTarget class="po-list-view-more-icon po-clickable" (click)="togglePopup(item, popupTarget)">
                <po-icon p-icon="ICON_MORE"></po-icon>
              </div>
            </div>
          </div>

          <div *ngIf="hasContentTemplate" class="po-list-view-content">
            <ng-template
              [ngTemplateOutlet]="listViewContentTemplate.templateRef"
              [ngTemplateOutletContext]="{ $implicit: item, index: index }"
            >
            </ng-template>
          </div>

          <div
            @showHideDetail
            (@showHideDetail.start)="item.$showDetail ? onAnimationEvent($event, item) : 'undefined'"
            *ngIf="hasDetailTemplate && item.$showDetail"
            class="po-list-view-detail"
          >
            <ng-template
              [ngTemplateOutlet]="listViewDetailTemplate.templateRef"
              [ngTemplateOutletContext]="{ $implicit: item, index: index }"
            >
            </ng-template>
          </div>
        </div>

        <div *ngIf="hasDetailTemplate" class="po-list-view-detail-button">
          <po-button
            p-kind="tertiary"
            [p-label]="item.$showDetail ? literals.hideDetails : literals.showDetails"
            (p-click)="item.$showDetail = !item.$showDetail"
          >
          </po-button>
        </div>
      </po-container>
    </ng-container>
  </div>
</div>

<div *ngIf="displayShowMoreButton" class="po-mb-2 po-text-center">
  <po-button [p-disabled]="showMoreDisabled" [p-label]="literals.loadMoreData" (p-click)="onShowMore()"> </po-button>
</div>

<po-popup #popup [p-actions]="actions" [p-target]="popupTarget"> </po-popup>
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: IterableDiffers
  }, {
    type: PoLanguageService
  }], {
    listViewContentTemplate: [{
      type: ContentChild,
      args: [PoListViewContentTemplateDirective, {
        static: true
      }]
    }],
    listViewDetailTemplate: [{
      type: ContentChild,
      args: [PoListViewDetailTemplateDirective, {
        static: true
      }]
    }],
    poPopupComponent: [{
      type: ViewChild,
      args: ["popup", {
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoListViewComponent, {
    className: "PoListViewComponent",
    filePath: "lib/components/po-list-view/po-list-view.component.ts",
    lineNumber: 55
  });
})();
var PoListViewModule = class _PoListViewModule {
  static ɵfac = function PoListViewModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoListViewModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoListViewModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, RouterModule, PoButtonModule, PoIconModule, PoPopupModule, PoCheckboxModule, PoContainerModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListViewModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, RouterModule, PoButtonModule, PoIconModule, PoPopupModule, PoCheckboxModule, PoContainerModule],
      declarations: [PoListViewComponent, PoListViewContentTemplateDirective, PoListViewDetailTemplateDirective],
      exports: [PoListViewComponent, PoListViewContentTemplateDirective, PoListViewDetailTemplateDirective],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoListViewModule, {
    declarations: [PoListViewComponent, PoListViewContentTemplateDirective, PoListViewDetailTemplateDirective],
    imports: [CommonModule, FormsModule, RouterModule, PoButtonModule, PoIconModule, PoPopupModule, PoCheckboxModule, PoContainerModule],
    exports: [PoListViewComponent, PoListViewContentTemplateDirective, PoListViewDetailTemplateDirective]
  });
})();
function PoLogoComponent_a_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 2);
    ɵɵelement(1, "img", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("href", ctx_r0.link === true ? "./" : ctx_r0.link, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵclassMap(ctx_r0.className);
    ɵɵproperty("alt", ctx_r0.logoAlt)("src", ctx_r0.logo, ɵɵsanitizeUrl)("title", ctx_r0.logoAlt);
  }
}
function PoLogoComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap(ctx_r0.className);
    ɵɵproperty("alt", ctx_r0.logoAlt)("src", ctx_r0.logo, ɵɵsanitizeUrl)("title", ctx_r0.logoAlt);
  }
}
var poLogoLiteralsDefault = {
  en: {
    logomarcaHome: "Home logo"
  },
  es: {
    logomarcaHome: "Logomarca inicio"
  },
  pt: {
    logomarcaHome: "Logomarca início"
  },
  ru: {
    logomarcaHome: "Дом Логомарка"
  }
};
var MAX_LENGHT = 125;
var PoLogoComponent = class _PoLogoComponent {
  poLanguageService;
  literals;
  _logo;
  _logoAlt;
  _link = "./";
  /**
   * Define uma classe para o elemento `img` do componente.
   *
   * > **Importante**
   * > A classe deve ser definida apenas quando houver necessidade de ajustar o componente dentro de outro componente.
   *
   */
  className = "po-logo";
  /**
   * Define se o componente terá o elemento âncora para uma rota específica.
   *
   * > Caso seja definido como false, o componente apenas renderizará o elemento `img`.
   * > Caso seja definido como true, a rota será `./`.
   * > Caso seja definido como string, a rota será a string passada.
   *
   * @default `true`
   */
  set link(value) {
    this._link = value !== false ? value : false;
  }
  get link() {
    return this._link;
  }
  /**
   * Definie o caminho para a imagem, que será exibida como logomarca.
   *
   */
  set logo(value) {
    this._logo = isTypeof(value, "string") && value.trim() ? value : void 0;
  }
  get logo() {
    return this._logo;
  }
  /**
   * Define o texto alternativo para a logomarca.
   *
   * > **Importante**
   * > Caso esta propriedade não seja definida o texto padrão será "Logomarca início".
   */
  set logoAlt(value) {
    this._logoAlt = isTypeof(value, "string") && value.trim() ? this.maxLength(value) : this.literals.logomarcaHome;
  }
  get logoAlt() {
    return this._logoAlt;
  }
  constructor(poLanguageService) {
    this.poLanguageService = poLanguageService;
    this.literals = __spreadValues(__spreadValues({}, poLogoLiteralsDefault[this.poLanguageService?.getLanguageDefault()]), poLogoLiteralsDefault[this.poLanguageService?.getShortLanguage()]);
    this._logoAlt = this.literals.logomarcaHome;
  }
  maxLength(value) {
    return value.length > MAX_LENGHT ? value.toString().substring(0, MAX_LENGHT) : value;
  }
  static ɵfac = function PoLogoComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLogoComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoLogoComponent,
    selectors: [["po-logo"]],
    inputs: {
      className: [0, "p-class", "className"],
      link: [0, "p-link", "link"],
      logo: [0, "p-logo", "logo"],
      logoAlt: [0, "p-logo-alt", "logoAlt"]
    },
    standalone: false,
    decls: 3,
    vars: 2,
    consts: [["noLink", ""], [3, "href", 4, "ngIf", "ngIfElse"], [3, "href"], [3, "alt", "src", "title"]],
    template: function PoLogoComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoLogoComponent_a_0_Template, 2, 6, "a", 1)(1, PoLogoComponent_ng_template_1_Template, 1, 5, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const noLink_r2 = ɵɵreference(2);
        ɵɵproperty("ngIf", ctx.link !== false)("ngIfElse", noLink_r2);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLogoComponent, [{
    type: Component,
    args: [{
      selector: "po-logo",
      standalone: false,
      template: `<a *ngIf="link !== false; else noLink" [href]="link === true ? './' : link">
  <img [alt]="logoAlt" [class]="className" [src]="logo" [title]="logoAlt" />
</a>

<ng-template #noLink>
  <img [alt]="logoAlt" [class]="className" [src]="logo" [title]="logoAlt" />
</ng-template>
`
    }]
  }], () => [{
    type: PoLanguageService
  }], {
    className: [{
      type: Input,
      args: ["p-class"]
    }],
    link: [{
      type: Input,
      args: ["p-link"]
    }],
    logo: [{
      type: Input,
      args: ["p-logo"]
    }],
    logoAlt: [{
      type: Input,
      args: ["p-logo-alt"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLogoComponent, {
    className: "PoLogoComponent",
    filePath: "lib/components/po-logo/po-logo.component.ts",
    lineNumber: 28
  });
})();
var PoLogoModule = class _PoLogoModule {
  static ɵfac = function PoLogoModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoLogoModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoLogoModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLogoModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PoLogoComponent],
      exports: [PoLogoComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoLogoModule, {
    declarations: [PoLogoComponent],
    imports: [CommonModule],
    exports: [PoLogoComponent]
  });
})();
var PoMenuPanelItemsService = class _PoMenuPanelItemsService {
  subjectChild = new Subject();
  subjectParent = new Subject();
  // Recebe do po-menu-panel-item sua informação de click.
  receiveFromChildMenuClicked() {
    return this.subjectChild.asObservable();
  }
  // Recebe do po-menu-panel as informações processadas do click de um po-menu-panel-item.
  receiveFromParentMenuClicked() {
    return this.subjectParent.asObservable();
  }
  // Envia informações do click do po-menu-panel-item para o po-menu
  sendToParentMenuClicked(menu) {
    this.subjectChild.next(menu);
  }
  // Envia para os po-menu-panel-item a resposta do processamento de click de um po-menu-panel-item.
  sendToChildMenuClicked(menu) {
    this.subjectParent.next(menu);
  }
  static ɵfac = function PoMenuPanelItemsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuPanelItemsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoMenuPanelItemsService,
    factory: _PoMenuPanelItemsService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuPanelItemsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function PoMenuPanelItemComponent_a_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuPanelItemComponent_a_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 4);
    ɵɵtemplate(1, PoMenuPanelItemComponent_a_0_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const menuItemTemplate_r2 = ɵɵreference(4);
    ɵɵproperty("routerLink", ctx_r0.menuItemInternal.link);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", menuItemTemplate_r2);
  }
}
function PoMenuPanelItemComponent_a_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuPanelItemComponent_a_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 6);
    ɵɵtemplate(1, PoMenuPanelItemComponent_a_1_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const menuItemTemplate_r2 = ɵɵreference(4);
    ɵɵproperty("href", ctx_r0.menuItemInternal.link, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", menuItemTemplate_r2);
  }
}
function PoMenuPanelItemComponent_a_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuPanelItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 7);
    ɵɵtemplate(1, PoMenuPanelItemComponent_a_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const menuItemTemplate_r2 = ɵɵreference(4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", menuItemTemplate_r2);
  }
}
function PoMenuPanelItemComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 8);
    ɵɵlistener("click", function PoMenuPanelItemComponent_ng_template_3_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.clickMenuItem($event));
    });
    ɵɵelement(1, "span");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-menu-panel-item-selected", ctx_r0.menuItemInternal.isSelected);
    ɵɵproperty("p-tooltip", ctx_r0.menuItemInternal.label);
    ɵɵadvance();
    ɵɵclassMapInterpolate1("po-icon ", ctx_r0.menuItemInternal.icon, "");
  }
}
var PoMenuPanelItemComponent = class _PoMenuPanelItemComponent {
  menuItemsService;
  menuItemInternal;
  itemsSubscription;
  constructor(menuItemsService) {
    this.menuItemsService = menuItemsService;
  }
  ngOnDestroy() {
    this.itemsSubscription.unsubscribe();
  }
  ngOnInit() {
    this.subscribeMenuClickedFromParent();
  }
  clickMenuItem(event) {
    if (!(event.ctrlKey || event.metaKey)) {
      event.preventDefault();
      this.menuItemsService.sendToParentMenuClicked(this.menuItemInternal);
    }
  }
  activateMenu(menu) {
    this.menuItemInternal.isSelected = this.menuItemInternal.id === menu.id;
  }
  processMenuItem(menu) {
    if (this.menuItemInternal.type === "internalLink") {
      this.activateMenu(menu.active);
    }
  }
  subscribeMenuClickedFromParent() {
    this.itemsSubscription = this.menuItemsService.receiveFromParentMenuClicked().subscribe((menu) => {
      this.processMenuItem(menu);
    });
  }
  static ɵfac = function PoMenuPanelItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuPanelItemComponent)(ɵɵdirectiveInject(PoMenuPanelItemsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoMenuPanelItemComponent,
    selectors: [["po-menu-panel-item"]],
    inputs: {
      menuItemInternal: [0, "p-menu-item-internal", "menuItemInternal"]
    },
    standalone: false,
    decls: 5,
    vars: 3,
    consts: [["menuItemTemplate", ""], [3, "routerLink", 4, "ngIf"], [3, "href", 4, "ngIf"], ["href", "javascript:;", 4, "ngIf"], [3, "routerLink"], [4, "ngTemplateOutlet"], [3, "href"], ["href", "javascript:;"], ["p-tooltip-position", "right", 1, "po-menu-panel-item", 3, "click", "p-tooltip"]],
    template: function PoMenuPanelItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoMenuPanelItemComponent_a_0_Template, 2, 2, "a", 1)(1, PoMenuPanelItemComponent_a_1_Template, 2, 2, "a", 2)(2, PoMenuPanelItemComponent_a_2_Template, 2, 1, "a", 3)(3, PoMenuPanelItemComponent_ng_template_3_Template, 2, 6, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.menuItemInternal.type === "internalLink");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.menuItemInternal.type === "externalLink");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.menuItemInternal.type === "noLink");
      }
    },
    dependencies: [NgIf, NgTemplateOutlet, RouterLink, PoTooltipDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuPanelItemComponent, [{
    type: Component,
    args: [{
      selector: "po-menu-panel-item",
      standalone: false,
      template: `<!-- menu com link interno -->
<a *ngIf="menuItemInternal.type === 'internalLink'" [routerLink]="menuItemInternal.link">
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>

<!-- menu com link externo -->
<a *ngIf="menuItemInternal.type === 'externalLink'" [href]="menuItemInternal.link">
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>

<!-- menu sem link -->
<a *ngIf="menuItemInternal.type === 'noLink'" href="javascript:;">
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>

<ng-template #menuItemTemplate>
  <div
    class="po-menu-panel-item"
    p-tooltip-position="right"
    [class.po-menu-panel-item-selected]="menuItemInternal.isSelected"
    [p-tooltip]="menuItemInternal.label"
    (click)="clickMenuItem($event)"
  >
    <span class="po-icon {{ menuItemInternal.icon }}"></span>
  </div>
</ng-template>
`
    }]
  }], () => [{
    type: PoMenuPanelItemsService
  }], {
    menuItemInternal: [{
      type: Input,
      args: ["p-menu-item-internal"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMenuPanelItemComponent, {
    className: "PoMenuPanelItemComponent",
    filePath: "lib/components/po-menu-panel/po-menu-panel-item/po-menu-panel-item.component.ts",
    lineNumber: 20
  });
})();
var poDefaultLogo = "https://po-ui.io/assets/po-logos/po_black.svg";
var PoMenuPanelBaseComponent = class _PoMenuPanelBaseComponent {
  _menus;
  _logo = poDefaultLogo;
  /** Lista dos itens do `po-menu-panel`. Se o valor estiver indefinido ou inválido, será inicializado como um array vazio. */
  set menus(menus) {
    this._menus = Array.isArray(menus) ? menus : [];
    this.setMenuExtraProperties(this._menus);
    this.validateMenus(this._menus);
  }
  get menus() {
    return this._menus;
  }
  /**
   * @optional
   *
   * @description
   *
   * Caminho para a logomarca localizada na parte superior do menu.
   *
   * > **Importante**
   * > Caso seja indefinida será aplicada a imagem default do PO UI.
   */
  set logo(src) {
    this._logo = src ?? poDefaultLogo;
  }
  get logo() {
    return this._logo;
  }
  /**
   * Define o texto alternativo para a logomarca.
   *
   * > **Importante**
   * > Caso esta propriedade não seja definida o texto padrão será "Logomarca início".
   *
   * @default `Logomarca início`
   */
  logoAlt;
  setMenuExtraProperties(menus) {
    menus.forEach((menuItem) => this.setMenuItemProperties(menuItem));
  }
  setMenuItemProperties(menuItem) {
    menuItem.id = menuItem.id || uuid();
    menuItem.type = this.setMenuType(menuItem);
  }
  setMenuType(menuItem) {
    if (!menuItem.link) {
      return "noLink";
    }
    if (isExternalLink(menuItem.link)) {
      return "externalLink";
    }
    return "internalLink";
  }
  validateMenu(menuItem) {
    if (!menuItem.label) {
      throw new Error("O atributo PoMenuPanelItem.label não pode ser vazio.");
    }
    if (!menuItem.icon) {
      throw new Error("O atributo PoMenuPanelItem.icon não pode ser vazio.");
    }
  }
  validateMenus(menus) {
    menus.forEach((menu) => this.validateMenu(menu));
  }
  static ɵfac = function PoMenuPanelBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuPanelBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoMenuPanelBaseComponent,
    inputs: {
      menus: [0, "p-menus", "menus"],
      logo: [0, "p-logo", "logo"],
      logoAlt: [0, "p-logo-alt", "logoAlt"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuPanelBaseComponent, [{
    type: Directive
  }], null, {
    menus: [{
      type: Input,
      args: ["p-menus"]
    }],
    logo: [{
      type: Input,
      args: ["p-logo"]
    }],
    logoAlt: [{
      type: Input,
      args: ["p-logo-alt"]
    }]
  });
})();
function PoMenuPanelComponent_po_logo_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-logo", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-logo", ctx_r0.logo)("p-logo-alt", ctx_r0.logoAlt);
  }
}
function PoMenuPanelComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵelement(1, "po-menu-panel-item", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const menu_r2 = ctx.$implicit;
    const menuIndex_r3 = ctx.index;
    ɵɵadvance();
    ɵɵclassProp("po-menu-panel-item-first", menuIndex_r3 === 0);
    ɵɵproperty("p-menu-item-internal", menu_r2);
  }
}
var PoMenuPanelComponent = class _PoMenuPanelComponent extends PoMenuPanelBaseComponent {
  location;
  menuItemsService;
  router;
  activeMenuItem;
  linkActive;
  routeSubscription;
  itemSubscription;
  constructor(viewRef, location, menuItemsService, router) {
    super();
    this.location = location;
    this.menuItemsService = menuItemsService;
    this.router = router;
  }
  ngOnDestroy() {
    this.itemSubscription.unsubscribe();
    this.routeSubscription.unsubscribe();
  }
  ngOnInit() {
    this.subscribeToMenuItem();
    this.subscribeToRoute();
  }
  activateMenuByUrl(urlPath, menus) {
    if (menus) {
      return menus.some((menu) => {
        if (getFormattedLink(menu.link) === urlPath) {
          this.activateMenuItem(menu);
          return true;
        }
      });
    }
  }
  activateMenuItem(menu) {
    this.activeMenuItem = menu;
    this.linkActive = getFormattedLink(menu.link);
    this.menuItemsService.sendToChildMenuClicked({
      active: this.activeMenuItem,
      activatedByRoute: true
    });
  }
  checkActiveMenuByUrl(urlPath) {
    if (!this.linkActive || this.linkActive !== urlPath) {
      this.activateMenuByUrl(urlPath, this.menus);
    }
  }
  clickMenuItem(menu) {
    if (menu.action) {
      menu.action(menu);
    }
    if (menu.type === "externalLink") {
      openExternalLink(menu.link);
    } else if (menu.type === "internalLink") {
      this.activateMenuItem(menu);
    }
  }
  subscribeToRoute() {
    this.routeSubscription = this.router.events.subscribe((rounterEvent) => {
      if (rounterEvent instanceof NavigationEnd) {
        this.checkActiveMenuByUrl(this.location.path());
      }
    });
  }
  subscribeToMenuItem() {
    this.itemSubscription = this.menuItemsService.receiveFromChildMenuClicked().subscribe((menu) => this.clickMenuItem(menu));
  }
  static ɵfac = function PoMenuPanelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuPanelComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Location), ɵɵdirectiveInject(PoMenuPanelItemsService), ɵɵdirectiveInject(Router));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoMenuPanelComponent,
    selectors: [["po-menu-panel"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 2,
    consts: [[1, "po-menu-panel"], [1, "po-menu-panel-logo-container"], ["p-class", "po-menu-panel-logo", 3, "p-logo", "p-logo-alt", 4, "ngIf"], [1, "po-menu-panel-container"], [1, "po-menu-panel-inner"], ["class", "po-menu-panel-item-wrapper", 4, "ngFor", "ngForOf"], ["p-class", "po-menu-panel-logo", 3, "p-logo", "p-logo-alt"], [1, "po-menu-panel-item-wrapper"], [3, "p-menu-item-internal"]],
    template: function PoMenuPanelComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "div", 1);
        ɵɵtemplate(2, PoMenuPanelComponent_po_logo_2_Template, 1, 2, "po-logo", 2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "nav", 3)(4, "div", 4);
        ɵɵtemplate(5, PoMenuPanelComponent_div_5_Template, 2, 3, "div", 5);
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.logo);
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ctx.menus);
      }
    },
    dependencies: [NgForOf, NgIf, PoLogoComponent, PoMenuPanelItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuPanelComponent, [{
    type: Component,
    args: [{
      selector: "po-menu-panel",
      standalone: false,
      template: '<div class="po-menu-panel">\n  <div class="po-menu-panel-logo-container">\n    <po-logo *ngIf="logo" p-class="po-menu-panel-logo" [p-logo]="logo" [p-logo-alt]="logoAlt"></po-logo>\n  </div>\n\n  <nav class="po-menu-panel-container">\n    <div class="po-menu-panel-inner">\n      <div *ngFor="let menu of menus; let menuIndex = index" class="po-menu-panel-item-wrapper">\n        <po-menu-panel-item\n          [class.po-menu-panel-item-first]="menuIndex === 0"\n          [p-menu-item-internal]="menu"\n        ></po-menu-panel-item>\n      </div>\n    </div>\n  </nav>\n</div>\n'
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: Location
  }, {
    type: PoMenuPanelItemsService
  }, {
    type: Router
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMenuPanelComponent, {
    className: "PoMenuPanelComponent",
    filePath: "lib/components/po-menu-panel/po-menu-panel.component.ts",
    lineNumber: 87
  });
})();
var PoMenuPanelModule = class _PoMenuPanelModule {
  static ɵfac = function PoMenuPanelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuPanelModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoMenuPanelModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoMenuPanelItemsService],
    imports: [CommonModule, RouterModule, PoFieldModule, PoLogoModule, PoTooltipModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuPanelModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, PoFieldModule, PoLogoModule, PoTooltipModule],
      declarations: [PoMenuPanelComponent, PoMenuPanelItemComponent],
      exports: [PoMenuPanelComponent],
      providers: [PoMenuPanelItemsService]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoMenuPanelModule, {
    declarations: [PoMenuPanelComponent, PoMenuPanelItemComponent],
    imports: [CommonModule, RouterModule, PoFieldModule, PoLogoModule, PoTooltipModule],
    exports: [PoMenuPanelComponent]
  });
})();
var _c0$q = ["inputFilter"];
function PoMenuFilterComponent_po_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 8);
  }
}
function PoMenuFilterComponent_po_loading_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-loading-icon", 9);
  }
}
var poMenuFilterLiteralsDefault = {
  en: {
    search: "Search"
  },
  es: {
    search: "Buscar"
  },
  pt: {
    search: "Pesquisar"
  },
  ru: {
    search: "Поиск"
  }
};
var PoMenuFilterComponent = class _PoMenuFilterComponent {
  languageService;
  loading;
  enableCollapse = false;
  // utilizado para repassar ao po-clean
  inputFilterElement;
  filter = new EventEmitter();
  literals;
  constructor(languageService) {
    this.languageService = languageService;
    this.literals = __spreadValues(__spreadValues({}, poMenuFilterLiteralsDefault[this.languageService?.getLanguageDefault()]), poMenuFilterLiteralsDefault[this.languageService?.getShortLanguage()]);
  }
  filterItems(search) {
    this.filter.emit(search);
  }
  static ɵfac = function PoMenuFilterComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuFilterComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoMenuFilterComponent,
    selectors: [["po-menu-filter"]],
    viewQuery: function PoMenuFilterComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$q, 7, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputFilterElement = _t.first);
      }
    },
    inputs: {
      loading: [0, "p-loading", "loading"],
      enableCollapse: [0, "p-enable-collapse", "enableCollapse"]
    },
    outputs: {
      filter: "p-filter"
    },
    standalone: false,
    decls: 8,
    vars: 6,
    consts: [["inputFilter", ""], [1, "po-menu-filter-container"], ["type", "text", 1, "po-menu-filter", 3, "keyup", "placeholder"], [1, "po-menu-filter-search-icon-container"], ["p-icon", "ICON_SEARCH po-field-icon", "class", "po-menu-filter-icon", 4, "ngIf"], ["p-size", "sm", 4, "ngIf"], [1, "po-menu-filter-close-icon-container"], [3, "p-change-event", "p-element-ref"], ["p-icon", "ICON_SEARCH po-field-icon", 1, "po-menu-filter-icon"], ["p-size", "sm"]],
    template: function PoMenuFilterComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 1)(1, "input", 2, 0);
        ɵɵlistener("keyup", function PoMenuFilterComponent_Template_input_keyup_1_listener() {
          ɵɵrestoreView(_r1);
          const inputFilter_r2 = ɵɵreference(2);
          return ɵɵresetView(ctx.filterItems(inputFilter_r2.value));
        });
        ɵɵelementEnd();
        ɵɵelementStart(3, "div", 3);
        ɵɵtemplate(4, PoMenuFilterComponent_po_icon_4_Template, 1, 0, "po-icon", 4)(5, PoMenuFilterComponent_po_loading_icon_5_Template, 1, 0, "po-loading-icon", 5);
        ɵɵelementEnd();
        ɵɵelementStart(6, "div", 6)(7, "po-clean", 7);
        ɵɵlistener("p-change-event", function PoMenuFilterComponent_Template_po_clean_p_change_event_7_listener() {
          ɵɵrestoreView(_r1);
          const inputFilter_r2 = ɵɵreference(2);
          return ɵɵresetView(ctx.filterItems(inputFilter_r2.value));
        });
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵclassProp("po-menu-filter-container-hidden", ctx.enableCollapse);
        ɵɵadvance();
        ɵɵproperty("placeholder", ctx.literals.search);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", !ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance(2);
        ɵɵproperty("p-element-ref", ctx.inputFilterElement);
      }
    },
    dependencies: [NgIf, PoCleanComponent, PoLoadingIconComponent, PoIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuFilterComponent, [{
    type: Component,
    args: [{
      selector: "po-menu-filter",
      standalone: false,
      template: '<div class="po-menu-filter-container" [class.po-menu-filter-container-hidden]="enableCollapse">\n  <input\n    #inputFilter\n    type="text"\n    class="po-menu-filter"\n    [placeholder]="literals.search"\n    (keyup)="filterItems(inputFilter.value)"\n  />\n\n  <div class="po-menu-filter-search-icon-container">\n    <po-icon p-icon="ICON_SEARCH po-field-icon" *ngIf="!loading" class="po-menu-filter-icon"></po-icon>\n    <po-loading-icon *ngIf="loading" p-size="sm"></po-loading-icon>\n  </div>\n  <div class="po-menu-filter-close-icon-container">\n    <po-clean [p-element-ref]="inputFilterElement" (p-change-event)="filterItems(inputFilter.value)"></po-clean>\n  </div>\n</div>\n'
    }]
  }], () => [{
    type: PoLanguageService
  }], {
    loading: [{
      type: Input,
      args: ["p-loading"]
    }],
    enableCollapse: [{
      type: Input,
      args: ["p-enable-collapse"]
    }],
    inputFilterElement: [{
      type: ViewChild,
      args: ["inputFilter", {
        read: ElementRef,
        static: true
      }]
    }],
    filter: [{
      type: Output,
      args: ["p-filter"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMenuFilterComponent, {
    className: "PoMenuFilterComponent",
    filePath: "lib/components/po-menu/po-menu-filter/po-menu-filter.component.ts",
    lineNumber: 24
  });
})();
var PoMenuHeaderTemplateDirective = class _PoMenuHeaderTemplateDirective {
  templateRef;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoMenuHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoMenuHeaderTemplateDirective,
    selectors: [["", "p-menu-header-template", ""]],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-menu-header-template]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var PoMenuItemsService = class _PoMenuItemsService {
  subjectParent = new Subject();
  subjectChild = new Subject();
  // Envia informações do click do po-menu-item para o po-menu
  sendToParentMenuClicked(menu) {
    this.subjectChild.next(menu);
  }
  // Recebe do po-menu-item sua informação de click.
  receiveFromChildMenuClicked() {
    return this.subjectChild.asObservable();
  }
  // Envia para os po-menu-item a resposta do processamento de click de um po-menu-item.
  sendToChildMenuClicked(menu) {
    this.subjectParent.next(menu);
  }
  // Recebe do po-menu as informações processadas do click de um po-menu-item.
  receiveFromParentMenuClicked() {
    return this.subjectParent.asObservable();
  }
  static ɵfac = function PoMenuItemsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuItemsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoMenuItemsService,
    factory: _PoMenuItemsService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuItemsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _c0$p = ["menuSubItems"];
function PoMenuItemComponent_a_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuItemComponent_a_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 7);
    ɵɵlistener("keydown.enter", function PoMenuItemComponent_a_0_Template_a_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clickMenuItem($event));
    })("keydown.space", function PoMenuItemComponent_a_0_Template_a_keydown_space_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clickMenuItem($event));
    });
    ɵɵtemplate(1, PoMenuItemComponent_a_0_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const menuItemTemplate_r3 = ɵɵreference(6);
    ɵɵproperty("routerLink", ctx_r1.link)("p-tooltip", ctx_r1.collapsedMenu && ctx_r1.shortLabel ? ctx_r1.shortLabel : void 0)("p-append-in-body", true);
    ɵɵattribute("aria-label", ctx_r1.label);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", menuItemTemplate_r3);
  }
}
function PoMenuItemComponent_a_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuItemComponent_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 9);
    ɵɵlistener("keydown.enter", function PoMenuItemComponent_a_1_Template_a_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clickMenuItem($event));
    })("keydown.space", function PoMenuItemComponent_a_1_Template_a_keydown_space_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clickMenuItem($event));
    });
    ɵɵtemplate(1, PoMenuItemComponent_a_1_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const menuItemTemplate_r3 = ɵɵreference(6);
    ɵɵproperty("href", ctx_r1.link, ɵɵsanitizeUrl)("p-tooltip", ctx_r1.collapsedMenu && ctx_r1.shortLabel ? ctx_r1.shortLabel : void 0)("p-append-in-body", true);
    ɵɵattribute("aria-label", ctx_r1.label);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", menuItemTemplate_r3);
  }
}
function PoMenuItemComponent_a_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 10);
    ɵɵlistener("keydown.enter", function PoMenuItemComponent_a_2_Template_a_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clickMenuItem($event));
    })("keydown.space", function PoMenuItemComponent_a_2_Template_a_keydown_space_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clickMenuItem($event));
    });
    ɵɵtemplate(1, PoMenuItemComponent_a_2_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const menuItemTemplate_r3 = ɵɵreference(6);
    ɵɵproperty("p-tooltip", ctx_r1.collapsedMenu && ctx_r1.shortLabel ? ctx_r1.shortLabel : void 0)("p-append-in-body", true);
    ɵɵattribute("aria-label", ctx_r1.label);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", menuItemTemplate_r3);
  }
}
function PoMenuItemComponent_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuItemComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵtemplate(1, PoMenuItemComponent_div_3_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const menuItemTemplate_r3 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", menuItemTemplate_r3);
  }
}
function PoMenuItemComponent_div_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuItemComponent_div_4_li_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 16);
    ɵɵelement(1, "po-menu-item", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const subItem_r6 = ctx.$implicit;
    ɵɵattribute("aria-level", subItem_r6.level);
    ɵɵadvance();
    ɵɵproperty("p-action", subItem_r6.action)("p-badge-alert", subItem_r6.badgeAlert)("p-badge-color", subItem_r6.badge ? subItem_r6.badge.color : void 0)("p-badge-value", subItem_r6.badge ? subItem_r6.badge.value : void 0)("p-id", subItem_r6.id)("p-label", subItem_r6.label)("p-level", subItem_r6.level)("p-link", subItem_r6.link)("p-sub-items", subItem_r6.subItems)("p-type", subItem_r6.type);
  }
}
function PoMenuItemComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtemplate(1, PoMenuItemComponent_div_4_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵɵelementStart(2, "div", 13, 1)(4, "ul", 14);
    ɵɵtemplate(5, PoMenuItemComponent_div_4_li_5_Template, 2, 11, "li", 15);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const menuItemTemplate_r3 = ɵɵreference(6);
    ɵɵattribute("aria-expanded", ctx_r1.isOpened ? true : false);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", menuItemTemplate_r3);
    ɵɵadvance();
    ɵɵstyleProp("max-height", ctx_r1.maxHeight, "px");
    ɵɵproperty("hidden", ctx_r1.collapsedMenu || !ctx_r1.isOpened);
    ɵɵattribute("aria-expanded", ctx_r1.isOpened ? true : false)("aria-hidden", !ctx_r1.isOpened ? true : false);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r1.subItems);
  }
}
function PoMenuItemComponent_ng_template_5_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 23);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-icon", ctx_r1.icon);
  }
}
function PoMenuItemComponent_ng_template_5_po_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 24);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-icon", ctx_r1.isOpened ? "ICON_ARROW_UP po-field-icon" : "ICON_ARROW_DOWN po-field-icon");
  }
}
function PoMenuItemComponent_ng_template_5_po_badge_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-badge", 25);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", !ctx_r1.collapsedMenu ? "po-menu-badge-align" : "po-menu-badge-align-collapsed")("p-color", ctx_r1.badgeColor)("p-value", ctx_r1.badgeValue);
  }
}
function PoMenuItemComponent_ng_template_5_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 26);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", !ctx_r1.collapsedMenu ? "po-menu-badge-alert" : "po-menu-badge-alert-collapsed");
  }
}
function PoMenuItemComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 18);
    ɵɵlistener("click", function PoMenuItemComponent_ng_template_5_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clickMenuItem($event));
    })("keydown.enter", function PoMenuItemComponent_ng_template_5_Template_div_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clickMenuItem($event));
    })("keydown.space", function PoMenuItemComponent_ng_template_5_Template_div_keydown_space_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clickMenuItem($event));
    });
    ɵɵtemplate(1, PoMenuItemComponent_ng_template_5_po_icon_1_Template, 1, 1, "po-icon", 19)(2, PoMenuItemComponent_ng_template_5_po_icon_2_Template, 1, 1, "po-icon", 20);
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵtemplate(5, PoMenuItemComponent_ng_template_5_po_badge_5_Template, 1, 3, "po-badge", 21)(6, PoMenuItemComponent_ng_template_5_span_6_Template, 1, 1, "span", 22);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-menu-icon-container", ctx_r1.level === 1 && ctx_r1.icon)("po-menu-item-selected", ctx_r1.isSelected)("po-menu-item-level-two", ctx_r1.level === 2)("po-menu-item-level-three", ctx_r1.level === 3)("po-menu-item-level-four", ctx_r1.level === 4)("po-menu-item-grouper-up", ctx_r1.type === "subItems" && ctx_r1.isOpened)("po-menu-item-grouper-down", ctx_r1.type === "subItems" && !ctx_r1.isOpened)("po-menu-item-no-data", ctx_r1.type === "noData")("po-menu-sub-item-selected", ctx_r1.isSelectedSubItem);
    ɵɵproperty("p-tooltip", ctx_r1.type === "subItems" && ctx_r1.collapsedMenu && ctx_r1.shortLabel ? ctx_r1.shortLabel : void 0)("p-append-in-body", true)("tabindex", ctx_r1.type === "subItems" ? 0 : -1);
    ɵɵattribute("aria-label", ctx_r1.label)("aria-hidden", ctx_r1.type === "subItems" ? false : true)("role", ctx_r1.type === "subItems" ? "menuitem" : void 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.level === 1 && ctx_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.type === "subItems" && !ctx_r1.collapsedMenu);
    ɵɵadvance();
    ɵɵclassProp("po-menu-icon-label", ctx_r1.level === 1 && ctx_r1.icon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.label, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.canShowBadge);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.badgeAlert);
  }
}
var poMenuItemSubItemSize = 98;
var PoMenuItemComponent = class _PoMenuItemComponent {
  menuItemsService;
  // Ação que será chamada ao clicar no item.
  action;
  // Indica se contém algum item filho com o badge.
  badgeAlert;
  // Cor do badge.
  badgeColor;
  // Indica se o menu está colapsado
  collapsedMenu;
  // Ícone de menu
  icon;
  // Identificador do item.
  id;
  // Indica se o item está aberto (menu agrupado)
  isOpened;
  // Texto que aparecerá representando o item.
  label;
  // Indica qual em nível do po-menu encontra-se.
  level;
  // Link do item.
  link;
  // Texto que aparecerá representando o item.
  shortLabel;
  // Indica o tipo de item, como 'internalLink' ou 'subItems'.
  type;
  menuSubItems;
  isSelectedSubItem;
  maxHeight = 0;
  itemSubscription;
  _badgeValue;
  _isSelected = false;
  _isSubItem = false;
  _subItems;
  // Valor do badge.
  set badgeValue(badgeValue) {
    this._badgeValue = convertToInt(badgeValue);
  }
  get badgeValue() {
    return this._badgeValue;
  }
  // Indica se o item está selecionado.
  set isSelected(value) {
    this._isSelected = convertToBoolean(value);
    this.isSelectedSubItem = this.isSelected && this.isSubItem;
  }
  get isSelected() {
    return this._isSelected;
  }
  // Indica se o item é um sub item
  set isSubItem(value) {
    this._isSubItem = convertToBoolean(value);
  }
  get isSubItem() {
    return this._isSubItem;
  }
  // Lista de sub-items.
  set subItems(subitems) {
    this._subItems = subitems;
    if (this.isOpened) {
      this.calcMenuSubItemsMaxHeight();
    }
  }
  get subItems() {
    return this._subItems;
  }
  get canShowBadge() {
    return this.type !== "subItems" && (this.badgeValue || this.badgeValue === 0) && this.badgeValue >= 0;
  }
  constructor(menuItemsService) {
    this.menuItemsService = menuItemsService;
  }
  ngOnDestroy() {
    this.itemSubscription.unsubscribe();
  }
  ngOnInit() {
    this.itemSubscription = this.menuItemsService.receiveFromParentMenuClicked().subscribe((menu) => {
      this.processMenuItem(menu);
    });
  }
  clickMenuItem(event) {
    if (!(event.ctrlKey || event.metaKey)) {
      event.preventDefault();
      this.menuItemsService.sendToParentMenuClicked({
        link: this.link,
        action: this.action,
        id: this.id,
        icon: this.icon,
        label: this.label,
        level: this.level,
        subItems: this.subItems,
        isSelected: this.isSelected,
        isOpened: this.isOpened,
        shortLabel: this.shortLabel,
        type: this.type
      });
    }
  }
  accordionAnimation(menuActive, menuOpened, hasSubItemOpened, activatedByRoute) {
    if (this.id === menuOpened["id"]) {
      this.maxHeight = this.subItems.length * poMenuItemSubItemSize;
    }
    if (hasSubItemOpened) {
      this.maxHeight = menuOpened["isOpened"] ? this.maxHeight + menuOpened.subItems.length * poMenuItemSubItemSize : this.maxHeight - menuOpened.subItems.length * poMenuItemSubItemSize;
      if (activatedByRoute) {
        this.maxHeight = this.getMinimumHeight(0, this, menuActive);
      }
    }
  }
  activateMenu(menu) {
    this.isSelected = menu && this.id === menu.id;
  }
  calcMenuSubItemsMaxHeight() {
    setTimeout(() => {
      const subItems = Array.from(this.menuSubItems.nativeElement.querySelectorAll(".po-menu-item"));
      subItems.forEach((menuItem) => this.maxHeight += menuItem.offsetHeight);
    });
  }
  getMinimumHeight(minimumHeight, menuItem, menuActive) {
    minimumHeight += poMenuItemSubItemSize;
    if (menuItem.subItems && this.hasSubItem(menuItem.subItems, menuActive["id"])) {
      for (let index = 0; index < menuItem.subItems.length; index++) {
        minimumHeight = this.getMinimumHeight(minimumHeight, menuItem.subItems[index], menuActive);
      }
    }
    return minimumHeight;
  }
  groupedMenu(menuActive, menuOpened, activatedByRoute = false) {
    const hasSubItemOpened = menuOpened && this.id !== menuOpened["id"] ? this.hasSubItem(this.subItems, menuOpened["id"]) : false;
    this.isOpened = this.isMenuOpened(menuOpened, hasSubItemOpened);
    this.isSelected = menuActive && !this.isOpened ? this.hasSubItem(this.subItems, menuActive["id"]) : false;
    if (!this.isOpened) {
      this.maxHeight = 0;
      return;
    }
    this.accordionAnimation(menuActive, menuOpened, hasSubItemOpened, activatedByRoute);
  }
  hasSubItem(subItems, id) {
    if (subItems) {
      return subItems.some((item) => item["id"] === id ? true : this.hasSubItem(item.subItems, id));
    }
  }
  isMenuOpened(menuOpened, hasSubItemOpened) {
    if (menuOpened) {
      return this.id === menuOpened["id"] ? menuOpened["isOpened"] : hasSubItemOpened;
    }
    return false;
  }
  processMenuItem(menu) {
    if (this.type === "internalLink") {
      this.activateMenu(menu.active);
      return;
    }
    if (this.type === "subItems") {
      this.groupedMenu(menu.active, menu.grouped, menu.activatedByRoute);
    }
  }
  static ɵfac = function PoMenuItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuItemComponent)(ɵɵdirectiveInject(PoMenuItemsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoMenuItemComponent,
    selectors: [["po-menu-item"]],
    viewQuery: function PoMenuItemComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$p, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuSubItems = _t.first);
      }
    },
    inputs: {
      action: [0, "p-action", "action"],
      badgeAlert: [0, "p-badge-alert", "badgeAlert"],
      badgeColor: [0, "p-badge-color", "badgeColor"],
      collapsedMenu: [0, "p-collapsed-menu", "collapsedMenu"],
      icon: [0, "p-icon", "icon"],
      id: [0, "p-id", "id"],
      isOpened: [0, "p-is-opened", "isOpened"],
      label: [0, "p-label", "label"],
      level: [0, "p-level", "level"],
      link: [0, "p-link", "link"],
      shortLabel: [0, "p-short-label", "shortLabel"],
      type: [0, "p-type", "type"],
      badgeValue: [0, "p-badge-value", "badgeValue"],
      isSelected: [0, "p-is-selected", "isSelected"],
      isSubItem: [0, "p-is-sub-item", "isSubItem"],
      subItems: [0, "p-sub-items", "subItems"]
    },
    standalone: false,
    decls: 7,
    vars: 5,
    consts: [["menuItemTemplate", ""], ["menuSubItems", ""], ["class", "po-menu-item-link", "role", "menuitem", "p-tooltip-position", "right", 3, "routerLink", "p-tooltip", "p-append-in-body", "keydown.enter", "keydown.space", 4, "ngIf"], ["class", "po-menu-item-link", "role", "menuitem", "p-tooltip-position", "right", 3, "href", "p-tooltip", "p-append-in-body", "keydown.enter", "keydown.space", 4, "ngIf"], ["class", "po-menu-item-link", "href", "javascript:;", "role", "menuitem", "p-tooltip-position", "right", 3, "p-tooltip", "p-append-in-body", "keydown.enter", "keydown.space", 4, "ngIf"], ["class", "po-menu-item-link", "role", "none", 4, "ngIf"], ["class", "po-menu-item-link po-clickable", "role", "menuitem", 4, "ngIf"], ["role", "menuitem", "p-tooltip-position", "right", 1, "po-menu-item-link", 3, "keydown.enter", "keydown.space", "routerLink", "p-tooltip", "p-append-in-body"], [4, "ngTemplateOutlet"], ["role", "menuitem", "p-tooltip-position", "right", 1, "po-menu-item-link", 3, "keydown.enter", "keydown.space", "href", "p-tooltip", "p-append-in-body"], ["href", "javascript:;", "role", "menuitem", "p-tooltip-position", "right", 1, "po-menu-item-link", 3, "keydown.enter", "keydown.space", "p-tooltip", "p-append-in-body"], ["role", "none", 1, "po-menu-item-link"], ["role", "menuitem", 1, "po-menu-item-link", "po-clickable"], ["role", "group", 1, "po-menu-sub-items", 3, "hidden"], [1, "po-menu-sub-items-list"], ["class", "po-menu-sub-items-list-item", 4, "ngFor", "ngForOf"], [1, "po-menu-sub-items-list-item"], ["p-is-sub-item", "", 3, "p-action", "p-badge-alert", "p-badge-color", "p-badge-value", "p-id", "p-label", "p-level", "p-link", "p-sub-items", "p-type"], ["p-tooltip-position", "right", 1, "po-menu-item", 3, "click", "keydown.enter", "keydown.space", "p-tooltip", "p-append-in-body", "tabindex"], ["aria-hidden", "true", "class", "po-menu-icon-item", 3, "p-icon", 4, "ngIf"], ["class", "po-menu-group-icon", 3, "p-icon", 4, "ngIf"], ["aria-hidden", "true", 3, "ngClass", "p-color", "p-value", 4, "ngIf"], ["aria-hidden", "true", "class", "po-color-07", 3, "ngClass", 4, "ngIf"], ["aria-hidden", "true", 1, "po-menu-icon-item", 3, "p-icon"], [1, "po-menu-group-icon", 3, "p-icon"], ["aria-hidden", "true", 3, "ngClass", "p-color", "p-value"], ["aria-hidden", "true", 1, "po-color-07", 3, "ngClass"]],
    template: function PoMenuItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoMenuItemComponent_a_0_Template, 2, 5, "a", 2)(1, PoMenuItemComponent_a_1_Template, 2, 5, "a", 3)(2, PoMenuItemComponent_a_2_Template, 2, 4, "a", 4)(3, PoMenuItemComponent_div_3_Template, 2, 1, "div", 5)(4, PoMenuItemComponent_div_4_Template, 6, 8, "div", 6)(5, PoMenuItemComponent_ng_template_5_Template, 7, 31, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.type === "internalLink");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "externalLink");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "noLink");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "noData");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.type === "subItems");
      }
    },
    dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, RouterLink, PoBadgeComponent, PoIconComponent, PoTooltipDirective, _PoMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuItemComponent, [{
    type: Component,
    args: [{
      selector: "po-menu-item",
      standalone: false,
      template: `<!-- menu com link interno -->
<a
  *ngIf="type === 'internalLink'"
  class="po-menu-item-link"
  role="menuitem"
  [attr.aria-label]="label"
  [routerLink]="link"
  (keydown.enter)="clickMenuItem($event)"
  (keydown.space)="clickMenuItem($event)"
  p-tooltip-position="right"
  [p-tooltip]="collapsedMenu && shortLabel ? shortLabel : undefined"
  [p-append-in-body]="true"
>
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>
<!-- menu com link externo -->
<a
  *ngIf="type === 'externalLink'"
  class="po-menu-item-link"
  role="menuitem"
  [attr.aria-label]="label"
  [href]="link"
  (keydown.enter)="clickMenuItem($event)"
  (keydown.space)="clickMenuItem($event)"
  p-tooltip-position="right"
  [p-tooltip]="collapsedMenu && shortLabel ? shortLabel : undefined"
  [p-append-in-body]="true"
>
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>
<!-- menu sem link -->
<a
  *ngIf="type === 'noLink'"
  class="po-menu-item-link"
  href="javascript:;"
  role="menuitem"
  [attr.aria-label]="label"
  (keydown.enter)="clickMenuItem($event)"
  (keydown.space)="clickMenuItem($event)"
  p-tooltip-position="right"
  [p-tooltip]="collapsedMenu && shortLabel ? shortLabel : undefined"
  [p-append-in-body]="true"
>
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>
<!-- menu sem dados -->
<div *ngIf="type === 'noData'" class="po-menu-item-link" role="none">
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</div>
<!-- menu com sub itens -->
<div
  *ngIf="type === 'subItems'"
  class="po-menu-item-link po-clickable"
  role="menuitem"
  [attr.aria-expanded]="isOpened ? true : false"
>
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>

  <div
    #menuSubItems
    class="po-menu-sub-items"
    [hidden]="collapsedMenu || !isOpened"
    [attr.aria-expanded]="isOpened ? true : false"
    [attr.aria-hidden]="!isOpened ? true : false"
    role="group"
    [style.maxHeight.px]="maxHeight"
  >
    <ul class="po-menu-sub-items-list">
      <li class="po-menu-sub-items-list-item" *ngFor="let subItem of subItems" [attr.aria-level]="subItem.level">
        <po-menu-item
          p-is-sub-item
          [p-action]="subItem.action"
          [p-badge-alert]="subItem.badgeAlert"
          [p-badge-color]="subItem.badge ? subItem.badge.color : undefined"
          [p-badge-value]="subItem.badge ? subItem.badge.value : undefined"
          [p-id]="subItem.id"
          [p-label]="subItem.label"
          [p-level]="subItem.level"
          [p-link]="subItem.link"
          [p-sub-items]="subItem.subItems"
          [p-type]="subItem.type"
        ></po-menu-item>
      </li>
    </ul>
  </div>
</div>

<ng-template #menuItemTemplate>
  <div
    p-tooltip-position="right"
    [p-tooltip]="type === 'subItems' && collapsedMenu && shortLabel ? shortLabel : undefined"
    [p-append-in-body]="true"
    class="po-menu-item"
    [tabindex]="type === 'subItems' ? 0 : -1"
    [attr.aria-label]="label"
    [attr.aria-hidden]="type === 'subItems' ? false : true"
    [attr.role]="type === 'subItems' ? 'menuitem' : undefined"
    [class.po-menu-icon-container]="level === 1 && icon"
    [class.po-menu-item-selected]="isSelected"
    [class.po-menu-item-level-two]="level === 2"
    [class.po-menu-item-level-three]="level === 3"
    [class.po-menu-item-level-four]="level === 4"
    [class.po-menu-item-grouper-up]="type === 'subItems' && isOpened"
    [class.po-menu-item-grouper-down]="type === 'subItems' && !isOpened"
    [class.po-menu-item-no-data]="type === 'noData'"
    [class.po-menu-sub-item-selected]="isSelectedSubItem"
    (click)="clickMenuItem($event)"
    (keydown.enter)="clickMenuItem($event)"
    (keydown.space)="clickMenuItem($event)"
  >
    <po-icon *ngIf="level === 1 && icon" aria-hidden="true" class="po-menu-icon-item" [p-icon]="icon"></po-icon>

    <po-icon
      *ngIf="type === 'subItems' && !collapsedMenu"
      class="po-menu-group-icon"
      [p-icon]="isOpened ? 'ICON_ARROW_UP po-field-icon' : 'ICON_ARROW_DOWN po-field-icon'"
    ></po-icon>

    <span [class.po-menu-icon-label]="level === 1 && icon">
      {{ label }}
    </span>

    <po-badge
      *ngIf="canShowBadge"
      aria-hidden="true"
      [ngClass]="!collapsedMenu ? 'po-menu-badge-align' : 'po-menu-badge-align-collapsed'"
      [p-color]="badgeColor"
      [p-value]="badgeValue"
    ></po-badge>

    <span
      *ngIf="badgeAlert"
      aria-hidden="true"
      class="po-color-07"
      [ngClass]="!collapsedMenu ? 'po-menu-badge-alert' : 'po-menu-badge-alert-collapsed'"
    ></span>
  </div>
</ng-template>
`
    }]
  }], () => [{
    type: PoMenuItemsService
  }], {
    action: [{
      type: Input,
      args: ["p-action"]
    }],
    badgeAlert: [{
      type: Input,
      args: ["p-badge-alert"]
    }],
    badgeColor: [{
      type: Input,
      args: ["p-badge-color"]
    }],
    collapsedMenu: [{
      type: Input,
      args: ["p-collapsed-menu"]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }],
    id: [{
      type: Input,
      args: ["p-id"]
    }],
    isOpened: [{
      type: Input,
      args: ["p-is-opened"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    level: [{
      type: Input,
      args: ["p-level"]
    }],
    link: [{
      type: Input,
      args: ["p-link"]
    }],
    shortLabel: [{
      type: Input,
      args: ["p-short-label"]
    }],
    type: [{
      type: Input,
      args: ["p-type"]
    }],
    menuSubItems: [{
      type: ViewChild,
      args: ["menuSubItems"]
    }],
    badgeValue: [{
      type: Input,
      args: ["p-badge-value"]
    }],
    isSelected: [{
      type: Input,
      args: ["p-is-selected"]
    }],
    isSubItem: [{
      type: Input,
      args: ["p-is-sub-item"]
    }],
    subItems: [{
      type: Input,
      args: ["p-sub-items"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMenuItemComponent, {
    className: "PoMenuItemComponent",
    filePath: "lib/components/po-menu/po-menu-item/po-menu-item.component.ts",
    lineNumber: 25
  });
})();
var PoMenuGlobalService = class _PoMenuGlobalService {
  applicationMenu = new Subject();
  menus = new Subject();
  removedApplicationMenu = new Subject();
  // eslint-disable-next-line @typescript-eslint/member-ordering
  receiveApplicationMenu$ = this.applicationMenu.asObservable();
  // eslint-disable-next-line @typescript-eslint/member-ordering
  receiveMenus$ = this.menus.asObservable();
  // eslint-disable-next-line @typescript-eslint/member-ordering
  receiveRemovedApplicationMenu$ = this.removedApplicationMenu.asObservable();
  sendApplicationMenu(menu) {
    this.applicationMenu.next(menu);
  }
  sendMenus(menus) {
    this.menus.next(menus);
  }
  sendRemovedApplicationMenu(id) {
    this.removedApplicationMenu.next(id);
  }
  static ɵfac = function PoMenuGlobalService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuGlobalService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoMenuGlobalService,
    factory: _PoMenuGlobalService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuGlobalService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var PoMenuService = class _PoMenuService {
  http;
  _url;
  get url() {
    return this._url;
  }
  constructor(http) {
    this.http = http;
  }
  configProperties(url) {
    this._url = url;
  }
  getFilteredData(search, params) {
    const filterParams = __spreadValues({
      search
    }, params);
    return this.http.get(this.url, {
      params: filterParams
    }).pipe(map((response) => response && response.items));
  }
  static ɵfac = function PoMenuService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoMenuService,
    factory: _PoMenuService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpClient
  }], null);
})();
var poMenuLiteralsDefault = {
  en: {
    itemNotFound: "Item not found",
    emptyLabelError: "Attribute PoMenuItem.label can not be empty",
    close: "Close menu",
    open: "Open menu"
  },
  es: {
    itemNotFound: "Elemento no encontrado",
    emptyLabelError: "El atributo PoMenuItem.label no puede ser vacío",
    close: "Cerrar menú",
    open: "Abrir menú"
  },
  pt: {
    itemNotFound: "Item não encontrado",
    emptyLabelError: "O atributo PoMenuItem.label não pode ser vazio",
    close: "Fechar menu",
    open: "Abrir menu"
  },
  ru: {
    itemNotFound: "Предмет не найден",
    emptyLabelError: "Атрибут PoMenuItem.label не может быть пустым",
    close: "Закрыть меню",
    open: "Открыть меню"
  }
};
var PoMenuBaseComponent = class _PoMenuBaseComponent {
  menuGlobalService;
  menuService;
  languageService;
  allowIcons;
  allowCollapseMenu;
  allowCollapseHover;
  filteredItems;
  filterService;
  literals;
  _collapsed = false;
  _filter = false;
  _searchTreeItems = false;
  _level;
  _maxLevel = 4;
  _menus = [];
  _params;
  _service;
  _logoLink = true;
  /**
   * @optional
   *
   * @description
   *
   * Expande e Colapsa (retrai) o menu automaticamente.
   *
   * @default `false`
   */
  automaticToggle = false;
  /**
   * @optional
   *
   * @description
   *
   * Colapsa (retrai) o menu e caso receba o valor `false` expande o menu.
   *
   * > Utilize esta propriedade para iniciar o menu colapsado.
   *
   * > Ao utilizar os métodos [`colapse`](documentation/po-menu#colapseMethod), [`expand`](documentation/po-menu#expandMethod) e
   * [`toggle`](documentation/po-menu#toggleMethod) o valor desta propriedade não é alterado.
   *
   * **Importante:**
   *
   * > O menu será colapsado/expandido apenas se todos os itens de menu tiverem valor nas propriedades `icon` e `shortLabel`.
   *
   * @default `false`
   */
  set collapsed(collapsed) {
    this._collapsed = convertToBoolean(collapsed);
    this.allowCollapseHover = this._collapsed;
    this.validateCollapseClass();
  }
  get collapsed() {
    return this._collapsed;
  }
  /** Lista dos itens do menu. Se o valor estiver indefinido ou inválido, será inicializado como um array vazio. */
  set menus(menus) {
    this._menus = Array.isArray(menus) ? menus : [];
    this.menuGlobalService.sendMenus(menus);
    setTimeout(() => {
      const urlRouter = this.checkingRouterChildrenFragments();
      this.checkActiveMenuByUrl(urlRouter);
    });
  }
  get menus() {
    return this._menus;
  }
  get maxLevel() {
    return this._maxLevel;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita um campo para pesquisa no menu.
   * A pesquisa é realizada em todos os níveis do menu e busca apenas pelos itens que contém uma ação e/ou link definidos,
   * ou também, pode ser realizada através de um serviço definido na propriedade `p-service`.
   *
   * > O campo de pesquisa é desabilitado se o menu estiver colapsado.
   *
   * @default `false`
   */
  set filter(filter2) {
    this._filter = filter2 === "" ? true : convertToBoolean(filter2);
    this.filteredItems = [...this._menus];
  }
  get filter() {
    return this._filter;
  }
  /**
   * @optional
   *
   * @description
   *
   * Quando ativado, a pesquisa também retornará itens agrupadores além dos itens que contêm uma ação e/ou link definidos.
   * Isso pode ser útil quando se deseja encontrar rapidamente categorias ou seções do menu.
   *
   * > É necessário que a propriedade `p-filter` esteja habilitada.
   *
   * @default `false`
   */
  set searchTreeItems(searchTreeItems) {
    this._searchTreeItems = searchTreeItems === "" ? true : convertToBoolean(searchTreeItems);
    this.filteredItems = [...this._menus];
  }
  get searchTreeItems() {
    return this._searchTreeItems;
  }
  /**
   * @optional
   *
   * @description
   *
   * Nesta propriedade deve ser informada a URL do serviço em que será utilizado para realizar o filtro de itens do
   * menu quando realizar uma busca. Caso haja a necessidade de customização, pode ser informado um
   * serviço implementando a interface `PoMenuFilter`.
   *
   * Caso utilizada uma URL, o serviço deve retornar os dados conforme o
   * [Guia de implementação de APIs](https://po-ui.io/guides/api) do PO UI.
   *
   * Quando utilizada uma URL de serviço, será realizado um *GET* na URL informada, passando o valor digitado
   * no parâmetro `search`, veja exemplo:
   *
   * > O filtro no serviço será realizado caso contenha no mínimo três caracteres no campo de busca, por exemplo `tot`.
   *
   * ```
   * <po-menu p-service="/api/v1/fnd/menu">
   * </po-menu>
   *
   * Requisição: GET /api/v1/fnd/menu?search=contas
   * ```
   *
   * > É necessário que propriedade `p-filter` esteja habilitada.
   */
  set service(value) {
    this._service = value || void 0;
    this.configService(this.service);
  }
  get service() {
    return this._service;
  }
  /**
   * @optional
   *
   * @description
   *
   * Deve ser informado um objeto que deseja-se utilizar na requisição de filtro dos itens de menu.
   *
   * Caso utilizado um serviço customizado, implementando a interface `PoMenuFilter`, o valor desta propriedade
   * será passado como parâmetro, na função `getFilteredData`.
   *
   * Quando utilizada uma URL de serviço, será realizado um *GET* na URL informada, passando os valores informados
   * nesta propriedade em conjunto com o parâmetro `search`, veja exemplo:
   *
   * ```
   * <po-menu p-service="/api/v1/fnd/menu" [p-params]="{ company: 1, user: 297767512 }">
   * </po-menu>
   *
   * Requisição: GET /api/v1/fnd/menu?search=contas&company=1&user=297767512
   * ```
   */
  set params(value) {
    this._params = value && isTypeof(value, "object") ? value : void 0;
  }
  get params() {
    return this._params;
  }
  /**
   * @optional
   *
   * @description
   *
   * Caminho para a logomarca, que será exibida quando o componente estiver expandido, localizada na parte superior.
   *
   * > **Importante:**
   * - Caso esta propriedade estiver indefinida ou inválida o espaço para logomarca será removido.
   * - Como boa prática, indica-se utilizar imagens com até `24px` de altura e `224px` de largura,
   * caso ultrapassar esses valores a imagem será readequada no espaço disponível.
   */
  logo;
  /**
   * @optional
   *
   * @description
   *
   * Define o texto alternativo para a logomarca.
   *
   * > **Importante**
   * > Caso esta propriedade não seja definida o texto padrão será "Logomarca início".
   *
   * @default `Logomarca início`
   */
  logoAlt;
  /**
   * @optional
   *
   * @description
   *
   * Caminho para a logomarca, que será exibida quando o componente estiver colapsado, localizada na parte superior.
   *
   * > **Importante:**
   * - Caso esta propriedade estiver indefinida ou inválida passa a assumir o valor informado na propriedade `p-logo` e na ausência desta o
   * espaço para logomarca será removido.
   * - Como boa prática, indica-se utilizar imagens com até `48px` de altura e `48px` de largura,
   * caso ultrapassar esses valores a imagem será readequada no espaço disponível.
   * - Caso não informar um valor, esta propriedade passa a assumir o valor informado na propriedade `p-logo`.
   */
  shortLogo;
  /**
   * @optional
   *
   * @description
   * Define o link para a rota ao clicar no logo do menu.
   *
   * - Se o valor for uma string, define a rota para o link informado.
   * - Se for `false`, o logo não terá link associado.
   * - Se for `true`, o logo terá a rota padrão `./`.
   *
   * @default `true`
   */
  set logoLink(value) {
    this._logoLink = value === false ? false : value || true;
  }
  get logoLink() {
    return this._logoLink;
  }
  constructor(menuGlobalService, menuService, languageService) {
    this.menuGlobalService = menuGlobalService;
    this.menuService = menuService;
    this.languageService = languageService;
    this.literals = __spreadValues(__spreadValues({}, poMenuLiteralsDefault[this.languageService?.getLanguageDefault()]), poMenuLiteralsDefault[this.languageService?.getShortLanguage()]);
  }
  setMenuExtraProperties() {
    this.allowIcons = !!this.menus.length;
    this.allowCollapseMenu = !!this.menus.length;
    this.menus.forEach((menuItem) => {
      this._level = 1;
      this.allowIcons = this.allowIcons ? validValue(menuItem.icon) : false;
      this.allowCollapseMenu = this.allowCollapseMenu && this.allowIcons ? validValue(menuItem.shortLabel) : false;
      this.removeBadgeAlert(menuItem);
      this.setMenuItemProperties(menuItem);
      if (menuItem.subItems) {
        this._level++;
        this.processSubItems(menuItem);
      }
    });
  }
  setMenuItemProperties(menuItem) {
    menuItem["id"] = menuItem["id"] || uuid();
    menuItem["level"] = this._level;
    menuItem["type"] = this.setMenuType(menuItem);
  }
  validateMenus(menus) {
    menus.forEach((menu) => this.validateMenu(menu));
  }
  setMenuType(menuItem) {
    if (menuItem.subItems && menuItem.subItems.length > 0 && this._level < this.maxLevel) {
      return "subItems";
    }
    if (!menuItem.link) {
      return "noLink";
    }
    if (isExternalLink(menuItem.link)) {
      return "externalLink";
    }
    return "internalLink";
  }
  configService(service) {
    if (typeof service === "string" && service.trim()) {
      this.menuService.configProperties(service);
      this.filterService = this.menuService;
    } else if (typeof service === "object" && service.getFilteredData) {
      this.filterService = service;
    } else {
      this.filterService = void 0;
    }
  }
  processSubItems(menu) {
    menu.subItems.forEach((menuItem, index, menuItems) => {
      const previousItem = menuItems[index - 1];
      if (previousItem && previousItem.subItems) {
        this._level = previousItem["level"];
      }
      if (this._level <= this.maxLevel) {
        this.setMenuItemProperties(menuItem);
        if (menuItem.subItems) {
          this._level++;
          this.processSubItems(menuItem);
        }
      }
      if (!menu["badgeAlert"]) {
        menu = this.setMenuBadgeAlert(menu, menuItem);
      }
    });
    menu.subItems = Object.assign([], menu.subItems);
  }
  removeBadgeAlert(menuItem) {
    if (menuItem["badgeAlert"]) {
      delete menuItem["badgeAlert"];
    }
    if (menuItem.subItems) {
      menuItem.subItems.forEach((subItem) => this.removeBadgeAlert(subItem));
    }
  }
  setMenuBadgeAlert(parent, child) {
    const childHasSubItems = child.subItems && child.subItems.length;
    const childHasBadgeAlert = child["badgeAlert"];
    const childHasBadge = child.badge && convertToInt(child.badge.value) >= 0;
    parent["badgeAlert"] = childHasBadgeAlert || childHasBadge && !childHasSubItems;
    return parent;
  }
  validateMenu(menuItem) {
    if (!menuItem.label || menuItem.label.trim() === "") {
      throw new Error(this.literals.emptyLabelError);
    } else if (menuItem.subItems) {
      menuItem.subItems.forEach((subItem) => {
        this.validateMenu(subItem);
      });
    }
  }
  static ɵfac = function PoMenuBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuBaseComponent)(ɵɵdirectiveInject(PoMenuGlobalService), ɵɵdirectiveInject(PoMenuService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoMenuBaseComponent,
    inputs: {
      automaticToggle: [2, "p-automatic-toggle", "automaticToggle", convertToBoolean],
      collapsed: [0, "p-collapsed", "collapsed"],
      menus: [0, "p-menus", "menus"],
      filter: [0, "p-filter", "filter"],
      searchTreeItems: [0, "p-search-tree-items", "searchTreeItems"],
      service: [0, "p-service", "service"],
      params: [0, "p-params", "params"],
      logo: [0, "p-logo", "logo"],
      logoAlt: [0, "p-logo-alt", "logoAlt"],
      shortLogo: [0, "p-short-logo", "shortLogo"],
      logoLink: [0, "p-logo-link", "logoLink"]
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoMenuGlobalService
  }, {
    type: PoMenuService
  }, {
    type: PoLanguageService
  }], {
    automaticToggle: [{
      type: Input,
      args: [{
        alias: "p-automatic-toggle",
        transform: convertToBoolean
      }]
    }],
    collapsed: [{
      type: Input,
      args: ["p-collapsed"]
    }],
    menus: [{
      type: Input,
      args: ["p-menus"]
    }],
    filter: [{
      type: Input,
      args: ["p-filter"]
    }],
    searchTreeItems: [{
      type: Input,
      args: ["p-search-tree-items"]
    }],
    service: [{
      type: Input,
      args: ["p-service"]
    }],
    params: [{
      type: Input,
      args: ["p-params"]
    }],
    logo: [{
      type: Input,
      args: ["p-logo"]
    }],
    logoAlt: [{
      type: Input,
      args: ["p-logo-alt"]
    }],
    shortLogo: [{
      type: Input,
      args: ["p-short-logo"]
    }],
    logoLink: [{
      type: Input,
      args: ["p-logo-link"]
    }]
  });
})();
var _c0$o = (a0) => ({
  "po-menu-animation": a0
});
function PoMenuComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17);
    ɵɵlistener("click", function PoMenuComponent_div_0_Template_div_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggleMenuMobile());
    });
    ɵɵelementEnd();
  }
}
function PoMenuComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 18);
    ɵɵelement(1, "po-logo", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-class", ctx_r1.enableCollapse ? "po-menu-short-logo" : "po-menu-logo")("p-logo", ctx_r1.enableCollapse ? ctx_r1.shortLogo || ctx_r1.logo : ctx_r1.logo)("p-logo-alt", ctx_r1.logoAlt)("p-link", ctx_r1.logoLink);
  }
}
function PoMenuComponent_div_8_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵtemplate(1, PoMenuComponent_div_8_ng_container_1_Template, 1, 0, "ng-container", 21);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.menuHeaderTemplate.templateRef);
  }
}
function PoMenuComponent_po_menu_filter_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-menu-filter", 22);
    ɵɵlistener("p-filter", function PoMenuComponent_po_menu_filter_9_Template_po_menu_filter_p_filter_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.debounceFilter($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-enable-collapse", ctx_r1.enableCollapse)("p-loading", ctx_r1.filterLoading);
  }
}
function PoMenuComponent_li_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 23);
    ɵɵelement(1, "po-menu-item", 24);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-level", 1)("p-label", ctx_r1.literals.itemNotFound)("p-short-label", ctx_r1.literals.itemNotFound);
  }
}
function PoMenuComponent_li_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 23);
    ɵɵelement(1, "po-menu-item", 25);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const menu_r4 = ctx.$implicit;
    const menuIndex_r5 = ctx.index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-menu-item-first", menuIndex_r5 === 0);
    ɵɵattribute("aria-level", menu_r4.level);
    ɵɵadvance();
    ɵɵproperty("p-action", menu_r4.action)("p-badge-alert", menu_r4.badgeAlert)("p-badge-color", menu_r4.badge ? menu_r4.badge.color : void 0)("p-badge-value", menu_r4.badge ? menu_r4.badge.value : void 0)("p-collapsed-menu", ctx_r1.enableCollapse)("p-icon", ctx_r1.allowIcons ? menu_r4.icon : null)("p-id", menu_r4.id)("p-label", menu_r4.label)("p-level", menu_r4.level)("p-link", menu_r4.link)("p-short-label", menu_r4.shortLabel)("p-sub-items", menu_r4.subItems)("p-type", menu_r4.type);
  }
}
function PoMenuComponent_div_17_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 30);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.literals.close);
  }
}
function PoMenuComponent_div_17_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 26)(1, "button", 27);
    ɵɵlistener("click", function PoMenuComponent_div_17_Template_button_click_1_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggle());
    });
    ɵɵtemplate(2, PoMenuComponent_div_17_span_2_Template, 2, 1, "span", 28);
    ɵɵelement(3, "po-icon", 29);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("aria-label", ctx_r1.enableCollapseButton ? ctx_r1.literals.close : ctx_r1.literals.open);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.enableCollapseButton);
    ɵɵadvance();
    ɵɵproperty("p-icon", ctx_r1.enableCollapse ? "ICON_MENU_OPEN" : "ICON_MENU_CLOSE");
  }
}
var poMenuDebounceTime = 400;
var poMenuMinLength = 3;
var poMenuRootLevel = 1;
var PoMenuComponent = class _PoMenuComponent extends PoMenuBaseComponent {
  changeDetector;
  element;
  renderer;
  router;
  menuItemsService;
  menuHeaderTemplate;
  activeMenuItem;
  collapsedMobile;
  filterLoading = false;
  groupedMenuItem;
  id = uuid();
  linkActive;
  mobileOpened = false;
  noData = false;
  timeoutFilter;
  filteringItems = false;
  menuInitialized = false;
  menuPrevious = null;
  resizeListener;
  itemSubscription;
  routeSubscription;
  constructor(changeDetector, element, renderer, router, menuItemsService, menuGlobalService, menuService, languageService) {
    super(menuGlobalService, menuService, languageService);
    this.changeDetector = changeDetector;
    this.element = element;
    this.renderer = renderer;
    this.router = router;
    this.menuItemsService = menuItemsService;
  }
  get isActiveItemMenuSubMenu() {
    return this.activeMenuItem["level"] > this.groupedMenuItem["level"];
  }
  get enableCollapse() {
    return this.isCollapsed && !this.collapsedMobile;
  }
  get enableCollapseButton() {
    return this.allowCollapseMenu && !this.collapsed && !this.mobileOpened;
  }
  get hasFooter() {
    return this.enableCollapseButton || this.enableCollapse;
  }
  get isCollapsed() {
    return this.allowCollapseMenu && this.collapsed;
  }
  ngDoCheck() {
    if (this.filteringItems && this.filter) {
      return;
    }
    const menuCurrent = this.stringify(this.menus);
    if (this.menuPrevious !== menuCurrent || !this.menuInitialized) {
      this.updateMenu();
      this.validateCollapseClass();
    }
  }
  ngOnDestroy() {
    this.itemSubscription.unsubscribe();
    this.routeSubscription.unsubscribe();
    if (this.resizeListener) {
      this.resizeListener();
    }
    this.menuGlobalService.sendRemovedApplicationMenu(this.id);
  }
  ngOnInit() {
    this.subscribeToMenuItem();
    this.subscribeToRoute();
  }
  ngAfterViewInit() {
    this.menuGlobalService.sendApplicationMenu(this);
  }
  activateMenuByUrl(urlPath, menus) {
    if (menus) {
      const urlPathWithoutLastFragment = urlPath.substr(0, urlPath.lastIndexOf("/"));
      return menus.some((menu) => {
        const formattedMenuLink = getFormattedLink(menu.link);
        const menuLinkPath = `${urlPathWithoutLastFragment}${formattedMenuLink.substr(formattedMenuLink.lastIndexOf("/"))}`;
        if (menuLinkPath === urlPath && menuLinkPath === formattedMenuLink) {
          this.linkActive = formattedMenuLink;
          this.activateMenuItem(menu);
          return true;
        } else {
          return this.activateMenuByUrl(urlPath, menu.subItems);
        }
      });
    }
  }
  checkActiveMenuByUrl(urlPath) {
    if (!this.linkActive || this.linkActive !== urlPath) {
      this.activateMenuByUrl(urlPath, this.menus);
    }
  }
  /**
   * <a id="colapseMethod"></a>
   *
   * *Método para colapsar (retrair) o menu.
   */
  collapse() {
    this.validateToggleMenu(true);
  }
  debounceFilter(filter2) {
    clearTimeout(this.timeoutFilter);
    this.timeoutFilter = setTimeout(() => {
      this.filterProcess(filter2);
    }, poMenuDebounceTime);
  }
  /**
   * <a id="expandMethod"></a>
   *
   * *Método para expandir (aumentar) o menu.
   */
  expand() {
    this.validateToggleMenu(false);
  }
  subscribeToMenuItem() {
    this.itemSubscription = this.menuItemsService.receiveFromChildMenuClicked().subscribe((menu) => {
      this.clickMenuItem(menu);
    });
  }
  subscribeToRoute() {
    this.routeSubscription = this.router.events.subscribe((val) => {
      if (val instanceof NavigationEnd || val instanceof NavigationCancel) {
        const urlRouter = this.checkingRouterChildrenFragments();
        this.checkActiveMenuByUrl(urlRouter);
      }
    });
  }
  /**
   * <a id="toggleMethod"></a>
   * *Método que colapsa e expande o menu alternadamente.
   *
   * > *Os métodos apenas vão colapsar/expandir o menu se:
   *  - Todos os itens de menu tiverem valor nas propriedades `icon` e `shortLabel`.
   */
  toggle() {
    this.validateToggleMenu(!this.collapsed);
  }
  toggleMenuMobile() {
    this.mobileOpened = !this.mobileOpened;
    this.collapsedMobile = this.collapsed && this.mobileOpened;
    this.validateCollapseClass(this.collapsedMobile);
    if (isMobile()) {
      return;
    }
    if (this.mobileOpened) {
      this.createResizeListener();
    }
  }
  onMouseEnter() {
    if (this.collapsed && this.automaticToggle) {
      this.collapsed = false;
      this.allowCollapseHover = true;
    }
  }
  onMouseLeave() {
    if (!this.collapsed && this.allowCollapseHover && this.automaticToggle) {
      this.collapsed = true;
    }
  }
  checkingRouterChildrenFragments() {
    const childrenPrimary = this.router.parseUrl(this.router.url).root.children["primary"];
    return childrenPrimary ? `/${childrenPrimary.segments.map((it) => it.path).join("/")}` : "";
  }
  validateCollapseClass(collapsedMobile = false) {
    const wrapper = this.element.nativeElement.parentNode;
    this.renderer[this.isCollapsed && !collapsedMobile ? "addClass" : "removeClass"](wrapper, "po-collapsed-menu");
  }
  activateCollapseSubMenuItem() {
    this.clearGroupMenuIfFirstLevel(this.activeMenuItem);
    if (!this.collapsed && this.activeMenuItem["level"] > poMenuRootLevel && this.isActiveItemMenuSubMenu) {
      this.openParentMenu(this.activeMenuItem);
    }
  }
  activateMenuItem(menu) {
    this.activeMenuItem = menu;
    this.linkActive = menu.link;
    if (this.activeMenuItem["level"] > poMenuRootLevel) {
      this.openParentMenu(this.activeMenuItem);
    } else {
      this.groupedMenuItem = null;
    }
    this.menuItemsService.sendToChildMenuClicked({
      active: this.activeMenuItem,
      grouped: this.groupedMenuItem,
      activatedByRoute: true
    });
  }
  areSubMenus(menus) {
    return menus.every((menu) => menu["level"] > poMenuRootLevel);
  }
  clearGroupMenuIfFirstLevel(activeMenuItem) {
    if (activeMenuItem["level"] === poMenuRootLevel) {
      this.groupedMenuItem = void 0;
    }
  }
  clickMenuItem(menu) {
    if (menu.action) {
      this.executeMenuAction(menu);
    }
    if (menu["type"] === "externalLink") {
      openExternalLink(menu.link);
    } else if (menu["type"] === "internalLink") {
      this.activateMenuItem(menu);
    } else if (menu["type"] === "subItems") {
      if (this.filteringItems) {
        this.filteringItems = false;
      }
      this.groupMenuItem(menu);
    }
    if (menu["type"] !== "subItems") {
      this.mobileOpened = false;
    }
  }
  convertToMenuItemFiltered(menuItem = {
    label: "",
    link: "",
    action: () => {
    }
  }) {
    const {
      label,
      link,
      action
    } = menuItem;
    const menuItemFiltered = {
      label,
      link,
      action
    };
    this.setMenuItemProperties(menuItemFiltered);
    return menuItemFiltered;
  }
  createResizeListener() {
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.toggleResize();
      this.resizeListener();
    });
  }
  executeMenuAction(menu) {
    menu.action(menu);
  }
  filterItems(filter2) {
    return __async(this, null, function* () {
      const trimFilter = filter2 && filter2.trim();
      if (trimFilter) {
        this.filteredItems = [];
        this.filteredItems = this.filterService ? yield this.filterOnService(trimFilter) : this.filterLocalItems(trimFilter);
        this.filteringItems = true;
      } else {
        this.filteredItems = [...this.menus];
        this.filteringItems = false;
      }
    });
  }
  filterLocalItems(filter2) {
    const filteredItems = [];
    this.findItems(this.menus, filter2.toLowerCase(), filteredItems);
    return filteredItems;
  }
  filterProcess(filter2) {
    this.filterLoading = true;
    this.filterItems(filter2).then(() => {
      this.filterLoading = false;
      this.showNoData();
      this.changeDetector.detectChanges();
      this.menuItemsService.sendToChildMenuClicked({
        active: this.activeMenuItem,
        grouped: this.groupedMenuItem
      });
    }).catch((error) => {
      this.filterLoading = false;
      Promise.reject(error);
    });
  }
  filterOnService(search = "") {
    return __async(this, null, function* () {
      if (search.length >= poMenuMinLength) {
        return yield this.filterService.getFilteredData(search, this.params).pipe(map((menuItemsFiltered) => menuItemsFiltered.map((menuItem) => this.convertToMenuItemFiltered(menuItem)))).toPromise();
      } else {
        return this.filteredItems;
      }
    });
  }
  findItems(menus, filter2, filteredItems) {
    menus.forEach((menu) => {
      const hasAction = this.searchTreeItems ? this.searchTreeItems : menu.action || menu.link;
      const labelHasFilter = menu.label.toLowerCase().includes(filter2);
      if (labelHasFilter && hasAction) {
        const newMenu = __spreadValues({}, menu);
        if (newMenu.subItems?.length) {
          if (!this.searchTreeItems) {
            delete newMenu.subItems;
          }
          newMenu["type"] = this.setMenuType(newMenu);
        }
        filteredItems.push(newMenu);
      }
      if (menu.subItems) {
        this.findItems(menu.subItems, filter2, filteredItems);
      }
    });
  }
  findParent(menus, menuItem) {
    const getParent = function(menuItems, id) {
      if (menuItems) {
        for (let index = 0; index < menuItems.length; index++) {
          const menu = menuItems[index];
          if (menu.subItems && menu.subItems.find((subItem) => subItem["id"] === id)) {
            return menu;
          }
          const found = getParent(menu.subItems, id);
          if (found) {
            return found;
          }
        }
      }
    };
    return getParent(menus, menuItem["id"]);
  }
  findRootParent(menus, menu) {
    const findParent = this.findParent;
    const getRootParent = function(menuItems, menuItem) {
      let parent = findParent(menuItems, menuItem);
      if (parent["level"] !== poMenuRootLevel) {
        parent = getRootParent(menuItems, parent);
      }
      return parent;
    };
    return getRootParent(menus, menu);
  }
  getActiveMenuParent(menus, activeMenuItem, groupedMenuItem) {
    if (this.areSubMenus([groupedMenuItem, activeMenuItem])) {
      return this.findRootParent(menus, activeMenuItem);
    }
  }
  groupMenuItem(menu) {
    if (this.collapsed) {
      this.toggleMenuCollapse();
    }
    menu["isOpened"] = !menu["isOpened"];
    this.groupedMenuItem = menu;
    if (this.activeMenuItem && menu["isOpened"] && this.isActiveItemMenuSubMenu && this.isRootMenuEqualGroupedMenu(this.menus, this.activeMenuItem, menu)) {
      this.activateMenuItem(this.activeMenuItem);
    }
    this.menuItemsService.sendToChildMenuClicked({
      active: this.activeMenuItem,
      grouped: this.groupedMenuItem
    });
  }
  isRootMenuEqualGroupedMenu(menus, activeMenuItem, groupedMenuItem) {
    const activeMenuRootParent = this.findRootParent(menus, activeMenuItem);
    return activeMenuRootParent["id"] === groupedMenuItem["id"];
  }
  openParentMenu(childMenu) {
    const parent = this.findParent(this.menus, childMenu);
    parent["isOpened"] = true;
    this.groupedMenuItem = parent;
  }
  showNoData() {
    this.noData = this.filteredItems.length === 0;
  }
  stringify(menus) {
    return JSON.stringify(this.menus, (key, value) => {
      if (key !== "icon") {
        return value;
      }
    });
  }
  toggleGroupedMenuItem() {
    this.groupedMenuItem["isOpened"] = !this.collapsed && this.allowCollapseMenu;
  }
  toggleMenuCollapse(collapsed = false) {
    this.collapsed = collapsed;
    if (this.groupedMenuItem && this.activeMenuItem) {
      this.groupedMenuItem = this.getActiveMenuParent(this.menus, this.activeMenuItem, this.groupedMenuItem) || this.groupedMenuItem;
      this.toggleGroupedMenuItem();
    }
    if (this.activeMenuItem) {
      this.activateCollapseSubMenuItem();
      this.menuItemsService.sendToChildMenuClicked({
        active: this.activeMenuItem,
        grouped: this.groupedMenuItem,
        activatedByRoute: true
      });
    }
    this.updateMenu();
  }
  toggleResize() {
    if (this.mobileOpened) {
      this.mobileOpened = false;
      this.collapsedMobile = false;
      this.validateCollapseClass(this.collapsedMobile);
    }
  }
  validateToggleMenu(collapsed) {
    if (!this.allowCollapseMenu) {
      return;
    }
    this.toggleMenuCollapse(collapsed);
  }
  updateMenu() {
    this.menuInitialized = true;
    this.setMenuExtraProperties();
    this.filteredItems = [...this.menus];
    this.menuPrevious = this.stringify(this.menus);
    this.validateMenus(this.menus);
  }
  static ɵfac = function PoMenuComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(PoMenuItemsService), ɵɵdirectiveInject(PoMenuGlobalService), ɵɵdirectiveInject(PoMenuService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoMenuComponent,
    selectors: [["po-menu"]],
    contentQueries: function PoMenuComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PoMenuHeaderTemplateDirective, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuHeaderTemplate = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoMenuItemsService, PoMenuService]), ɵɵInheritDefinitionFeature],
    decls: 18,
    vars: 11,
    consts: [["class", "po-menu-overlay", 3, "click", 4, "ngIf"], [1, "po-menu-mobile", "po-clickable", 3, "click"], ["p-icon", "ICON_MENU"], [1, "po-menu", 3, "ngClass"], [1, "po-menu-container", 3, "mouseenter", "mouseleave"], [1, "po-menu-header"], ["class", "po-menu-header-container-logo", 4, "ngIf"], ["class", "po-menu-header-template", 4, "ngIf"], [3, "p-enable-collapse", "p-loading", "p-filter", 4, "ngIf"], [1, "po-menu-body"], [1, "po-menu-outer"], [1, "po-menu-inner"], [1, "po-menu-nav"], ["role", "menu", 1, "po-menu-list"], ["class", "po-menu-list-item", "role", "presentation", 4, "ngIf"], ["class", "po-menu-list-item", "role", "presentation", 3, "po-menu-item-first", 4, "ngFor", "ngForOf"], ["class", "po-menu-footer", 4, "ngIf"], [1, "po-menu-overlay", 3, "click"], [1, "po-menu-header-container-logo"], [3, "p-class", "p-logo", "p-logo-alt", "p-link"], [1, "po-menu-header-template"], [4, "ngTemplateOutlet"], [3, "p-filter", "p-enable-collapse", "p-loading"], ["role", "presentation", 1, "po-menu-list-item"], ["p-icon", "ICON_INFO", "p-type", "noData", 3, "p-level", "p-label", "p-short-label"], [3, "p-action", "p-badge-alert", "p-badge-color", "p-badge-value", "p-collapsed-menu", "p-icon", "p-id", "p-label", "p-level", "p-link", "p-short-label", "p-sub-items", "p-type"], [1, "po-menu-footer"], ["type", "button", 1, "po-menu-collapse-button-icon", 3, "click"], ["aria-hidden", "true", 4, "ngIf"], [3, "p-icon"], ["aria-hidden", "true"]],
    template: function PoMenuComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoMenuComponent_div_0_Template, 1, 0, "div", 0);
        ɵɵelementStart(1, "div")(2, "div", 1);
        ɵɵlistener("click", function PoMenuComponent_Template_div_click_2_listener() {
          return ctx.toggleMenuMobile();
        });
        ɵɵelement(3, "po-icon", 2);
        ɵɵelementEnd();
        ɵɵelementStart(4, "div", 3)(5, "div", 4);
        ɵɵlistener("mouseenter", function PoMenuComponent_Template_div_mouseenter_5_listener() {
          return ctx.onMouseEnter();
        })("mouseleave", function PoMenuComponent_Template_div_mouseleave_5_listener() {
          return ctx.onMouseLeave();
        });
        ɵɵelementStart(6, "div", 5);
        ɵɵtemplate(7, PoMenuComponent_div_7_Template, 2, 4, "div", 6)(8, PoMenuComponent_div_8_Template, 2, 1, "div", 7)(9, PoMenuComponent_po_menu_filter_9_Template, 1, 2, "po-menu-filter", 8);
        ɵɵelementEnd();
        ɵɵelementStart(10, "div", 9)(11, "div", 10)(12, "div", 11)(13, "nav", 12)(14, "ul", 13);
        ɵɵtemplate(15, PoMenuComponent_li_15_Template, 2, 3, "li", 14)(16, PoMenuComponent_li_16_Template, 2, 16, "li", 15);
        ɵɵelementEnd()()()()()();
        ɵɵtemplate(17, PoMenuComponent_div_17_Template, 4, 3, "div", 16);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.mobileOpened);
        ɵɵadvance(4);
        ɵɵproperty("ngClass", ɵɵpureFunction1(9, _c0$o, ctx.mobileOpened));
        ɵɵattribute("aria-expanded", !ctx.collapsed);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.logo || ctx.shortLogo && ctx.enableCollapse);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.enableCollapse && ctx.menuHeaderTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.filter);
        ɵɵadvance(6);
        ɵɵproperty("ngIf", ctx.noData);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.filteredItems);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasFooter);
      }
    },
    dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, PoLogoComponent, PoIconComponent, PoMenuFilterComponent, PoMenuItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuComponent, [{
    type: Component,
    args: [{
      selector: "po-menu",
      providers: [PoMenuItemsService, PoMenuService],
      standalone: false,
      template: `<div *ngIf="mobileOpened" class="po-menu-overlay" (click)="toggleMenuMobile()"></div>

<div>
  <div class="po-menu-mobile po-clickable" (click)="toggleMenuMobile()">
    <po-icon p-icon="ICON_MENU"></po-icon>
  </div>

  <div class="po-menu" [attr.aria-expanded]="!collapsed" [ngClass]="{ 'po-menu-animation': mobileOpened }">
    <div class="po-menu-container" (mouseenter)="onMouseEnter()" (mouseleave)="onMouseLeave()">
      <div class="po-menu-header">
        <div *ngIf="logo || (shortLogo && enableCollapse)" class="po-menu-header-container-logo">
          <po-logo
            [p-class]="enableCollapse ? 'po-menu-short-logo' : 'po-menu-logo'"
            [p-logo]="enableCollapse ? shortLogo || logo : logo"
            [p-logo-alt]="logoAlt"
            [p-link]="logoLink"
          ></po-logo>
        </div>

        <div *ngIf="!enableCollapse && menuHeaderTemplate" class="po-menu-header-template">
          <ng-container *ngTemplateOutlet="menuHeaderTemplate.templateRef"></ng-container>
        </div>

        <po-menu-filter
          *ngIf="filter"
          [p-enable-collapse]="enableCollapse"
          [p-loading]="filterLoading"
          (p-filter)="debounceFilter($event)"
        ></po-menu-filter>
      </div>

      <div class="po-menu-body">
        <div class="po-menu-outer">
          <div class="po-menu-inner">
            <nav class="po-menu-nav">
              <ul class="po-menu-list" role="menu">
                <li *ngIf="noData" class="po-menu-list-item" role="presentation">
                  <po-menu-item
                    p-icon="ICON_INFO"
                    p-type="noData"
                    [p-level]="1"
                    [p-label]="literals.itemNotFound"
                    [p-short-label]="literals.itemNotFound"
                  ></po-menu-item>
                </li>
                <li
                  *ngFor="let menu of filteredItems; let menuIndex = index"
                  class="po-menu-list-item"
                  role="presentation"
                  [attr.aria-level]="menu.level"
                  [class.po-menu-item-first]="menuIndex === 0"
                >
                  <po-menu-item
                    [p-action]="menu.action"
                    [p-badge-alert]="menu.badgeAlert"
                    [p-badge-color]="menu.badge ? menu.badge.color : undefined"
                    [p-badge-value]="menu.badge ? menu.badge.value : undefined"
                    [p-collapsed-menu]="enableCollapse"
                    [p-icon]="allowIcons ? menu.icon : null"
                    [p-id]="menu.id"
                    [p-label]="menu.label"
                    [p-level]="menu.level"
                    [p-link]="menu.link"
                    [p-short-label]="menu.shortLabel"
                    [p-sub-items]="menu.subItems"
                    [p-type]="menu.type"
                  ></po-menu-item>
                </li>
              </ul>
            </nav>
          </div>
        </div>
      </div>
    </div>

    <div *ngIf="hasFooter" class="po-menu-footer">
      <button
        class="po-menu-collapse-button-icon"
        type="button"
        [attr.aria-label]="enableCollapseButton ? literals.close : literals.open"
        (click)="toggle()"
      >
        <span *ngIf="enableCollapseButton" aria-hidden="true">{{ literals.close }}</span>

        <po-icon [p-icon]="enableCollapse ? 'ICON_MENU_OPEN' : 'ICON_MENU_CLOSE'"></po-icon>
      </button>
    </div>
  </div>
</div>
`
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: Router
  }, {
    type: PoMenuItemsService
  }, {
    type: PoMenuGlobalService
  }, {
    type: PoMenuService
  }, {
    type: PoLanguageService
  }], {
    menuHeaderTemplate: [{
      type: ContentChild,
      args: [PoMenuHeaderTemplateDirective, {
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMenuComponent, {
    className: "PoMenuComponent",
    filePath: "lib/components/po-menu/po-menu.component.ts",
    lineNumber: 121
  });
})();
var PoMenuModule = class _PoMenuModule {
  static ɵfac = function PoMenuModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoMenuModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoMenuModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, RouterModule, PoBadgeModule, PoFieldModule, PoLoadingModule, PoLogoModule, PoIconModule, PoTooltipModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, PoBadgeModule, PoFieldModule, PoLoadingModule, PoLogoModule, PoIconModule, PoTooltipModule],
      declarations: [PoMenuComponent, PoMenuFilterComponent, PoMenuHeaderTemplateDirective, PoMenuItemComponent],
      exports: [PoMenuComponent, PoMenuHeaderTemplateDirective]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoMenuModule, {
    declarations: [PoMenuComponent, PoMenuFilterComponent, PoMenuHeaderTemplateDirective, PoMenuItemComponent],
    imports: [CommonModule, RouterModule, PoBadgeModule, PoFieldModule, PoLoadingModule, PoLogoModule, PoIconModule, PoTooltipModule],
    exports: [PoMenuComponent, PoMenuHeaderTemplateDirective]
  });
})();
var PoNavbarActionComponent = class _PoNavbarActionComponent {
  router;
  action;
  icon;
  label;
  link;
  tooltip;
  constructor(viewContainerRef, router) {
    this.router = router;
  }
  click() {
    if (this.action) {
      this.action();
      return;
    }
    if (this.link) {
      return this.openUrl(this.link);
    }
  }
  openUrl(url) {
    if (isExternalLink(url)) {
      return openExternalLink(url);
    }
    if (url) {
      return this.router.navigate([url]);
    }
  }
  static ɵfac = function PoNavbarActionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarActionComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Router));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoNavbarActionComponent,
    selectors: [["po-navbar-action"]],
    inputs: {
      action: [0, "p-action", "action"],
      icon: [0, "p-icon", "icon"],
      label: [0, "p-label", "label"],
      link: [0, "p-link", "link"],
      tooltip: [0, "p-tooltip-text", "tooltip"]
    },
    standalone: false,
    decls: 1,
    vars: 2,
    consts: [["tabindex", "0", 1, "po-navbar-action-content", "po-clickable", 3, "click", "p-icon", "p-tooltip"]],
    template: function PoNavbarActionComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "po-icon", 0);
        ɵɵlistener("click", function PoNavbarActionComponent_Template_po_icon_click_0_listener() {
          return ctx.click();
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-icon", ctx.icon)("p-tooltip", ctx.tooltip);
      }
    },
    dependencies: [PoTooltipDirective, PoIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarActionComponent, [{
    type: Component,
    args: [{
      selector: "po-navbar-action",
      standalone: false,
      template: '<po-icon\n  tabindex="0"\n  class="po-navbar-action-content po-clickable"\n  [p-icon]="icon"\n  [p-tooltip]="tooltip"\n  (click)="click()"\n></po-icon>\n'
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: Router
  }], {
    action: [{
      type: Input,
      args: ["p-action"]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    link: [{
      type: Input,
      args: ["p-link"]
    }],
    tooltip: [{
      type: Input,
      args: ["p-tooltip-text"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarActionComponent, {
    className: "PoNavbarActionComponent",
    filePath: "lib/components/po-navbar/po-navbar-actions/po-navbar-action/po-navbar-action.component.ts",
    lineNumber: 11
  });
})();
var PoNavbarActionPopupComponent = class _PoNavbarActionPopupComponent {
  iconActions;
  getLastIconAction() {
    if (this.iconActions && this.iconActions.length) {
      return this.iconActions[this.iconActions.length - 1].icon;
    }
  }
  static ɵfac = function PoNavbarActionPopupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarActionPopupComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoNavbarActionPopupComponent,
    selectors: [["po-navbar-action-popup"]],
    inputs: {
      iconActions: [0, "p-icon-actions", "iconActions"]
    },
    standalone: false,
    decls: 5,
    vars: 5,
    consts: [["target", ""], ["popup", ""], ["tabindex", "0", 1, "po-navbar-action-popup-content", "po-clickable", 3, "click"], [3, "p-actions", "p-target"]],
    template: function PoNavbarActionPopupComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 2, 0);
        ɵɵlistener("click", function PoNavbarActionPopupComponent_Template_div_click_0_listener() {
          ɵɵrestoreView(_r1);
          const popup_r2 = ɵɵreference(4);
          return ɵɵresetView(popup_r2.toggle());
        });
        ɵɵelement(2, "span");
        ɵɵelementEnd();
        ɵɵelement(3, "po-popup", 3, 1);
      }
      if (rf & 2) {
        const target_r3 = ɵɵreference(1);
        ɵɵadvance(2);
        ɵɵclassMapInterpolate1("po-icon ", ctx.getLastIconAction(), "");
        ɵɵadvance();
        ɵɵproperty("p-actions", ctx.iconActions)("p-target", target_r3);
      }
    },
    dependencies: [PoPopupComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarActionPopupComponent, [{
    type: Component,
    args: [{
      selector: "po-navbar-action-popup",
      standalone: false,
      template: '<div tabindex="0" #target class="po-navbar-action-popup-content po-clickable" (click)="popup.toggle()">\n  <span class="po-icon {{ getLastIconAction() }}"></span>\n</div>\n\n<po-popup #popup [p-actions]="iconActions" [p-target]="target"> </po-popup>\n'
    }]
  }], null, {
    iconActions: [{
      type: Input,
      args: ["p-icon-actions"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarActionPopupComponent, {
    className: "PoNavbarActionPopupComponent",
    filePath: "lib/components/po-navbar/po-navbar-actions/po-navbar-action-popup/po-navbar-action-popup.component.ts",
    lineNumber: 10
  });
})();
function PoNavbarActionsComponent_po_navbar_action_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-navbar-action", 2);
  }
  if (rf & 2) {
    const iconAction_r1 = ctx.$implicit;
    ɵɵproperty("p-action", iconAction_r1.action)("p-icon", iconAction_r1.icon)("p-label", iconAction_r1.label)("p-link", iconAction_r1.link)("p-tooltip-text", iconAction_r1.tooltip);
  }
}
var PoNavbarActionsComponent = class _PoNavbarActionsComponent {
  _iconActions;
  set iconActions(actions) {
    this._iconActions = actions.map((action) => __spreadProps(__spreadValues({}, action), {
      separator: true,
      url: action.link
    }));
  }
  get iconActions() {
    return this._iconActions;
  }
  static ɵfac = function PoNavbarActionsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarActionsComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoNavbarActionsComponent,
    selectors: [["po-navbar-actions"]],
    inputs: {
      iconActions: [0, "p-icon-actions", "iconActions"]
    },
    standalone: false,
    decls: 2,
    vars: 2,
    consts: [["class", "po-navbar-action", 3, "p-action", "p-icon", "p-label", "p-link", "p-tooltip-text", 4, "ngFor", "ngForOf"], [1, "po-navbar-action-popup", 3, "p-icon-actions"], [1, "po-navbar-action", 3, "p-action", "p-icon", "p-label", "p-link", "p-tooltip-text"]],
    template: function PoNavbarActionsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoNavbarActionsComponent_po_navbar_action_0_Template, 1, 5, "po-navbar-action", 0);
        ɵɵelement(1, "po-navbar-action-popup", 1);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.iconActions);
        ɵɵadvance();
        ɵɵproperty("p-icon-actions", ctx.iconActions);
      }
    },
    dependencies: [NgForOf, PoNavbarActionComponent, PoNavbarActionPopupComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarActionsComponent, [{
    type: Component,
    args: [{
      selector: "po-navbar-actions",
      standalone: false,
      template: '<po-navbar-action\n  *ngFor="let iconAction of iconActions"\n  class="po-navbar-action"\n  [p-action]="iconAction.action"\n  [p-icon]="iconAction.icon"\n  [p-label]="iconAction.label"\n  [p-link]="iconAction.link"\n  [p-tooltip-text]="iconAction.tooltip"\n>\n</po-navbar-action>\n\n<po-navbar-action-popup class="po-navbar-action-popup" [p-icon-actions]="iconActions"> </po-navbar-action-popup>\n'
    }]
  }], null, {
    iconActions: [{
      type: Input,
      args: ["p-icon-actions"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarActionsComponent, {
    className: "PoNavbarActionsComponent",
    filePath: "lib/components/po-navbar/po-navbar-actions/po-navbar-actions.component.ts",
    lineNumber: 10
  });
})();
var PoNavbarActionsModule = class _PoNavbarActionsModule {
  static ɵfac = function PoNavbarActionsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarActionsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoNavbarActionsModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoPopupModule, PoTooltipModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarActionsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoPopupModule, PoTooltipModule, PoIconModule],
      declarations: [PoNavbarActionComponent, PoNavbarActionPopupComponent, PoNavbarActionsComponent],
      exports: [PoNavbarActionsComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoNavbarActionsModule, {
    declarations: [PoNavbarActionComponent, PoNavbarActionPopupComponent, PoNavbarActionsComponent],
    imports: [CommonModule, PoPopupModule, PoTooltipModule, PoIconModule],
    exports: [PoNavbarActionsComponent]
  });
})();
var _c0$n = (a0, a1) => ({
  "po-navbar-item-navigation-icon-disabled": a0,
  "po-clickable": a1
});
var PoNavbarItemNavigationIconComponent = class _PoNavbarItemNavigationIconComponent {
  disabled;
  icon;
  click = new EventEmitter();
  static ɵfac = function PoNavbarItemNavigationIconComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarItemNavigationIconComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoNavbarItemNavigationIconComponent,
    selectors: [["po-navbar-item-navigation-icon"]],
    inputs: {
      disabled: [0, "p-disabled", "disabled"],
      icon: [0, "p-icon", "icon"]
    },
    outputs: {
      click: "p-click"
    },
    standalone: false,
    decls: 2,
    vars: 6,
    consts: [["tabindex", "0", 3, "click", "ngClass"], [3, "p-icon"]],
    template: function PoNavbarItemNavigationIconComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵlistener("click", function PoNavbarItemNavigationIconComponent_Template_div_click_0_listener() {
          return ctx.disabled ? void 0 : ctx.click.emit(ctx.icon);
        });
        ɵɵelement(1, "po-icon", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngClass", ɵɵpureFunction2(3, _c0$n, ctx.disabled, !ctx.disabled));
        ɵɵadvance();
        ɵɵpropertyInterpolate1("p-icon", "ICON_ARROW_", ctx.icon, "");
      }
    },
    dependencies: [NgClass, PoIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemNavigationIconComponent, [{
    type: Component,
    args: [{
      selector: "po-navbar-item-navigation-icon",
      standalone: false,
      template: `<div
  [ngClass]="{ 'po-navbar-item-navigation-icon-disabled': disabled, 'po-clickable': !disabled }"
  tabindex="0"
  (click)="disabled ? undefined : click.emit(icon)"
>
  <po-icon p-icon="ICON_ARROW_{{ icon }}"></po-icon>
</div>
`
    }]
  }], null, {
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    icon: [{
      type: Input,
      args: ["p-icon"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarItemNavigationIconComponent, {
    className: "PoNavbarItemNavigationIconComponent",
    filePath: "lib/components/po-navbar/po-navbar-item-navigation/po-navbar-item-navigation-icon/po-navbar-item-navigation-icon.component.ts",
    lineNumber: 8
  });
})();
var PoNavbarItemNavigationComponent = class _PoNavbarItemNavigationComponent {
  disableLeft;
  disableRight;
  click = new EventEmitter();
  static ɵfac = function PoNavbarItemNavigationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarItemNavigationComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoNavbarItemNavigationComponent,
    selectors: [["po-navbar-item-navigation"]],
    inputs: {
      disableLeft: [0, "p-disable-left", "disableLeft"],
      disableRight: [0, "p-disable-right", "disableRight"]
    },
    outputs: {
      click: "p-click"
    },
    standalone: false,
    decls: 2,
    vars: 2,
    consts: [["p-icon", "left", 1, "po-navbar-item-navigation-icon", 3, "p-click", "p-disabled"], ["p-icon", "right", 1, "po-navbar-item-navigation-icon", 3, "p-click", "p-disabled"]],
    template: function PoNavbarItemNavigationComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "po-navbar-item-navigation-icon", 0);
        ɵɵlistener("p-click", function PoNavbarItemNavigationComponent_Template_po_navbar_item_navigation_icon_p_click_0_listener($event) {
          return ctx.click.emit($event);
        });
        ɵɵelementEnd();
        ɵɵelementStart(1, "po-navbar-item-navigation-icon", 1);
        ɵɵlistener("p-click", function PoNavbarItemNavigationComponent_Template_po_navbar_item_navigation_icon_p_click_1_listener($event) {
          return ctx.click.emit($event);
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("p-disabled", ctx.disableLeft);
        ɵɵadvance();
        ɵɵproperty("p-disabled", ctx.disableRight);
      }
    },
    dependencies: [PoNavbarItemNavigationIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemNavigationComponent, [{
    type: Component,
    args: [{
      selector: "po-navbar-item-navigation",
      standalone: false,
      template: '<po-navbar-item-navigation-icon\n  class="po-navbar-item-navigation-icon"\n  p-icon="left"\n  [p-disabled]="disableLeft"\n  (p-click)="click.emit($event)"\n>\n</po-navbar-item-navigation-icon>\n\n<po-navbar-item-navigation-icon\n  class="po-navbar-item-navigation-icon"\n  p-icon="right"\n  [p-disabled]="disableRight"\n  (p-click)="click.emit($event)"\n>\n</po-navbar-item-navigation-icon>\n'
    }]
  }], null, {
    disableLeft: [{
      type: Input,
      args: ["p-disable-left"]
    }],
    disableRight: [{
      type: Input,
      args: ["p-disable-right"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarItemNavigationComponent, {
    className: "PoNavbarItemNavigationComponent",
    filePath: "lib/components/po-navbar/po-navbar-item-navigation/po-navbar-item-navigation.component.ts",
    lineNumber: 8
  });
})();
var PoNavbarItemNavigationModule = class _PoNavbarItemNavigationModule {
  static ɵfac = function PoNavbarItemNavigationModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarItemNavigationModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoNavbarItemNavigationModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, RouterModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemNavigationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, PoIconModule],
      declarations: [PoNavbarItemNavigationComponent, PoNavbarItemNavigationIconComponent],
      exports: [PoNavbarItemNavigationComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoNavbarItemNavigationModule, {
    declarations: [PoNavbarItemNavigationComponent, PoNavbarItemNavigationIconComponent],
    imports: [CommonModule, RouterModule, PoIconModule],
    exports: [PoNavbarItemNavigationComponent]
  });
})();
function PoNavbarItemComponent_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 3);
    ɵɵlistener("click", function PoNavbarItemComponent_a_1_Template_a_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.itemClick());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-clickable", ctx_r1.clickable);
    ɵɵproperty("href", ctx_r1.link, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.label, " ");
  }
}
function PoNavbarItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 4);
    ɵɵlistener("click", function PoNavbarItemComponent_a_2_Template_a_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.itemClick(ctx_r1.label, ctx_r1.link));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-clickable", ctx_r1.clickable);
    ɵɵproperty("routerLink", ctx_r1.link);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.label, " ");
  }
}
var PoNavbarItemComponent = class _PoNavbarItemComponent {
  action;
  clickable;
  label;
  link;
  click = new EventEmitter();
  get type() {
    return isExternalLink(this.link) ? "externalLink" : "internalLink";
  }
  itemClick(label, link) {
    if (this.action) {
      this.action({
        label,
        link
      });
    }
    this.click.emit();
  }
  static ɵfac = function PoNavbarItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarItemComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoNavbarItemComponent,
    selectors: [["po-navbar-item"]],
    inputs: {
      action: [0, "p-action", "action"],
      clickable: [0, "p-clickable", "clickable"],
      label: [0, "p-label", "label"],
      link: [0, "p-link", "link"]
    },
    outputs: {
      click: "p-click"
    },
    standalone: false,
    decls: 3,
    vars: 3,
    consts: [[3, "ngSwitch"], ["class", "po-navbar-item-link", "target", "_blank", 3, "po-clickable", "href", "click", 4, "ngSwitchCase"], ["class", "po-navbar-item-link", 3, "po-clickable", "routerLink", "click", 4, "ngSwitchCase"], ["target", "_blank", 1, "po-navbar-item-link", 3, "click", "href"], [1, "po-navbar-item-link", 3, "click", "routerLink"]],
    template: function PoNavbarItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0, 0);
        ɵɵtemplate(1, PoNavbarItemComponent_a_1_Template, 2, 4, "a", 1)(2, PoNavbarItemComponent_a_2_Template, 2, 4, "a", 2);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngSwitch", ctx.type);
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", "externalLink");
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", "internalLink");
      }
    },
    dependencies: [NgSwitch, NgSwitchCase, RouterLink],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemComponent, [{
    type: Component,
    args: [{
      selector: "po-navbar-item",
      standalone: false,
      template: `<ng-container [ngSwitch]="type">
  <a
    *ngSwitchCase="'externalLink'"
    class="po-navbar-item-link"
    [class.po-clickable]="clickable"
    [href]="link"
    target="_blank"
    (click)="itemClick()"
  >
    {{ label }}
  </a>

  <a
    *ngSwitchCase="'internalLink'"
    class="po-navbar-item-link"
    [class.po-clickable]="clickable"
    [routerLink]="link"
    (click)="itemClick(label, link)"
  >
    {{ label }}
  </a>
</ng-container>
`
    }]
  }], null, {
    action: [{
      type: Input,
      args: ["p-action"]
    }],
    clickable: [{
      type: Input,
      args: ["p-clickable"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    link: [{
      type: Input,
      args: ["p-link"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarItemComponent, {
    className: "PoNavbarItemComponent",
    filePath: "lib/components/po-navbar/po-navbar-items/po-navbar-item/po-navbar-item.component.ts",
    lineNumber: 12
  });
})();
var _c0$m = ["navbarItemsContainer"];
function PoNavbarItemsComponent_li_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 3);
    ɵɵelement(1, "po-navbar-item", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-navbar-item-selected", ctx_r1.selectedItem === item_r1);
    ɵɵadvance();
    ɵɵproperty("p-action", item_r1.action)("p-clickable", ctx_r1.selectedItem !== item_r1)("p-label", item_r1.label)("p-link", item_r1.link);
  }
}
var PoNavbarItemsComponent = class _PoNavbarItemsComponent {
  router;
  navbarItemsContainer;
  allNavbarItems;
  items;
  selectedItem;
  routeSubscription;
  constructor(router) {
    this.router = router;
  }
  ngOnDestroy() {
    this.routeSubscription.unsubscribe();
  }
  ngOnInit() {
    this.subscribeToRoute();
  }
  checkActiveItemByUrl(urlRouter) {
    const urlArray = urlRouter.split("/");
    let counter = urlArray.length;
    while (counter >= 0) {
      const url = urlArray.slice(0, counter).join("/");
      this.selectedItem = this.items.find((item) => item.link === url);
      if (this.selectedItem) {
        break;
      }
      counter--;
    }
  }
  checkRouterChildrenFragments() {
    const childrenPrimary = this.router.parseUrl(this.router.url).root.children["primary"];
    return childrenPrimary ? `/${childrenPrimary.segments.map((it) => it.path).join("/")}` : "/";
  }
  subscribeToRoute() {
    this.routeSubscription = this.router.events.subscribe((val) => {
      if (val instanceof NavigationEnd || val instanceof NavigationCancel) {
        const urlRouter = this.checkRouterChildrenFragments();
        this.checkActiveItemByUrl(urlRouter);
      }
    });
  }
  static ɵfac = function PoNavbarItemsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarItemsComponent)(ɵɵdirectiveInject(Router));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoNavbarItemsComponent,
    selectors: [["po-navbar-items"]],
    viewQuery: function PoNavbarItemsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$m, 7, ElementRef);
        ɵɵviewQuery(PoNavbarItemComponent, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navbarItemsContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allNavbarItems = _t);
      }
    },
    inputs: {
      items: [0, "p-items", "items"]
    },
    standalone: false,
    decls: 4,
    vars: 1,
    consts: [["navbarItemsContainer", ""], [1, "po-navbar-items-container"], ["class", "po-navbar-item", 3, "po-navbar-item-selected", 4, "ngFor", "ngForOf"], [1, "po-navbar-item"], [3, "p-action", "p-clickable", "p-label", "p-link"]],
    template: function PoNavbarItemsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "nav")(1, "ul", 1, 0);
        ɵɵtemplate(3, PoNavbarItemsComponent_li_3_Template, 2, 6, "li", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ctx.items);
      }
    },
    dependencies: [NgForOf, PoNavbarItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemsComponent, [{
    type: Component,
    args: [{
      selector: "po-navbar-items",
      standalone: false,
      template: '<nav>\n  <ul class="po-navbar-items-container" #navbarItemsContainer>\n    <li *ngFor="let item of items" class="po-navbar-item" [class.po-navbar-item-selected]="selectedItem === item">\n      <po-navbar-item\n        [p-action]="item.action"\n        [p-clickable]="selectedItem !== item"\n        [p-label]="item.label"\n        [p-link]="item.link"\n      >\n      </po-navbar-item>\n    </li>\n  </ul>\n</nav>\n'
    }]
  }], () => [{
    type: Router
  }], {
    navbarItemsContainer: [{
      type: ViewChild,
      args: ["navbarItemsContainer", {
        read: ElementRef,
        static: true
      }]
    }],
    allNavbarItems: [{
      type: ViewChildren,
      args: [PoNavbarItemComponent, {
        read: ElementRef
      }]
    }],
    items: [{
      type: Input,
      args: ["p-items"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarItemsComponent, {
    className: "PoNavbarItemsComponent",
    filePath: "lib/components/po-navbar/po-navbar-items/po-navbar-items.component.ts",
    lineNumber: 14
  });
})();
var PoNavbarItemsModule = class _PoNavbarItemsModule {
  static ɵfac = function PoNavbarItemsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarItemsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoNavbarItemsModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, RouterModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule],
      declarations: [PoNavbarItemComponent, PoNavbarItemsComponent],
      exports: [PoNavbarItemsComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoNavbarItemsModule, {
    declarations: [PoNavbarItemComponent, PoNavbarItemsComponent],
    imports: [CommonModule, RouterModule],
    exports: [PoNavbarItemsComponent]
  });
})();
function PoNavbarLogoComponent_po_logo_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-logo", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-logo", ctx_r0.logo)("p-logo-alt", ctx_r0.logoAlt);
  }
}
var PoNavbarLogoComponent = class _PoNavbarLogoComponent {
  logo;
  logoAlt;
  static ɵfac = function PoNavbarLogoComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarLogoComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoNavbarLogoComponent,
    selectors: [["po-navbar-logo"]],
    inputs: {
      logo: [0, "p-logo", "logo"],
      logoAlt: [0, "p-logo-alt", "logoAlt"]
    },
    standalone: false,
    decls: 1,
    vars: 1,
    consts: [["p-class", "po-navbar-logo-image", 3, "p-logo", "p-logo-alt", 4, "ngIf"], ["p-class", "po-navbar-logo-image", 3, "p-logo", "p-logo-alt"]],
    template: function PoNavbarLogoComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoNavbarLogoComponent_po_logo_0_Template, 1, 2, "po-logo", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.logo);
      }
    },
    dependencies: [NgIf, PoLogoComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarLogoComponent, [{
    type: Component,
    args: [{
      selector: "po-navbar-logo",
      standalone: false,
      template: '<po-logo *ngIf="logo" p-class="po-navbar-logo-image" [p-logo]="logo" [p-logo-alt]="logoAlt"></po-logo>\n'
    }]
  }], null, {
    logo: [{
      type: Input,
      args: ["p-logo"]
    }],
    logoAlt: [{
      type: Input,
      args: ["p-logo-alt"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarLogoComponent, {
    className: "PoNavbarLogoComponent",
    filePath: "lib/components/po-navbar/po-navbar-logo/po-navbar-logo.component.ts",
    lineNumber: 8
  });
})();
var poNavbarLiteralsDefault = {
  en: {
    navbarLinks: "Navbar links"
  },
  es: {
    navbarLinks: "Navbar links"
  },
  pt: {
    navbarLinks: "Navbar links"
  },
  ru: {
    navbarLinks: "Navbar связи"
  }
};
var PoNavbarBaseComponent = class _PoNavbarBaseComponent {
  // Menu que esta sendo exibido na pagina corrente.
  applicationMenu;
  _iconActions = [];
  _items = [];
  _literals;
  _logo;
  _shadow = false;
  language = poLocaleDefault;
  /**
   * @optional
   *
   * @description
   *
   * Define uma lista de ações apresentadas em ícones no lado direito do `po-navbar`.
   */
  set iconActions(value) {
    this._iconActions = Array.isArray(value) ? value : [];
  }
  get iconActions() {
    return this._iconActions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma lista de items do `po-navbar`.
   */
  set items(value) {
    this._items = Array.isArray(value) ? value : [];
  }
  get items() {
    return this._items;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com a literal usada na propriedade `p-literals`.
   *
   * Para customizar a literal, basta declarar um objeto do tipo `PoNavbarLiterals` conforme exemplo abaixo:
   *
   * ```
   *  const customLiterals: PoNavbarLiterals = {
   *    navbarLinks: 'Itens de navegação'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-navbar
   *   [p-literals]="customLiterals">
   * </po-navbar>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poNavbarLiteralsDefault[poLocaleDefault]), poNavbarLiteralsDefault[this.language]), value);
    } else {
      this._literals = poNavbarLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poNavbarLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a logo apresentada `po-navbar`.
   */
  set logo(value) {
    this._logo = value;
    if (this.applicationMenu) {
      this.validateMenuLogo();
    }
  }
  get logo() {
    return this._logo;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o texto alternativo para a logomarca.
   *
   * > **Importante**
   * > Caso esta propriedade não seja definida o texto padrão será "Logomarca início".
   *
   * @default `Logomarca início`
   */
  logoAlt;
  /**
   * @optional
   *
   * @description
   *
   * Aplica uma sombra na parte inferior do `po-navbar`.
   *
   * @default `false`
   */
  set shadow(value) {
    this._shadow = convertToBoolean(value);
  }
  get shadow() {
    return this._shadow;
  }
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoNavbarBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoNavbarBaseComponent,
    inputs: {
      iconActions: [0, "p-icon-actions", "iconActions"],
      items: [0, "p-items", "items"],
      literals: [0, "p-literals", "literals"],
      logo: [0, "p-logo", "logo"],
      logoAlt: [0, "p-logo-alt", "logoAlt"],
      shadow: [0, "p-shadow", "shadow"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    iconActions: [{
      type: Input,
      args: ["p-icon-actions"]
    }],
    items: [{
      type: Input,
      args: ["p-items"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    logo: [{
      type: Input,
      args: ["p-logo"]
    }],
    logoAlt: [{
      type: Input,
      args: ["p-logo-alt"]
    }],
    shadow: [{
      type: Input,
      args: ["p-shadow"]
    }]
  });
})();
var _c0$l = (a0) => ({
  "po-navbar-shadow": a0
});
var _c1$5 = (a0, a1) => ({
  "po-navbar-logo-menu": a0,
  "po-navbar-no-logo": a1
});
function PoNavbarComponent_po_navbar_item_navigation_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-navbar-item-navigation", 6);
    ɵɵlistener("p-click", function PoNavbarComponent_po_navbar_item_navigation_3_Template_po_navbar_item_navigation_p_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.navigateItems($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-disable-left", ctx_r1.navbarItemNavigationDisableLeft)("p-disable-right", ctx_r1.navbarItemNavigationDisableRight);
  }
}
function PoNavbarComponent_po_menu_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-menu", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-menus", ctx_r1.items);
  }
}
var poNavbarNavigationWidth = 88;
var poNavbarMenuMedia = 768;
var poNavbarMatchMedia = `(max-width: ${poNavbarMenuMedia}px)`;
var poNavbarTiming = "250ms ease";
var PoNavbarComponent = class _PoNavbarComponent extends PoNavbarBaseComponent {
  renderer;
  builder;
  changeDetector;
  menuGlobalService;
  navbarItemsElement;
  navbarItems;
  disableRight;
  showItemsNavigation = false;
  windowResizeListener;
  _menuComponent;
  isNavbarUpdateMenu = false;
  id = uuid();
  mediaQuery;
  offset = 0;
  player;
  menuItems;
  previousMenuComponentId;
  previousMenusItems = [];
  applicationMenuSubscription;
  menusSubscription;
  removedMenuSubscription;
  get navbarItemNavigationDisableLeft() {
    return this.offset === 0;
  }
  get navbarItemNavigationDisableRight() {
    return this.disableRight && this.offset !== 0;
  }
  set menuComponent(menu) {
    this._menuComponent = menu;
    this.previousMenuComponentId = menu?.id || this.previousMenuComponentId;
  }
  get isCollapsedMedia() {
    return window.innerWidth < poNavbarMenuMedia;
  }
  constructor(poLanguageService, renderer, builder, changeDetector, menuGlobalService) {
    super(poLanguageService);
    this.renderer = renderer;
    this.builder = builder;
    this.changeDetector = changeDetector;
    this.menuGlobalService = menuGlobalService;
    this.windowResizeListener = this.renderer.listen(window, "resize", this.displayItemsNavigation.bind(this));
  }
  ngOnInit() {
    this.menusSubscription = this.menuGlobalService.receiveMenus$.subscribe((newMenus) => {
      const previousMenusiIsNavbarLinks = this.previousMenusItems?.length === 1 && this.previousMenusItems[0].id === this.id;
      if (this.applicationMenu && this.isCollapsedMedia && this.isNavbarUpdateMenu && previousMenusiIsNavbarLinks) {
        this.isNavbarUpdateMenu = false;
        this.applicationMenu.menus = [{
          label: this.literals.navbarLinks,
          subItems: this.items,
          id: this.id
        }, ...newMenus];
      }
      this.isNavbarUpdateMenu = false;
      this.previousMenusItems = newMenus;
    });
    this.removedMenuSubscription = this.menuGlobalService.receiveRemovedApplicationMenu$.subscribe((removedMenuId) => {
      this.applicationMenu = this.applicationMenu && this.previousMenuComponentId === removedMenuId ? this.applicationMenu : void 0;
      this.changeDetector.detectChanges();
      if (!this.applicationMenu && this.mediaQuery) {
        this.mediaQuery.removeListener(this.onMediaQueryChange);
      }
    });
    this.applicationMenuSubscription = this.menuGlobalService.receiveApplicationMenu$.pipe(delay(100)).subscribe((newMenu) => {
      this.applicationMenu = this.previousMenuComponentId === newMenu.id ? void 0 : newMenu;
      this.changeDetector.detectChanges();
      if (this.applicationMenu) {
        this.initNavbarMenu();
      }
    });
  }
  ngAfterViewInit() {
    this.displayItemsNavigation();
  }
  ngOnDestroy() {
    if (this.mediaQuery) {
      this.mediaQuery.removeListener(this.onMediaQueryChange);
    }
    this.removedMenuSubscription?.unsubscribe();
    this.applicationMenuSubscription?.unsubscribe();
    this.menusSubscription?.unsubscribe();
  }
  navigateItems(orientation) {
    orientation === "left" ? this.navigateLeft() : this.navigateRight();
    this.animate(this.offset);
  }
  validateMenuLogo() {
    if (this.applicationMenu.logo && this.logo) {
      this.applicationMenu.logo = void 0;
      this.changeDetector.detectChanges();
    }
  }
  allNavbarItemsWidth() {
    return this.navbarItems.allNavbarItems.reduce((previous, current) => previous + current.nativeElement.offsetWidth, 0);
  }
  animate(offset) {
    const animation = this.buildTransitionAnimation(offset);
    this.player = animation.create(this.navbarItems.navbarItemsContainer.nativeElement);
    this.player.play();
  }
  buildTransitionAnimation(offset) {
    return this.builder.build([animate(poNavbarTiming, keyframes([style({
      transform: `translateX(${-offset}px)`
    })]))]);
  }
  changeNavbarMenuItems(isCollapsedMedia, navbarItems, label) {
    if (isCollapsedMedia) {
      this.applicationMenu.menus = [{
        label,
        subItems: navbarItems,
        id: this.id
      }, ...this.applicationMenu.menus];
    } else {
      this.applicationMenu.menus = this.applicationMenu.menus.filter((m) => m.id !== this.id);
    }
    this.isNavbarUpdateMenu = true;
    this.changeDetector.detectChanges();
  }
  calculateLeftNavigation() {
    let calculatedOffset;
    this.navbarItems.allNavbarItems.some((navbarItem) => {
      const navbarItemOffset = navbarItem.nativeElement.offsetLeft;
      const navbarItemWidth = navbarItem.nativeElement.offsetWidth;
      if (navbarItemOffset >= this.offset) {
        calculatedOffset = navbarItemOffset - (this.navbarItemsWidth() - navbarItemWidth);
        return true;
      }
    });
    return calculatedOffset;
  }
  calculateRightNavigation(itemBreakPoint) {
    let calculatedOffset;
    this.navbarItems.allNavbarItems.some((navbarItem) => {
      const offsetLeft = navbarItem.nativeElement.offsetLeft;
      const finalPosition = navbarItem.nativeElement.offsetWidth + offsetLeft;
      if (itemBreakPoint < finalPosition) {
        calculatedOffset = offsetLeft;
        return true;
      }
    });
    return calculatedOffset;
  }
  displayItemsNavigation() {
    this.showItemsNavigation = this.navbarItemsWidth() < this.allNavbarItemsWidth() + poNavbarNavigationWidth;
    this.changeDetector.detectChanges();
    if (this.offset !== 0) {
      this.setOffsetToZero();
      this.animate(this.offset);
    }
  }
  initNavbarMenu() {
    this.mediaQuery = window.matchMedia(poNavbarMatchMedia);
    if (this.isCollapsedMedia) {
      this.changeNavbarMenuItems(true, this.items, this.literals.navbarLinks);
    }
    this.validateMenuLogo();
    this.mediaQuery.addListener(this.onMediaQueryChange);
  }
  navbarItemsWidth() {
    return this.navbarItemsElement.nativeElement.offsetWidth;
  }
  navigateLeft() {
    this.disableRight = false;
    this.offset = this.calculateLeftNavigation();
    if (this.offset < 0) {
      this.setOffsetToZero();
    }
  }
  navigateRight() {
    const maxAllowedOffset = this.allNavbarItemsWidth() - this.navbarItemsWidth();
    const itemBreakPoint = this.offset + this.navbarItemsWidth();
    this.offset = this.calculateRightNavigation(itemBreakPoint);
    this.validateMaxOffset(maxAllowedOffset);
  }
  onMediaQueryChange = (changed) => {
    this.changeNavbarMenuItems(changed.matches, this.items, this.literals.navbarLinks);
  };
  setOffsetToZero() {
    this.offset = 0;
  }
  validateMaxOffset(maxAllowedOffset) {
    if (this.offset >= maxAllowedOffset) {
      this.offset = maxAllowedOffset;
      this.disableRight = true;
    }
  }
  static ɵfac = function PoNavbarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(AnimationBuilder), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoMenuGlobalService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoNavbarComponent,
    selectors: [["po-navbar"]],
    viewQuery: function PoNavbarComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoNavbarItemsComponent, 7, ElementRef);
        ɵɵviewQuery(PoNavbarItemsComponent, 7);
        ɵɵviewQuery(PoMenuComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navbarItemsElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navbarItems = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuComponent = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 12,
    consts: [[1, "po-navbar", 3, "ngClass"], [1, "po-navbar-logo", 3, "ngClass", "p-logo"], [1, "po-navbar-items", 3, "p-items"], ["class", "po-navbar-item-navigation", 3, "p-disable-left", "p-disable-right", "p-click", 4, "ngIf"], [1, "po-navbar-actions", 3, "p-icon-actions"], [3, "p-menus", 4, "ngIf"], [1, "po-navbar-item-navigation", 3, "p-click", "p-disable-left", "p-disable-right"], [3, "p-menus"]],
    template: function PoNavbarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "header", 0);
        ɵɵelement(1, "po-navbar-logo", 1)(2, "po-navbar-items", 2);
        ɵɵtemplate(3, PoNavbarComponent_po_navbar_item_navigation_3_Template, 1, 2, "po-navbar-item-navigation", 3);
        ɵɵelement(4, "po-navbar-actions", 4);
        ɵɵelementEnd();
        ɵɵtemplate(5, PoNavbarComponent_po_menu_5_Template, 1, 1, "po-menu", 5);
      }
      if (rf & 2) {
        ɵɵproperty("ngClass", ɵɵpureFunction1(7, _c0$l, ctx.shadow));
        ɵɵadvance();
        ɵɵproperty("ngClass", ɵɵpureFunction2(9, _c1$5, !!ctx.applicationMenu, !ctx.logo))("p-logo", ctx.logo);
        ɵɵadvance();
        ɵɵproperty("p-items", ctx.items);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showItemsNavigation);
        ɵɵadvance();
        ɵɵproperty("p-icon-actions", ctx.iconActions);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.applicationMenu);
      }
    },
    dependencies: [NgClass, NgIf, PoMenuComponent, PoNavbarActionsComponent, PoNavbarItemNavigationComponent, PoNavbarItemsComponent, PoNavbarLogoComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarComponent, [{
    type: Component,
    args: [{
      selector: "po-navbar",
      standalone: false,
      template: `<header class="po-navbar" [ngClass]="{ 'po-navbar-shadow': shadow }">
  <po-navbar-logo
    class="po-navbar-logo"
    [ngClass]="{ 'po-navbar-logo-menu': !!applicationMenu, 'po-navbar-no-logo': !logo }"
    [p-logo]="logo"
  >
  </po-navbar-logo>

  <po-navbar-items class="po-navbar-items" [p-items]="items"> </po-navbar-items>

  <po-navbar-item-navigation
    *ngIf="showItemsNavigation"
    class="po-navbar-item-navigation"
    [p-disable-left]="navbarItemNavigationDisableLeft"
    [p-disable-right]="navbarItemNavigationDisableRight"
    (p-click)="navigateItems($event)"
  >
  </po-navbar-item-navigation>

  <po-navbar-actions class="po-navbar-actions" [p-icon-actions]="iconActions"> </po-navbar-actions>
</header>

<po-menu *ngIf="!applicationMenu" [p-menus]="items"> </po-menu>
`
    }]
  }], () => [{
    type: PoLanguageService
  }, {
    type: Renderer2
  }, {
    type: AnimationBuilder
  }, {
    type: ChangeDetectorRef
  }, {
    type: PoMenuGlobalService
  }], {
    navbarItemsElement: [{
      type: ViewChild,
      args: [PoNavbarItemsComponent, {
        read: ElementRef,
        static: true
      }]
    }],
    navbarItems: [{
      type: ViewChild,
      args: [PoNavbarItemsComponent, {
        static: true
      }]
    }],
    menuComponent: [{
      type: ViewChild,
      args: [PoMenuComponent]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarComponent, {
    className: "PoNavbarComponent",
    filePath: "lib/components/po-navbar/po-navbar.component.ts",
    lineNumber: 39
  });
})();
var PoNavbarModule = class _PoNavbarModule {
  static ɵfac = function PoNavbarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoNavbarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoNavbarModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoIconModule, PoLogoModule, PoMenuModule, PoNavbarActionsModule, PoNavbarItemNavigationModule, PoNavbarItemsModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoIconModule, PoLogoModule, PoMenuModule, PoNavbarActionsModule, PoNavbarItemNavigationModule, PoNavbarItemsModule],
      declarations: [PoNavbarComponent, PoNavbarLogoComponent],
      exports: [PoNavbarComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoNavbarModule, {
    declarations: [PoNavbarComponent, PoNavbarLogoComponent],
    imports: [CommonModule, PoIconModule, PoLogoModule, PoMenuModule, PoNavbarActionsModule, PoNavbarItemNavigationModule, PoNavbarItemsModule],
    exports: [PoNavbarComponent]
  });
})();
var PoPageContentBaseComponent = class {
  resizeListener;
};
var _c0$k = ["*"];
var PoPageContentComponent = class _PoPageContentComponent extends PoPageContentBaseComponent {
  renderer;
  contentOpacity = 0;
  height = "90%";
  overflowY = "none";
  constructor(renderer) {
    super();
    this.renderer = renderer;
    this.initializeListeners();
  }
  ngAfterViewInit() {
    this.recalculateHeaderSize();
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  recalculateHeaderSize() {
    setTimeout(() => {
      const pageHeaderElement = document.querySelector("div.po-page-header");
      this.setHeightContent(pageHeaderElement);
      this.contentOpacity = 1;
    });
  }
  setHeightContent(poPageHeader) {
    const bodyHeight = document.body.clientHeight;
    const pageHeaderHeight = poPageHeader ? poPageHeader.offsetTop + poPageHeader.offsetHeight : 0;
    const newHeight = bodyHeight - pageHeaderHeight;
    this.height = `${newHeight}px`;
  }
  initializeListeners() {
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.recalculateHeaderSize();
    });
  }
  removeListeners() {
    this.resizeListener();
  }
  static ɵfac = function PoPageContentComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageContentComponent)(ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPageContentComponent,
    selectors: [["po-page-content"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0$k,
    decls: 2,
    vars: 6,
    consts: [[1, "po-page-content"]],
    template: function PoPageContentComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0);
        ɵɵprojection(1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵstyleProp("height", ctx.height)("opacity", ctx.contentOpacity)("overflow-y", ctx.overflowY);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageContentComponent, [{
    type: Component,
    args: [{
      selector: "po-page-content",
      standalone: false,
      template: '<div class="po-page-content" [style.height]="height" [style.opacity]="contentOpacity" [style.overflow-y]="overflowY">\n  <ng-content></ng-content>\n</div>\n'
    }]
  }], () => [{
    type: Renderer2
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageContentComponent, {
    className: "PoPageContentComponent",
    filePath: "lib/components/po-page/po-page-content/po-page-content.component.ts",
    lineNumber: 15
  });
})();
var poPageDefaultLiteralsDefault = {
  en: {
    otherActions: "Other actions"
  },
  es: {
    otherActions: "Otras acciones"
  },
  pt: {
    otherActions: "Outras ações"
  },
  ru: {
    otherActions: "Другие действия"
  }
};
var PoPageDefaultBaseComponent = class _PoPageDefaultBaseComponent {
  poPageContent;
  /** Objeto com propriedades do breadcrumb. */
  breadcrumb;
  visibleActions = [];
  language;
  _actions = [];
  _literals;
  _title;
  /**
   * @optional
   *
   * @description
   *
   * Nesta propriedade deve ser definido um array de objetos que implementam a interface `PoPageAction`.
   */
  set actions(actions) {
    this._actions = Array.isArray(actions) ? actions : [];
    this.visibleActions = this.getVisibleActions();
    this.setDropdownActions();
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-page-default`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoPageDefaultLiterals = {
   *    otherActions: 'Mais ações'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoPageDefaultLiterals = {
   *    otherActions: 'Ações da página'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-page-default
   *   [p-literals]="customLiterals">
   * </po-page-default>
   * ```
   *
   * > O valor padrão será traduzido de acordo com o idioma configurado no [`PoI18nService`](/documentation/po-i18n) ou *browser*.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poPageDefaultLiteralsDefault[poLocaleDefault]), poPageDefaultLiteralsDefault[this.language]), value);
    } else {
      this._literals = poPageDefaultLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poPageDefaultLiteralsDefault[this.language];
  }
  /** Título da página. */
  set title(title) {
    this._title = title;
    setTimeout(() => this.poPageContent.recalculateHeaderSize());
  }
  get title() {
    return this._title;
  }
  /**
   * @optional
   *
   * @description
   *
   * Subtitulo do Header da página
   */
  subtitle;
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoPageDefaultBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageDefaultBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoPageDefaultBaseComponent,
    viewQuery: function PoPageDefaultBaseComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoPageContentComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPageContent = _t.first);
      }
    },
    inputs: {
      breadcrumb: [0, "p-breadcrumb", "breadcrumb"],
      actions: [0, "p-actions", "actions"],
      literals: [0, "p-literals", "literals"],
      title: [0, "p-title", "title"],
      subtitle: [0, "p-subtitle", "subtitle"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageDefaultBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    poPageContent: [{
      type: ViewChild,
      args: [PoPageContentComponent, {
        static: true
      }]
    }],
    breadcrumb: [{
      type: Input,
      args: ["p-breadcrumb"]
    }],
    actions: [{
      type: Input,
      args: ["p-actions"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    subtitle: [{
      type: Input,
      args: ["p-subtitle"]
    }]
  });
})();
var PoPageBaseComponent = class {
};
var _c0$j = ["*"];
var PoPageComponent = class _PoPageComponent extends PoPageBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoPageComponent_BaseFactory;
    return function PoPageComponent_Factory(__ngFactoryType__) {
      return (ɵPoPageComponent_BaseFactory || (ɵPoPageComponent_BaseFactory = ɵɵgetInheritedFactory(_PoPageComponent)))(__ngFactoryType__ || _PoPageComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPageComponent,
    selectors: [["po-page"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0$j,
    decls: 2,
    vars: 0,
    consts: [[1, "po-page"]],
    template: function PoPageComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0);
        ɵɵprojection(1);
        ɵɵelementEnd();
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageComponent, [{
    type: Component,
    args: [{
      selector: "po-page",
      standalone: false,
      template: '<div class="po-page">\n  <ng-content> </ng-content>\n</div>\n'
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageComponent, {
    className: "PoPageComponent",
    filePath: "lib/components/po-page/po-page.component.ts",
    lineNumber: 15
  });
})();
var PoPageHeaderBaseComponent = class _PoPageHeaderBaseComponent {
  /** Título da página. */
  title;
  /** Subtítulo da página. */
  subtitle;
  _breadcrumb;
  /** Objeto com propriedades do breadcrumb. */
  set breadcrumb(value) {
    this._breadcrumb = value;
  }
  get breadcrumb() {
    return this._breadcrumb;
  }
  static ɵfac = function PoPageHeaderBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageHeaderBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoPageHeaderBaseComponent,
    inputs: {
      title: [0, "p-title", "title"],
      subtitle: [0, "p-subtitle", "subtitle"],
      breadcrumb: [0, "p-breadcrumb", "breadcrumb"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageHeaderBaseComponent, [{
    type: Directive
  }], null, {
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    subtitle: [{
      type: Input,
      args: ["p-subtitle"]
    }],
    breadcrumb: [{
      type: Input,
      args: ["p-breadcrumb"]
    }]
  });
})();
var _c0$i = ["*"];
function PoPageHeaderComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵelement(1, "po-breadcrumb", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-favorite-service", ctx_r0.breadcrumb.favorite)("p-items", ctx_r0.breadcrumb.items)("p-params-service", ctx_r0.breadcrumb.params);
  }
}
function PoPageHeaderComponent_div_3_h1_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "h1", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.title, " ");
  }
}
function PoPageHeaderComponent_div_3_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.subtitle, " ");
  }
}
function PoPageHeaderComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, PoPageHeaderComponent_div_3_h1_1_Template, 2, 1, "h1", 7)(2, PoPageHeaderComponent_div_3_div_2_Template, 2, 1, "div", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.subtitle);
  }
}
var PoPageHeaderComponent = class _PoPageHeaderComponent extends PoPageHeaderBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoPageHeaderComponent_BaseFactory;
    return function PoPageHeaderComponent_Factory(__ngFactoryType__) {
      return (ɵPoPageHeaderComponent_BaseFactory || (ɵPoPageHeaderComponent_BaseFactory = ɵɵgetInheritedFactory(_PoPageHeaderComponent)))(__ngFactoryType__ || _PoPageHeaderComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPageHeaderComponent,
    selectors: [["po-page-header"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0$i,
    decls: 5,
    vars: 2,
    consts: [[1, "po-page-header"], ["class", "po-page-header-breadcrumb", 4, "ngIf"], [1, "po-page-header-container"], ["class", "po-page-header-title-container", 4, "ngIf"], [1, "po-page-header-breadcrumb"], [3, "p-favorite-service", "p-items", "p-params-service"], [1, "po-page-header-title-container"], ["class", "po-page-header-title", 4, "ngIf"], ["class", "po-page-header-subtitle", 4, "ngIf"], [1, "po-page-header-title"], [1, "po-page-header-subtitle"]],
    template: function PoPageHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoPageHeaderComponent_div_1_Template, 2, 3, "div", 1);
        ɵɵelementStart(2, "div", 2);
        ɵɵtemplate(3, PoPageHeaderComponent_div_3_Template, 3, 2, "div", 3);
        ɵɵprojection(4);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.breadcrumb && ctx.breadcrumb.items.length);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.title || ctx.subtitle);
      }
    },
    dependencies: [NgIf, PoBreadcrumbComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageHeaderComponent, [{
    type: Component,
    args: [{
      selector: "po-page-header",
      standalone: false,
      template: '<div class="po-page-header">\n  <!-- Breadcrumb -->\n  <div class="po-page-header-breadcrumb" *ngIf="breadcrumb && breadcrumb.items.length">\n    <po-breadcrumb\n      [p-favorite-service]="breadcrumb.favorite"\n      [p-items]="breadcrumb.items"\n      [p-params-service]="breadcrumb.params"\n    >\n    </po-breadcrumb>\n  </div>\n\n  <div class="po-page-header-container">\n    <!-- Titulo e SubTitulo-->\n    <div class="po-page-header-title-container" *ngIf="title || subtitle">\n      <h1 class="po-page-header-title" *ngIf="title">\n        {{ title }}\n      </h1>\n      <div class="po-page-header-subtitle" *ngIf="subtitle">\n        {{ subtitle }}\n      </div>\n    </div>\n\n    <!-- Operações -->\n    <ng-content></ng-content>\n  </div>\n</div>\n'
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageHeaderComponent, {
    className: "PoPageHeaderComponent",
    filePath: "lib/components/po-page/po-page-header/po-page-header.component.ts",
    lineNumber: 14
  });
})();
var _c0$h = ["*"];
function PoPageDefaultComponent_po_page_header_1_po_dropdown_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-dropdown", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("p-label", ctx_r0.literals.otherActions)("p-actions", ctx_r0.dropdownActions);
  }
}
function PoPageDefaultComponent_po_page_header_1_po_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 8);
    ɵɵlistener("p-click", function PoPageDefaultComponent_po_page_header_1_po_button_3_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.callAction(ctx_r0.visibleActions[2]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("p-danger", ctx_r0.visibleActions[2].type === "danger")("p-disabled", ctx_r0.actionIsDisabled(ctx_r0.visibleActions[2]))("p-label", ctx_r0.visibleActions[2].label);
  }
}
function PoPageDefaultComponent_po_page_header_1_po_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 9);
    ɵɵlistener("p-click", function PoPageDefaultComponent_po_page_header_1_po_button_4_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.callAction(ctx_r0.visibleActions[1]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("p-disabled", ctx_r0.actionIsDisabled(ctx_r0.visibleActions[1]))("p-label", ctx_r0.visibleActions[1].label)("p-danger", ctx_r0.visibleActions[1].type === "danger");
  }
}
function PoPageDefaultComponent_po_page_header_1_po_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 10);
    ɵɵlistener("p-click", function PoPageDefaultComponent_po_page_header_1_po_button_5_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.callAction(ctx_r0.visibleActions[0]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("p-danger", ctx_r0.visibleActions[0].type === "danger")("p-disabled", ctx_r0.actionIsDisabled(ctx_r0.visibleActions[0]))("p-icon", ctx_r0.visibleActions[0].icon)("p-label", ctx_r0.visibleActions[0].label);
  }
}
function PoPageDefaultComponent_po_page_header_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-page-header", 1)(1, "div", 2);
    ɵɵtemplate(2, PoPageDefaultComponent_po_page_header_1_po_dropdown_2_Template, 1, 2, "po-dropdown", 3)(3, PoPageDefaultComponent_po_page_header_1_po_button_3_Template, 1, 3, "po-button", 4)(4, PoPageDefaultComponent_po_page_header_1_po_button_4_Template, 1, 3, "po-button", 5)(5, PoPageDefaultComponent_po_page_header_1_po_button_5_Template, 1, 4, "po-button", 6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-breadcrumb", ctx_r0.breadcrumb)("p-title", ctx_r0.title)("p-subtitle", ctx_r0.subtitle);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.visibleActions.length > ctx_r0.limitPrimaryActions);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.visibleActions.length === 3 && ctx_r0.visibleActions[2] && !ctx_r0.isMobile);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.visibleActions[1] && (ctx_r0.visibleActions.length === 2 || !ctx_r0.isMobile));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.visibleActions[0]);
  }
}
var PoPageDefaultComponent = class _PoPageDefaultComponent extends PoPageDefaultBaseComponent {
  renderer;
  router;
  limitPrimaryActions = 3;
  dropdownActions;
  isMobile;
  maxWidthMobile = 480;
  constructor(viewRef, languageService, renderer, router) {
    super(languageService);
    this.renderer = renderer;
    this.router = router;
  }
  ngAfterContentInit() {
    this.setIsMobile();
    this.setDropdownActions();
    this.renderer.listen("window", "resize", (event) => {
      this.onResize(event);
    });
  }
  ngOnChanges(changes) {
    this.setDropdownActions();
  }
  actionIsDisabled(action) {
    return isTypeof(action.disabled, "function") ? action.disabled(action) : action.disabled;
  }
  actionIsVisible(action) {
    return isTypeof(action.visible, "function") ? action.visible(action) : action.visible;
  }
  callAction(item) {
    if (item.url) {
      isExternalLink(item.url) ? openExternalLink(item.url) : this.router.navigate([item.url]);
    } else if (item.action) {
      item.action();
    }
  }
  hasPageHeader() {
    this.visibleActions = this.getVisibleActions();
    this.setDropdownActions();
    return !!(this.title || this.visibleActions && this.visibleActions.length || this.breadcrumb && this.breadcrumb.items.length);
  }
  setDropdownActions() {
    if (this.visibleActions.length > this.limitPrimaryActions) {
      this.dropdownActions = this.visibleActions.slice(this.limitPrimaryActions - 1);
    }
  }
  getVisibleActions() {
    return this.actions.filter((action) => this.actionIsVisible(action) !== false);
  }
  onResize(event) {
    const width = event.target.innerWidth;
    if (width < this.maxWidthMobile) {
      this.isMobile = true;
      this.limitPrimaryActions = 2;
      this.setDropdownActions();
    } else {
      this.isMobile = false;
      this.limitPrimaryActions = 3;
      this.setDropdownActions();
    }
  }
  setIsMobile() {
    if (window.innerWidth < this.maxWidthMobile) {
      this.isMobile = true;
      this.limitPrimaryActions = 2;
    }
  }
  static ɵfac = function PoPageDefaultComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageDefaultComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Router));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPageDefaultComponent,
    selectors: [["po-page-default"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    ngContentSelectors: _c0$h,
    decls: 4,
    vars: 1,
    consts: [[3, "p-breadcrumb", "p-title", "p-subtitle", 4, "ngIf"], [3, "p-breadcrumb", "p-title", "p-subtitle"], [1, "po-page-header-actions"], [3, "p-label", "p-actions", 4, "ngIf"], [3, "p-danger", "p-disabled", "p-label", "p-click", 4, "ngIf"], [3, "p-disabled", "p-label", "p-danger", "p-click", 4, "ngIf"], ["p-kind", "primary", 3, "p-danger", "p-disabled", "p-icon", "p-label", "p-click", 4, "ngIf"], [3, "p-label", "p-actions"], [3, "p-click", "p-danger", "p-disabled", "p-label"], [3, "p-click", "p-disabled", "p-label", "p-danger"], ["p-kind", "primary", 3, "p-click", "p-danger", "p-disabled", "p-icon", "p-label"]],
    template: function PoPageDefaultComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "po-page");
        ɵɵtemplate(1, PoPageDefaultComponent_po_page_header_1_Template, 6, 7, "po-page-header", 0);
        ɵɵelementStart(2, "po-page-content");
        ɵɵprojection(3);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasPageHeader());
      }
    },
    dependencies: [NgIf, PoButtonComponent, PoDropdownComponent, PoPageComponent, PoPageContentComponent, PoPageHeaderComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageDefaultComponent, [{
    type: Component,
    args: [{
      selector: "po-page-default",
      standalone: false,
      template: `<po-page>
  <!-- HEADER -->
  <po-page-header *ngIf="hasPageHeader()" [p-breadcrumb]="breadcrumb" [p-title]="title" [p-subtitle]="subtitle">
    <!-- OPERATIONS -->
    <div class="po-page-header-actions">
      <po-dropdown
        *ngIf="visibleActions.length > limitPrimaryActions"
        [p-label]="literals.otherActions"
        [p-actions]="dropdownActions"
      >
      </po-dropdown>

      <po-button
        *ngIf="visibleActions.length === 3 && visibleActions[2] && !isMobile"
        [p-danger]="visibleActions[2].type === 'danger'"
        [p-disabled]="actionIsDisabled(visibleActions[2])"
        [p-label]="visibleActions[2].label"
        (p-click)="callAction(visibleActions[2])"
      >
      </po-button>

      <po-button
        *ngIf="visibleActions[1] && (visibleActions.length === 2 || !isMobile)"
        [p-disabled]="actionIsDisabled(visibleActions[1])"
        [p-label]="visibleActions[1].label"
        [p-danger]="visibleActions[1].type === 'danger'"
        (p-click)="callAction(visibleActions[1])"
      >
      </po-button>

      <po-button
        *ngIf="visibleActions[0]"
        p-kind="primary"
        [p-danger]="visibleActions[0].type === 'danger'"
        [p-disabled]="actionIsDisabled(visibleActions[0])"
        [p-icon]="visibleActions[0].icon"
        [p-label]="visibleActions[0].label"
        (p-click)="callAction(visibleActions[0])"
      >
      </po-button>
    </div>
  </po-page-header>

  <!-- CONTENT -->
  <po-page-content>
    <ng-content></ng-content>
  </po-page-content>
</po-page>
`
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: PoLanguageService
  }, {
    type: Renderer2
  }, {
    type: Router
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageDefaultComponent, {
    className: "PoPageDefaultComponent",
    filePath: "lib/components/po-page/po-page-default/po-page-default.component.ts",
    lineNumber: 37
  });
})();
var poPageDetailLiteralsDefault = {
  en: {
    back: "Back",
    edit: "Edit",
    remove: "Remove"
  },
  es: {
    back: "Volver",
    edit: "Editar",
    remove: "Eliminar"
  },
  pt: {
    back: "Voltar",
    edit: "Editar",
    remove: "Remover"
  },
  ru: {
    back: "возвращение",
    edit: "редактировать",
    remove: "удаление"
  }
};
var PoPageDetailBaseComponent = class _PoPageDetailBaseComponent {
  poPageContent;
  /** Objeto com propriedades do breadcrumb. */
  breadcrumb;
  /**
   * Evento que será disparado ao clicar no botão de "Voltar".
   *
   * ```
   * <po-page-detail (p-back)="myBackFunction()">
   * </po-page-detail>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Voltar" não será exibido.
   */
  back = new EventEmitter();
  /**
   * Evento que será disparado ao clicar no botão de "Editar".
   *
   * ```
   * <po-page-detail (p-edit)="myEditFunction()">
   * </po-page-detail>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Editar" não será exibido.
   */
  edit = new EventEmitter();
  /**
   * Evento que será disparado ao clicar no botão de "Remover".
   *
   * ```
   * <po-page-detail (p-remove)="myRemoveFunction()">
   * </po-page-detail>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Remover" não será exibido.
   */
  remove = new EventEmitter();
  _literals;
  _title;
  language;
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-page-detail`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoPageDetailLiterals = {
   *    edit: 'Edição',
   *    remove: 'Exclusão',
   *    back: 'Menu'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoPageDetailLiterals = {
   *    remove: 'Excluir registro permanentemente'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-page-detail
   *   [p-literals]="customLiterals">
   * </po-page-detail>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poPageDetailLiteralsDefault[poLocaleDefault]), poPageDetailLiteralsDefault[this.language]), value);
    } else {
      this._literals = poPageDetailLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poPageDetailLiteralsDefault[this.language];
  }
  /** Título da página. */
  set title(title) {
    this._title = title;
    setTimeout(() => this.poPageContent.recalculateHeaderSize());
  }
  get title() {
    return this._title;
  }
  /**
   * @optional
   *
   * @description
   *
   * Subtitulo do Header da página
   */
  subtitle;
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoPageDetailBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageDetailBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoPageDetailBaseComponent,
    viewQuery: function PoPageDetailBaseComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoPageContentComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPageContent = _t.first);
      }
    },
    inputs: {
      breadcrumb: [0, "p-breadcrumb", "breadcrumb"],
      literals: [0, "p-literals", "literals"],
      title: [0, "p-title", "title"],
      subtitle: [0, "p-subtitle", "subtitle"]
    },
    outputs: {
      back: "p-back",
      edit: "p-edit",
      remove: "p-remove"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageDetailBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    poPageContent: [{
      type: ViewChild,
      args: [PoPageContentComponent, {
        static: true
      }]
    }],
    breadcrumb: [{
      type: Input,
      args: ["p-breadcrumb"]
    }],
    back: [{
      type: Output,
      args: ["p-back"]
    }],
    edit: [{
      type: Output,
      args: ["p-edit"]
    }],
    remove: [{
      type: Output,
      args: ["p-remove"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    subtitle: [{
      type: Input,
      args: ["p-subtitle"]
    }]
  });
})();
var _c0$g = ["*"];
function PoPageDetailComponent_po_page_header_1_div_1_po_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 7);
    ɵɵlistener("p-click", function PoPageDetailComponent_po_page_header_1_div_1_po_button_1_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.back.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-icon", ctx_r1.hasEditOrRemoveFn("icon"))("p-label", ctx_r1.literals.back)("p-kind", ctx_r1.hasEditOrRemoveFn("type"));
  }
}
function PoPageDetailComponent_po_page_header_1_div_1_po_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 8);
    ɵɵlistener("p-click", function PoPageDetailComponent_po_page_header_1_div_1_po_button_2_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.remove.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-icon", ctx_r1.hasEditFn("icon"))("p-label", ctx_r1.literals.remove)("p-kind", ctx_r1.hasEditFn("type"));
  }
}
function PoPageDetailComponent_po_page_header_1_div_1_po_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 9);
    ɵɵlistener("p-click", function PoPageDetailComponent_po_page_header_1_div_1_po_button_3_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.edit.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-label", ctx_r1.literals.edit);
  }
}
function PoPageDetailComponent_po_page_header_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtemplate(1, PoPageDetailComponent_po_page_header_1_div_1_po_button_1_Template, 1, 3, "po-button", 4)(2, PoPageDetailComponent_po_page_header_1_div_1_po_button_2_Template, 1, 3, "po-button", 5)(3, PoPageDetailComponent_po_page_header_1_div_1_po_button_3_Template, 1, 1, "po-button", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("back"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("remove"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("edit"));
  }
}
function PoPageDetailComponent_po_page_header_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-page-header", 1);
    ɵɵtemplate(1, PoPageDetailComponent_po_page_header_1_div_1_Template, 4, 3, "div", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-breadcrumb", ctx_r1.breadcrumb)("p-title", ctx_r1.title)("p-subtitle", ctx_r1.subtitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasAnyAction());
  }
}
var PoPageDetailComponent = class _PoPageDetailComponent extends PoPageDetailBaseComponent {
  hasAnyAction() {
    return this.hasEvent("back") || this.hasEvent("edit") || this.hasEvent("remove");
  }
  hasEditFn(property) {
    if (property === "icon") {
      return this.hasEvent("edit") ? "" : "ICON_DELETE";
    } else if (property === "type") {
      return this.hasEvent("edit") ? "secondary" : "primary";
    } else {
      return "";
    }
  }
  hasEditOrRemoveFn(property) {
    if (property === "icon") {
      return this.hasEvent("edit") || this.hasEvent("remove") ? "" : "ICON_ARROW_LEFT";
    } else if (property === "type") {
      return this.hasEvent("edit") || this.hasEvent("remove") ? "secondary" : "primary";
    } else {
      return "";
    }
  }
  hasEvent(event) {
    return !!this[event].observers.length;
  }
  hasPageHeader() {
    return !!(this.title || this.hasAnyAction() || this.breadcrumb && this.breadcrumb.items.length);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoPageDetailComponent_BaseFactory;
    return function PoPageDetailComponent_Factory(__ngFactoryType__) {
      return (ɵPoPageDetailComponent_BaseFactory || (ɵPoPageDetailComponent_BaseFactory = ɵɵgetInheritedFactory(_PoPageDetailComponent)))(__ngFactoryType__ || _PoPageDetailComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPageDetailComponent,
    selectors: [["po-page-detail"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0$g,
    decls: 4,
    vars: 1,
    consts: [[3, "p-breadcrumb", "p-title", "p-subtitle", 4, "ngIf"], [3, "p-breadcrumb", "p-title", "p-subtitle"], ["class", "po-page-header-actions", 4, "ngIf"], [1, "po-page-header-actions"], [3, "p-icon", "p-label", "p-kind", "p-click", 4, "ngIf"], ["p-danger", "", 3, "p-icon", "p-label", "p-kind", "p-click", 4, "ngIf"], ["p-icon", "ICON_EDIT", "p-kind", "primary", 3, "p-label", "p-click", 4, "ngIf"], [3, "p-click", "p-icon", "p-label", "p-kind"], ["p-danger", "", 3, "p-click", "p-icon", "p-label", "p-kind"], ["p-icon", "ICON_EDIT", "p-kind", "primary", 3, "p-click", "p-label"]],
    template: function PoPageDetailComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "po-page");
        ɵɵtemplate(1, PoPageDetailComponent_po_page_header_1_Template, 2, 4, "po-page-header", 0);
        ɵɵelementStart(2, "po-page-content");
        ɵɵprojection(3);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasPageHeader());
      }
    },
    dependencies: [NgIf, PoButtonComponent, PoPageComponent, PoPageContentComponent, PoPageHeaderComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageDetailComponent, [{
    type: Component,
    args: [{
      selector: "po-page-detail",
      standalone: false,
      template: `<po-page>
  <!-- HEADER -->
  <po-page-header *ngIf="hasPageHeader()" [p-breadcrumb]="breadcrumb" [p-title]="title" [p-subtitle]="subtitle">
    <!-- OPERATIONS -->
    <div *ngIf="hasAnyAction()" class="po-page-header-actions">
      <po-button
        *ngIf="hasEvent('back')"
        [p-icon]="hasEditOrRemoveFn('icon')"
        [p-label]="literals.back"
        [p-kind]="hasEditOrRemoveFn('type')"
        (p-click)="back.emit()"
      >
      </po-button>

      <po-button
        *ngIf="hasEvent('remove')"
        p-danger
        [p-icon]="hasEditFn('icon')"
        [p-label]="literals.remove"
        [p-kind]="hasEditFn('type')"
        (p-click)="remove.emit()"
      >
      </po-button>

      <po-button
        *ngIf="hasEvent('edit')"
        p-icon="ICON_EDIT"
        p-kind="primary"
        [p-label]="literals.edit"
        (p-click)="edit.emit()"
      >
      </po-button>
    </div>
  </po-page-header>

  <!-- CONTENT -->
  <po-page-content>
    <ng-content> </ng-content>
  </po-page-content>
</po-page>
`
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageDetailComponent, {
    className: "PoPageDetailComponent",
    filePath: "lib/components/po-page/po-page-detail/po-page-detail.component.ts",
    lineNumber: 30
  });
})();
var poPageEditLiteralsDefault = {
  en: {
    cancel: "Cancel",
    save: "Save",
    saveNew: "Save and New"
  },
  es: {
    cancel: "Cancelar",
    save: "Guardar",
    saveNew: "Guardar y Nuevo"
  },
  pt: {
    cancel: "Cancelar",
    save: "Salvar",
    saveNew: "Salvar e Novo"
  },
  ru: {
    cancel: "отменить",
    save: "экономить",
    saveNew: "Сохранить и новый"
  }
};
var PoPageEditBaseComponent = class _PoPageEditBaseComponent {
  poPageContent;
  /** Objeto com propriedades do breadcrumb. */
  breadcrumb;
  /** Desabilita botões de submissão (save e saveNew) */
  disableSubmit;
  /**
   * Evento que será disparado ao clicar no botão de "Cancelar".
   *
   * ```
   * <po-page-edit (p-cancel)="myCancelFunction()">
   * </po-page-edit>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Cancelar" não será exibido.
   */
  cancel = new EventEmitter();
  /**
   * Evento que será disparado ao clicar no botão de "Salvar".
   *
   * ```
   * <po-page-edit (p-save)="mySaveFunction()">
   * </po-page-edit>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Salvar" não será exibido.
   */
  save = new EventEmitter();
  /**
   * Evento que será disparado ao clicar no botão de "Salvar e Novo".
   *
   * ```
   * <po-page-edit (p-save-new)="mySaveNewFunction()">
   * </po-page-edit>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Salvar e Novo" não será exibido.
   */
  saveNew = new EventEmitter();
  _literals;
  _title;
  language;
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-page-edit`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoPageEditLiterals = {
   *    cancel: 'Voltar',
   *    save: 'Confirmar',
   *    saveNew: 'Confirmar e criar um novo'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoPageEditLiterals = {
   *    cancel: 'Cancelar processo'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-page-edit
   *   [p-literals]="customLiterals">
   * </po-page-edit>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poPageEditLiteralsDefault[poLocaleDefault]), poPageEditLiteralsDefault[this.language]), value);
    } else {
      this._literals = poPageEditLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poPageEditLiteralsDefault[this.language];
  }
  /** Título da página. */
  set title(title) {
    this._title = title;
    setTimeout(() => this.poPageContent.recalculateHeaderSize());
  }
  get title() {
    return this._title;
  }
  /**
   * @optional
   *
   * @description
   *
   * Subtitulo do Header da página
   */
  subtitle;
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoPageEditBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageEditBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoPageEditBaseComponent,
    viewQuery: function PoPageEditBaseComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoPageContentComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPageContent = _t.first);
      }
    },
    inputs: {
      breadcrumb: [0, "p-breadcrumb", "breadcrumb"],
      disableSubmit: [0, "p-disable-submit", "disableSubmit"],
      literals: [0, "p-literals", "literals"],
      title: [0, "p-title", "title"],
      subtitle: [0, "p-subtitle", "subtitle"]
    },
    outputs: {
      cancel: "p-cancel",
      save: "p-save",
      saveNew: "p-save-new"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageEditBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    poPageContent: [{
      type: ViewChild,
      args: [PoPageContentComponent, {
        static: true
      }]
    }],
    breadcrumb: [{
      type: Input,
      args: ["p-breadcrumb"]
    }],
    disableSubmit: [{
      type: Input,
      args: ["p-disable-submit"]
    }],
    cancel: [{
      type: Output,
      args: ["p-cancel"]
    }],
    save: [{
      type: Output,
      args: ["p-save"]
    }],
    saveNew: [{
      type: Output,
      args: ["p-save-new"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    subtitle: [{
      type: Input,
      args: ["p-subtitle"]
    }]
  });
})();
var _c0$f = ["*"];
function PoPageEditComponent_po_page_header_1_div_1_po_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 7);
    ɵɵlistener("p-click", function PoPageEditComponent_po_page_header_1_div_1_po_button_1_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.cancel.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-icon", ctx_r1.getIcon("cancel"))("p-label", ctx_r1.literals.cancel)("p-kind", ctx_r1.getType("cancel"));
  }
}
function PoPageEditComponent_po_page_header_1_div_1_po_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 8);
    ɵɵlistener("p-click", function PoPageEditComponent_po_page_header_1_div_1_po_button_2_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.saveNew.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-disabled", ctx_r1.disableSubmit)("p-icon", ctx_r1.getIcon("saveNew"))("p-label", ctx_r1.literals.saveNew)("p-kind", ctx_r1.getType("saveNew"));
  }
}
function PoPageEditComponent_po_page_header_1_div_1_po_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 9);
    ɵɵlistener("p-click", function PoPageEditComponent_po_page_header_1_div_1_po_button_3_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.save.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-disabled", ctx_r1.disableSubmit)("p-label", ctx_r1.literals.save);
  }
}
function PoPageEditComponent_po_page_header_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtemplate(1, PoPageEditComponent_po_page_header_1_div_1_po_button_1_Template, 1, 3, "po-button", 4)(2, PoPageEditComponent_po_page_header_1_div_1_po_button_2_Template, 1, 4, "po-button", 5)(3, PoPageEditComponent_po_page_header_1_div_1_po_button_3_Template, 1, 2, "po-button", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("cancel"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("saveNew"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("save"));
  }
}
function PoPageEditComponent_po_page_header_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-page-header", 1);
    ɵɵtemplate(1, PoPageEditComponent_po_page_header_1_div_1_Template, 4, 3, "div", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-breadcrumb", ctx_r1.breadcrumb)("p-title", ctx_r1.title)("p-subtitle", ctx_r1.subtitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasAnyAction());
  }
}
var PoPageEditComponent = class _PoPageEditComponent extends PoPageEditBaseComponent {
  getIcon(icon) {
    if (icon === "cancel") {
      return this.isPrimaryAction("cancel") ? "ICON_CLOSE" : "";
    }
    if (icon === "saveNew") {
      return this.isPrimaryAction("saveNew") ? "ICON_OK" : "";
    }
    return "";
  }
  getType(type) {
    const isCancelPrimaryAction = type === "cancel" && this.isPrimaryAction("cancel");
    const isSaveNewPrimaryAction = type === "saveNew" && this.isPrimaryAction("saveNew");
    return isCancelPrimaryAction || isSaveNewPrimaryAction ? "primary" : "secondary";
  }
  hasAnyAction() {
    return this.hasEvent("cancel") || this.hasEvent("saveNew") || this.hasEvent("save");
  }
  hasPageHeader() {
    return !!(this.title || this.hasAnyAction() || this.breadcrumb && this.breadcrumb.items.length);
  }
  hasEvent(event) {
    return !!this[event].observers.length;
  }
  isPrimaryAction(action) {
    const hasSaveAction = this.hasEvent("save");
    if (action === "saveNew") {
      return !hasSaveAction;
    }
    if (action === "cancel") {
      const hasSaveNewAction = this.hasEvent("saveNew");
      return !hasSaveNewAction && !hasSaveAction;
    }
    return false;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoPageEditComponent_BaseFactory;
    return function PoPageEditComponent_Factory(__ngFactoryType__) {
      return (ɵPoPageEditComponent_BaseFactory || (ɵPoPageEditComponent_BaseFactory = ɵɵgetInheritedFactory(_PoPageEditComponent)))(__ngFactoryType__ || _PoPageEditComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPageEditComponent,
    selectors: [["po-page-edit"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0$f,
    decls: 4,
    vars: 1,
    consts: [[3, "p-breadcrumb", "p-title", "p-subtitle", 4, "ngIf"], [3, "p-breadcrumb", "p-title", "p-subtitle"], ["class", "po-page-header-actions", 4, "ngIf"], [1, "po-page-header-actions"], [3, "p-icon", "p-label", "p-kind", "p-click", 4, "ngIf"], [3, "p-disabled", "p-icon", "p-label", "p-kind", "p-click", 4, "ngIf"], ["p-icon", "ICON_OK", "p-kind", "primary", 3, "p-disabled", "p-label", "p-click", 4, "ngIf"], [3, "p-click", "p-icon", "p-label", "p-kind"], [3, "p-click", "p-disabled", "p-icon", "p-label", "p-kind"], ["p-icon", "ICON_OK", "p-kind", "primary", 3, "p-click", "p-disabled", "p-label"]],
    template: function PoPageEditComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "po-page");
        ɵɵtemplate(1, PoPageEditComponent_po_page_header_1_Template, 2, 4, "po-page-header", 0);
        ɵɵelementStart(2, "po-page-content");
        ɵɵprojection(3);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasPageHeader());
      }
    },
    dependencies: [NgIf, PoButtonComponent, PoPageComponent, PoPageContentComponent, PoPageHeaderComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageEditComponent, [{
    type: Component,
    args: [{
      selector: "po-page-edit",
      standalone: false,
      template: `<po-page>
  <!-- HEADER -->
  <po-page-header *ngIf="hasPageHeader()" [p-breadcrumb]="breadcrumb" [p-title]="title" [p-subtitle]="subtitle">
    <!-- OPERATIONS -->
    <div *ngIf="hasAnyAction()" class="po-page-header-actions">
      <po-button
        *ngIf="hasEvent('cancel')"
        [p-icon]="getIcon('cancel')"
        [p-label]="literals.cancel"
        [p-kind]="getType('cancel')"
        (p-click)="cancel.emit()"
      >
      </po-button>

      <po-button
        *ngIf="hasEvent('saveNew')"
        [p-disabled]="disableSubmit"
        [p-icon]="getIcon('saveNew')"
        [p-label]="literals.saveNew"
        [p-kind]="getType('saveNew')"
        (p-click)="saveNew.emit()"
      >
      </po-button>

      <po-button
        *ngIf="hasEvent('save')"
        p-icon="ICON_OK"
        p-kind="primary"
        [p-disabled]="disableSubmit"
        [p-label]="literals.save"
        (p-click)="save.emit()"
      >
      </po-button>
    </div>
  </po-page-header>

  <!-- CONTENT -->
  <po-page-content>
    <ng-content> </ng-content>
  </po-page-content>
</po-page>
`
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageEditComponent, {
    className: "PoPageEditComponent",
    filePath: "lib/components/po-page/po-page-edit/po-page-edit.component.ts",
    lineNumber: 30
  });
})();
var poPageListLiteralsDefault = {
  en: {
    otherActions: "Other actions"
  },
  es: {
    otherActions: "Otras acciones"
  },
  pt: {
    otherActions: "Outras ações"
  },
  ru: {
    otherActions: "Другие действия"
  }
};
var PoPageListBaseComponent = class _PoPageListBaseComponent {
  poPageContent;
  /**
   * @optional
   *
   * @description
   *
   * Objeto que implementa as propriedades da interface `PoBreadcrumb`.
   */
  breadcrumb;
  /**
   * @description
   *
   * Objeto que implementa as propriedades da interface `PoPageFilter`.
   */
  filter;
  /**
   * @optional
   *
   * @description
   *
   * Valor padrão na busca rápida ao inicializar o componente
   *
   */
  quickSearchValue;
  visibleActions = [];
  language;
  resizeListener;
  _actions = [];
  _disclaimerGroup;
  _literals;
  _title;
  /**
   * @optional
   *
   * @description
   *
   * Nesta propriedade deve ser definido um array de objetos que implementam a interface `PoPageAction`.
   */
  set actions(actions) {
    this._actions = Array.isArray(actions) ? actions : [];
    this.visibleActions = this.actions.filter((action) => action.visible !== false);
    this.setDropdownActions();
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto que implementa as propriedades da interface `PoDisclaimerGroup`.
   */
  set disclaimerGroup(value) {
    if (!value) {
      value = {};
    }
    this._disclaimerGroup = value;
  }
  get disclaimerGroup() {
    return this._disclaimerGroup;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-page-list`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoPageListLiterals = {
   *    otherActions: 'Mais ações'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoPageListLiterals = {
   *    otherActions: 'Ações da página'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-page-list
   *   [p-literals]="customLiterals">
   * </po-page-list>
   * ```
   *
   * > O valor padrão será traduzido de acordo com o idioma configurado no [`PoI18nService`](/documentation/po-i18n) ou *browser*.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poPageListLiteralsDefault[poLocaleDefault]), poPageListLiteralsDefault[this.language]), value);
    } else {
      this._literals = poPageListLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poPageListLiteralsDefault[this.language];
  }
  /** Título da página. */
  set title(title) {
    this._title = title;
    setTimeout(() => this.poPageContent.recalculateHeaderSize());
  }
  get title() {
    return this._title;
  }
  /**
   * @optional
   *
   * @description
   *
   * Subtitulo do Header da página
   */
  subtitle;
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoPageListBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageListBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoPageListBaseComponent,
    viewQuery: function PoPageListBaseComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoPageContentComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPageContent = _t.first);
      }
    },
    inputs: {
      breadcrumb: [0, "p-breadcrumb", "breadcrumb"],
      filter: [0, "p-filter", "filter"],
      quickSearchValue: [0, "p-quick-search-value", "quickSearchValue"],
      actions: [0, "p-actions", "actions"],
      disclaimerGroup: [0, "p-disclaimer-group", "disclaimerGroup"],
      literals: [0, "p-literals", "literals"],
      title: [0, "p-title", "title"],
      subtitle: [0, "p-subtitle", "subtitle"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageListBaseComponent, [{
    type: Directive
  }], () => [{
    type: PoLanguageService
  }], {
    poPageContent: [{
      type: ViewChild,
      args: [PoPageContentComponent, {
        static: true
      }]
    }],
    breadcrumb: [{
      type: Input,
      args: ["p-breadcrumb"]
    }],
    filter: [{
      type: Input,
      args: ["p-filter"]
    }],
    quickSearchValue: [{
      type: Input,
      args: ["p-quick-search-value"]
    }],
    actions: [{
      type: Input,
      args: ["p-actions"]
    }],
    disclaimerGroup: [{
      type: Input,
      args: ["p-disclaimer-group"]
    }],
    literals: [{
      type: Input,
      args: ["p-literals"]
    }],
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    subtitle: [{
      type: Input,
      args: ["p-subtitle"]
    }]
  });
})();
var _c0$e = ["filterInput"];
var _c1$4 = ["*"];
function PoPageListComponent_po_page_header_1_po_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 11);
    ɵɵlistener("p-click", function PoPageListComponent_po_page_header_1_po_button_4_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.callAction(ctx_r1.visibleActions[0]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-danger", ctx_r1.visibleActions[0].type === "danger")("p-disabled", ctx_r1.actionIsDisabled(ctx_r1.actions[0]))("p-icon", ctx_r1.visibleActions[0].icon)("p-label", ctx_r1.visibleActions[0].label);
  }
}
function PoPageListComponent_po_page_header_1_po_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 12);
    ɵɵlistener("p-click", function PoPageListComponent_po_page_header_1_po_button_5_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.callAction(ctx_r1.visibleActions[1]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-danger", ctx_r1.visibleActions[1].type === "danger")("p-disabled", ctx_r1.actionIsDisabled(ctx_r1.actions[1]))("p-label", ctx_r1.visibleActions[1].label);
  }
}
function PoPageListComponent_po_page_header_1_po_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 12);
    ɵɵlistener("p-click", function PoPageListComponent_po_page_header_1_po_button_6_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.callAction(ctx_r1.visibleActions[2]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-danger", ctx_r1.visibleActions[2].type === "danger")("p-disabled", ctx_r1.actionIsDisabled(ctx_r1.visibleActions[2]))("p-label", ctx_r1.visibleActions[2].label);
  }
}
function PoPageListComponent_po_page_header_1_po_dropdown_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-dropdown", 13);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-actions", ctx_r1.dropdownActions)("p-label", ctx_r1.literals.otherActions);
  }
}
function PoPageListComponent_po_page_header_1_div_8_div_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "span", 21);
    ɵɵlistener("click", function PoPageListComponent_po_page_header_1_div_8_div_6_Template_span_click_1_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.callActionFilter("advancedAction"));
    })("keydown.enter", function PoPageListComponent_po_page_header_1_div_8_div_6_Template_span_keydown_enter_1_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.callActionFilter("advancedAction"));
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.advancedSearch, " ");
  }
}
function PoPageListComponent_po_page_header_1_div_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 14)(1, "div", 15)(2, "div", 16)(3, "po-icon", 17);
    ɵɵlistener("click", function PoPageListComponent_po_page_header_1_div_8_Template_po_icon_click_3_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.callActionFilter("action"));
    });
    ɵɵelementEnd()();
    ɵɵelementStart(4, "input", 18, 0);
    ɵɵlistener("keypress", function PoPageListComponent_po_page_header_1_div_8_Template_input_keypress_4_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onkeypress($event.keyCode));
    });
    ɵɵelementEnd()();
    ɵɵtemplate(6, PoPageListComponent_po_page_header_1_div_8_div_6_Template, 3, 1, "div", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r1.hasCustomFilterSize() ? ctx_r1.filterSizeClass(ctx_r1.filter.width) : "");
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.hasCustomFilterSize() ? ctx_r1.filter.advancedAction ? "po-page-filter-input-variable-size" : "po-page-filter-input-variable-size-wo-adv-search" : "");
    ɵɵadvance(3);
    ɵɵproperty("placeholder", ctx_r1.filter.placeholder || "")("value", ctx_r1.quickSearchValue || "");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.filter.advancedAction);
  }
}
function PoPageListComponent_po_page_header_1_po_disclaimer_group_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-disclaimer-group", 22);
    ɵɵlistener("p-change", function PoPageListComponent_po_page_header_1_po_disclaimer_group_9_Template_po_disclaimer_group_p_change_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onChangeDisclaimerGroup($event));
    })("p-remove", function PoPageListComponent_po_page_header_1_po_disclaimer_group_9_Template_po_disclaimer_group_p_remove_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onRemoveDisclaimer($event));
    })("p-remove-all", function PoPageListComponent_po_page_header_1_po_disclaimer_group_9_Template_po_disclaimer_group_p_remove_all_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onRemoveAllDisclaimers($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassProp("po-page-list-disclaimer-group", !!(ctx_r1.disclaimerGroup == null ? null : ctx_r1.disclaimerGroup.disclaimers == null ? null : ctx_r1.disclaimerGroup.disclaimers.length));
    ɵɵproperty("p-disclaimers", ctx_r1.disclaimerGroup == null ? null : ctx_r1.disclaimerGroup.disclaimers)("p-hide-remove-all", ctx_r1.disclaimerGroup == null ? null : ctx_r1.disclaimerGroup.hideRemoveAll)("p-title", ctx_r1.disclaimerGroup == null ? null : ctx_r1.disclaimerGroup.title);
  }
}
function PoPageListComponent_po_page_header_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-page-header", 2)(1, "div", 3)(2, "div", 4)(3, "div", 5);
    ɵɵtemplate(4, PoPageListComponent_po_page_header_1_po_button_4_Template, 1, 4, "po-button", 6)(5, PoPageListComponent_po_page_header_1_po_button_5_Template, 1, 3, "po-button", 7)(6, PoPageListComponent_po_page_header_1_po_button_6_Template, 1, 3, "po-button", 7)(7, PoPageListComponent_po_page_header_1_po_dropdown_7_Template, 1, 2, "po-dropdown", 8);
    ɵɵelementEnd();
    ɵɵtemplate(8, PoPageListComponent_po_page_header_1_div_8_Template, 7, 5, "div", 9);
    ɵɵelementEnd();
    ɵɵtemplate(9, PoPageListComponent_po_page_header_1_po_disclaimer_group_9_Template, 1, 5, "po-disclaimer-group", 10);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-page-list-header-padding", ctx_r1.filter && !ctx_r1.visibleActions.length);
    ɵɵproperty("p-breadcrumb", ctx_r1.breadcrumb)("p-title", ctx_r1.title)("p-subtitle", ctx_r1.subtitle);
    ɵɵadvance(3);
    ɵɵclassProp("po-page-list-actions-padding", ctx_r1.filter);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.visibleActions[0]);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.visibleActions[1] && (ctx_r1.visibleActions.length === 2 || !ctx_r1.isMobile));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.visibleActions.length === 3 && ctx_r1.visibleActions[2] && !ctx_r1.isMobile);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.visibleActions.length > ctx_r1.limitPrimaryActions);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.filter);
    ɵɵadvance();
    ɵɵproperty("ngIf", !!ctx_r1.disclaimerGroup);
  }
}
var PoPageListComponent = class _PoPageListComponent extends PoPageListBaseComponent {
  renderer;
  router;
  changeDetector;
  filterInput;
  advancedSearch;
  dropdownActions;
  isMobile;
  limitPrimaryActions = 3;
  callFunction = callFunction;
  isRecalculate = true;
  maxWidthMobile = 480;
  /* istanbul ignore next */
  constructor(viewRef, languageService, renderer, router, changeDetector) {
    super(languageService);
    this.renderer = renderer;
    this.router = router;
    this.changeDetector = changeDetector;
    this.initializeListeners();
  }
  ngOnInit() {
    this.advancedSearch = this.initializeFixedLiterals();
  }
  ngAfterContentInit() {
    this.setIsMobile();
    this.setDropdownActions();
  }
  ngOnChanges(changes) {
    this.setDropdownActions();
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  actionIsDisabled(action) {
    return isTypeof(action.disabled, "function") ? action.disabled(action) : action.disabled;
  }
  callAction(item) {
    if (item.url) {
      isExternalLink(item.url) ? openExternalLink(item.url) : this.router.navigate([item.url]);
    } else if (item.action) {
      item.action();
    }
  }
  hasPageHeader() {
    return !!(this.title || this.visibleActions && this.visibleActions.length || this.breadcrumb && this.breadcrumb.items.length);
  }
  hasCustomFilterSize() {
    if (!this.filter) {
      return false;
    }
    return this.filter.width >= 1 && this.filter.width <= 6;
  }
  filterSizeClass(width) {
    const smWidth = Math.max(this.filter?.advancedAction ? 6 : 2, width);
    const mdWidth = Math.max(this.filter?.advancedAction ? 4 : 1, width);
    if (this.filter?.advancedAction) {
      width = Math.max(width, 2);
    }
    return `po-sm-${smWidth} po-md-${mdWidth} po-lg-${width} po-xl-${width}`;
  }
  setDropdownActions() {
    if (this.visibleActions.length > this.limitPrimaryActions) {
      this.dropdownActions = this.visibleActions.slice(this.limitPrimaryActions - 1);
    }
  }
  callActionFilter(field) {
    this.filter[field](this.filterInput.nativeElement.value);
    this.changeDetector.detectChanges();
  }
  /**
   * Limpa o campo de pesquisa.
   */
  clearInputSearch() {
    this.filterInput.nativeElement.value = null;
  }
  onkeypress(key) {
    if (key === 13) {
      this.callActionFilter("action");
    }
  }
  // Recebe evento change do disclaimer e recalcula tela
  onChangeDisclaimerGroup(disclaimers) {
    if (disclaimers && disclaimers.length && this.isRecalculate || disclaimers.length === 0 && !this.isRecalculate) {
      this.poPageContent.recalculateHeaderSize();
      this.isRecalculate = !this.isRecalculate;
    }
    if (this.disclaimerGroup && this.disclaimerGroup.change) {
      this.disclaimerGroup.change(disclaimers);
    }
  }
  onRemoveDisclaimer(removeData) {
    if (this.disclaimerGroup.remove) {
      this.disclaimerGroup.remove(removeData);
    }
  }
  onRemoveAllDisclaimers(removedDisclaimers) {
    if (this.disclaimerGroup.removeAll) {
      this.disclaimerGroup.removeAll(removedDisclaimers);
    }
  }
  initializeFixedLiterals() {
    const literal = {
      pt: {
        advancedSearch: "Busca avançada"
      },
      en: {
        advancedSearch: "Advanced search"
      },
      es: {
        advancedSearch: "Búsqueda avanzada"
      },
      ru: {
        advancedSearch: "полный поиск"
      }
    };
    return literal[this.language].advancedSearch;
  }
  initializeListeners() {
    this.resizeListener = this.renderer.listen("window", "resize", (event) => {
      this.onResize(event);
    });
  }
  removeListeners() {
    this.resizeListener();
  }
  onResize(event) {
    const width = event.target.innerWidth;
    if (width < this.maxWidthMobile) {
      this.isMobile = true;
      this.limitPrimaryActions = 2;
      this.setDropdownActions();
    } else {
      this.isMobile = false;
      this.limitPrimaryActions = 3;
      this.setDropdownActions();
    }
  }
  setIsMobile() {
    if (window.innerWidth < this.maxWidthMobile) {
      this.isMobile = true;
      this.limitPrimaryActions = 2;
    }
  }
  static ɵfac = function PoPageListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageListComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoPageListComponent,
    selectors: [["po-page-list"]],
    viewQuery: function PoPageListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$e, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterInput = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    ngContentSelectors: _c1$4,
    decls: 4,
    vars: 1,
    consts: [["filterInput", ""], [3, "po-page-list-header-padding", "p-breadcrumb", "p-title", "p-subtitle", 4, "ngIf"], [3, "p-breadcrumb", "p-title", "p-subtitle"], [1, "po-page-list-container"], [1, "po-page-list-operations"], [1, "po-page-list-actions"], ["p-kind", "primary", 3, "p-danger", "p-disabled", "p-icon", "p-label", "p-click", 4, "ngIf"], [3, "p-danger", "p-disabled", "p-label", "p-click", 4, "ngIf"], [3, "p-actions", "p-label", 4, "ngIf"], ["class", "po-page-list-filter-wrapper", 3, "ngClass", 4, "ngIf"], [3, "po-page-list-disclaimer-group", "p-disclaimers", "p-hide-remove-all", "p-title", "p-change", "p-remove", "p-remove-all", 4, "ngIf"], ["p-kind", "primary", 3, "p-click", "p-danger", "p-disabled", "p-icon", "p-label"], [3, "p-click", "p-danger", "p-disabled", "p-label"], [3, "p-actions", "p-label"], [1, "po-page-list-filter-wrapper", 3, "ngClass"], [1, "po-field-container-content", "po-page-filter-content", 3, "ngClass"], [1, "po-field-icon-container-right"], ["p-icon", "ICON_SEARCH", 1, "po-field-icon", "po-icon-input", 3, "click"], ["name", "model", "type", "text", 1, "po-input", "po-input-icon-right", 3, "keypress", "placeholder", "value"], ["class", "po-page-list-filter-search", 4, "ngIf"], [1, "po-page-list-filter-search"], ["tabindex", "0", 1, "po-page-list-filter-search-link", 3, "click", "keydown.enter"], [3, "p-change", "p-remove", "p-remove-all", "p-disclaimers", "p-hide-remove-all", "p-title"]],
    template: function PoPageListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "po-page");
        ɵɵtemplate(1, PoPageListComponent_po_page_header_1_Template, 10, 13, "po-page-header", 1);
        ɵɵelementStart(2, "po-page-content");
        ɵɵprojection(3);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasPageHeader());
      }
    },
    dependencies: [NgClass, NgIf, PoButtonComponent, PoDisclaimerGroupComponent, PoDropdownComponent, PoIconComponent, PoPageComponent, PoPageContentComponent, PoPageHeaderComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageListComponent, [{
    type: Component,
    args: [{
      selector: "po-page-list",
      standalone: false,
      template: `<po-page>
  <!-- HEADER -->
  <po-page-header
    *ngIf="hasPageHeader()"
    [class.po-page-list-header-padding]="filter && !visibleActions.length"
    [p-breadcrumb]="breadcrumb"
    [p-title]="title"
    [p-subtitle]="subtitle"
  >
    <div class="po-page-list-container">
      <!-- OPERATIONS -->
      <div class="po-page-list-operations">
        <div class="po-page-list-actions" [class.po-page-list-actions-padding]="filter">
          <po-button
            *ngIf="visibleActions[0]"
            p-kind="primary"
            [p-danger]="visibleActions[0].type === 'danger'"
            [p-disabled]="actionIsDisabled(actions[0])"
            [p-icon]="visibleActions[0].icon"
            [p-label]="visibleActions[0].label"
            (p-click)="callAction(visibleActions[0])"
          >
          </po-button>

          <po-button
            *ngIf="visibleActions[1] && (visibleActions.length === 2 || !isMobile)"
            [p-danger]="visibleActions[1].type === 'danger'"
            [p-disabled]="actionIsDisabled(actions[1])"
            [p-label]="visibleActions[1].label"
            (p-click)="callAction(visibleActions[1])"
          >
          </po-button>

          <po-button
            *ngIf="visibleActions.length === 3 && visibleActions[2] && !isMobile"
            [p-danger]="visibleActions[2].type === 'danger'"
            [p-disabled]="actionIsDisabled(visibleActions[2])"
            [p-label]="visibleActions[2].label"
            (p-click)="callAction(visibleActions[2])"
          >
          </po-button>

          <po-dropdown
            *ngIf="visibleActions.length > limitPrimaryActions"
            [p-actions]="dropdownActions"
            [p-label]="literals.otherActions"
          >
          </po-dropdown>
        </div>

        <!-- FILTER -->
        <div
          class="po-page-list-filter-wrapper"
          *ngIf="filter"
          [ngClass]="hasCustomFilterSize() ? filterSizeClass(filter.width) : ''"
        >
          <div
            class="po-field-container-content po-page-filter-content"
            [ngClass]="
              hasCustomFilterSize()
                ? filter.advancedAction
                  ? 'po-page-filter-input-variable-size'
                  : 'po-page-filter-input-variable-size-wo-adv-search'
                : ''
            "
          >
            <div class="po-field-icon-container-right">
              <po-icon p-icon="ICON_SEARCH" class="po-field-icon po-icon-input" (click)="callActionFilter('action')">
              </po-icon>
            </div>

            <input
              #filterInput
              class="po-input po-input-icon-right"
              name="model"
              type="text"
              [placeholder]="filter.placeholder || ''"
              (keypress)="onkeypress($event.keyCode)"
              [value]="quickSearchValue || ''"
            />
          </div>

          <div class="po-page-list-filter-search" *ngIf="filter.advancedAction">
            <span
              class="po-page-list-filter-search-link"
              tabindex="0"
              (click)="callActionFilter('advancedAction')"
              (keydown.enter)="callActionFilter('advancedAction')"
            >
              {{ advancedSearch }}
            </span>
          </div>
        </div>
      </div>

      <!-- DISCLAIMER -->
      <po-disclaimer-group
        *ngIf="!!disclaimerGroup"
        [class.po-page-list-disclaimer-group]="!!disclaimerGroup?.disclaimers?.length"
        [p-disclaimers]="disclaimerGroup?.disclaimers"
        [p-hide-remove-all]="disclaimerGroup?.hideRemoveAll"
        [p-title]="disclaimerGroup?.title"
        (p-change)="onChangeDisclaimerGroup($event)"
        (p-remove)="onRemoveDisclaimer($event)"
        (p-remove-all)="onRemoveAllDisclaimers($event)"
      >
      </po-disclaimer-group>
    </div>
  </po-page-header>

  <!-- CONTENT -->
  <po-page-content>
    <ng-content></ng-content>
  </po-page-content>
</po-page>
`
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: PoLanguageService
  }, {
    type: Renderer2
  }, {
    type: Router
  }, {
    type: ChangeDetectorRef
  }], {
    filterInput: [{
      type: ViewChild,
      args: ["filterInput"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageListComponent, {
    className: "PoPageListComponent",
    filePath: "lib/components/po-page/po-page-list/po-page-list.component.ts",
    lineNumber: 51
  });
})();
var PoPageModule = class _PoPageModule {
  static ɵfac = function PoPageModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPageModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoPageModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, RouterModule, PoBreadcrumbModule, PoButtonModule, PoDisclaimerGroupModule, PoDropdownModule, PoFieldModule, PoIconModule, PoLanguageModule, PoModalModule, PoPageSlideModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, RouterModule, PoBreadcrumbModule, PoButtonModule, PoDisclaimerGroupModule, PoDropdownModule, PoFieldModule, PoIconModule, PoLanguageModule, PoModalModule, PoPageSlideModule],
      declarations: [PoPageComponent, PoPageContentComponent, PoPageDefaultComponent, PoPageDetailComponent, PoPageEditComponent, PoPageHeaderComponent, PoPageListComponent],
      exports: [PoPageDefaultComponent, PoPageDetailComponent, PoPageEditComponent, PoPageListComponent, PoPageSlideComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoPageModule, {
    declarations: [PoPageComponent, PoPageContentComponent, PoPageDefaultComponent, PoPageDetailComponent, PoPageEditComponent, PoPageHeaderComponent, PoPageListComponent],
    imports: [CommonModule, FormsModule, RouterModule, PoBreadcrumbModule, PoButtonModule, PoDisclaimerGroupModule, PoDropdownModule, PoFieldModule, PoIconModule, PoLanguageModule, PoModalModule, PoPageSlideModule],
    exports: [PoPageDefaultComponent, PoPageDetailComponent, PoPageEditComponent, PoPageListComponent, PoPageSlideComponent]
  });
})();
function PoSlideCirclesComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 2);
    ɵɵlistener("click", function PoSlideCirclesComponent_ng_container_1_Template_div_click_1_listener() {
      const index_r2 = ɵɵrestoreView(_r1).index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.click.emit(index_r2));
    });
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const index_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-slide-active-circle", index_r2 === ctx_r2.currentSlideIndex);
  }
}
var PoSlideCirclesComponent = class _PoSlideCirclesComponent {
  /** Index do slide atual. */
  currentSlideIndex;
  /** Itens do slide. */
  items;
  /** Evento emitido ao clicar em um controle. */
  click = new EventEmitter();
  static ɵfac = function PoSlideCirclesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSlideCirclesComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoSlideCirclesComponent,
    selectors: [["po-slide-circles"]],
    inputs: {
      currentSlideIndex: [0, "p-current-slide-index", "currentSlideIndex"],
      items: [0, "p-items", "items"]
    },
    outputs: {
      click: "p-click"
    },
    standalone: false,
    decls: 2,
    vars: 1,
    consts: [[1, "po-slide-circles"], [4, "ngFor", "ngForOf"], [1, "po-slide-circle", 3, "click"]],
    template: function PoSlideCirclesComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵtemplate(1, PoSlideCirclesComponent_ng_container_1_Template, 2, 2, "ng-container", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.items);
      }
    },
    dependencies: [NgForOf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideCirclesComponent, [{
    type: Component,
    args: [{
      selector: "po-slide-circles",
      standalone: false,
      template: '<div class="po-slide-circles">\n  <ng-container *ngFor="let item of items; let index = index">\n    <div\n      class="po-slide-circle"\n      [class.po-slide-active-circle]="index === currentSlideIndex"\n      (click)="click.emit(index)"\n    ></div>\n  </ng-container>\n</div>\n'
    }]
  }], null, {
    currentSlideIndex: [{
      type: Input,
      args: ["p-current-slide-index"]
    }],
    items: [{
      type: Input,
      args: ["p-items"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSlideCirclesComponent, {
    className: "PoSlideCirclesComponent",
    filePath: "lib/components/po-slide/po-slide-circles/po-slide-circles.component.ts",
    lineNumber: 15
  });
})();
var poSlideIntervalDefault = 4e3;
var PoSlideBaseComponent = class _PoSlideBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Define a exibição das setas de navegação.
   *
   * @default `false`
   */
  hideArrows = false;
  _interval = poSlideIntervalDefault;
  _height;
  _slides;
  /**
   * @optional
   *
   * @description
   * Altura do po-slide, caso seja slide com template customizado, não assume o valor `default`.
   *
   * @default `336`
   */
  set height(value) {
    this._height = convertToInt(value);
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor em milissegundos que define o tempo de troca dos slides, caso o valor seja menor que `1000` os slides não trocam automaticamente.
   *
   * @default `4000`
   */
  set interval(value) {
    this._interval = convertToInt(value, poSlideIntervalDefault);
    this._interval >= 1e3 ? this.startInterval() : this.cancelInterval();
  }
  get interval() {
    return this._interval;
  }
  /**
   * @description
   *
   * Array de imagens ou dados para o slide, pode ser de três formas:
   *
   * - Array implementando objetos da interface `PoSlideItem`:
   * ```
   * [{ image: '/assets/image-1', action: 'imageClick.bind(this)'}, { image: '/assets/image-2' }]
   * ```
   * - Array de `strings` com os caminhos das imagens:
   * ```
   * ['/assets/image-1', '/assets/image-2' ]
   * ```
   * - Array com lista de itens (para utilizar template):
   * ```
   * [{ label: '1', img: '/assets/image-1' }, { label: '2', img: '/assets/image-1' }]
   * ```
   *
   * > As setas de navegação e o controle com círculos apenas serão renderizados caso possua mais de um slide.
   */
  set slides(value) {
    this._slides = value;
    this.setSlideItems(value);
    if (value && value.length) {
      this.startSlide();
    }
  }
  get slides() {
    return this._slides;
  }
  static ɵfac = function PoSlideBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSlideBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoSlideBaseComponent,
    inputs: {
      hideArrows: [2, "p-hide-arrows", "hideArrows", convertToBoolean],
      height: [0, "p-height", "height"],
      interval: [0, "p-interval", "interval"],
      slides: [0, "p-slides", "slides"]
    },
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideBaseComponent, [{
    type: Directive
  }], null, {
    hideArrows: [{
      type: Input,
      args: [{
        alias: "p-hide-arrows",
        transform: convertToBoolean
      }]
    }],
    height: [{
      type: Input,
      args: ["p-height"]
    }],
    interval: [{
      type: Input,
      args: ["p-interval"]
    }],
    slides: [{
      type: Input,
      args: ["p-slides"]
    }]
  });
})();
var PoSlideContentTemplateDirective = class _PoSlideContentTemplateDirective {
  templateRef;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoSlideContentTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSlideContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoSlideContentTemplateDirective,
    selectors: [["", "p-slide-content-template", ""]],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-slide-content-template]",
      standalone: false
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _c0$d = ["slideItem"];
var _c1$3 = (a0, a1) => ({
  alt: a0,
  image: a1
});
var _c2$2 = (a0) => ({
  item: a0
});
var _c3$1 = (a0, a1, a2) => ({
  alt: a0,
  image: a1,
  data: a2
});
var _c4 = (a0, a1) => ({
  $implicit: a0,
  index: a1
});
function PoSlideItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 8);
    ɵɵelementContainer(1, 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const slideItemImage_r2 = ɵɵreference(8);
    ɵɵproperty("routerLink", ctx_r0.link);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", slideItemImage_r2)("ngTemplateOutletContext", ɵɵpureFunction1(6, _c2$2, ɵɵpureFunction2(3, _c1$3, ctx_r0.alt, ctx_r0.image)));
  }
}
function PoSlideItemComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 10);
    ɵɵelementContainer(1, 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const slideItemImage_r2 = ɵɵreference(8);
    ɵɵproperty("href", ctx_r0.link, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", slideItemImage_r2)("ngTemplateOutletContext", ɵɵpureFunction1(6, _c2$2, ɵɵpureFunction2(3, _c1$3, ctx_r0.alt, ctx_r0.image)));
  }
}
function PoSlideItemComponent_a_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 11);
    ɵɵlistener("click", function PoSlideItemComponent_a_4_Template_a_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.action ? ctx_r0.action(ctx_r0.data) : void 0);
    });
    ɵɵelementContainer(1, 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const slideItemTemplate_r4 = ɵɵreference(6);
    const slideItemImage_r2 = ɵɵreference(8);
    ɵɵproperty("ngClass", ctx_r0.action ? "po-slide-item-link" : "po-slide-item-no-link");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template ? slideItemTemplate_r4 : slideItemImage_r2)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c2$2, ɵɵpureFunction3(3, _c3$1, ctx_r0.alt, ctx_r0.image, ctx_r0.data)));
  }
}
function PoSlideItemComponent_ng_template_5_div_0_ng_template_1_Template(rf, ctx) {
}
function PoSlideItemComponent_ng_template_5_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, PoSlideItemComponent_ng_template_5_div_0_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const item_r6 = ctx_r4.item;
    const index_r7 = ctx_r4.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c4, item_r6.data, index_r7));
  }
}
function PoSlideItemComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoSlideItemComponent_ng_template_5_div_0_Template, 2, 5, "div", 12);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r0.template);
  }
}
function PoSlideItemComponent_ng_template_7_img_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 15);
  }
  if (rf & 2) {
    const item_r8 = ɵɵnextContext().item;
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r0.imageHeight, "px");
    ɵɵproperty("alt", item_r8.alt)("src", item_r8.image, ɵɵsanitizeUrl);
  }
}
function PoSlideItemComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoSlideItemComponent_ng_template_7_img_0_Template, 1, 4, "img", 14);
  }
  if (rf & 2) {
    const item_r8 = ctx.item;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngIf", item_r8.image && !ctx_r0.isIEOrEdge);
  }
}
var PoSlideItemComponent = class _PoSlideItemComponent {
  itemElement;
  /** Ação executada ao clicar em uma imagem */
  action;
  /** Texto alternativo quando a imagem não é encontrada */
  alt;
  /** Dados para o template customizado */
  data;
  /** Caminho da imagem */
  image;
  /** Altura da imagem */
  imageHeight;
  /** Template customizado */
  template;
  /** Link executado ao clicar em uma imagem */
  link;
  isIEOrEdge = isIEOrEdge();
  setLinkType() {
    if (!this.template && this.link) {
      return this.link.startsWith("http") ? "externalLink" : "internalLink";
    }
    return "noLink";
  }
  static ɵfac = function PoSlideItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSlideItemComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoSlideItemComponent,
    selectors: [["po-slide-item"]],
    viewQuery: function PoSlideItemComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$d, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemElement = _t.first);
      }
    },
    inputs: {
      action: [0, "p-action", "action"],
      alt: [0, "p-alt", "alt"],
      data: [0, "p-data", "data"],
      image: [0, "p-image", "image"],
      imageHeight: [0, "p-image-height", "imageHeight"],
      template: [0, "p-template", "template"],
      link: [0, "p-link", "link"]
    },
    standalone: false,
    decls: 9,
    vars: 8,
    consts: [["slideItem", ""], ["slideItemTemplate", ""], ["slideItemImage", ""], [1, "po-slide-item", 3, "ngSwitch"], ["class", "po-slide-item-link", 3, "routerLink", 4, "ngSwitchCase"], ["class", "po-slide-item-link", 3, "href", 4, "ngSwitchCase"], [3, "ngClass", "click", 4, "ngSwitchCase"], [";", ""], [1, "po-slide-item-link", 3, "routerLink"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "po-slide-item-link", 3, "href"], [3, "click", "ngClass"], ["class", "po-slide-item-content", 4, "ngIf"], [1, "po-slide-item-content"], ["class", "po-slide-image", 3, "alt", "src", "height", 4, "ngIf"], [1, "po-slide-image", 3, "alt", "src"]],
    template: function PoSlideItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 3, 0);
        ɵɵtemplate(2, PoSlideItemComponent_a_2_Template, 2, 8, "a", 4)(3, PoSlideItemComponent_a_3_Template, 2, 8, "a", 5)(4, PoSlideItemComponent_a_4_Template, 2, 9, "a", 6);
        ɵɵelementEnd();
        ɵɵtemplate(5, PoSlideItemComponent_ng_template_5_Template, 1, 1, "ng-template", 7, 1, ɵɵtemplateRefExtractor)(7, PoSlideItemComponent_ng_template_7_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵstyleProp("background-image", !ctx.template && ctx.isIEOrEdge ? "url(" + ctx.image + ")" : "");
        ɵɵclassProp("po-slide-item-background-image", !ctx.template && ctx.isIEOrEdge);
        ɵɵproperty("ngSwitch", ctx.setLinkType());
        ɵɵadvance(2);
        ɵɵproperty("ngSwitchCase", "internalLink");
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", "externalLink");
        ɵɵadvance();
        ɵɵproperty("ngSwitchCase", "noLink");
      }
    },
    dependencies: [NgClass, NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, RouterLink],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideItemComponent, [{
    type: Component,
    args: [{
      selector: "po-slide-item",
      standalone: false,
      template: `<div
  #slideItem
  class="po-slide-item"
  [class.po-slide-item-background-image]="!template && isIEOrEdge"
  [style.background-image]="!template && isIEOrEdge ? 'url(' + image + ')' : ''"
  [ngSwitch]="setLinkType()"
>
  <!-- slide com link interno -->
  <a *ngSwitchCase="'internalLink'" class="po-slide-item-link" [routerLink]="link">
    <ng-container [ngTemplateOutlet]="slideItemImage" [ngTemplateOutletContext]="{ item: { alt: alt, image: image } }">
    </ng-container>
  </a>
  <!-- slide com link externo -->
  <a *ngSwitchCase="'externalLink'" class="po-slide-item-link" [href]="link">
    <ng-container [ngTemplateOutlet]="slideItemImage" [ngTemplateOutletContext]="{ item: { alt: alt, image: image } }">
    </ng-container>
  </a>
  <!-- slide sem link -->
  <a
    *ngSwitchCase="'noLink'"
    [ngClass]="action ? 'po-slide-item-link' : 'po-slide-item-no-link'"
    (click)="action ? action(data) : undefined"
  >
    <ng-container
      [ngTemplateOutlet]="template ? slideItemTemplate : slideItemImage"
      [ngTemplateOutletContext]="{ item: { alt: alt, image: image, data: data } }"
    >
    </ng-container>
  </a>
</div>

<ng-template #slideItemTemplate let-item="item" ; let-index="index">
  <div *ngIf="template" class="po-slide-item-content">
    <ng-template
      [ngTemplateOutlet]="template.templateRef"
      [ngTemplateOutletContext]="{ $implicit: item.data, index: index }"
    >
    </ng-template>
  </div>
</ng-template>

<ng-template #slideItemImage let-item="item">
  <img
    *ngIf="item.image && !isIEOrEdge"
    class="po-slide-image"
    [alt]="item.alt"
    [src]="item.image"
    [style.height.px]="imageHeight"
  />
</ng-template>
`
    }]
  }], null, {
    itemElement: [{
      type: ViewChild,
      args: ["slideItem", {
        static: true
      }]
    }],
    action: [{
      type: Input,
      args: ["p-action"]
    }],
    alt: [{
      type: Input,
      args: ["p-alt"]
    }],
    data: [{
      type: Input,
      args: ["p-data"]
    }],
    image: [{
      type: Input,
      args: ["p-image"]
    }],
    imageHeight: [{
      type: Input,
      args: ["p-image-height"]
    }],
    template: [{
      type: Input,
      args: ["p-template"]
    }],
    link: [{
      type: Input,
      args: ["p-link"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSlideItemComponent, {
    className: "PoSlideItemComponent",
    filePath: "lib/components/po-slide/po-slide-item/po-slide-item.component.ts",
    lineNumber: 19
  });
})();
var PoSlideControlComponent = class _PoSlideControlComponent {
  /** Tipo de controle que aceita os valores: 'previous' e 'next'. */
  control;
  /** Evento emitido ao clicar em um controle. */
  click = new EventEmitter();
  static ɵfac = function PoSlideControlComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSlideControlComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoSlideControlComponent,
    selectors: [["po-slide-control"]],
    inputs: {
      control: [0, "p-control", "control"]
    },
    outputs: {
      click: "p-click"
    },
    standalone: false,
    decls: 3,
    vars: 4,
    consts: [[1, "po-slide-arrow-circle", 3, "click"], [3, "p-icon"]],
    template: function PoSlideControlComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div")(1, "div", 0);
        ɵɵlistener("click", function PoSlideControlComponent_Template_div_click_1_listener() {
          return ctx.click.emit();
        });
        ɵɵelement(2, "po-icon", 1);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵclassMapInterpolate1("po-slide-control-", ctx.control, "");
        ɵɵadvance(2);
        ɵɵproperty("p-icon", ctx.control === "next" ? "ICON_ARROW_RIGHT" : "ICON_ARROW_LEFT");
      }
    },
    dependencies: [PoIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideControlComponent, [{
    type: Component,
    args: [{
      selector: "po-slide-control",
      standalone: false,
      template: `<div class="po-slide-control-{{ control }}">
  <div class="po-slide-arrow-circle" (click)="click.emit()">
    <po-icon [p-icon]="control === 'next' ? 'ICON_ARROW_RIGHT' : 'ICON_ARROW_LEFT'"></po-icon>
  </div>
</div>
`
    }]
  }], null, {
    control: [{
      type: Input,
      args: ["p-control"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSlideControlComponent, {
    className: "PoSlideControlComponent",
    filePath: "lib/components/po-slide/po-slide-control/po-slide-control.component.ts",
    lineNumber: 15
  });
})();
var _c0$c = ["slide"];
function PoSlideComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "po-slide-item", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-action", item_r1.action)("p-data", item_r1)("p-image", item_r1.image)("p-image-height", ctx_r1.imageHeight)("p-template", ctx_r1.slideContentTemplate)("p-alt", item_r1.alt)("p-link", item_r1.link);
  }
}
function PoSlideComponent_po_slide_control_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-slide-control", 9);
    ɵɵlistener("p-click", function PoSlideComponent_po_slide_control_5_Template_po_slide_control_p_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.previousControl());
    });
    ɵɵelementEnd();
  }
}
function PoSlideComponent_po_slide_control_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-slide-control", 10);
    ɵɵlistener("p-click", function PoSlideComponent_po_slide_control_6_Template_po_slide_control_p_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.nextControl());
    });
    ɵɵelementEnd();
  }
}
function PoSlideComponent_po_slide_circles_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-slide-circles", 11);
    ɵɵlistener("p-click", function PoSlideComponent_po_slide_circles_7_Template_po_slide_circles_p_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.goToItem($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-current-slide-index", ctx_r1.currentSlideIndex)("p-items", ctx_r1.slideItems);
  }
}
var poSlideDefaultHeight = 336;
var poSlideIntervalMin = 1e3;
var poSlideMinHeight = 192;
var poSlideTiming = "250ms ease";
var PoSlideComponent = class _PoSlideComponent extends PoSlideBaseComponent {
  builder;
  slideContentTemplate;
  slide;
  itemsElements;
  currentSlideIndex = 0;
  imageHeight;
  slideItems = [];
  slideItemWidth;
  isLoaded = false;
  player;
  setInterval;
  resize$ = new Subject();
  resizeSubscription;
  get hasElements() {
    return !!this.slide.nativeElement.offsetWidth && !!this.itemsElements && !!this.itemsElements.length;
  }
  get isImageSlide() {
    return !this.slideContentTemplate;
  }
  get offset() {
    return this.currentSlideIndex * this.slideItemWidth;
  }
  get hasSlides() {
    return !!this.slides && !!this.slides.length;
  }
  constructor(builder) {
    super();
    this.builder = builder;
  }
  onResize() {
    this.resize$.next({});
  }
  ngOnInit() {
    this.resizeSubscription = this.resize$.pipe(debounceTime(150)).subscribe(() => {
      this.setSlideItemWidth();
      this.goToItem(this.currentSlideIndex);
    });
  }
  ngDoCheck() {
    if (!this.isLoaded && this.hasElements) {
      this.setSlideItemWidth();
      this.isLoaded = true;
      if (this.hasSlides) {
        this.startSlide();
      }
    }
  }
  ngOnChanges(changes) {
    if (changes.height) {
      this.setSlideHeight(this.height);
    }
  }
  ngOnDestroy() {
    this.resizeSubscription?.unsubscribe();
  }
  /**
   * Método que retorna o index do slide atual
   *
   * ```
   * @ViewChild('slideComponent', { static: true }) slideComponent: PoSlideComponent;
   *  myFunction() {
   *    let currentIndex = this.slideComponent.getCurrentSlideIndex();
   * }
   *
   * ```
   */
  getCurrentSlideIndex() {
    return this.currentSlideIndex;
  }
  goToItem(index) {
    if (this.interval > poSlideIntervalMin) {
      this.startInterval();
    }
    this.currentSlideIndex = index;
    this.animate(this.offset);
  }
  nextControl() {
    if (this.interval > poSlideIntervalMin) {
      this.startInterval();
    }
    this.next();
  }
  /**
   * Método para chamar o próximo slide.
   *
   * ```
   * @ViewChild('slideComponent', { static: true }) slideComponent: PoSlideComponent;
   *
   * myFunction() {
   *  this.slideComponent.next();
   * }
   * ```
   */
  next() {
    if (this.currentSlideIndex + 1 === this.slideItems.length) {
      this.currentSlideIndex = 0;
      this.animate(0);
      return;
    }
    this.currentSlideIndex = (this.currentSlideIndex + 1) % this.slideItems.length;
    this.animate(this.offset);
  }
  /**
   * Método para chamar o slide anterior.
   *
   * ```
   * @ViewChild('slideComponent', { static: true }) slideComponent: PoSlideComponent;
   *
   * myFunction() {
   *  this.slideComponent.previous();
   * }
   * ```
   */
  previous() {
    if (this.currentSlideIndex === 0) {
      this.currentSlideIndex = this.slideItems.length - 1;
      this.animate(this.offset);
      return;
    }
    this.currentSlideIndex = (this.currentSlideIndex - 1 + this.slideItems.length) % this.slideItems.length;
    this.animate(this.offset);
  }
  previousControl() {
    if (this.interval > poSlideIntervalMin) {
      this.startInterval();
    }
    this.previous();
  }
  setSlideHeight(height) {
    this.setHeight(height);
  }
  cancelInterval() {
    clearInterval(this.setInterval);
  }
  setSlideItems(slides) {
    if (this.hasSlides) {
      this.slideContentTemplate ? this.createArrayForTemplate(slides) : this.createArrayFromSlides(slides);
    } else {
      this.slideItems = [];
      this.cancelInterval();
    }
  }
  startSlide() {
    this.setSlideHeight(this.height);
    if (this.interval > poSlideIntervalMin) {
      this.startInterval();
    }
    this.currentSlideIndex = 0;
  }
  startInterval() {
    if (this.setInterval) {
      this.cancelInterval();
    }
    this.setInterval = this.hasSlides && this.hasElements ? setInterval(() => {
      this.next();
    }, this.interval) : void 0;
  }
  animate(offset) {
    if (this.hasElements) {
      const animation = this.buildTransitionAnimation(offset);
      this.player = animation.create(this.slide.nativeElement);
      this.player.play();
    }
  }
  buildTransitionAnimation(offset) {
    return this.builder.build([animate(poSlideTiming, keyframes([style({
      transform: `translateX(-${offset}px)`
    })]))]);
  }
  createArrayForTemplate(slides) {
    this.slideItems = [...slides];
  }
  createArrayFromSlides(slides) {
    const isStringArray = slides.every((item) => typeof item === "string");
    if (isStringArray) {
      slides.forEach((element) => this.slideItems.push({
        image: `${element}`
      }));
    } else {
      this.slideItems = [...slides];
    }
  }
  setDefaultHeight(height) {
    if (height && height <= poSlideMinHeight || !height && this.isImageSlide) {
      this.slide.nativeElement.style.height = `${poSlideDefaultHeight}px`;
      this.imageHeight = poSlideDefaultHeight;
    } else {
      this.imageHeight = void 0;
    }
  }
  setHeight(height) {
    if (height && height > poSlideMinHeight) {
      this.slide.nativeElement.style.height = `${height}px`;
      this.imageHeight = height;
    } else {
      this.setDefaultHeight(height);
    }
  }
  setSlideItemWidth() {
    if (this.hasElements) {
      this.slideItemWidth = this.itemsElements.first.itemElement.nativeElement.getBoundingClientRect().width;
    }
  }
  static ɵfac = function PoSlideComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSlideComponent)(ɵɵdirectiveInject(AnimationBuilder));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoSlideComponent,
    selectors: [["po-slide"]],
    contentQueries: function PoSlideComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PoSlideContentTemplateDirective, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.slideContentTemplate = _t.first);
      }
    },
    viewQuery: function PoSlideComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$c, 7);
        ɵɵviewQuery(PoSlideItemComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.slide = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemsElements = _t);
      }
    },
    hostBindings: function PoSlideComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("resize", function PoSlideComponent_resize_HostBindingHandler() {
          return ctx.onResize();
        }, false, ɵɵresolveWindow);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 8,
    vars: 4,
    consts: [["slide", ""], [1, "po-slide-wrapper"], [1, "po-slide-outer"], [1, "po-slide-inner"], [4, "ngFor", "ngForOf"], ["p-control", "previous", 3, "p-click", 4, "ngIf"], ["p-control", "next", 3, "p-click", 4, "ngIf"], [3, "p-current-slide-index", "p-items", "p-click", 4, "ngIf"], [3, "p-action", "p-data", "p-image", "p-image-height", "p-template", "p-alt", "p-link"], ["p-control", "previous", 3, "p-click"], ["p-control", "next", 3, "p-click"], [3, "p-click", "p-current-slide-index", "p-items"]],
    template: function PoSlideComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 1)(1, "div", 2)(2, "div", 3, 0);
        ɵɵtemplate(4, PoSlideComponent_ng_container_4_Template, 2, 7, "ng-container", 4);
        ɵɵelementEnd();
        ɵɵtemplate(5, PoSlideComponent_po_slide_control_5_Template, 1, 0, "po-slide-control", 5)(6, PoSlideComponent_po_slide_control_6_Template, 1, 0, "po-slide-control", 6);
        ɵɵelementEnd();
        ɵɵtemplate(7, PoSlideComponent_po_slide_circles_7_Template, 1, 2, "po-slide-circles", 7);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(4);
        ɵɵproperty("ngForOf", ctx.slideItems);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.hideArrows && ctx.hasSlides && ctx.slides.length > 1);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.hideArrows && ctx.hasSlides && ctx.slides.length > 1);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasSlides && ctx.slides.length > 1);
      }
    },
    dependencies: [NgForOf, NgIf, PoSlideCirclesComponent, PoSlideControlComponent, PoSlideItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideComponent, [{
    type: Component,
    args: [{
      selector: "po-slide",
      standalone: false,
      template: '<div class="po-slide-wrapper">\n  <div class="po-slide-outer">\n    <div class="po-slide-inner" #slide>\n      <ng-container *ngFor="let item of slideItems; let index = index">\n        <po-slide-item\n          [p-action]="item.action"\n          [p-data]="item"\n          [p-image]="item.image"\n          [p-image-height]="imageHeight"\n          [p-template]="slideContentTemplate"\n          [p-alt]="item.alt"\n          [p-link]="item.link"\n        >\n        </po-slide-item>\n      </ng-container>\n    </div>\n\n    <po-slide-control\n      *ngIf="!hideArrows && hasSlides && slides.length > 1"\n      p-control="previous"\n      (p-click)="previousControl()"\n    >\n    </po-slide-control>\n\n    <po-slide-control *ngIf="!hideArrows && hasSlides && slides.length > 1" p-control="next" (p-click)="nextControl()">\n    </po-slide-control>\n  </div>\n\n  <po-slide-circles\n    *ngIf="hasSlides && slides.length > 1"\n    [p-current-slide-index]="currentSlideIndex"\n    [p-items]="slideItems"\n    (p-click)="goToItem($event)"\n  >\n  </po-slide-circles>\n</div>\n'
    }]
  }], () => [{
    type: AnimationBuilder
  }], {
    slideContentTemplate: [{
      type: ContentChild,
      args: [PoSlideContentTemplateDirective, {
        static: true
      }]
    }],
    slide: [{
      type: ViewChild,
      args: ["slide", {
        static: true
      }]
    }],
    itemsElements: [{
      type: ViewChildren,
      args: [PoSlideItemComponent]
    }],
    onResize: [{
      type: HostListener,
      args: ["window:resize"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSlideComponent, {
    className: "PoSlideComponent",
    filePath: "lib/components/po-slide/po-slide.component.ts",
    lineNumber: 65
  });
})();
var PoSlideModule = class _PoSlideModule {
  static ɵfac = function PoSlideModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoSlideModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoSlideModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, RouterModule, PoContainerModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, PoContainerModule, PoIconModule],
      declarations: [PoSlideCirclesComponent, PoSlideComponent, PoSlideControlComponent, PoSlideContentTemplateDirective, PoSlideItemComponent],
      exports: [PoSlideComponent, PoSlideContentTemplateDirective],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoSlideModule, {
    declarations: [PoSlideCirclesComponent, PoSlideComponent, PoSlideControlComponent, PoSlideContentTemplateDirective, PoSlideItemComponent],
    imports: [CommonModule, RouterModule, PoContainerModule, PoIconModule],
    exports: [PoSlideComponent, PoSlideContentTemplateDirective]
  });
})();
var PoStepperStatus;
(function(PoStepperStatus2) {
  PoStepperStatus2["Active"] = "active";
  PoStepperStatus2["Default"] = "default";
  PoStepperStatus2["Disabled"] = "disabled";
  PoStepperStatus2["Done"] = "done";
  PoStepperStatus2["Error"] = "error";
})(PoStepperStatus || (PoStepperStatus = {}));
var _c0$b = ["*"];
var PoStepComponent = class _PoStepComponent {
  elementRef;
  /**
   * @optional
   *
   * @description
   *
   * Função chamada quando o próximo *step* for clicado ou quando o método `PoStepperComponent.next()` for chamado.
   * Ao retornar `true` define que esse *step* ficará ativo e o atual como concluído (*done*).
   * Também aceita funções que retornem `Observable<boolean>`. Ao retornar um `Observable<boolean>`,
   * garanta que esse `Observable` será completado, caso houver algum erro durante o processo não será possível prosseguir
   * ao próximo *step*.
   *
   * Ao ser disparada, a mesma receberá por parâmetro o `PoStepComponent` atual.
   *
   * O contexto da função que será chamada, será o mesmo que o do `PoStepComponent`, então para poder alterar
   * para o contexto do componente que o está utilizando, pode ser utilizado a propriedade `bind` do Javascript.
   * Por exemplo, para a função `validate`:
   *
   * ```
   * <po-step p-label="Step 1" [p-can-active-next-step]="validate.bind(this)">
   * ...
   * </po-step>
   * ```
   */
  canActiveNextStep;
  /** Título que será exibido descrevendo o passo (*step*). */
  label = "";
  // ID do step
  id = uuid();
  _status = PoStepperStatus.Disabled;
  // Estado de exibição do `po-step`.
  set status(status) {
    this._status = status;
    this.setDisplayOnActiveOrError();
  }
  get status() {
    return this._status;
  }
  /**
   * @optional
   *
   * @description
   * Define o ícone padrão do step em seu status *default*.
   * Esta propriedade permite usar ícones da [Biblioteca de ícones](https://po-ui.io/icons).
   * ```
   * <po-stepper>
   *    ...
   *    <po-step p-icon-default="an an-map-pin"></po-step>
   * </po-stepper>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-stepper>
   *    ...
   *    <po-step [p-icon-default]="template"></po-step>
   * </po-stepper>
   *
   * <ng-template #template>
   *    <i class="an an-shopping-cart"></i>
   * </ng-template
   * ```
   * > Deve-se usar `font-size: inherit` para ajustar ícones que não se ajustam automaticamente.
   */
  iconDefault;
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
  ngAfterContentInit() {
    this.setDisplayOnActiveOrError();
  }
  setDisplayOnActiveOrError() {
    this.elementRef.nativeElement.style.display = this.status === PoStepperStatus.Active || this.status === PoStepperStatus.Error ? "" : "none";
  }
  static ɵfac = function PoStepComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoStepComponent)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoStepComponent,
    selectors: [["po-step"]],
    inputs: {
      canActiveNextStep: [0, "p-can-active-next-step", "canActiveNextStep"],
      label: [0, "p-label", "label"],
      status: [0, "p-status", "status"],
      iconDefault: [0, "p-icon-default", "iconDefault"]
    },
    standalone: false,
    ngContentSelectors: _c0$b,
    decls: 1,
    vars: 0,
    template: function PoStepComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepComponent, [{
    type: Component,
    args: [{
      selector: "po-step",
      standalone: false,
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [{
    type: ElementRef
  }], {
    canActiveNextStep: [{
      type: Input,
      args: ["p-can-active-next-step"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    status: [{
      type: Input,
      args: ["p-status"]
    }],
    iconDefault: [{
      type: Input,
      args: ["p-icon-default"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoStepComponent, {
    className: "PoStepComponent",
    filePath: "lib/components/po-stepper/po-step/po-step.component.ts",
    lineNumber: 50
  });
})();
var _c0$a = (a0, a1) => ({
  "po-stepper-circle-border": a0,
  "po-stepper-circle-done": a1
});
function PoStepperCircleComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 3);
    ɵɵelement(2, "po-icon", 4);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵclassProp("po-icon", true)("po-stepper-circle-content-lg", ctx_r0.isLargeStep)("po-stepper-circle-content-md", ctx_r0.isMediumStep);
    ɵɵproperty("p-icon", ctx_r0.iconActive ? ctx_r0.iconActive : "ICON_EDIT");
  }
}
function PoStepperCircleComponent_ng_template_2_po_icon_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-icon", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassProp("po-icon", ctx_r0.icons || ctx_r0.isDone)("po-stepper-circle-content-lg", ctx_r0.isLargeStep)("po-stepper-circle-content-md", ctx_r0.isMediumStep);
    ɵɵproperty("p-icon", ctx_r0.isDone ? ctx_r0.iconDone || "ICON_OK" : ctx_r0.iconDefault ? ctx_r0.iconDefault : ctx_r0.icons ? "ICON_INFO" : "");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", !ctx_r0.icons && !ctx_r0.isDone && !ctx_r0.iconDefault ? ctx_r0.content : "", " ");
  }
}
function PoStepperCircleComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoStepperCircleComponent_ng_template_2_po_icon_0_Template, 2, 8, "po-icon", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngIf", !ctx_r0.isActive);
  }
}
var poMediumStepSize = 32;
var poLargeStepSize = 48;
var PoStepperCircleComponent = class _PoStepperCircleComponent {
  // Alinhamento do *step*.
  alignCenter;
  // Conteúdo que irá aparecer no círculo do *step*.
  content;
  // Ícone para o status Active do *step*.
  iconActive;
  // Ícone para o status Done do *step*.
  iconDone;
  // Ícone para o status default do *step*.
  iconDefault;
  // Define se serão exibidos ícones no lugar de números nos steps.
  icons;
  // Tamanho do *step-circle*.
  size;
  // Status do *step*.
  status;
  get isActive() {
    return this.status === PoStepperStatus.Active;
  }
  get isDefault() {
    return this.status === PoStepperStatus.Default;
  }
  get isDisabled() {
    return this.status === PoStepperStatus.Disabled;
  }
  get isDone() {
    return this.status === PoStepperStatus.Done;
  }
  get isError() {
    return this.status === PoStepperStatus.Error;
  }
  get isLargeStep() {
    return this.size >= poLargeStepSize;
  }
  get isMediumStep() {
    return this.size >= poMediumStepSize && !this.isLargeStep;
  }
  static ɵfac = function PoStepperCircleComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoStepperCircleComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoStepperCircleComponent,
    selectors: [["po-stepper-circle"]],
    inputs: {
      alignCenter: [0, "p-align-center", "alignCenter"],
      content: [0, "p-content", "content"],
      iconActive: [0, "p-step-icon-active", "iconActive"],
      iconDone: [0, "p-step-icon-done", "iconDone"],
      iconDefault: [0, "p-icon-default", "iconDefault"],
      icons: [0, "p-icons", "icons"],
      size: [0, "p-size", "size"],
      status: [0, "p-status", "status"]
    },
    standalone: false,
    decls: 4,
    vars: 12,
    consts: [["defaultContent", ""], [1, "po-stepper-circle", 3, "ngClass"], [4, "ngIf", "ngIfElse"], [1, "po-stepper-circle-active"], [1, "po-stepper-circle-content", 3, "p-icon"], ["class", "po-stepper-circle-content", 3, "po-icon", "p-icon", "po-stepper-circle-content-lg", "po-stepper-circle-content-md", 4, "ngIf"]],
    template: function PoStepperCircleComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 1);
        ɵɵtemplate(1, PoStepperCircleComponent_ng_container_1_Template, 3, 7, "ng-container", 2)(2, PoStepperCircleComponent_ng_template_2_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        const defaultContent_r2 = ɵɵreference(3);
        ɵɵstyleProp("height", ctx.size, "px")("width", ctx.size, "px");
        ɵɵclassProp("po-stepper-circle-center", ctx.alignCenter);
        ɵɵproperty("ngClass", ɵɵpureFunction2(9, _c0$a, !ctx.isActive && !ctx.isError, ctx.isDone));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isActive || ctx.isError)("ngIfElse", defaultContent_r2);
      }
    },
    dependencies: [NgClass, NgIf, PoIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperCircleComponent, [{
    type: Component,
    args: [{
      selector: "po-stepper-circle",
      standalone: false,
      template: `<div
  class="po-stepper-circle"
  [class.po-stepper-circle-center]="alignCenter"
  [ngClass]="{ 'po-stepper-circle-border': !isActive && !isError, 'po-stepper-circle-done': isDone }"
  [style.height.px]="size"
  [style.width.px]="size"
>
  <ng-container *ngIf="isActive || isError; else defaultContent">
    <div class="po-stepper-circle-active">
      <po-icon
        class="po-stepper-circle-content"
        [class.po-icon]="true"
        [p-icon]="iconActive ? iconActive : 'ICON_EDIT'"
        [class.po-stepper-circle-content-lg]="isLargeStep"
        [class.po-stepper-circle-content-md]="isMediumStep"
      ></po-icon>
    </div>
  </ng-container>
  <ng-template #defaultContent>
    <po-icon
      *ngIf="!isActive"
      class="po-stepper-circle-content"
      [class.po-icon]="icons || isDone"
      [p-icon]="isDone ? iconDone || 'ICON_OK' : iconDefault ? iconDefault : icons ? 'ICON_INFO' : ''"
      [class.po-stepper-circle-content-lg]="isLargeStep"
      [class.po-stepper-circle-content-md]="isMediumStep"
    >
      {{ !icons && !isDone && !iconDefault ? content : '' }}
    </po-icon>
  </ng-template>
</div>
`
    }]
  }], null, {
    alignCenter: [{
      type: Input,
      args: ["p-align-center"]
    }],
    content: [{
      type: Input,
      args: ["p-content"]
    }],
    iconActive: [{
      type: Input,
      args: ["p-step-icon-active"]
    }],
    iconDone: [{
      type: Input,
      args: ["p-step-icon-done"]
    }],
    iconDefault: [{
      type: Input,
      args: ["p-icon-default"]
    }],
    icons: [{
      type: Input,
      args: ["p-icons"]
    }],
    size: [{
      type: Input,
      args: ["p-size"]
    }],
    status: [{
      type: Input,
      args: ["p-status"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoStepperCircleComponent, {
    className: "PoStepperCircleComponent",
    filePath: "lib/components/po-stepper/po-stepper-circle/po-stepper-circle.component.ts",
    lineNumber: 20
  });
})();
var PoStepperOrientation;
(function(PoStepperOrientation2) {
  PoStepperOrientation2["Horizontal"] = "horizontal";
  PoStepperOrientation2["Vertical"] = "vertical";
})(PoStepperOrientation || (PoStepperOrientation = {}));
var poStepperOrientationDefault = PoStepperOrientation.Horizontal;
var PoStepperBaseComponent = class _PoStepperBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * <a id="stepIconsProperty"></a>
   *
   * Habilita a exibição de ícone ao invés de número no centro do círculo dos *steps*.
   *
   * @default `false`
   */
  stepIcons;
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho dos *steps* em *pixels*, possibilitando um maior destaque.
   *
   * O valor informado deve ser entre `24` e `64`.
   *
   * > Valores que não se enquadrarem a esta regra serão ignorados, mantendo-se o valor *default*.
   *
   * @default `24`
   */
  stepSize;
  /** Ação que será executada quando o usuário mudar o passo do `po-stepper`. */
  onChangeStep = new EventEmitter();
  _alignCenter = true;
  _orientation = poStepperOrientationDefault;
  _sequential = true;
  _step = 1;
  _steps = [];
  /**
   * @optional
   *
   * @description
   *
   * Define o alinhamento dos *steps* e *labels* no *stepper*, dependendo da orientação.
   *
   * - Quando `true`, ficam centralizados em ambas as orientações (horizontal e vertical).
   * - Quando `false`, ficam alinhados à esquerda na orientação horizontal e ao topo na orientação vertical.
   *
   * @default `true`
   */
  set alignCenter(alignCenter) {
    this._alignCenter = convertToBoolean(alignCenter);
  }
  get alignCenter() {
    return this._alignCenter;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a orientação de exibição do `po-stepper`.
   *
   * > Veja os valores válidos no *enum* [PoStepperOrientation](documentation/po-stepper#stepperOrientation).
   *
   * @default `PoStepperOrientation.Horizontal`
   */
  set orientation(value) {
    this._orientation = Object.values(PoStepperOrientation).includes(value) ? value : poStepperOrientationDefault;
  }
  get orientation() {
    return this._orientation;
  }
  /**
   * @optional
   *
   * @description
   *
   * Controla o passo atual do `po-stepper`.
   *
   * > Ao utilizar esta propriedade e também utilizar o componente [**po-step**](/documentation/po-step),
   * o valor desta propriedade será ignorada permanecendo a definição do [**po-step**](/documentation/po-step).
   *
   * @default `1`
   */
  set step(step) {
    if (step >= 1 && step <= this.steps.length) {
      this._step = step;
      this._steps[this._step - 1].status = PoStepperStatus.Active;
    }
  }
  get step() {
    return this._step;
  }
  /**
   * @optional
   *
   * @description
   *
   * Lista dos itens do stepper. Se o valor estiver indefinido ou inválido, será inicializado como um array vazio.
   *
   * > Ao utilizar esta propriedade e também utilizar o componente [**po-step**](/documentation/po-step),
   * o valor desta propriedade será ignorada permanecendo a definição do [**po-step**](/documentation/po-step).
   */
  set steps(steps) {
    this._steps = Array.isArray(steps) ? steps : [];
    this._steps.forEach((step) => {
      step.status = step.status ?? PoStepperStatus.Default;
      step.id = step.id ?? uuid();
    });
    this.initializeSteps();
  }
  get steps() {
    return this._steps;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define se o `po-stepper` será sequencial ou aleatório.
   *
   * > Ao utilizar o componente [**po-step**](/documentation/po-step), o valor desta propriedade sempre será verdadeiro.
   *
   * @default `true`
   */
  set sequential(sequential) {
    this._sequential = convertToBoolean(sequential);
  }
  get sequential() {
    return this._sequential;
  }
  /**
   * @optional
   *
   * @description
   * Permite definir o ícone do step no status concluído.
   * Esta propriedade permite usar ícones da [Biblioteca de ícones](https://po-ui.io/icons)
   * ```
   * <po-stepper p-step-icon-done="an an-check-circle">
   *    ...
   * </po-stepper>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-stepper [p-step-icon-done]="doneIcon">
   *    ...
   * </po-stepper>
   *
   * <ng-template #doneIcon>
   *    <i class="an an-check-fat"></i>
   * </ng-template>
   * ```
   * > Deve-se usar `font-size: inherit` para ajustar ícones que não se ajustam automaticamente.
   *
   * @default `po-icon-ok`
   */
  iconDone;
  /**
   * @optional
   *
   * @description
   * Permite definir o ícone do step no status ativo.
   * Esta propriedade permite usar ícones da [Biblioteca de ícones](https://po-ui.io/icons).
   * ```
   * <po-stepper p-step-icon-active="an an-pencil-simple-line">
   *    ...
   * </po-stepper>
   * ```
   * Para customizar o ícone através do `TemplateRef`, veja a documentação da propriedade `p-step-icon-done`.
   *
   * > Deve-se usar `font-size: inherit` para ajustar ícones que não se ajustam automaticamente.
   *
   * @default `po-icon-edit`
   */
  iconActive;
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o clique nos steps.
   *
   * @default `false`
   */
  disabledClick = false;
  initializeSteps() {
    const hasStatus = this._steps.some((step) => step.status !== PoStepperStatus.Default);
    if (!hasStatus && this.step === 1) {
      this.step = 1;
    }
  }
  static ɵfac = function PoStepperBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoStepperBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoStepperBaseComponent,
    inputs: {
      stepIcons: [0, "p-step-icons", "stepIcons"],
      stepSize: [0, "p-step-size", "stepSize"],
      alignCenter: [0, "p-align-center", "alignCenter"],
      orientation: [0, "p-orientation", "orientation"],
      step: [0, "p-step", "step"],
      steps: [0, "p-steps", "steps"],
      sequential: [0, "p-sequential", "sequential"],
      iconDone: [0, "p-step-icon-done", "iconDone"],
      iconActive: [0, "p-step-icon-active", "iconActive"],
      disabledClick: [0, "p-disable-click", "disabledClick"]
    },
    outputs: {
      onChangeStep: "p-change-step"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperBaseComponent, [{
    type: Directive
  }], null, {
    stepIcons: [{
      type: Input,
      args: ["p-step-icons"]
    }],
    stepSize: [{
      type: Input,
      args: ["p-step-size"]
    }],
    onChangeStep: [{
      type: Output,
      args: ["p-change-step"]
    }],
    alignCenter: [{
      type: Input,
      args: ["p-align-center"]
    }],
    orientation: [{
      type: Input,
      args: ["p-orientation"]
    }],
    step: [{
      type: Input,
      args: ["p-step"]
    }],
    steps: [{
      type: Input,
      args: ["p-steps"]
    }],
    sequential: [{
      type: Input,
      args: ["p-sequential"]
    }],
    iconDone: [{
      type: Input,
      args: ["p-step-icon-done"]
    }],
    iconActive: [{
      type: Input,
      args: ["p-step-icon-active"]
    }],
    disabledClick: [{
      type: Input,
      args: ["p-disable-click"]
    }]
  });
})();
var _c0$9 = ["labelElement"];
var PoStepperLabelComponent = class _PoStepperLabelComponent {
  renderer;
  changeDetectorRef;
  // Alinhamento da label.
  alignCenter;
  // Conteúdo da label.
  content;
  // Informa o status da etapa.
  status;
  // Informa se a orientação do stepper é vertical.
  isVerticalOrientation;
  labelElement;
  disabledClick = false;
  displayedContent;
  tooltipContent;
  maxLabelLength = 100;
  constructor(renderer, changeDetectorRef) {
    this.renderer = renderer;
    this.changeDetectorRef = changeDetectorRef;
  }
  ngAfterViewInit() {
    this.updateLabel();
    this.changeDetectorRef.detectChanges();
  }
  ngOnChanges(changes) {
    if (changes["content"] || changes["isVerticalOrientation"]) {
      this.updateLabel();
      this.changeDetectorRef.detectChanges();
    }
  }
  onMouseOver() {
    this.updateTooltip();
    this.renderer.addClass(this.labelElement.nativeElement, "hovered");
  }
  onMouseOut() {
    this.renderer.removeClass(this.labelElement.nativeElement, "hovered");
  }
  updateLabel() {
    if (!this.labelElement) return;
    const originalContent = this.content;
    let displayedContent = originalContent;
    if (this.isVerticalOrientation && originalContent.length > this.maxLabelLength) {
      displayedContent = originalContent.substring(0, this.maxLabelLength) + "...";
    }
    this.displayedContent = displayedContent;
    this.updateTooltip();
  }
  updateTooltip() {
    if (this.labelElement) {
      const element = this.labelElement.nativeElement;
      const isTextOverflowing = element.scrollWidth > element.clientWidth;
      const isTextTooLong = this.isVerticalOrientation && this.content.length > this.maxLabelLength;
      this.tooltipContent = isTextOverflowing || isTextTooLong ? this.content : null;
    }
  }
  static ɵfac = function PoStepperLabelComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoStepperLabelComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoStepperLabelComponent,
    selectors: [["po-stepper-label"]],
    viewQuery: function PoStepperLabelComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$9, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.labelElement = _t.first);
      }
    },
    hostBindings: function PoStepperLabelComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("mouseover", function PoStepperLabelComponent_mouseover_HostBindingHandler() {
          return ctx.onMouseOver();
        })("mouseout", function PoStepperLabelComponent_mouseout_HostBindingHandler() {
          return ctx.onMouseOut();
        });
      }
    },
    inputs: {
      alignCenter: [0, "p-align-center", "alignCenter"],
      content: [0, "p-content", "content"],
      status: [0, "p-status", "status"],
      isVerticalOrientation: [0, "p-vertical-orientation", "isVerticalOrientation"],
      disabledClick: [0, "p-disable-click", "disabledClick"]
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature],
    decls: 3,
    vars: 14,
    consts: [["labelElement", ""], ["aria-hidden", "true", 1, "po-stepper-label", 3, "mouseover", "mouseout", "p-tooltip"]],
    template: function PoStepperLabelComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 1, 0);
        ɵɵlistener("mouseover", function PoStepperLabelComponent_Template_div_mouseover_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onMouseOver());
        })("mouseout", function PoStepperLabelComponent_Template_div_mouseout_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onMouseOut());
        });
        ɵɵtext(2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("po-link", ctx.status !== "disabled" && !ctx.disabledClick)("po-stepper-disabled-click", ctx.disabledClick)("po-stepper-label-active", ctx.status === "active" || ctx.status === "error")("po-stepper-label-done", ctx.status === "done")("po-stepper-label-vertical", ctx.isVerticalOrientation)("po-stepper-label-center", ctx.alignCenter);
        ɵɵproperty("p-tooltip", ctx.tooltipContent);
        ɵɵadvance(2);
        ɵɵtextInterpolate1(" ", ctx.displayedContent, "\n");
      }
    },
    dependencies: [PoTooltipDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperLabelComponent, [{
    type: Component,
    args: [{
      selector: "po-stepper-label",
      standalone: false,
      template: `<div
  #labelElement
  class="po-stepper-label"
  [class.po-link]="status !== 'disabled' && !this.disabledClick"
  [class.po-stepper-disabled-click]="this.disabledClick"
  [class.po-stepper-label-active]="status === 'active' || status === 'error'"
  [class.po-stepper-label-done]="status === 'done'"
  [class.po-stepper-label-vertical]="isVerticalOrientation"
  [class.po-stepper-label-center]="alignCenter"
  [p-tooltip]="tooltipContent"
  aria-hidden="true"
  (mouseover)="onMouseOver()"
  (mouseout)="onMouseOut()"
>
  {{ displayedContent }}
</div>
`
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }], {
    alignCenter: [{
      type: Input,
      args: ["p-align-center"]
    }],
    content: [{
      type: Input,
      args: ["p-content"]
    }],
    status: [{
      type: Input,
      args: ["p-status"]
    }],
    isVerticalOrientation: [{
      type: Input,
      args: ["p-vertical-orientation"]
    }],
    labelElement: [{
      type: ViewChild,
      args: ["labelElement"]
    }],
    disabledClick: [{
      type: Input,
      args: ["p-disable-click"]
    }],
    onMouseOver: [{
      type: HostListener,
      args: ["mouseover"]
    }],
    onMouseOut: [{
      type: HostListener,
      args: ["mouseout"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoStepperLabelComponent, {
    className: "PoStepperLabelComponent",
    filePath: "lib/components/po-stepper/po-stepper-label/po-stepper-label.component.ts",
    lineNumber: 26
  });
})();
function PoStepperStepComponent_po_stepper_label_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-stepper-label", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-align-center", ctx_r0.alignCenter)("p-content", ctx_r0.label)("p-status", ctx_r0.status)("p-vertical-orientation", ctx_r0.isVerticalOrientation)("p-disable-click", ctx_r0.disabledClick);
    ɵɵattribute("aria-label", ctx_r0.label);
  }
}
var poStepperStepSizeDefault = 24;
var poStepperStepSizeMax = 64;
var poStepLiteralsDefault = {
  en: {
    label: "Step"
  },
  es: {
    label: "Paso"
  },
  pt: {
    label: "Passo"
  }
};
var PoStepperStepComponent = class _PoStepperStepComponent {
  // Alinhamento do *step* e da label.
  alignCenter;
  // Conteúdo que será repassado para o componente `p-circle-content` através da propriedade `p-content`.
  circleContent;
  // Informa o status da próxima etapa.
  nextStatus;
  // Define a orientação de exibição.
  orientation;
  // Label do *step*.
  set label(value) {
    this._label = isTypeof(value, "string") ? value : `${this.literals.label} ${this.circleContent}`;
  }
  get label() {
    return this._label;
  }
  // Define o estado de exibição.
  set status(value) {
    this._status = value ? value : void 0;
    if (this.status === PoStepperStatus.Active) {
      this.activated.emit();
    }
  }
  get status() {
    return this._status;
  }
  set stepIcons(stepIcons) {
    this._stepIcons = convertToBoolean(stepIcons);
  }
  get stepIcons() {
    return this._stepIcons;
  }
  // Tamanho do `step` em *pixels*, possibilitando um maior destaque.
  // O valor informado deve ser entre `24` e `64`.
  set stepSize(value) {
    this._stepSize = value >= poStepperStepSizeDefault && value <= poStepperStepSizeMax ? value : poStepperStepSizeDefault;
  }
  get stepSize() {
    return this._stepSize;
  }
  set iconDefault(value) {
    this._iconDefault = value;
  }
  get iconDefault() {
    return this._iconDefault;
  }
  set iconDone(value) {
    this._iconDone = value;
  }
  get iconDone() {
    return this._iconDone;
  }
  set iconActive(value) {
    this._iconActive = value;
  }
  get iconActive() {
    return this._iconActive;
  }
  // Informa se a orientação do stepper é vertical.
  isVerticalOrientation;
  // Evento que será emitido quando o status do *step* estiver ativo (`PoStepperStatus.Active`).
  activated = new EventEmitter();
  // Evento que será emitido ao clicar no *step*.
  click = new EventEmitter();
  // Evento que será emitido ao focar no *step* e pressionar a tecla *enter*.
  enter = new EventEmitter();
  disabledClick = false;
  literals = __spreadValues(__spreadValues({}, poStepLiteralsDefault[poLocaleDefault]), poStepLiteralsDefault[getShortBrowserLanguage()]);
  stepSizeOriginal;
  _label;
  _status;
  _stepIcons = false;
  _stepSize = poStepperStepSizeDefault;
  _iconDefault;
  _iconDone;
  _iconActive;
  get minHeightCircle() {
    if (this.stepSize === 24) {
      return 32;
    }
    return this.isVerticalOrientation ? Math.max(this.stepSize, 24) + 8 : null;
  }
  get minWidthCircle() {
    if (this.isVerticalOrientation && this.stepSize === 24) {
      return 32;
    }
    return null;
  }
  ngOnChanges(changes) {
    if (this.stepSizeOriginal === void 0 || changes["stepSize"]) {
      this.stepSizeOriginal = this._stepSize;
    }
    if (changes["status"] || changes["stepSize"]) {
      this.setDefaultStepSize();
    }
  }
  getStatusClass(status) {
    switch (status) {
      case PoStepperStatus.Active:
        return "po-stepper-step-default";
      case PoStepperStatus.Disabled:
        return "po-stepper-step-disabled";
      case PoStepperStatus.Done:
        return "po-stepper-step-default";
      case PoStepperStatus.Error:
        return "po-stepper-step-error";
      default:
        return "po-stepper-step-default";
    }
  }
  onClick() {
    if (this.status !== PoStepperStatus.Disabled && !this.disabledClick) {
      this.click.emit();
    }
  }
  onEnter() {
    if (this.status !== PoStepperStatus.Disabled && !this.disabledClick) {
      this.enter.emit();
    }
  }
  setDefaultStepSize() {
    if (this._stepSize === poStepperStepSizeDefault && this._status === PoStepperStatus.Active) {
      this._stepSize = poStepperStepSizeDefault + 8;
    } else if (this.stepSizeOriginal === poStepperStepSizeDefault && (this._status === PoStepperStatus.Error || this._status === PoStepperStatus.Active)) {
      this._stepSize = poStepperStepSizeDefault + 8;
    } else {
      this._stepSize = this.stepSizeOriginal;
    }
  }
  static ɵfac = function PoStepperStepComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoStepperStepComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoStepperStepComponent,
    selectors: [["po-stepper-step"]],
    inputs: {
      alignCenter: [0, "p-align-center", "alignCenter"],
      circleContent: [0, "p-circle-content", "circleContent"],
      nextStatus: [0, "p-next-status", "nextStatus"],
      orientation: [0, "p-orientation", "orientation"],
      label: [0, "p-label", "label"],
      status: [0, "p-status", "status"],
      stepIcons: [0, "p-step-icons", "stepIcons"],
      stepSize: [0, "p-step-size", "stepSize"],
      iconDefault: [0, "p-icon-default", "iconDefault"],
      iconDone: [0, "p-step-icon-done", "iconDone"],
      iconActive: [0, "p-step-icon-active", "iconActive"],
      isVerticalOrientation: [0, "p-vertical-orientation", "isVerticalOrientation"],
      disabledClick: [0, "p-disable-click", "disabledClick"]
    },
    outputs: {
      activated: "p-activated",
      click: "p-click",
      enter: "p-enter"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature],
    decls: 4,
    vars: 26,
    consts: [["role", "tab", 1, "po-stepper-step", 3, "click", "keydown.enter", "ngClass", "tabindex"], [1, "po-stepper-step-container"], [3, "p-align-center", "p-content", "p-icons", "p-size", "p-status", "p-icon-default", "p-step-icon-done", "p-step-icon-active"], ["class", "po-stepper-step-label-position", 3, "p-align-center", "p-content", "p-status", "p-vertical-orientation", "p-disable-click", 4, "ngIf"], [1, "po-stepper-step-label-position", 3, "p-align-center", "p-content", "p-status", "p-vertical-orientation", "p-disable-click"]],
    template: function PoStepperStepComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵlistener("click", function PoStepperStepComponent_Template_div_click_0_listener() {
          return ctx.onClick();
        })("keydown.enter", function PoStepperStepComponent_Template_div_keydown_enter_0_listener() {
          return ctx.onEnter();
        });
        ɵɵelementStart(1, "div", 1);
        ɵɵelement(2, "po-stepper-circle", 2);
        ɵɵtemplate(3, PoStepperStepComponent_po_stepper_label_3_Template, 1, 6, "po-stepper-label", 3);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵclassProp("po-stepper-disabled-click", ctx.disabledClick);
        ɵɵproperty("ngClass", ctx.getStatusClass(ctx.status))("tabindex", ctx.status === "disabled" || ctx.disabledClick ? -1 : 0);
        ɵɵattribute("aria-selected", ctx.status === "active")("aria-disabled", ctx.status === "disabled")("aria-required", ctx.status === "error");
        ɵɵadvance(2);
        ɵɵstyleProp("min-width", ctx.minWidthCircle, "px")("min-height", ctx.minHeightCircle, "px");
        ɵɵclassProp("po-stepper-circle-vertical", ctx.isVerticalOrientation)("po-stepper-circle-vertical-center", ctx.alignCenter)("po-stepper-circle-horizontal", !ctx.isVerticalOrientation);
        ɵɵproperty("p-align-center", ctx.alignCenter)("p-content", ctx.circleContent)("p-icons", ctx.stepIcons)("p-size", ctx.stepSize)("p-status", ctx.status)("p-icon-default", ctx.iconDefault)("p-step-icon-done", ctx.iconDone)("p-step-icon-active", ctx.iconActive);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.label);
      }
    },
    dependencies: [NgClass, NgIf, PoStepperCircleComponent, PoStepperLabelComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperStepComponent, [{
    type: Component,
    args: [{
      selector: "po-stepper-step",
      standalone: false,
      template: `<div
  class="po-stepper-step"
  [ngClass]="getStatusClass(status)"
  role="tab"
  [tabindex]="status === 'disabled' || disabledClick ? -1 : 0"
  [attr.aria-selected]="status === 'active'"
  [attr.aria-disabled]="status === 'disabled'"
  [attr.aria-required]="status === 'error'"
  [class.po-stepper-disabled-click]="disabledClick"
  (click)="onClick()"
  (keydown.enter)="onEnter()"
>
  <div class="po-stepper-step-container">
    <po-stepper-circle
      [p-align-center]="alignCenter"
      [p-content]="circleContent"
      [p-icons]="stepIcons"
      [p-size]="stepSize"
      [p-status]="status"
      [p-icon-default]="iconDefault"
      [p-step-icon-done]="iconDone"
      [p-step-icon-active]="iconActive"
      [class.po-stepper-circle-vertical]="isVerticalOrientation"
      [class.po-stepper-circle-vertical-center]="alignCenter"
      [class.po-stepper-circle-horizontal]="!isVerticalOrientation"
      [style.minWidth.px]="minWidthCircle"
      [style.minHeight.px]="minHeightCircle"
    >
    </po-stepper-circle>

    <po-stepper-label
      *ngIf="label"
      class="po-stepper-step-label-position"
      [p-align-center]="alignCenter"
      [p-content]="label"
      [p-status]="status"
      [p-vertical-orientation]="isVerticalOrientation"
      [attr.aria-label]="label"
      [p-disable-click]="disabledClick"
    >
    </po-stepper-label>
  </div>
</div>
`
    }]
  }], null, {
    alignCenter: [{
      type: Input,
      args: ["p-align-center"]
    }],
    circleContent: [{
      type: Input,
      args: ["p-circle-content"]
    }],
    nextStatus: [{
      type: Input,
      args: ["p-next-status"]
    }],
    orientation: [{
      type: Input,
      args: ["p-orientation"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    status: [{
      type: Input,
      args: ["p-status"]
    }],
    stepIcons: [{
      type: Input,
      args: ["p-step-icons"]
    }],
    stepSize: [{
      type: Input,
      args: ["p-step-size"]
    }],
    iconDefault: [{
      type: Input,
      args: ["p-icon-default"]
    }],
    iconDone: [{
      type: Input,
      args: ["p-step-icon-done"]
    }],
    iconActive: [{
      type: Input,
      args: ["p-step-icon-active"]
    }],
    isVerticalOrientation: [{
      type: Input,
      args: ["p-vertical-orientation"]
    }],
    activated: [{
      type: Output,
      args: ["p-activated"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }],
    enter: [{
      type: Output,
      args: ["p-enter"]
    }],
    disabledClick: [{
      type: Input,
      args: ["p-disable-click"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoStepperStepComponent, {
    className: "PoStepperStepComponent",
    filePath: "lib/components/po-stepper/po-stepper-step/po-stepper-step.component.ts",
    lineNumber: 28
  });
})();
var _c0$8 = ["*"];
function PoStepperComponent_ng_container_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const step_r3 = ctx_r1.$implicit;
    const index_r4 = ctx_r1.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵstyleProp("left", ctx_r4.isVerticalOrientation ? !ctx_r4.stepSizeCircle || ctx_r4.stepSizeCircle === 24 ? 16 : ctx_r4.stepSizeCircle / 2 : null, "px");
    ɵɵclassProp("po-stepper-step-bar-top", ctx_r4.alignCenter && ctx_r4.isVerticalOrientation)("po-stepper-step-dashed-border-vertical", ctx_r4.alignCenter && ctx_r4.isVerticalOrientation && ctx_r4.isDashedBorderTop(step_r3, index_r4));
  }
}
function PoStepperComponent_ng_container_2_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const step_r3 = ctx_r1.$implicit;
    const index_r4 = ctx_r1.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵstyleProp("top", !ctx_r4.isVerticalOrientation ? ctx_r4.stepSizeCircle === 24 ? 16 : ctx_r4.stepSizeCircle / 2 : null, "px")("left", ctx_r4.isVerticalOrientation ? !ctx_r4.stepSizeCircle || ctx_r4.stepSizeCircle === 24 ? 16 : ctx_r4.stepSizeCircle / 2 : null, "px");
    ɵɵclassProp("po-stepper-step-bar-bottom", ctx_r4.isVerticalOrientation)("po-stepper-step-bar-bottom-center", ctx_r4.alignCenter && ctx_r4.isVerticalOrientation)("po-stepper-step-bar-right", !ctx_r4.isVerticalOrientation)("po-stepper-step-bar-center", ctx_r4.alignCenter && !ctx_r4.isVerticalOrientation)("po-stepper-step-dashed-border", !ctx_r4.isVerticalOrientation && ctx_r4.isDashedBorder(step_r3, index_r4))("po-stepper-step-dashed-border-vertical", ctx_r4.isVerticalOrientation && ctx_r4.isDashedBorder(step_r3, index_r4));
  }
}
function PoStepperComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 3);
    ɵɵtemplate(2, PoStepperComponent_ng_container_2_div_2_Template, 1, 6, "div", 4);
    ɵɵelementStart(3, "po-stepper-step", 5);
    ɵɵlistener("p-activated", function PoStepperComponent_ng_container_2_Template_po_stepper_step_p_activated_3_listener() {
      const step_r3 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onStepActive(step_r3));
    })("p-click", function PoStepperComponent_ng_container_2_Template_po_stepper_step_p_click_3_listener() {
      const ctx_r5 = ɵɵrestoreView(_r1);
      const step_r3 = ctx_r5.$implicit;
      const index_r4 = ctx_r5.index;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.changeStep(index_r4, step_r3));
    })("p-enter", function PoStepperComponent_ng_container_2_Template_po_stepper_step_p_enter_3_listener() {
      const ctx_r6 = ɵɵrestoreView(_r1);
      const step_r3 = ctx_r6.$implicit;
      const index_r4 = ctx_r6.index;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.changeStep(index_r4, step_r3));
    });
    ɵɵelementEnd();
    ɵɵtemplate(4, PoStepperComponent_ng_container_2_div_4_Template, 1, 16, "div", 6);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    let tmp_12_0;
    const step_r3 = ctx.$implicit;
    const index_r4 = ctx.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngIf", index_r4 > 0);
    ɵɵadvance();
    ɵɵclassProp("po-stepper-step-position-center", ctx_r4.alignCenter);
    ɵɵproperty("p-align-center", ctx_r4.alignCenter)("p-circle-content", index_r4 + 1)("p-label", step_r3.label)("p-orientation", ctx_r4.orientation)("p-status", step_r3.status)("p-step-icons", ctx_r4.stepIcons)("p-step-size", ctx_r4.stepSize)("p-next-status", (tmp_12_0 = ctx_r4.poSteps.get(index_r4 + 1)) == null ? null : tmp_12_0.status)("p-icon-default", step_r3.iconDefault)("p-step-icon-active", ctx_r4.iconActive)("p-step-icon-done", ctx_r4.iconDone)("p-vertical-orientation", ctx_r4.isVerticalOrientation)("p-disable-click", ctx_r4.disabledClick);
    ɵɵadvance();
    ɵɵproperty("ngIf", index_r4 < ctx_r4.stepList.length - 1);
  }
}
function PoStepperComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
}
var PoStepperComponent = class _PoStepperComponent extends PoStepperBaseComponent {
  changeDetector;
  poSteps;
  currentActiveStep;
  previousActiveStepIndex = null;
  get currentStepIndex() {
    return this.step - 1;
  }
  get isVerticalOrientation() {
    return this.orientation === "vertical";
  }
  get stepList() {
    return this.usePoSteps && this.poSteps || this.steps;
  }
  get stepSizeCircle() {
    return this.calculateDividerPosition();
  }
  get usePoSteps() {
    return !!this.poSteps.length;
  }
  constructor(changeDetector) {
    super();
    this.changeDetector = changeDetector;
  }
  ngAfterContentInit() {
    this.activeFirstStep();
    this.poSteps.changes.subscribe(() => {
      this.controlStepsStatus(this.poSteps.first);
    });
  }
  /**
   * Altera o status do *step* para ativo.
   *
   * > Este método é valido apenas para as implementações que utilizam o componente [**po-step**](/documentation/po-step).
   *
   * @param {number} index Índice do `po-step` que se deseja ativar.
   */
  active(index) {
    if (!this.usePoSteps) {
      return;
    }
    const stepsArray = this.getPoSteps();
    if (index < 0 || index >= stepsArray.length) {
      return;
    }
    const step = stepsArray[index];
    this.changeStep(index, step);
  }
  /**
   * Ativa o primeiro *step*.
   *
   * > Este método é valido apenas para as implementações que utilizam o componente [**po-step**](/documentation/po-step).
   */
  first() {
    if (!this.usePoSteps) {
      return;
    }
    const firstStep = this.poSteps.first;
    const firstStepIndex = 0;
    this.changeStep(firstStepIndex, firstStep);
  }
  /**
   * Ativa o próximo *step*.
   *
   * > Este método é valido apenas para as implementações que utilizam o componente [**po-step**](/documentation/po-step).
   */
  next() {
    if (!this.usePoSteps) {
      return;
    }
    const {
      steps,
      stepIndex
    } = this.getStepsAndIndex(this.currentActiveStep);
    const nextIndex = stepIndex + 1;
    if (nextIndex >= steps.length) {
      return;
    }
    const nextStep = steps[nextIndex];
    this.changeStep(nextIndex, nextStep);
  }
  /**
   * Ativa o *step* anterior.
   *
   * > Este método é valido apenas para as implementações que utilizam o componente [**po-step**](/documentation/po-step).
   */
  previous() {
    if (!this.usePoSteps) {
      return;
    }
    const {
      steps,
      stepIndex
    } = this.getStepsAndIndex(this.currentActiveStep);
    const previousIndex = stepIndex - 1;
    if (previousIndex < 0) {
      return;
    }
    const previousStep = steps[previousIndex];
    this.changeStep(previousIndex, previousStep);
  }
  changeStep(stepIndex, step) {
    if (!step || this.currentActiveStep && this.currentActiveStep.id === step.id) {
      return;
    }
    this.allowNextStep(stepIndex, step).pipe(take(1)).subscribe((nextStepAllowed) => {
      if (nextStepAllowed) {
        const isDifferentStep = !this.currentActiveStep || step.id !== this.currentActiveStep.id;
        if (this.usePoSteps && isDifferentStep) {
          this.controlStepsStatus(step);
          this.onChangeStep.emit(step);
        } else if (!this.usePoSteps && stepIndex !== this.currentStepIndex) {
          this.onChangeStep.emit(stepIndex + 1);
        }
      }
    });
  }
  getNextPoSteps(stepIndex) {
    const poSteps = this.getPoSteps();
    return poSteps[stepIndex + 1];
  }
  getNextSteps(stepIndex) {
    return this.steps[stepIndex + 1];
  }
  getPreviousPoSteps(stepIndex) {
    const poSteps = this.getPoSteps();
    return poSteps[stepIndex - 1];
  }
  getPreviousSteps(stepIndex) {
    return this.steps[stepIndex - 1];
  }
  isDashedBorder(step, index) {
    const nextStepPoSteps = this.getNextPoSteps(index);
    const nextStepSteps = this.getNextSteps(index);
    return !(step.status === "active" && (nextStepPoSteps?.status === "done" || nextStepSteps?.status === "done")) && step.status !== "done" && (this.usePoSteps || this.sequential);
  }
  isDashedBorderTop(step, index) {
    const previousStepPoSteps = this.getPreviousPoSteps(index);
    const getPreviousSteps = this.getPreviousSteps(index);
    return (step.status === "done" && previousStepPoSteps?.status !== "done" && previousStepPoSteps?.status !== "active" || step.status !== "done") && (step.status === "done" && getPreviousSteps?.status !== "done" && getPreviousSteps?.status !== "active" || step.status !== "done") && (step.status !== "active" || step.status === "active" && getPreviousSteps?.status === "error") && (step.status === "default" && getPreviousSteps?.status !== "done" || step.status === "disabled" || getPreviousSteps?.status !== "done") && previousStepPoSteps?.status !== "done" && (this.usePoSteps || this.sequential);
  }
  onStepActive(step) {
    this.currentActiveStep = step;
    const {
      stepIndex
    } = this.getStepsAndIndex(this.currentActiveStep);
    this.poSteps.forEach((stepChild, i) => {
      if (i < stepIndex) {
        stepChild.status = PoStepperStatus.Done;
      }
    });
  }
  trackByFn(step) {
    return step.id;
  }
  activeFirstStep() {
    const hasStepActive = this.poSteps.some((poStep) => poStep.status === PoStepperStatus.Active);
    if (this.usePoSteps && !hasStepActive) {
      this.changeStep(0, this.poSteps.first);
    }
  }
  allowNextStep(nextStepIndex, step) {
    if (!this.sequential) {
      return of(true);
    }
    if (this.hasStepWithCanActiveNextStep() && this.hasDefaultBeforeDone(nextStepIndex)) {
      return of(false);
    }
    const isAllowNextStep$ = this.checkAllowNextStep(nextStepIndex);
    return typeof isAllowNextStep$ === "boolean" ? of(isAllowNextStep$) : isAllowNextStep$;
  }
  canActiveNextStep(currentActiveStep = {}, nextStepIndex) {
    const isCurrentStep = this.isCurrentStep(nextStepIndex);
    if (!currentActiveStep.canActiveNextStep) {
      if (!isCurrentStep) {
        currentActiveStep.status = PoStepperStatus.Done;
      }
      return of(true);
    }
    const canActiveNextStep$ = this.getCanActiveNextStepObservable(currentActiveStep);
    return of(this.isBeforeStep(nextStepIndex)).pipe(mergeMap((isBefore) => {
      if (isBefore && !isCurrentStep) {
        return canActiveNextStep$.pipe(tap((isCanActiveNextStep) => {
          currentActiveStep.status = isCanActiveNextStep ? PoStepperStatus.Done : PoStepperStatus.Default;
        }), map(() => true));
      } else {
        return canActiveNextStep$;
      }
    }), tap((isCanActiveNextStep) => {
      if (!this.isBeforeStep(nextStepIndex) && !isCurrentStep) {
        this.updateStepStatus(currentActiveStep, isCanActiveNextStep);
      }
    }), catchError((err) => {
      currentActiveStep.status = PoStepperStatus.Error;
      return throwError(err);
    }));
  }
  checkAllowNextStep(nextStepIndex) {
    return this.usePoSteps ? this.canActiveNextStep(this.currentActiveStep, nextStepIndex) : of(this.steps.slice(this.step, nextStepIndex).every((step) => step.status === PoStepperStatus.Done));
  }
  getCanActiveNextStepObservable(currentActiveStep) {
    const canActiveNextStep = currentActiveStep.canActiveNextStep(currentActiveStep);
    return canActiveNextStep instanceof Observable ? canActiveNextStep : of(canActiveNextStep);
  }
  hasDefaultBeforeDone(nextStepIndex) {
    return this.getPoSteps().slice(this.step, nextStepIndex).some((step) => step.status === PoStepperStatus.Default);
  }
  isCurrentStep(stepIndex) {
    return this.currentActiveStep && this.getPoSteps().findIndex((step) => step.id === this.currentActiveStep.id) === stepIndex;
  }
  controlStepsStatus(step) {
    if (this.usePoSteps) {
      const {
        steps,
        stepIndex: currentStepIndex
      } = this.getStepsAndIndex(step);
      if (!this.hasStepWithCanActiveNextStep()) {
        this.updatePreviousStepStatus(steps, currentStepIndex);
      }
      this.setStepAsActive(step);
      this.handleNextStep(steps, currentStepIndex);
      this.previousActiveStepIndex = currentStepIndex;
      this.changeDetector.detectChanges();
    }
  }
  calculateDividerPosition() {
    return this.stepSize >= 24 && this.stepSize <= 64 ? this.stepSize : 24;
  }
  getStepperStatusByCanActive(canActiveNextStep) {
    return canActiveNextStep ? PoStepperStatus.Done : PoStepperStatus.Error;
  }
  getStepsAndIndex(step = {}) {
    const steps = this.getPoSteps();
    const stepIndex = steps.findIndex((poStep) => poStep.id === step.id);
    return {
      steps,
      stepIndex
    };
  }
  getPoSteps() {
    return this.poSteps.toArray();
  }
  handleNextStep(steps, currentStepIndex) {
    const nextStep = steps[currentStepIndex + 1];
    const currentStep = steps[currentStepIndex];
    const isNextStepDisabled = nextStep && nextStep.status === PoStepperStatus.Disabled;
    if (!this.hasStepWithCanActiveNextStep() && isNextStepDisabled) {
      this.setNextStepAsDefault(steps[currentStepIndex]);
      if (this.isBeforeStep(currentStepIndex)) {
        this.setFinalSteppersAsDisabled(currentStepIndex);
      }
    }
    if (this.hasStepWithCanActiveNextStep() && isNextStepDisabled) {
      this.setNextStepAsDefault(currentStep);
      this.setFinalSteppersAsDisabled(currentStepIndex);
    }
  }
  hasStepWithCanActiveNextStep() {
    return this.getPoSteps().some((step) => step.canActiveNextStep);
  }
  isBeforeStep(stepIndex) {
    const currentActiveStepIndex = () => this.getPoSteps().findIndex((step) => step.id === this.currentActiveStep.id);
    return !!this.currentActiveStep && currentActiveStepIndex() >= stepIndex;
  }
  setFinalSteppersAsDisabled(stepIndex) {
    this.getPoSteps().filter((step, index) => step && index >= stepIndex + 2).forEach((step) => step.status = PoStepperStatus.Disabled);
  }
  setStepAsActive(step) {
    step.status = PoStepperStatus.Active;
  }
  setNextStepAsDefault(currentStep) {
    const {
      steps,
      stepIndex
    } = this.getStepsAndIndex(currentStep);
    const nextIndex = stepIndex + 1;
    if (nextIndex < this.poSteps.length) {
      steps[nextIndex].status = PoStepperStatus.Default;
    }
  }
  updatePreviousStepStatus(steps, currentStepIndex) {
    if (this.previousActiveStepIndex !== null && this.previousActiveStepIndex !== currentStepIndex) {
      steps[this.previousActiveStepIndex].status = PoStepperStatus.Done;
    }
  }
  updateStepStatus(currentActiveStep, isCanActiveNextStep) {
    currentActiveStep.status = this.getStepperStatusByCanActive(isCanActiveNextStep);
  }
  static ɵfac = function PoStepperComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoStepperComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoStepperComponent,
    selectors: [["po-stepper"]],
    contentQueries: function PoStepperComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PoStepComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poSteps = _t);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0$8,
    decls: 4,
    vars: 9,
    consts: [["role", "tablist"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "po-stepper-content", 4, "ngIf"], [1, "po-stepper-step-wrapper"], [3, "po-stepper-step-bar-top", "po-stepper-step-dashed-border-vertical", "left", 4, "ngIf"], [3, "p-activated", "p-click", "p-enter", "p-align-center", "p-circle-content", "p-label", "p-orientation", "p-status", "p-step-icons", "p-step-size", "p-next-status", "p-icon-default", "p-step-icon-active", "p-step-icon-done", "p-vertical-orientation", "p-disable-click"], [3, "po-stepper-step-bar-bottom", "po-stepper-step-bar-bottom-center", "po-stepper-step-bar-right", "po-stepper-step-bar-center", "po-stepper-step-dashed-border", "po-stepper-step-dashed-border-vertical", "top", "left", 4, "ngIf"], [1, "po-stepper-content"]],
    template: function PoStepperComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div")(1, "div", 0);
        ɵɵtemplate(2, PoStepperComponent_ng_container_2_Template, 5, 17, "ng-container", 1);
        ɵɵelementEnd();
        ɵɵtemplate(3, PoStepperComponent_div_3_Template, 2, 0, "div", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMapInterpolate1("po-stepper-", ctx.orientation, "");
        ɵɵadvance();
        ɵɵclassMapInterpolate1("po-stepper-container-", ctx.orientation, "");
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.stepList)("ngForTrackBy", ctx.trackByFn);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.usePoSteps);
      }
    },
    dependencies: [NgForOf, NgIf, PoStepperStepComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperComponent, [{
    type: Component,
    args: [{
      selector: "po-stepper",
      standalone: false,
      template: '<div class="po-stepper-{{ orientation }}">\n  <div role="tablist" class="po-stepper-container-{{ orientation }}">\n    <ng-container *ngFor="let step of stepList; let index = index; trackBy: trackByFn">\n      <div class="po-stepper-step-wrapper">\n        <div\n          *ngIf="index > 0"\n          [class.po-stepper-step-bar-top]="alignCenter && isVerticalOrientation"\n          [class.po-stepper-step-dashed-border-vertical]="\n            alignCenter && isVerticalOrientation && isDashedBorderTop(step, index)\n          "\n          [style.left.px]="\n            isVerticalOrientation ? (!stepSizeCircle || stepSizeCircle === 24 ? 16 : stepSizeCircle / 2) : null\n          "\n        ></div>\n\n        <po-stepper-step\n          [class.po-stepper-step-position-center]="alignCenter"\n          [p-align-center]="alignCenter"\n          [p-circle-content]="index + 1"\n          [p-label]="step.label"\n          [p-orientation]="orientation"\n          [p-status]="step.status"\n          [p-step-icons]="stepIcons"\n          [p-step-size]="stepSize"\n          [p-next-status]="poSteps.get(index + 1)?.status"\n          [p-icon-default]="step.iconDefault"\n          [p-step-icon-active]="iconActive"\n          [p-step-icon-done]="iconDone"\n          [p-vertical-orientation]="isVerticalOrientation"\n          [p-disable-click]="disabledClick"\n          (p-activated)="onStepActive(step)"\n          (p-click)="changeStep(index, step)"\n          (p-enter)="changeStep(index, step)"\n        >\n        </po-stepper-step>\n\n        <div\n          *ngIf="index < stepList.length - 1"\n          [class.po-stepper-step-bar-bottom]="isVerticalOrientation"\n          [class.po-stepper-step-bar-bottom-center]="alignCenter && isVerticalOrientation"\n          [class.po-stepper-step-bar-right]="!isVerticalOrientation"\n          [class.po-stepper-step-bar-center]="alignCenter && !isVerticalOrientation"\n          [class.po-stepper-step-dashed-border]="!isVerticalOrientation && isDashedBorder(step, index)"\n          [class.po-stepper-step-dashed-border-vertical]="isVerticalOrientation && isDashedBorder(step, index)"\n          [style.top.px]="!isVerticalOrientation ? (stepSizeCircle === 24 ? 16 : stepSizeCircle / 2) : null"\n          [style.left.px]="\n            isVerticalOrientation ? (!stepSizeCircle || stepSizeCircle === 24 ? 16 : stepSizeCircle / 2) : null\n          "\n        ></div>\n      </div>\n    </ng-container>\n  </div>\n\n  <div *ngIf="usePoSteps" class="po-stepper-content">\n    <ng-content></ng-content>\n  </div>\n</div>\n'
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    poSteps: [{
      type: ContentChildren,
      args: [PoStepComponent]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoStepperComponent, {
    className: "PoStepperComponent",
    filePath: "lib/components/po-stepper/po-stepper.component.ts",
    lineNumber: 47
  });
})();
var PoStepperModule = class _PoStepperModule {
  static ɵfac = function PoStepperModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoStepperModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoStepperModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoIconModule, PoTooltipModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoIconModule, PoTooltipModule],
      declarations: [PoStepComponent, PoStepperCircleComponent, PoStepperComponent, PoStepperLabelComponent, PoStepperStepComponent],
      exports: [PoStepComponent, PoStepperComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoStepperModule, {
    declarations: [PoStepComponent, PoStepperCircleComponent, PoStepperComponent, PoStepperLabelComponent, PoStepperStepComponent],
    imports: [CommonModule, PoIconModule, PoTooltipModule],
    exports: [PoStepComponent, PoStepperComponent]
  });
})();
var _c0$7 = ["tabButtom"];
var _c1$2 = (a0) => ({
  "po-tab-focusable": a0
});
var _c2$1 = (a0, a1) => ({
  "po-tab-border-active": a0,
  "po-tab-border-disabled": a1
});
var PoTabButtonComponent = class _PoTabButtonComponent {
  elementRef;
  changeDetector;
  tabButtom;
  // Desabilita o botão
  disabled;
  // Identificador do componente
  id;
  // Rótulo do botão
  label;
  // Função sera emitida quando a tab ficar ativada
  activated = new EventEmitter();
  // Função sera emitida quando a tab ficar desabilitada ou escondida
  changeState = new EventEmitter();
  // Método recebido do usuário para ser disparado quando clicar na aba
  click = new EventEmitter();
  _active;
  _hide;
  widthButton;
  // Ativa o botão
  set active(value) {
    this._active = value;
    this.emitActivated();
  }
  get active() {
    return this._active;
  }
  // Oculta o botão
  set hide(value) {
    this._hide = convertToBoolean(value);
    this.setDisplayOnHide();
  }
  get hide() {
    return this._hide;
  }
  constructor(elementRef, changeDetector) {
    this.elementRef = elementRef;
    this.changeDetector = changeDetector;
  }
  ngAfterViewInit() {
    this.widthButton = this.tabButtom.nativeElement.offsetWidth;
    this.changeDetector.detectChanges();
  }
  ngOnChanges(changes) {
    if (changes.hide && changes.hide.currentValue || changes.disabled && changes.disabled.currentValue) {
      this.changeState.emit(this);
    }
  }
  onClick() {
    if (!this.disabled) {
      this.click.emit(this.id);
    }
  }
  emitActivated() {
    if (this.active) {
      this.activated.emit(this);
    }
  }
  setDisplayOnHide() {
    this.elementRef.nativeElement.style.display = this.hide ? "none" : "";
  }
  static ɵfac = function PoTabButtonComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTabButtonComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTabButtonComponent,
    selectors: [["po-tab-button"]],
    viewQuery: function PoTabButtonComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$7, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabButtom = _t.first);
      }
    },
    inputs: {
      disabled: [0, "p-disabled", "disabled"],
      id: [0, "p-id", "id"],
      label: [0, "p-label", "label"],
      active: [0, "p-active", "active"],
      hide: [0, "p-hide", "hide"]
    },
    outputs: {
      activated: "p-activated",
      changeState: "p-change-state",
      click: "p-click"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature],
    decls: 5,
    vars: 16,
    consts: [["tabButtom", ""], ["role", "tab", "p-tooltip-position", "top", 1, "po-tab-button-default", 3, "click", "keyup.enter", "p-tooltip", "id", "ngClass"], [1, "po-tab-button-label", "po-text-ellipsis"], [3, "ngClass"]],
    template: function PoTabButtonComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 1, 0);
        ɵɵlistener("click", function PoTabButtonComponent_Template_div_click_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onClick());
        })("keyup.enter", function PoTabButtonComponent_Template_div_keyup_enter_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onClick());
        });
        ɵɵelementStart(2, "span", 2);
        ɵɵtext(3);
        ɵɵelementEnd()();
        ɵɵelement(4, "div", 3);
      }
      if (rf & 2) {
        ɵɵclassProp("po-tab-button-active", ctx.active)("po-tab-button-disabled", ctx.disabled);
        ɵɵproperty("p-tooltip", ctx.widthButton > 239 ? ctx.label : "")("id", ctx.id)("ngClass", ɵɵpureFunction1(11, _c1$2, !ctx.disabled && !ctx.hide));
        ɵɵattribute("tabindex", ctx.disabled ? null : 0)("aria-selected", ctx.active);
        ɵɵadvance(3);
        ɵɵtextInterpolate1(" ", ctx.label, " ");
        ɵɵadvance();
        ɵɵproperty("ngClass", ɵɵpureFunction2(13, _c2$1, ctx.active, !ctx.active));
      }
    },
    dependencies: [NgClass, PoTooltipDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabButtonComponent, [{
    type: Component,
    args: [{
      selector: "po-tab-button",
      standalone: false,
      template: `<div
  #tabButtom
  role="tab"
  [p-tooltip]="widthButton > 239 ? label : ''"
  p-tooltip-position="top"
  class="po-tab-button-default"
  [id]="id"
  [ngClass]="{ 'po-tab-focusable': !disabled && !hide }"
  [attr.tabindex]="disabled ? null : 0"
  [attr.aria-selected]="active"
  [class.po-tab-button-active]="active"
  [class.po-tab-button-disabled]="disabled"
  (click)="onClick()"
  (keyup.enter)="onClick()"
>
  <span class="po-tab-button-label po-text-ellipsis">
    {{ label }}
  </span>
</div>
<div [ngClass]="{ 'po-tab-border-active': active, 'po-tab-border-disabled': !active }"></div>
`
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    tabButtom: [{
      type: ViewChild,
      args: ["tabButtom", {
        static: true
      }]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    id: [{
      type: Input,
      args: ["p-id"]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    activated: [{
      type: Output,
      args: ["p-activated"]
    }],
    changeState: [{
      type: Output,
      args: ["p-change-state"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }],
    active: [{
      type: Input,
      args: ["p-active"]
    }],
    hide: [{
      type: Input,
      args: ["p-hide"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTabButtonComponent, {
    className: "PoTabButtonComponent",
    filePath: "lib/components/po-tabs/po-tab-button/po-tab-button.component.ts",
    lineNumber: 28
  });
})();
var PoTabBaseComponent = class _PoTabBaseComponent {
  /** Rótulo da aba. */
  label;
  /** Método disparado ao clicar na aba. */
  click = new EventEmitter();
  // ID da aba
  id = uuid();
  _active = false;
  _disabled = false;
  _hide = false;
  widthButton;
  /**
   * @optional
   *
   * @description
   *
   * Ativa a aba exibindo seu conteúdo.
   *
   * > Sugere-se utilizar na aba de conteúdo inicial.
   *
   * @default `false`
   */
  set active(active) {
    this._active = convertToBoolean(active);
    this.setDisplayOnActive();
  }
  get active() {
    return this._active;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita a aba.
   *
   * @default `false`
   */
  set disabled(disabled) {
    this._disabled = convertToBoolean(disabled);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Oculta a aba.
   *
   * @default `false`
   */
  set hide(hide) {
    this._hide = convertToBoolean(hide);
  }
  get hide() {
    return this._hide;
  }
  static ɵfac = function PoTabBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTabBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTabBaseComponent,
    inputs: {
      label: [0, "p-label", "label"],
      active: [0, "p-active", "active"],
      disabled: [0, "p-disabled", "disabled"],
      hide: [0, "p-hide", "hide"]
    },
    outputs: {
      click: "p-click"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabBaseComponent, [{
    type: Directive
  }], null, {
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }],
    active: [{
      type: Input,
      args: ["p-active"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    hide: [{
      type: Input,
      args: ["p-hide"]
    }]
  });
})();
var PoTabsService = class _PoTabsService {
  onChangesTriggeredSource = new Subject();
  onChangesTriggeredActiveSource = new Subject();
  onChangesTriggered$ = this.onChangesTriggeredSource.asObservable();
  triggerActiveOnChanges$ = this.onChangesTriggeredActiveSource.asObservable();
  triggerOnChanges() {
    this.onChangesTriggeredSource.next();
  }
  triggerActiveOnChanges(tab) {
    this.onChangesTriggeredActiveSource.next(tab);
  }
  static ɵfac = function PoTabsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTabsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoTabsService,
    factory: _PoTabsService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _c0$6 = ["*"];
var PoTabComponent = class _PoTabComponent extends PoTabBaseComponent {
  elementRef;
  tabsService;
  constructor(elementRef, tabsService) {
    super();
    this.elementRef = elementRef;
    this.tabsService = tabsService;
  }
  ngAfterContentInit() {
    this.setDisplayOnActive();
  }
  ngOnChanges(changes) {
    setTimeout(() => {
      this.tabsService.triggerOnChanges();
      if (changes?.active?.currentValue) {
        this.tabsService.triggerActiveOnChanges(this);
      }
    }, 100);
  }
  setDisplayOnActive() {
    this.elementRef.nativeElement.style.display = this.active ? "" : "none";
  }
  static ɵfac = function PoTabComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTabComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoTabsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTabComponent,
    selectors: [["po-tab"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    ngContentSelectors: _c0$6,
    decls: 1,
    vars: 0,
    template: function PoTabComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabComponent, [{
    type: Component,
    args: [{
      selector: "po-tab",
      standalone: false,
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: PoTabsService
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTabComponent, {
    className: "PoTabComponent",
    filePath: "lib/components/po-tabs/po-tab/po-tab.component.ts",
    lineNumber: 14
  });
})();
var _c0$5 = ["popover"];
function PoTabDropdownComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 5)(1, "po-listbox", 6, 1);
    ɵɵlistener("p-activated-tabs", function PoTabDropdownComponent_div_3_Template_po_listbox_p_activated_tabs_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.activated.emit($event));
    })("p-change-state-tabs", function PoTabDropdownComponent_div_3_Template_po_listbox_p_change_state_tabs_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.changeState.emit($event));
    })("p-click-tabs", function PoTabDropdownComponent_div_3_Template_po_listbox_p_click_tabs_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      ctx_r2.closeDropdown();
      return ɵɵresetView(ctx_r2.click.emit($event));
    })("p-close", function PoTabDropdownComponent_div_3_Template_po_listbox_p_close_1_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.closeAndReturnToButtom());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r2.dropdownStyles);
    ɵɵadvance();
    ɵɵproperty("p-items", ctx_r2.tabs)("p-is-tabs", true);
  }
}
var PoTabDropdownComponent = class _PoTabDropdownComponent {
  elementRef;
  popover;
  button;
  // Rótulo do `po-tab-button`
  label;
  // Lista de abas
  tabs = [];
  // Evento que será emitido ao ativar uma aba
  activated = new EventEmitter();
  // Evento que será emitido a aba for desabilitada ou ocultada
  changeState = new EventEmitter();
  // Evento de click
  click = new EventEmitter();
  isDropdownOpen = false;
  dropdownStyles = {};
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
  ngAfterViewInit() {
    this.setDropdownPosition();
  }
  toggleDropdown() {
    this.isDropdownOpen = !this.isDropdownOpen;
    if (this.isDropdownOpen) {
      this.setDropdownPosition();
    }
  }
  closeAndReturnToButtom() {
    this.closeDropdown();
    this.button.focus();
  }
  closeDropdown() {
    this.isDropdownOpen = false;
  }
  get buttonElement() {
    return this.button.buttonElement;
  }
  setDropdownPosition() {
    const buttonRect = this.buttonElement.nativeElement.getBoundingClientRect();
    const tabsContainerRect = this.buttonElement.nativeElement.closest(".po-tabs-container").getBoundingClientRect();
    const dropdownWidth = 300;
    const isInsidePage = this.elementRef.nativeElement.closest(".po-page-content");
    this.dropdownStyles = this.calculateDropdownStyles(buttonRect, tabsContainerRect, dropdownWidth, isInsidePage);
  }
  calculateDropdownStyles(buttonRect, tabsContainerRect, dropdownWidth, isInsidePage) {
    if (isInsidePage) {
      return {
        top: `${tabsContainerRect.height + 4 + window.scrollY}px`,
        maxWidth: `${dropdownWidth}px`,
        right: `${tabsContainerRect.right - buttonRect.right}px`
      };
    }
    let rightPosition = tabsContainerRect.width - buttonRect.right;
    rightPosition = Math.max(0, rightPosition);
    return {
      top: `${tabsContainerRect.bottom + 4 + window.scrollY}px`,
      maxWidth: `${dropdownWidth}px`,
      right: `${rightPosition}px`
    };
  }
  onClickOutside(event) {
    if (this.isDropdownOpen && !this.elementRef.nativeElement.contains(event.target)) {
      this.closeDropdown();
    }
  }
  static ɵfac = function PoTabDropdownComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTabDropdownComponent)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTabDropdownComponent,
    selectors: [["po-tab-dropdown"]],
    viewQuery: function PoTabDropdownComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$5, 7);
        ɵɵviewQuery(PoButtonComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popover = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.button = _t.first);
      }
    },
    hostBindings: function PoTabDropdownComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function PoTabDropdownComponent_click_HostBindingHandler($event) {
          return ctx.onClickOutside($event);
        }, false, ɵɵresolveDocument);
      }
    },
    inputs: {
      label: [0, "p-label", "label"],
      tabs: [0, "p-tabs", "tabs"]
    },
    outputs: {
      activated: "p-activated",
      changeState: "p-change-state",
      click: "p-click"
    },
    standalone: false,
    decls: 4,
    vars: 2,
    consts: [["button", ""], ["listbox", "", "poListBoxRef", ""], [1, "po-tab-dropdown-content", "po-tab-button-default"], ["p-kind", "tertiary", "p-icon", "ICON_ARROW_DOWN", 3, "p-click", "p-aria-label"], ["class", "po-tab-dropdown-container", 3, "ngStyle", 4, "ngIf"], [1, "po-tab-dropdown-container", 3, "ngStyle"], ["p-type", "action", 3, "p-activated-tabs", "p-change-state-tabs", "p-click-tabs", "p-close", "p-items", "p-is-tabs"]],
    template: function PoTabDropdownComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 2)(1, "po-button", 3, 0);
        ɵɵlistener("p-click", function PoTabDropdownComponent_Template_po_button_p_click_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.toggleDropdown());
        });
        ɵɵelementEnd()();
        ɵɵtemplate(3, PoTabDropdownComponent_div_3_Template, 4, 3, "div", 4);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("p-aria-label", ctx.label);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.isDropdownOpen);
      }
    },
    dependencies: [NgIf, NgStyle, PoButtonComponent, PoListBoxComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabDropdownComponent, [{
    type: Component,
    args: [{
      selector: "po-tab-dropdown",
      standalone: false,
      template: '<div class="po-tab-dropdown-content po-tab-button-default">\n  <po-button #button p-kind="tertiary" [p-aria-label]="label" p-icon="ICON_ARROW_DOWN" (p-click)="toggleDropdown()">\n  </po-button>\n</div>\n\n<div class="po-tab-dropdown-container" *ngIf="isDropdownOpen" [ngStyle]="dropdownStyles">\n  <po-listbox\n    #listbox\n    #poListBoxRef\n    p-type="action"\n    [p-items]="tabs"\n    [p-is-tabs]="true"\n    (p-activated-tabs)="activated.emit($event)"\n    (p-change-state-tabs)="changeState.emit($event)"\n    (p-click-tabs)="closeDropdown(); click.emit($event)"\n    (p-close)="closeAndReturnToButtom()"\n  >\n  </po-listbox>\n</div>\n'
    }]
  }], () => [{
    type: ElementRef
  }], {
    popover: [{
      type: ViewChild,
      args: ["popover", {
        static: true
      }]
    }],
    button: [{
      type: ViewChild,
      args: [PoButtonComponent, {
        static: true
      }]
    }],
    label: [{
      type: Input,
      args: ["p-label"]
    }],
    tabs: [{
      type: Input,
      args: ["p-tabs"]
    }],
    activated: [{
      type: Output,
      args: ["p-activated"]
    }],
    changeState: [{
      type: Output,
      args: ["p-change-state"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }],
    onClickOutside: [{
      type: HostListener,
      args: ["document:click", ["$event"]]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTabDropdownComponent, {
    className: "PoTabDropdownComponent",
    filePath: "lib/components/po-tabs/po-tab-dropdown/po-tab-dropdown.component.ts",
    lineNumber: 29
  });
})();
var PoTabsBaseComponent = class _PoTabsBaseComponent {
  static ɵfac = function PoTabsBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTabsBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTabsBaseComponent
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabsBaseComponent, [{
    type: Directive
  }], null, null);
})();
var _c0$4 = ["tabDropdown"];
var _c1$1 = ["containerTabs"];
var _c2 = ["tabButton"];
var _c3 = ["*"];
function PoTabsComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "po-tab-button", 9, 1);
    ɵɵlistener("keyup.enter", function PoTabsComponent_ng_container_4_Template_po_tab_button_keyup_enter_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.closeListbox());
    })("p-activated", function PoTabsComponent_ng_container_4_Template_po_tab_button_p_activated_1_listener() {
      const tab_r3 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabActive(tab_r3));
    })("p-change-state", function PoTabsComponent_ng_container_4_Template_po_tab_button_p_change_state_1_listener() {
      const tab_r3 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabChangeState(tab_r3));
    })("p-click", function PoTabsComponent_ng_container_4_Template_po_tab_button_p_click_1_listener() {
      const tab_r3 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectedTab(tab_r3));
    });
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const tab_r3 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("p-active", tab_r3.active)("p-disabled", tab_r3.disabled)("p-hide", tab_r3.hide)("p-id", tab_r3.id)("hidden", tab_r3.hide)("p-label", tab_r3.label)("id", tab_r3.id);
    ɵɵattribute("disabled", tab_r3.disabled);
  }
}
function PoTabsComponent_po_tab_dropdown_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-tab-dropdown", 10, 2);
    ɵɵlistener("p-change-state", function PoTabsComponent_po_tab_dropdown_5_Template_po_tab_dropdown_p_change_state_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabChangeState($event));
    })("p-click", function PoTabsComponent_po_tab_dropdown_5_Template_po_tab_dropdown_p_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTabActiveByDropdown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-tab-dropdown-device", !(ctx_r1.tabsDefault == null ? null : ctx_r1.tabsDefault.length));
    ɵɵproperty("p-label", ctx_r1.literals.moreTabs)("p-tabs", ctx_r1.overflowedTabs);
  }
}
var poTabsLiterals = {
  en: {
    moreTabs: "More"
  },
  es: {
    moreTabs: "Más"
  },
  pt: {
    moreTabs: "Mais"
  },
  ru: {
    moreTabs: "Ещё"
  }
};
var poTabsMaxNumberOfTabs = 5;
var PoTabsComponent = class _PoTabsComponent extends PoTabsBaseComponent {
  changeDetector;
  languageService;
  tabsService;
  // Tabs utilizados no ng-content
  tabsChildren;
  tabButton;
  tabDropdown;
  containerTabs;
  maxNumberOfTabs = poTabsMaxNumberOfTabs;
  literals;
  tabsDefault = [];
  tabsDropdown = [];
  initializeCalculation = true;
  initializeComponent = false;
  quantityTabsButton;
  defaultLastTabWidth;
  previousActiveTab;
  subscription = new Subscription();
  subscriptionTabsService = new Subscription();
  subscriptionTabActive = new Subscription();
  constructor(changeDetector, languageService, tabsService) {
    super();
    this.changeDetector = changeDetector;
    this.languageService = languageService;
    this.tabsService = tabsService;
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues({}, poTabsLiterals[language]);
  }
  ngOnInit() {
    this.subscriptionTabsService = this.tabsService.onChangesTriggered$.subscribe(() => {
      this.updateTabsState();
      if (this.initializeComponent) {
        this.handleKeyboardNavigationTab();
      }
    });
    this.subscriptionTabActive = this.tabsService.triggerActiveOnChanges$.subscribe((tab) => {
      const isTabInDropdown = this.tabsDropdown.some((t) => t.id === tab.id);
      if (isTabInDropdown) {
        this.onTabActiveByDropdown(tab, false);
      }
    });
  }
  ngAfterViewInit() {
    this.calculateTabs(this.initializeCalculation);
    this.initializeCalculation = false;
    this.updateTabsState();
    this.changeDetector.detectChanges();
    this.handleKeyboardNavigationTab();
    this.initializeComponent = true;
  }
  ngAfterContentInit() {
    this.updateTabsState(true);
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
    this.subscriptionTabsService.unsubscribe();
    this.subscriptionTabActive.unsubscribe();
  }
  get isShowTabDropdown() {
    return this.tabsChildren["_results"].slice(this.quantityTabsButton).filter((item) => !item.hide).length;
  }
  // tabs que serão apresentadas na aba "Mais"
  get overflowedTabs() {
    return this.tabsChildren["_results"].slice(this.quantityTabsButton);
  }
  get tabs() {
    return this.tabsChildren["_results"].slice(0, this.quantityTabsButton);
  }
  get tabsChildrenArray() {
    return this.tabsChildren.toArray();
  }
  closeListbox() {
    if (this.tabDropdown && this.tabDropdown.isDropdownOpen) {
      this.tabDropdown.closeDropdown();
    }
  }
  isVisibleTab(tab) {
    return !tab.hide;
  }
  onTabActiveByDropdown(tab, eventEmitter = true) {
    this.changeTabPositionByDropdown(tab);
    const lastTabWidth = this.defaultLastTabWidth > 0 ? this.defaultLastTabWidth : this.tabsChildren.find((e) => e === this.tabsChildrenArray[this.quantityTabsButton - 1])?.widthButton;
    this.reorderTabs(tab);
    tab.widthButton = lastTabWidth;
    this.tabButton.last.nativeElement.style.width = `${lastTabWidth}px`;
    this.handleKeyboardNavigationTab();
    if (eventEmitter) {
      tab.click.emit(tab);
    }
  }
  // Função disparada quando alguma tab ficar ativa
  onTabActive(tab) {
    this.previousActiveTab = this.tabsChildren.find((tabChild) => tabChild.active && tabChild.id !== tab.id);
    this.deactivateTab();
  }
  // funcao será disparada quando mudar o estado do poTab para desabilitado ou escondido.
  onTabChangeState(tab) {
    if (tab.active) {
      tab.active = false;
      this.activeDistinctTab();
      this.changeDetector.detectChanges();
    }
  }
  reorderTabs(tabToReorder) {
    const tabsArray = this.tabsChildrenArray;
    const tabIndex = tabsArray.findIndex((item) => item.id === tabToReorder.id);
    if (tabIndex !== -1) {
      const [tab] = tabsArray.splice(tabIndex, 1);
      tabsArray.splice(this.quantityTabsButton - 1, 0, tab);
    }
    this.tabsChildren.reset(tabsArray);
    this.changeDetector.detectChanges();
  }
  // selectiona a aba informada por parametro, caso houver click faz a emição do evento.
  selectedTab(tab) {
    tab.active = true;
    if (tab.click) {
      tab.click.emit(tab);
    }
    const isTabInDropdown = this.overflowedTabs.some((t) => t.id === tab.id);
    if (isTabInDropdown) {
      this.onTabActiveByDropdown(tab);
    }
    this.changeDetector.detectChanges();
  }
  trackByFn(_i, tab) {
    return tab.id;
  }
  // ativa a previousActiveTab ou primeira tab encontrada.
  activeDistinctTab() {
    if (this.previousActiveTab) {
      this.previousActiveTab.active = true;
    } else {
      this.activeFirstTab();
    }
  }
  // Ativa a primeira Tab que não estiver desabilitada ou escondida.
  activeFirstTab() {
    this.tabs.some((tabChild) => {
      if (!tabChild.disabled && !tabChild.hide) {
        tabChild.active = true;
        return true;
      }
    });
  }
  // Movimenta a tab da visão de tabs para o dropdown, e vice-versa.
  changeTabPositionByDropdown(tabToActivate) {
    const lastTab = this.tabsDefault[this.tabsDefault.length - 1];
    this.tabsDefault = this.tabsDefault.filter((tab) => tab.id !== lastTab.id);
    this.tabsDefault.push(tabToActivate);
    const _tabsDropdown = this.tabsDropdown.filter((tab) => tab.id !== tabToActivate.id);
    _tabsDropdown.unshift(lastTab);
    this.tabsDropdown = _tabsDropdown;
    tabToActivate.active = true;
    this.onTabActive(tabToActivate);
  }
  // desativa previousActiveTab e dispara a detecção de mudança.
  deactivateTab() {
    if (this.previousActiveTab) {
      this.previousActiveTab.active = false;
      this.changeDetector.detectChanges();
    }
  }
  updateTabsState(initialState = false) {
    this.defaultLastTabWidth = this.tabButton?.last?.nativeElement?.getBoundingClientRect().width;
    if (this.defaultLastTabWidth <= 0) {
      return;
    }
    const lastTabChildren = this.tabsChildrenArray[this.quantityTabsButton - 1];
    if (lastTabChildren) {
      lastTabChildren.widthButton = this.defaultLastTabWidth;
    }
    if (this.tabsChildren) {
      const _tabsChildren = [...this.tabsChildrenArray];
      if (initialState) {
        this.tabsDefault = _tabsChildren;
      } else {
        this.tabsDefault = _tabsChildren.slice(0, this.quantityTabsButton);
        this.tabsDropdown = _tabsChildren.slice(this.quantityTabsButton);
      }
    }
  }
  calculateTabs(initializeCalculation) {
    if (initializeCalculation) {
      let sumOfWidth = 150;
      const screenSize = this.containerTabs.nativeElement.offsetWidth;
      const listTabButton = [];
      if (this.tabButton?.length) {
        this.tabButton.forEach((element) => {
          const width = element.nativeElement.offsetWidth;
          if (sumOfWidth + width <= screenSize || screenSize < 1) {
            listTabButton.push(element);
          }
          sumOfWidth += width;
        });
      }
      this.quantityTabsButton = listTabButton.length;
    }
  }
  handleKeyboardNavigationTab(initialIndex = 0) {
    this.subscription.unsubscribe();
    this.subscription = new Subscription();
    if (this.tabButton?.length) {
      const tabFocusable = this.tabButton.filter((element, index) => element.nativeElement.children[0]?.id === this.tabsChildren["_results"][index]?.id).map((el) => {
        if (el.nativeElement.children[0].classList.contains("po-tab-focusable")) {
          return el.nativeElement.children[0];
        }
      }).filter(Boolean);
      if (tabFocusable) {
        this.initializeTabAccessibilityElements(tabFocusable, initialIndex);
      }
    }
  }
  /**
   * Função que atribui o número de tabs fora do dropdown.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoTabsComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild('poTab', { static: true }) poTab: PoTabsComponent;
   *
   * changeQuantityTabs() {
   *   this.poTab.setQuantityTabsButton(1); //Número de tabs
   * }
   * ```
   */
  setQuantityTabsButton(number) {
    this.quantityTabsButton = number;
  }
  initializeTabAccessibilityElements(tabRemoveElements, initialIndex) {
    tabRemoveElements.forEach((tabRemoveElement, index) => {
      if (index === initialIndex) {
        this.setTabIndex(tabRemoveElements[initialIndex], 0);
      } else if (tabRemoveElements.length === initialIndex) {
        this.setTabIndex(tabRemoveElements[initialIndex - 1], 0);
      } else {
        this.setTabIndex(tabRemoveElement, -1);
      }
      this.subscription.add(fromEvent(tabRemoveElement, "keydown").subscribe((event) => {
        this.handleKeyDown(event, tabRemoveElements, index);
      }));
      if (index !== 0) {
        this.subscription.add(fromEvent(tabRemoveElements, "blur").subscribe(() => {
          this.setTabIndex(tabRemoveElements[index], -1);
          this.setTabIndex(tabRemoveElements[0], 0);
        }));
      }
    });
  }
  setTabIndex(element, tabIndex) {
    element.setAttribute("tabindex", tabIndex);
  }
  handleKeyDown(event, tabRemoveElements, index) {
    const KEY_SPACE = "Space";
    const KEY_ARROW_LEFT = "ArrowLeft";
    const KEY_ARROW_RIGHT = "ArrowRight";
    const KEY_HOME = "Home";
    const KEY_END = "End";
    if (event.code === KEY_SPACE || event.code === KEY_HOME || event.code === KEY_END) {
      event.preventDefault();
      event.stopPropagation();
    }
    if (event.key === KEY_ARROW_LEFT) {
      this.handleArrowLeft(tabRemoveElements, index);
    } else if (event.key === KEY_ARROW_RIGHT) {
      this.handleArrowRight(tabRemoveElements, index);
    } else if (event.key === KEY_HOME) {
      this.handleHomeKey(tabRemoveElements, index);
    } else if (event.key === KEY_END) {
      this.handleEndKey(tabRemoveElements, index);
    }
  }
  handleArrowLeft(tabRemoveElements, index) {
    if (index > 0) {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[index - 1].focus();
      this.setTabIndex(tabRemoveElements[index - 1], 0);
    } else {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[tabRemoveElements.length - 1].focus();
      this.setTabIndex(tabRemoveElements[tabRemoveElements.length - 1], 0);
    }
  }
  handleHomeKey(tabRemoveElements, index) {
    if (index > 0) {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[0].focus();
      this.setTabIndex(tabRemoveElements[0], 0);
    }
  }
  handleEndKey(tabRemoveElements, index) {
    if (index < tabRemoveElements.length - 1) {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[tabRemoveElements.length - 1].focus();
      this.setTabIndex(tabRemoveElements[tabRemoveElements.length - 1], 0);
    }
  }
  handleArrowRight(tabRemoveElements, index) {
    if (index < tabRemoveElements.length - 1) {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[index + 1].focus();
      this.setTabIndex(tabRemoveElements[index + 1], 0);
    } else {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[0].focus();
      this.setTabIndex(tabRemoveElements[0], 0);
    }
  }
  static ɵfac = function PoTabsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTabsComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(PoTabsService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTabsComponent,
    selectors: [["po-tabs"]],
    contentQueries: function PoTabsComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, PoTabComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabsChildren = _t);
      }
    },
    viewQuery: function PoTabsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$4, 7);
        ɵɵviewQuery(_c1$1, 7, ElementRef);
        ɵɵviewQuery(_c2, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabDropdown = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.containerTabs = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabButton = _t);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c3,
    decls: 8,
    vars: 3,
    consts: [["containerTabs", ""], ["tabButton", ""], ["tabDropdown", ""], [1, "po-tabs-container"], [1, "po-tabs-header"], ["role", "tablist", 1, "po-tabs-button-wrapper"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "po-tab-dropdown", 3, "po-tab-dropdown-device", "p-label", "p-tabs", "p-change-state", "p-click", 4, "ngIf"], [1, "po-tabs-content"], [1, "po-tab-button", 3, "keyup.enter", "p-activated", "p-change-state", "p-click", "p-active", "p-disabled", "p-hide", "p-id", "hidden", "p-label", "id"], [1, "po-tab-dropdown", 3, "p-change-state", "p-click", "p-label", "p-tabs"]],
    template: function PoTabsComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 3)(1, "div", 4, 0)(3, "div", 5);
        ɵɵtemplate(4, PoTabsComponent_ng_container_4_Template, 3, 8, "ng-container", 6)(5, PoTabsComponent_po_tab_dropdown_5_Template, 2, 4, "po-tab-dropdown", 7);
        ɵɵelementEnd()()();
        ɵɵelementStart(6, "div", 8);
        ɵɵprojection(7);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(4);
        ɵɵproperty("ngForOf", ctx.tabs)("ngForTrackBy", ctx.trackByFn);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isShowTabDropdown);
      }
    },
    dependencies: [NgForOf, NgIf, PoTabButtonComponent, PoTabDropdownComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabsComponent, [{
    type: Component,
    args: [{
      selector: "po-tabs",
      standalone: false,
      template: '<div class="po-tabs-container">\n  <div #containerTabs class="po-tabs-header">\n    <div class="po-tabs-button-wrapper" role="tablist">\n      <ng-container *ngFor="let tab of tabs; trackBy: trackByFn">\n        <po-tab-button\n          #tabButton\n          class="po-tab-button"\n          [p-active]="tab.active"\n          [p-disabled]="tab.disabled"\n          [p-hide]="tab.hide"\n          [p-id]="tab.id"\n          [hidden]="tab.hide"\n          [attr.disabled]="tab.disabled"\n          [p-label]="tab.label"\n          [id]="tab.id"\n          (keyup.enter)="closeListbox()"\n          (p-activated)="onTabActive(tab)"\n          (p-change-state)="onTabChangeState(tab)"\n          (p-click)="selectedTab(tab)"\n        >\n        </po-tab-button>\n      </ng-container>\n\n      <po-tab-dropdown\n        #tabDropdown\n        *ngIf="isShowTabDropdown"\n        class="po-tab-dropdown"\n        [class.po-tab-dropdown-device]="!tabsDefault?.length"\n        [p-label]="literals.moreTabs"\n        [p-tabs]="overflowedTabs"\n        (p-change-state)="onTabChangeState($event)"\n        (p-click)="onTabActiveByDropdown($event)"\n      >\n      </po-tab-dropdown>\n    </div>\n  </div>\n</div>\n<div class="po-tabs-content">\n  <ng-content></ng-content>\n</div>\n'
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: PoLanguageService
  }, {
    type: PoTabsService
  }], {
    tabsChildren: [{
      type: ContentChildren,
      args: [PoTabComponent]
    }],
    tabButton: [{
      type: ViewChildren,
      args: ["tabButton", {
        read: ElementRef
      }]
    }],
    tabDropdown: [{
      type: ViewChild,
      args: ["tabDropdown", {
        static: true
      }]
    }],
    containerTabs: [{
      type: ViewChild,
      args: ["containerTabs", {
        read: ElementRef,
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTabsComponent, {
    className: "PoTabsComponent",
    filePath: "lib/components/po-tabs/po-tabs.component.ts",
    lineNumber: 70
  });
})();
var PoTabsModule = class _PoTabsModule {
  static ɵfac = function PoTabsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTabsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoTabsModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoTabsService],
    imports: [CommonModule, PoPopoverModule, PoDropdownModule, PoTooltipModule, PoButtonModule, PoListBoxModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoPopoverModule, PoDropdownModule, PoTooltipModule, PoButtonModule, PoListBoxModule],
      declarations: [PoTabButtonComponent, PoTabComponent, PoTabDropdownComponent, PoTabsComponent],
      exports: [PoTabComponent, PoTabsComponent],
      providers: [PoTabsService]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTabsModule, {
    declarations: [PoTabButtonComponent, PoTabComponent, PoTabDropdownComponent, PoTabsComponent],
    imports: [CommonModule, PoPopoverModule, PoDropdownModule, PoTooltipModule, PoButtonModule, PoListBoxModule],
    exports: [PoTabComponent, PoTabsComponent]
  });
})();
var poToolbarActionsIconDefault = "ICON_MORE";
var PoToolbarActionsComponent = class _PoToolbarActionsComponent {
  /** Define uma lista de ações. */
  actions;
  _actionsIcon = poToolbarActionsIconDefault;
  /** Define o ícone das ações. */
  set actionsIcon(icon) {
    this._actionsIcon = isTypeof(icon, "string") || icon instanceof TemplateRef ? icon : poToolbarActionsIconDefault;
  }
  get actionsIcon() {
    return this._actionsIcon;
  }
  static ɵfac = function PoToolbarActionsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoToolbarActionsComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoToolbarActionsComponent,
    selectors: [["po-toolbar-actions"]],
    inputs: {
      actions: [0, "p-actions", "actions"],
      actionsIcon: [0, "p-actions-icon", "actionsIcon"]
    },
    standalone: false,
    decls: 6,
    vars: 3,
    consts: [["toolbarActions", ""], ["popup", ""], [1, "po-toolbar-actions", 3, "click"], [1, "po-toolbar-icon", "po-clickable", 3, "p-icon"], [3, "p-actions", "p-target"]],
    template: function PoToolbarActionsComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 2);
        ɵɵlistener("click", function PoToolbarActionsComponent_Template_div_click_0_listener() {
          ɵɵrestoreView(_r1);
          const popup_r2 = ɵɵreference(5);
          return ɵɵresetView(popup_r2.toggle());
        });
        ɵɵelementStart(1, "span", null, 0);
        ɵɵelement(3, "po-icon", 3);
        ɵɵelementEnd()();
        ɵɵelement(4, "po-popup", 4, 1);
      }
      if (rf & 2) {
        const toolbarActions_r3 = ɵɵreference(2);
        ɵɵadvance(3);
        ɵɵproperty("p-icon", ctx.actionsIcon);
        ɵɵadvance();
        ɵɵproperty("p-actions", ctx.actions)("p-target", toolbarActions_r3);
      }
    },
    dependencies: [PoPopupComponent, PoIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarActionsComponent, [{
    type: Component,
    args: [{
      selector: "po-toolbar-actions",
      standalone: false,
      template: '<div class="po-toolbar-actions" (click)="popup.toggle()">\n  <span #toolbarActions>\n    <po-icon class="po-toolbar-icon po-clickable" [p-icon]="actionsIcon"></po-icon>\n  </span>\n</div>\n\n<po-popup #popup [p-actions]="actions" [p-target]="toolbarActions"> </po-popup>\n'
    }]
  }], null, {
    actions: [{
      type: Input,
      args: ["p-actions"]
    }],
    actionsIcon: [{
      type: Input,
      args: ["p-actions-icon"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoToolbarActionsComponent, {
    className: "PoToolbarActionsComponent",
    filePath: "lib/components/po-toolbar/po-toolbar-actions/po-toolbar-actions.component.ts",
    lineNumber: 23
  });
})();
var PoToolbarBaseComponent = class _PoToolbarBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Define uma lista de ações que serão exibidas ao clicar no ícone declarado em `p-actions-icon`.
   */
  actions;
  /**
   * @optional
   *
   * @description
   *
   * Define um [ícone](https://po-ui.io/icons) para a propriedade `p-actions`.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](https://po-ui.io/icons). conforme exemplo abaixo:
   * ```
   * <po-toolbar p-actions-icon="an an-user" [p-actions]="actions"></po-toolbar>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-toolbar p-actions-icon="far fa-comment-alt" [p-actions]="actions"></po-toolbar>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-toolbar [p-actions-icon]="template" [p-actions]="actions"></po-toolbar>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   *
   * > Caso não haja ações definidas em `p-actions`, o ícone não será exibido.
   *
   * @default `an-dots-three`
   */
  actionsIcon;
  /** Define o objeto que será o cabeçalho da lista de ações com as informações do perfil. */
  profile;
  /** Define uma lista de ações que serão exibidas ao clicar no ícone do perfil. */
  profileActions;
  /** Se falso, oculta o ícone de notificações. */
  showNotification = true;
  /** Título do *toolbar* e aplicação. */
  title;
  /**
   * @optional
   *
   * @description
   *
   * Lista de ações da notificação.
   */
  notificationActions;
  _notificationNumber;
  /**
   * @optional
   *
   * @description
   *
   * Número de notificações.
   */
  set notificationNumber(value) {
    this._notificationNumber = convertToInt(value, 0);
  }
  get notificationNumber() {
    return this._notificationNumber;
  }
  get isShowProfile() {
    return !!(this.profile || this.profileActions);
  }
  static ɵfac = function PoToolbarBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoToolbarBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoToolbarBaseComponent,
    inputs: {
      actions: [0, "p-actions", "actions"],
      actionsIcon: [0, "p-actions-icon", "actionsIcon"],
      profile: [0, "p-profile", "profile"],
      profileActions: [0, "p-profile-actions", "profileActions"],
      showNotification: [0, "p-show-notification", "showNotification"],
      title: [0, "p-title", "title"],
      notificationActions: [0, "p-notification-actions", "notificationActions"],
      notificationNumber: [0, "p-notification-number", "notificationNumber"]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarBaseComponent, [{
    type: Directive
  }], null, {
    actions: [{
      type: Input,
      args: ["p-actions"]
    }],
    actionsIcon: [{
      type: Input,
      args: ["p-actions-icon"]
    }],
    profile: [{
      type: Input,
      args: ["p-profile"]
    }],
    profileActions: [{
      type: Input,
      args: ["p-profile-actions"]
    }],
    showNotification: [{
      type: Input,
      args: ["p-show-notification"]
    }],
    title: [{
      type: Input,
      args: ["p-title"]
    }],
    notificationActions: [{
      type: Input,
      args: ["p-notification-actions"]
    }],
    notificationNumber: [{
      type: Input,
      args: ["p-notification-number"]
    }]
  });
})();
var _c0$3 = ["notification"];
function PoToolbarNotificationComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.notificationNumber, " ");
  }
}
var PoToolbarNotificationComponent = class _PoToolbarNotificationComponent {
  cdr;
  notificationRef;
  notificationActions;
  _notificationNumber = 0;
  set notificationNumber(value) {
    this._notificationNumber = Number.isInteger(value) ? value : 0;
  }
  get notificationNumber() {
    return this._notificationNumber;
  }
  constructor(cdr) {
    this.cdr = cdr;
  }
  ngAfterViewInit() {
    this.cdr.detectChanges();
  }
  static ɵfac = function PoToolbarNotificationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoToolbarNotificationComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoToolbarNotificationComponent,
    selectors: [["po-toolbar-notification"]],
    viewQuery: function PoToolbarNotificationComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$3, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.notificationRef = _t.first);
      }
    },
    inputs: {
      notificationActions: [0, "p-notification-actions", "notificationActions"],
      notificationNumber: [0, "p-notification-number", "notificationNumber"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoControlPositionService])],
    decls: 6,
    vars: 3,
    consts: [["notification", ""], ["popup", ""], [1, "po-toolbar-notification", "po-clickable", 3, "click"], ["p-icon", "ICON_NOTIFICATION", 1, "po-toolbar-icon"], ["class", "po-toolbar-notification-badge", 4, "ngIf"], [3, "p-actions", "p-target"], [1, "po-toolbar-notification-badge"]],
    template: function PoToolbarNotificationComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 2);
        ɵɵlistener("click", function PoToolbarNotificationComponent_Template_div_click_0_listener() {
          ɵɵrestoreView(_r1);
          const popup_r2 = ɵɵreference(5);
          return ɵɵresetView(popup_r2.toggle());
        });
        ɵɵelement(1, "po-icon", 3, 0);
        ɵɵtemplate(3, PoToolbarNotificationComponent_div_3_Template, 2, 1, "div", 4);
        ɵɵelementEnd();
        ɵɵelement(4, "po-popup", 5, 1);
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.notificationNumber);
        ɵɵadvance();
        ɵɵproperty("p-actions", ctx.notificationActions)("p-target", ctx.notificationRef);
      }
    },
    dependencies: [NgIf, PoPopupComponent, PoIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarNotificationComponent, [{
    type: Component,
    args: [{
      selector: "po-toolbar-notification",
      providers: [PoControlPositionService],
      standalone: false,
      template: '<div class="po-toolbar-notification po-clickable" (click)="popup.toggle()">\n  <po-icon #notification p-icon="ICON_NOTIFICATION" class="po-toolbar-icon"></po-icon>\n  <div *ngIf="notificationNumber" class="po-toolbar-notification-badge">\n    {{ notificationNumber }}\n  </div>\n</div>\n\n<po-popup #popup [p-actions]="notificationActions" [p-target]="notificationRef"> </po-popup>\n'
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    notificationRef: [{
      type: ViewChild,
      args: ["notification", {
        read: ElementRef
      }]
    }],
    notificationActions: [{
      type: Input,
      args: ["p-notification-actions"]
    }],
    notificationNumber: [{
      type: Input,
      args: ["p-notification-number"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoToolbarNotificationComponent, {
    className: "PoToolbarNotificationComponent",
    filePath: "lib/components/po-toolbar/po-toolbar-notification/po-toolbar-notification.component.ts",
    lineNumber: 26
  });
})();
function PoToolbarProfileComponent_div_5_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.profile.subtitle, " ");
  }
}
function PoToolbarProfileComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵelement(1, "po-avatar", 7);
    ɵɵelementStart(2, "div")(3, "div", 8);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵtemplate(5, PoToolbarProfileComponent_div_5_div_5_Template, 2, 1, "div", 9);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-src", ctx_r2.profileAvatar);
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ctx_r2.profile.title, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.profile.subtitle);
  }
}
var PoToolbarProfileComponent = class _PoToolbarProfileComponent {
  /** Objeto que implementa a interface `PoToolbarProfile`. */
  profile;
  /** Define uma lista de ações. */
  profileActions;
  get profileAvatar() {
    return this.profile ? this.profile.avatar : void 0;
  }
  static ɵfac = function PoToolbarProfileComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoToolbarProfileComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoToolbarProfileComponent,
    selectors: [["po-toolbar-profile"]],
    inputs: {
      profile: [0, "p-profile", "profile"],
      profileActions: [0, "p-profile-actions", "profileActions"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PoControlPositionService])],
    decls: 6,
    vars: 4,
    consts: [["profileElement", ""], ["popup", ""], [1, "po-toolbar-profile", "po-clickable", 3, "click"], ["p-size", "xs", 3, "p-src"], [3, "p-actions", "p-target"], ["p-popup-header-template", "", "class", "po-toolbar-profile-item-header", 4, "ngIf"], ["p-popup-header-template", "", 1, "po-toolbar-profile-item-header"], ["p-size", "sm", 1, "po-toolbar-profile-item-avatar", 3, "p-src"], [1, "po-toolbar-profile-item-header-title"], ["class", "po-toolbar-profile-item-header-subtitle", 4, "ngIf"], [1, "po-toolbar-profile-item-header-subtitle"]],
    template: function PoToolbarProfileComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 2, 0);
        ɵɵlistener("click", function PoToolbarProfileComponent_Template_div_click_0_listener() {
          ɵɵrestoreView(_r1);
          const popup_r2 = ɵɵreference(4);
          return ɵɵresetView(popup_r2.toggle());
        });
        ɵɵelement(2, "po-avatar", 3);
        ɵɵelementEnd();
        ɵɵelementStart(3, "po-popup", 4, 1);
        ɵɵtemplate(5, PoToolbarProfileComponent_div_5_Template, 6, 3, "div", 5);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        const profileElement_r4 = ɵɵreference(1);
        ɵɵadvance(2);
        ɵɵproperty("p-src", ctx.profileAvatar);
        ɵɵadvance();
        ɵɵproperty("p-actions", ctx.profileActions)("p-target", profileElement_r4);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.profile == null ? null : ctx.profile.title);
      }
    },
    dependencies: [NgIf, PoAvatarComponent, PoPopupComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarProfileComponent, [{
    type: Component,
    args: [{
      selector: "po-toolbar-profile",
      providers: [PoControlPositionService],
      standalone: false,
      template: '<div #profileElement class="po-toolbar-profile po-clickable" (click)="popup.toggle()">\n  <po-avatar p-size="xs" [p-src]="profileAvatar"></po-avatar>\n</div>\n\n<po-popup #popup [p-actions]="profileActions" [p-target]="profileElement">\n  <div p-popup-header-template *ngIf="profile?.title" class="po-toolbar-profile-item-header">\n    <po-avatar class="po-toolbar-profile-item-avatar" p-size="sm" [p-src]="profileAvatar"> </po-avatar>\n\n    <div>\n      <div class="po-toolbar-profile-item-header-title">\n        {{ profile.title }}\n      </div>\n\n      <div *ngIf="profile.subtitle" class="po-toolbar-profile-item-header-subtitle">\n        {{ profile.subtitle }}\n      </div>\n    </div>\n  </div>\n</po-popup>\n'
    }]
  }], null, {
    profile: [{
      type: Input,
      args: ["p-profile"]
    }],
    profileActions: [{
      type: Input,
      args: ["p-profile-actions"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoToolbarProfileComponent, {
    className: "PoToolbarProfileComponent",
    filePath: "lib/components/po-toolbar/po-toolbar-profile/po-toolbar-profile.component.ts",
    lineNumber: 23
  });
})();
function PoToolbarComponent_po_toolbar_actions_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-toolbar-actions", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-actions", ctx_r0.actions)("p-actions-icon", ctx_r0.actionsIcon);
  }
}
function PoToolbarComponent_po_toolbar_notification_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-toolbar-notification", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-notification-actions", ctx_r0.notificationActions)("p-notification-number", ctx_r0.notificationNumber);
  }
}
function PoToolbarComponent_po_toolbar_profile_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-toolbar-profile", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-profile", ctx_r0.profile)("p-profile-actions", ctx_r0.profileActions);
  }
}
var PoToolbarComponent = class _PoToolbarComponent extends PoToolbarBaseComponent {
  titleService;
  constructor(titleService, viewRef) {
    super();
    this.titleService = titleService;
  }
  ngOnInit() {
    this.setTitle(this.title);
  }
  setTitle(newTitle) {
    this.titleService.setTitle(newTitle);
  }
  static ɵfac = function PoToolbarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoToolbarComponent)(ɵɵdirectiveInject(Title), ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoToolbarComponent,
    selectors: [["po-toolbar"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 7,
    vars: 4,
    consts: [[1, "po-toolbar"], [1, "po-toolbar-title"], [1, "po-toolbar-group-icon"], [3, "p-actions", "p-actions-icon", 4, "ngIf"], [3, "p-notification-actions", "p-notification-number", 4, "ngIf"], [3, "p-profile", "p-profile-actions", 4, "ngIf"], [3, "p-actions", "p-actions-icon"], [3, "p-notification-actions", "p-notification-number"], [3, "p-profile", "p-profile-actions"]],
    template: function PoToolbarComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "div", 1);
        ɵɵtext(2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "div", 2);
        ɵɵtemplate(4, PoToolbarComponent_po_toolbar_actions_4_Template, 1, 2, "po-toolbar-actions", 3)(5, PoToolbarComponent_po_toolbar_notification_5_Template, 1, 2, "po-toolbar-notification", 4)(6, PoToolbarComponent_po_toolbar_profile_6_Template, 1, 2, "po-toolbar-profile", 5);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.title);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.actions && ctx.actions.length);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showNotification && ctx.notificationActions);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isShowProfile);
      }
    },
    dependencies: [NgIf, PoToolbarActionsComponent, PoToolbarNotificationComponent, PoToolbarProfileComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarComponent, [{
    type: Component,
    args: [{
      selector: "po-toolbar",
      standalone: false,
      template: '<div class="po-toolbar">\n  <div class="po-toolbar-title">{{ title }}</div>\n\n  <div class="po-toolbar-group-icon">\n    <po-toolbar-actions *ngIf="actions && actions.length" [p-actions]="actions" [p-actions-icon]="actionsIcon">\n    </po-toolbar-actions>\n\n    <po-toolbar-notification\n      *ngIf="showNotification && notificationActions"\n      [p-notification-actions]="notificationActions"\n      [p-notification-number]="notificationNumber"\n    >\n    </po-toolbar-notification>\n\n    <po-toolbar-profile *ngIf="isShowProfile" [p-profile]="profile" [p-profile-actions]="profileActions">\n    </po-toolbar-profile>\n  </div>\n</div>\n'
    }]
  }], () => [{
    type: Title
  }, {
    type: ViewContainerRef
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoToolbarComponent, {
    className: "PoToolbarComponent",
    filePath: "lib/components/po-toolbar/po-toolbar.component.ts",
    lineNumber: 31
  });
})();
var PoToolbarModule = class _PoToolbarModule {
  static ɵfac = function PoToolbarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoToolbarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoToolbarModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoAvatarModule, PoPopupModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoAvatarModule, PoPopupModule, PoIconModule],
      declarations: [PoToolbarActionsComponent, PoToolbarComponent, PoToolbarNotificationComponent, PoToolbarProfileComponent],
      exports: [PoToolbarComponent],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoToolbarModule, {
    declarations: [PoToolbarActionsComponent, PoToolbarComponent, PoToolbarNotificationComponent, PoToolbarProfileComponent],
    imports: [CommonModule, PoAvatarModule, PoPopupModule, PoIconModule],
    exports: [PoToolbarComponent]
  });
})();
var poTreeViewMaxLevel = 4;
var PoTreeViewBaseComponent = class _PoTreeViewBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Ação que será disparada ao colapsar um item.
   *
   * > Como parâmetro o componente envia o item colapsado.
   */
  collapsed = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que será disparada ao expandir um item.
   *
   * > Como parâmetro o componente envia o item expandido.
   */
  expanded = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que será disparada ao selecionar um item.
   *
   * > Como parâmetro o componente envia o item selecionado.
   */
  selected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que será disparada ao desfazer a seleção de um item.
   *
   * > Como parâmetro o componente envia o item que foi desmarcado.
   */
  unselected = new EventEmitter();
  _items = [];
  _selectable = false;
  _maxLevel = poTreeViewMaxLevel;
  _singleSelect = false;
  // armazena o value do item selecionado
  selectedValue;
  /**
   * Lista de itens do tipo `PoTreeViewItem` que será renderizada pelo componente.
   */
  inputedItems;
  set items(value) {
    this._items = Array.isArray(value) ? this.getItemsByMaxLevel(value) : [];
  }
  get items() {
    return this._items;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita uma caixa de seleção para selecionar e/ou desmarcar um item da lista.
   *
   * @default false
   */
  set selectable(value) {
    this._selectable = convertToBoolean(value);
  }
  get selectable() {
    return this._selectable;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita a seleção para item único atráves de po-radio.
   *
   * @default false
   */
  set singleSelect(value) {
    this._singleSelect = convertToBoolean(value);
  }
  get singleSelect() {
    return this._singleSelect;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o máximo de níveis para o tree-view.
   *
   * > O valor padrão é 4
   *
   * @default 4
   */
  set maxLevel(value) {
    this._maxLevel = convertToInt(value, poTreeViewMaxLevel);
  }
  get maxLevel() {
    return this._maxLevel;
  }
  emitExpanded(treeViewItem) {
    const event = treeViewItem.expanded ? "expanded" : "collapsed";
    this[event].emit(__spreadValues({}, treeViewItem));
  }
  emitSelected(treeViewItem) {
    const event = treeViewItem.selected ? "selected" : "unselected";
    this.selectedValue = treeViewItem.value;
    const _a = treeViewItem, {
      subItems
    } = _a, rest = __objRest(_a, [
      "subItems"
    ]);
    const treeViewToEmit = this.singleSelect ? __spreadValues({}, rest) : treeViewItem;
    this.updateItemsOnSelect(treeViewToEmit);
    this[event].emit(__spreadValues({}, treeViewToEmit));
  }
  addChildItemInParent(childItem, parentItem) {
    if (!parentItem.subItems) {
      parentItem.subItems = [];
    }
    parentItem.subItems.push(childItem);
  }
  // caso houver parentItem:
  //  - expande o parentItem caso o filho estiver expandido;
  //  - adiciona o childItem no parentItem;
  //  - marca o parentItem caso conter subItems marcodos ou nulos;
  // Se não conter parentItem, adiciona o childItem no items.
  addItem(items, childItem, parentItem, isNewItem) {
    if (parentItem) {
      if (isNewItem) {
        this.expandParentItem(childItem, parentItem);
      }
      this.addChildItemInParent(childItem, parentItem);
      if (!this.singleSelect) {
        this.selectItemBySubItems(parentItem);
      }
      items.push(parentItem);
    } else {
      items.push(childItem);
    }
  }
  selectAllItems(items, isSelected) {
    items.forEach((item) => {
      if (item.subItems) {
        this.selectAllItems(item.subItems, isSelected);
      }
      item.selected = item.isSelectable !== false ? isSelected : false;
    });
  }
  selectItemBySubItems(item) {
    item.selected = this.everyItemSelected(item.subItems);
  }
  // retornará:
  //  - true: se todos os items estiverem marcados;
  //  - null: se no minimo um item esteja marcado ou nullo (indeterminate)
  //  - false: caso não corresponda em nenhuma das opções acima, no caso, nenhum marcado ou nulo;
  everyItemSelected(items = []) {
    const itemsLength = items.length;
    const lengthCheckedItems = items.filter((item) => item.selected).length;
    if (itemsLength && itemsLength === lengthCheckedItems) {
      return true;
    }
    const hasIndeterminateItems = items.filter((item) => item.selected || item.selected === null).length;
    if (hasIndeterminateItems) {
      return null;
    }
    return false;
  }
  // expande o item pai caso o filho estiver expandido.
  expandParentItem(childItem, parentItem) {
    if (childItem.expanded) {
      parentItem.expanded = true;
    }
  }
  getItemsByMaxLevel(items = [], level = 0, parentItem, newItems = []) {
    items.forEach((item) => {
      const _a = item, {
        subItems
      } = _a, currentItem = __objRest(_a, [
        "subItems"
      ]);
      if (level === this.maxLevel) {
        return;
      }
      if (Array.isArray(subItems)) {
        if (currentItem.selected) {
          this.selectAllItems(subItems, currentItem.selected);
        }
        this.getItemsByMaxLevel(subItems, ++level, currentItem);
        --level;
      }
      if (item.selected) {
        this.selectedValue = currentItem.value;
      }
      this.addItem(newItems, currentItem, parentItem, true);
    });
    return newItems;
  }
  getItemsWithParentSelected(items = [], parentItem, newItems = []) {
    items.forEach((item) => {
      const _a = item, {
        subItems
      } = _a, currentItem = __objRest(_a, [
        "subItems"
      ]);
      if (Array.isArray(subItems)) {
        this.getItemsWithParentSelected(subItems, currentItem);
      }
      this.addItem(newItems, currentItem, parentItem);
    });
    return newItems;
  }
  updateItemsOnSelect(selectedItem) {
    if (selectedItem.subItems && !this.singleSelect) {
      this.selectAllItems(selectedItem.subItems, selectedItem.selected);
    }
    this._items = this.getItemsWithParentSelected(this.items);
  }
  static ɵfac = function PoTreeViewBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTreeViewBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoTreeViewBaseComponent,
    inputs: {
      inputedItems: [0, "p-items", "inputedItems"],
      selectable: [0, "p-selectable", "selectable"],
      singleSelect: [0, "p-single-select", "singleSelect"],
      maxLevel: [0, "p-max-level", "maxLevel"]
    },
    outputs: {
      collapsed: "p-collapsed",
      expanded: "p-expanded",
      selected: "p-selected",
      unselected: "p-unselected"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewBaseComponent, [{
    type: Directive
  }], null, {
    collapsed: [{
      type: Output,
      args: ["p-collapsed"]
    }],
    expanded: [{
      type: Output,
      args: ["p-expanded"]
    }],
    selected: [{
      type: Output,
      args: ["p-selected"]
    }],
    unselected: [{
      type: Output,
      args: ["p-unselected"]
    }],
    inputedItems: [{
      type: Input,
      args: ["p-items"]
    }],
    selectable: [{
      type: Input,
      args: ["p-selectable"]
    }],
    singleSelect: [{
      type: Input,
      args: ["p-single-select"]
    }],
    maxLevel: [{
      type: Input,
      args: ["p-max-level"]
    }]
  });
})();
var PoTreeViewService = class _PoTreeViewService {
  expandedEvent = new Subject();
  selectedEvent = new Subject();
  emitExpandedEvent(treeViewItem) {
    return this.expandedEvent.next(treeViewItem);
  }
  emitSelectedEvent(treeViewItem) {
    return this.selectedEvent.next(treeViewItem);
  }
  onExpand() {
    return this.expandedEvent.asObservable();
  }
  onSelect() {
    return this.selectedEvent.asObservable();
  }
  static ɵfac = function PoTreeViewService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTreeViewService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoTreeViewService,
    factory: _PoTreeViewService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _c0$2 = ["inputCheckbox"];
function PoTreeViewItemHeaderComponent_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 8);
    ɵɵlistener("click", function PoTreeViewItemHeaderComponent_button_1_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.expanded.emit($event));
    });
    ɵɵelement(1, "po-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-tree-view-item-header-button-icon-transform", ctx_r1.item.expanded);
  }
}
function PoTreeViewItemHeaderComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTreeViewItemHeaderComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-tree-view-item-header-padding", !ctx_r1.hasSubItems);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.item.label, " ");
  }
}
function PoTreeViewItemHeaderComponent_ng_template_5_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTreeViewItemHeaderComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTreeViewItemHeaderComponent_ng_template_5_ng_container_0_Template, 1, 0, "ng-container", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const checkboxTemplate_r3 = ɵɵreference(8);
    const radioTemplate_r4 = ɵɵreference(10);
    ɵɵproperty("ngIf", ctx_r1.singleSelect)("ngIfThen", radioTemplate_r4)("ngIfElse", checkboxTemplate_r3);
  }
}
function PoTreeViewItemHeaderComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox", 11);
    ɵɵtwoWayListener("ngModelChange", function PoTreeViewItemHeaderComponent_ng_template_7_Template_po_checkbox_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.item.selected, $event) || (ctx_r1.item.selected = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoTreeViewItemHeaderComponent_ng_template_7_Template_po_checkbox_p_change_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selected.emit(ctx_r1.item));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-tree-view-item-header-padding", !ctx_r1.hasSubItems);
    ɵɵproperty("p-label", ctx_r1.item.label);
    ɵɵtwoWayProperty("ngModel", ctx_r1.item.selected);
    ɵɵproperty("p-disabled", ctx_r1.item.isSelectable === false);
  }
}
function PoTreeViewItemHeaderComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-radio", 12, 4);
    ɵɵtwoWayListener("ngModelChange", function PoTreeViewItemHeaderComponent_ng_template_9_Template_po_radio_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.item.selected, $event) || (ctx_r1.item.selected = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change-selected", function PoTreeViewItemHeaderComponent_ng_template_9_Template_po_radio_p_change_selected_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selected.emit(ctx_r1.item));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-tree-view-item-header-padding", !ctx_r1.hasSubItems);
    ɵɵproperty("name", ctx_r1.idRadio);
    ɵɵtwoWayProperty("ngModel", ctx_r1.item.selected);
    ɵɵproperty("p-label", ctx_r1.item.label)("p-value", ctx_r1.item.value)("p-checked", ctx_r1.item.value === ctx_r1.selectedValue)("p-disabled", ctx_r1.item.isSelectable === false);
  }
}
var PoTreeViewItemHeaderComponent = class _PoTreeViewItemHeaderComponent {
  inputCheckbox;
  item;
  selectable = false;
  singleSelect;
  expanded = new EventEmitter();
  selected = new EventEmitter();
  selectedValue;
  idRadio = `po-radio[${uuid()}]`;
  get hasSubItems() {
    return !!(this.item.subItems && this.item.subItems.length);
  }
  static ɵfac = function PoTreeViewItemHeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTreeViewItemHeaderComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTreeViewItemHeaderComponent,
    selectors: [["po-tree-view-item-header"]],
    viewQuery: function PoTreeViewItemHeaderComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0$2, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputCheckbox = _t.first);
      }
    },
    inputs: {
      item: [0, "p-item", "item"],
      selectable: [0, "p-selectable", "selectable"],
      singleSelect: [0, "p-single-select", "singleSelect"],
      selectedValue: [0, "p-selected-value", "selectedValue"]
    },
    outputs: {
      expanded: "p-expanded",
      selected: "p-selected"
    },
    standalone: false,
    decls: 11,
    vars: 4,
    consts: [["labelTemplate", ""], ["selectionTemplate", ""], ["checkboxTemplate", ""], ["radioTemplate", ""], ["inputRadio", ""], [1, "po-tree-view-item-header"], ["class", "po-tree-view-item-header-button", 3, "click", 4, "ngIf"], [4, "ngIf", "ngIfThen", "ngIfElse"], [1, "po-tree-view-item-header-button", 3, "click"], ["p-icon", "ICON_ARROW_DOWN", 1, "po-tree-view-item-header-button-icon"], [1, "po-tree-view-item-header-label"], [1, "po-tree-view-item-header-checkbox", 3, "ngModelChange", "p-change", "p-label", "ngModel", "p-disabled"], [1, "po-tree-view-item-header-checkbox", 3, "ngModelChange", "p-change-selected", "name", "ngModel", "p-label", "p-value", "p-checked", "p-disabled"]],
    template: function PoTreeViewItemHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 5);
        ɵɵtemplate(1, PoTreeViewItemHeaderComponent_button_1_Template, 2, 2, "button", 6)(2, PoTreeViewItemHeaderComponent_ng_container_2_Template, 1, 0, "ng-container", 7);
        ɵɵelementEnd();
        ɵɵtemplate(3, PoTreeViewItemHeaderComponent_ng_template_3_Template, 2, 3, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, PoTreeViewItemHeaderComponent_ng_template_5_Template, 1, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor)(7, PoTreeViewItemHeaderComponent_ng_template_7_Template, 1, 5, "ng-template", null, 2, ɵɵtemplateRefExtractor)(9, PoTreeViewItemHeaderComponent_ng_template_9_Template, 2, 8, "ng-template", null, 3, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const labelTemplate_r7 = ɵɵreference(4);
        const selectionTemplate_r8 = ɵɵreference(6);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasSubItems);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.selectable)("ngIfThen", selectionTemplate_r8)("ngIfElse", labelTemplate_r7);
      }
    },
    dependencies: [NgIf, NgControlStatus, NgModel, PoCheckboxComponent, PoRadioComponent, PoIconComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewItemHeaderComponent, [{
    type: Component,
    args: [{
      selector: "po-tree-view-item-header",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<div class="po-tree-view-item-header">\n  <button *ngIf="hasSubItems" class="po-tree-view-item-header-button" (click)="expanded.emit($event)">\n    <po-icon\n      p-icon="ICON_ARROW_DOWN"\n      class="po-tree-view-item-header-button-icon"\n      [class.po-tree-view-item-header-button-icon-transform]="item.expanded"\n    >\n    </po-icon>\n  </button>\n\n  <ng-container *ngIf="selectable; then selectionTemplate; else labelTemplate"></ng-container>\n</div>\n\n<ng-template #labelTemplate>\n  <span class="po-tree-view-item-header-label" [class.po-tree-view-item-header-padding]="!hasSubItems">\n    {{ item.label }}\n  </span>\n</ng-template>\n\n<ng-template #selectionTemplate>\n  <ng-container *ngIf="singleSelect; then radioTemplate; else checkboxTemplate"></ng-container>\n</ng-template>\n\n<ng-template #checkboxTemplate>\n  <po-checkbox\n    class="po-tree-view-item-header-checkbox"\n    [class.po-tree-view-item-header-padding]="!hasSubItems"\n    [p-label]="item.label"\n    [(ngModel)]="item.selected"\n    (p-change)="selected.emit(item)"\n    [p-disabled]="item.isSelectable === false"\n  >\n  </po-checkbox>\n</ng-template>\n\n<ng-template #radioTemplate>\n  <po-radio\n    class="po-tree-view-item-header-checkbox"\n    [class.po-tree-view-item-header-padding]="!hasSubItems"\n    #inputRadio\n    [name]="idRadio"\n    [(ngModel)]="item.selected"\n    [p-label]="item.label"\n    [p-value]="item.value"\n    [p-checked]="item.value === selectedValue"\n    (p-change-selected)="selected.emit(item)"\n    [p-disabled]="item.isSelectable === false"\n  >\n  </po-radio>\n</ng-template>\n'
    }]
  }], null, {
    inputCheckbox: [{
      type: ViewChild,
      args: ["inputCheckbox"]
    }],
    item: [{
      type: Input,
      args: ["p-item"]
    }],
    selectable: [{
      type: Input,
      args: ["p-selectable"]
    }],
    singleSelect: [{
      type: Input,
      args: ["p-single-select"]
    }],
    expanded: [{
      type: Output,
      args: ["p-expanded"]
    }],
    selected: [{
      type: Output,
      args: ["p-selected"]
    }],
    selectedValue: [{
      type: Input,
      args: ["p-selected-value"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTreeViewItemHeaderComponent, {
    className: "PoTreeViewItemHeaderComponent",
    filePath: "lib/components/po-tree-view/po-tree-view-item-header/po-tree-view-item-header.component.ts",
    lineNumber: 12
  });
})();
function PoTreeViewItemComponent_ul_2_div_1_po_tree_view_item_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-tree-view-item", 6);
  }
  if (rf & 2) {
    const subItem_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("p-item", subItem_r1)("p-selectable", ctx_r1.selectable)("p-single-select", ctx_r1.singleSelect)("p-selected-value", ctx_r1.selectedValue);
  }
}
function PoTreeViewItemComponent_ul_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, PoTreeViewItemComponent_ul_2_div_1_po_tree_view_item_1_Template, 1, 4, "po-tree-view-item", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("@toggleBody", void 0);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.item.subItems)("ngForTrackBy", ctx_r1.trackByFunction);
  }
}
function PoTreeViewItemComponent_ul_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul", 3);
    ɵɵtemplate(1, PoTreeViewItemComponent_ul_2_div_1_Template, 2, 3, "div", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.item.expanded);
  }
}
var PoTreeViewItemComponent = class _PoTreeViewItemComponent {
  treeViewService;
  item;
  selectable;
  singleSelect;
  selectedValue;
  get hasSubItems() {
    return !!(this.item.subItems && this.item.subItems.length);
  }
  constructor(treeViewService) {
    this.treeViewService = treeViewService;
  }
  onClick(event) {
    event.preventDefault();
    event.stopPropagation();
    this.item.expanded = !this.item.expanded;
    this.treeViewService.emitExpandedEvent(__spreadValues({}, this.item));
  }
  onSelect(selectedItem) {
    this.treeViewService.emitSelectedEvent(__spreadValues({}, selectedItem));
  }
  trackByFunction(index) {
    return index;
  }
  static ɵfac = function PoTreeViewItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTreeViewItemComponent)(ɵɵdirectiveInject(PoTreeViewService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTreeViewItemComponent,
    selectors: [["po-tree-view-item"]],
    inputs: {
      item: [0, "p-item", "item"],
      selectable: [0, "p-selectable", "selectable"],
      singleSelect: [0, "p-single-select", "singleSelect"],
      selectedValue: [0, "p-selected-value", "selectedValue"]
    },
    standalone: false,
    decls: 3,
    vars: 5,
    consts: [[1, "po-tree-view-item"], [3, "p-expanded", "p-selected", "p-item", "p-selectable", "p-single-select", "p-selected-value"], ["class", "po-tree-view-item-group", 4, "ngIf"], [1, "po-tree-view-item-group"], [4, "ngIf"], [3, "p-item", "p-selectable", "p-single-select", "p-selected-value", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-item", "p-selectable", "p-single-select", "p-selected-value"]],
    template: function PoTreeViewItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "li", 0)(1, "po-tree-view-item-header", 1);
        ɵɵlistener("p-expanded", function PoTreeViewItemComponent_Template_po_tree_view_item_header_p_expanded_1_listener($event) {
          return ctx.onClick($event);
        })("p-selected", function PoTreeViewItemComponent_Template_po_tree_view_item_header_p_selected_1_listener() {
          return ctx.onSelect(ctx.item);
        });
        ɵɵelementEnd();
        ɵɵtemplate(2, PoTreeViewItemComponent_ul_2_Template, 2, 1, "ul", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("p-item", ctx.item)("p-selectable", ctx.selectable)("p-single-select", ctx.singleSelect)("p-selected-value", ctx.selectedValue);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasSubItems);
      }
    },
    dependencies: [NgForOf, NgIf, _PoTreeViewItemComponent, PoTreeViewItemHeaderComponent],
    encapsulation: 2,
    data: {
      animation: [trigger("toggleBody", [transition(":enter", [style({
        "overflow-y": "hidden",
        visibility: "hidden",
        opacity: 0,
        height: "0"
      }), animate(200, style({
        height: "*"
      })), animate(100, style({
        opacity: 1
      }))]), transition(":leave", [style({
        "overflow-y": "hidden",
        visibility: "visible",
        opacity: 1,
        height: "*"
      }), animate(200, style({
        height: 0
      })), animate(100, style({
        opacity: 0
      }))])])]
    },
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewItemComponent, [{
    type: Component,
    args: [{
      selector: "po-tree-view-item",
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("toggleBody", [transition(":enter", [style({
        "overflow-y": "hidden",
        visibility: "hidden",
        opacity: 0,
        height: "0"
      }), animate(200, style({
        height: "*"
      })), animate(100, style({
        opacity: 1
      }))]), transition(":leave", [style({
        "overflow-y": "hidden",
        visibility: "visible",
        opacity: 1,
        height: "*"
      }), animate(200, style({
        height: 0
      })), animate(100, style({
        opacity: 0
      }))])])],
      standalone: false,
      template: '<li class="po-tree-view-item">\n  <po-tree-view-item-header\n    [p-item]="item"\n    [p-selectable]="selectable"\n    [p-single-select]="singleSelect"\n    [p-selected-value]="selectedValue"\n    (p-expanded)="onClick($event)"\n    (p-selected)="onSelect(item)"\n  >\n  </po-tree-view-item-header>\n\n  <ul *ngIf="hasSubItems" class="po-tree-view-item-group">\n    <div *ngIf="item.expanded" @toggleBody>\n      <po-tree-view-item\n        *ngFor="let subItem of item.subItems; trackBy: trackByFunction"\n        [p-item]="subItem"\n        [p-selectable]="selectable"\n        [p-single-select]="singleSelect"\n        [p-selected-value]="selectedValue"\n      >\n      </po-tree-view-item>\n    </div>\n  </ul>\n</li>\n'
    }]
  }], () => [{
    type: PoTreeViewService
  }], {
    item: [{
      type: Input,
      args: ["p-item"]
    }],
    selectable: [{
      type: Input,
      args: ["p-selectable"]
    }],
    singleSelect: [{
      type: Input,
      args: ["p-single-select"]
    }],
    selectedValue: [{
      type: Input,
      args: ["p-selected-value"]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTreeViewItemComponent, {
    className: "PoTreeViewItemComponent",
    filePath: "lib/components/po-tree-view/po-tree-view-item/po-tree-view-item.component.ts",
    lineNumber: 37
  });
})();
function PoTreeViewComponent_po_container_0_po_tree_view_item_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-tree-view-item", 4);
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-item", item_r1)("p-selectable", ctx_r1.selectable)("p-single-select", ctx_r1.singleSelect)("p-selected-value", ctx_r1.selectedValue);
  }
}
function PoTreeViewComponent_po_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-container", 1)(1, "ul", 2);
    ɵɵtemplate(2, PoTreeViewComponent_po_container_0_po_tree_view_item_2_Template, 1, 4, "po-tree-view-item", 3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.items)("ngForTrackBy", ctx_r1.trackByFunction);
  }
}
var PoTreeViewComponent = class _PoTreeViewComponent extends PoTreeViewBaseComponent {
  treeViewService;
  get hasItems() {
    return !!(this.items && this.items.length);
  }
  constructor(treeViewService) {
    super();
    this.treeViewService = treeViewService;
  }
  ngOnInit() {
    this.treeViewService.onExpand().subscribe((treeViewItem) => {
      this.emitExpanded(treeViewItem);
    });
    this.treeViewService.onSelect().subscribe((treeViewItem) => {
      this.emitSelected(treeViewItem);
    });
  }
  ngOnChanges(changes) {
    if (changes?.["inputedItems"]) {
      this.items = this.inputedItems;
    }
  }
  trackByFunction(index) {
    return index;
  }
  static ɵfac = function PoTreeViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTreeViewComponent)(ɵɵdirectiveInject(PoTreeViewService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoTreeViewComponent,
    selectors: [["po-tree-view"]],
    standalone: false,
    features: [ɵɵProvidersFeature([PoTreeViewService]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
    decls: 1,
    vars: 1,
    consts: [["p-no-padding", "", 4, "ngIf"], ["p-no-padding", ""], [1, "po-tree-view"], [3, "p-item", "p-selectable", "p-single-select", "p-selected-value", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-item", "p-selectable", "p-single-select", "p-selected-value"]],
    template: function PoTreeViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, PoTreeViewComponent_po_container_0_Template, 3, 2, "po-container", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.hasItems);
      }
    },
    dependencies: [NgForOf, NgIf, PoContainerComponent, PoTreeViewItemComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewComponent, [{
    type: Component,
    args: [{
      selector: "po-tree-view",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [PoTreeViewService],
      standalone: false,
      template: '<po-container *ngIf="hasItems" p-no-padding>\n  <ul class="po-tree-view">\n    <po-tree-view-item\n      *ngFor="let item of items; trackBy: trackByFunction"\n      [p-item]="item"\n      [p-selectable]="selectable"\n      [p-single-select]="singleSelect"\n      [p-selected-value]="selectedValue"\n    >\n    </po-tree-view-item>\n  </ul>\n</po-container>\n'
    }]
  }], () => [{
    type: PoTreeViewService
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTreeViewComponent, {
    className: "PoTreeViewComponent",
    filePath: "lib/components/po-tree-view/po-tree-view.component.ts",
    lineNumber: 39
  });
})();
var PoTreeViewModule = class _PoTreeViewModule {
  static ɵfac = function PoTreeViewModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoTreeViewModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoTreeViewModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, PoContainerModule, PoFieldModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewModule, [{
    type: NgModule,
    args: [{
      declarations: [PoTreeViewComponent, PoTreeViewItemComponent, PoTreeViewItemHeaderComponent],
      exports: [PoTreeViewComponent],
      imports: [CommonModule, FormsModule, PoContainerModule, PoFieldModule, PoIconModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTreeViewModule, {
    declarations: [PoTreeViewComponent, PoTreeViewItemComponent, PoTreeViewItemHeaderComponent],
    imports: [CommonModule, FormsModule, PoContainerModule, PoFieldModule, PoIconModule],
    exports: [PoTreeViewComponent]
  });
})();
var PoWidgetBaseComponent = class _PoWidgetBaseComponent {
  /** Descrição da segunda ação. */
  secondaryLabel;
  /**
   * @optional
   *
   * @description
   *
   * Ação que será executada quando o usuário clicar sobre a área total do `po-widget`.
   */
  click = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função que será disparada com o valor do `p-disabled` quando esta propriedade for alterada.
   */
  onDisabled = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função que será chamada na primeira ação.
   */
  primaryAction = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função que será chamada na segunda ação.
   */
  secondaryAction = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Função chamada ao clicar no ícone de configuração
   */
  setting = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Função que será chamada ao clicar no título.
   */
  titleAction = new EventEmitter();
  containerHeight = "auto";
  id = uuid();
  _background;
  _disabled = false;
  _height;
  _help;
  _noShadow = false;
  _primary = false;
  _primaryLabel;
  _title;
  /**
   * @optional
   *
   * @description
   *
   * Aplicação de imagem de fundo.
   * > Se a imagem escolhida intervir na legibilidade do texto contido no `p-widget`,
   * pode-se utilizar a propriedade `p-primary` em conjunto para que os textos fiquem na cor branca.
   *
   */
  set background(value) {
    this._background = value && typeof value === "string" ? value : void 0;
  }
  get background() {
    return this._background;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita todas as ações do componente.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
    this.onDisabled.emit(this.disabled);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a altura do `po-widget`.
   * A altura mínima para o `po-widget` depende do que será exibido através das propriedades `p-primary-label`,
   * `p-setting`, `p-help` e `p-title`.
   * > Caso não seja informado valor, a propriedade irá assumir o tamanho do conteúdo.
   */
  set height(value) {
    this._height = parseInt(value, 10);
    this.setHeight(this.height);
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Link de ajuda
   */
  set help(value) {
    this._help = isTypeof(value, "string") ? value : "";
    this.setHeight(this.height);
  }
  get help() {
    return this._help;
  }
  /**
   *
   * @optional
   *
   * @description
   *
   * Desabilita a sombra do `po-widget` quando o mesmo for clicável.
   *
   * @default `true`
   */
  set noShadow(value) {
    this._noShadow = value === "" ? true : convertToBoolean(value);
    this.setHeight(this.height);
  }
  get noShadow() {
    return this._noShadow;
  }
  /**
   * @optional
   *
   * @description
   *
   * Opção para que o `po-widget` fique em destaque.
   *
   * @default `false`
   */
  set primary(value) {
    this._primary = value === "" ? true : convertToBoolean(value);
  }
  get primary() {
    return this._primary;
  }
  /**
   * @optional
   *
   * @description
   *
   * Descrição da primeira ação.
   *
   * @default `false`
   */
  set primaryLabel(value) {
    this._primaryLabel = isTypeof(value, "string") ? value : "";
    this.setHeight(this.height);
  }
  get primaryLabel() {
    return this._primaryLabel;
  }
  /**
   * @optional
   *
   * @description
   *
   * Título do `po-widget`.
   *
   * @default `false`
   */
  set title(value) {
    this._title = isTypeof(value, "string") ? value : "";
    this.setHeight(this.height);
  }
  get title() {
    return this._title;
  }
  static ɵfac = function PoWidgetBaseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoWidgetBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoWidgetBaseComponent,
    inputs: {
      secondaryLabel: [0, "p-secondary-label", "secondaryLabel"],
      background: [0, "p-background", "background"],
      disabled: [0, "p-disabled", "disabled"],
      height: [0, "p-height", "height"],
      help: [0, "p-help", "help"],
      noShadow: [0, "p-no-shadow", "noShadow"],
      primary: [0, "p-primary", "primary"],
      primaryLabel: [0, "p-primary-label", "primaryLabel"],
      title: [0, "p-title", "title"]
    },
    outputs: {
      click: "p-click",
      onDisabled: "p-on-disabled",
      primaryAction: "p-primary-action",
      secondaryAction: "p-secondary-action",
      setting: "p-setting",
      titleAction: "p-title-action"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoWidgetBaseComponent, [{
    type: Directive
  }], null, {
    secondaryLabel: [{
      type: Input,
      args: ["p-secondary-label"]
    }],
    click: [{
      type: Output,
      args: ["p-click"]
    }],
    onDisabled: [{
      type: Output,
      args: ["p-on-disabled"]
    }],
    primaryAction: [{
      type: Output,
      args: ["p-primary-action"]
    }],
    secondaryAction: [{
      type: Output,
      args: ["p-secondary-action"]
    }],
    setting: [{
      type: Output,
      args: ["p-setting"]
    }],
    titleAction: [{
      type: Output,
      args: ["p-title-action"]
    }],
    background: [{
      type: Input,
      args: ["p-background"]
    }],
    disabled: [{
      type: Input,
      args: ["p-disabled"]
    }],
    height: [{
      type: Input,
      args: ["p-height"]
    }],
    help: [{
      type: Input,
      args: ["p-help"]
    }],
    noShadow: [{
      type: Input,
      args: ["p-no-shadow"]
    }],
    primary: [{
      type: Input,
      args: ["p-primary"]
    }],
    primaryLabel: [{
      type: Input,
      args: ["p-primary-label"]
    }],
    title: [{
      type: Input,
      args: ["p-title"]
    }]
  });
})();
var _c0$1 = ["*"];
function PoWidgetComponent_div_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 9);
    ɵɵlistener("click", function PoWidgetComponent_div_1_span_1_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.runTitleAction($event));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.title, " ");
  }
}
function PoWidgetComponent_div_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r1.title);
  }
}
function PoWidgetComponent_div_1_div_4_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-icon", 13);
    ɵɵlistener("click", function PoWidgetComponent_div_1_div_4_po_icon_1_Template_po_icon_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.settingOutput($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵpropertyInterpolate1("id", "settingAction-", ctx_r1.id, "");
  }
}
function PoWidgetComponent_div_1_div_4_po_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-icon", 14);
    ɵɵlistener("click", function PoWidgetComponent_div_1_div_4_po_icon_2_Template_po_icon_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.openHelp($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵpropertyInterpolate1("id", "helpLink-", ctx_r1.id, "");
  }
}
function PoWidgetComponent_div_1_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtemplate(1, PoWidgetComponent_div_1_div_4_po_icon_1_Template, 1, 2, "po-icon", 11)(2, PoWidgetComponent_div_1_div_4_po_icon_2_Template, 1, 2, "po-icon", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.setting.observers[0]);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.help);
  }
}
function PoWidgetComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, PoWidgetComponent_div_1_span_1_Template, 2, 1, "span", 7)(2, PoWidgetComponent_div_1_ng_template_2_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(4, PoWidgetComponent_div_1_div_4_Template, 3, 2, "div", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const noTitleAction_r5 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showTitleAction)("ngIfElse", noTitleAction_r5);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r1.setting.observers[0] || ctx_r1.help);
  }
}
function PoWidgetComponent_div_5_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 18)(1, "a", 19);
    ɵɵlistener("click", function PoWidgetComponent_div_5_div_1_Template_a_click_1_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.runPrimaryAction($event));
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵpropertyInterpolate1("id", "primaryAct-", ctx_r1.id, "");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.primaryLabel);
  }
}
function PoWidgetComponent_div_5_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "a", 19);
    ɵɵlistener("click", function PoWidgetComponent_div_5_div_2_Template_a_click_1_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.runPrimaryAction($event));
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵpropertyInterpolate1("id", "primaryAct-", ctx_r1.id, "");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.primaryLabel);
  }
}
function PoWidgetComponent_div_5_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "a", 19);
    ɵɵlistener("click", function PoWidgetComponent_div_5_div_3_Template_a_click_1_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.runSecondaryAction($event));
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵpropertyInterpolate1("id", "secondaryAct-", ctx_r1.id, "");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.secondaryLabel);
  }
}
function PoWidgetComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtemplate(1, PoWidgetComponent_div_5_div_1_Template, 3, 3, "div", 16)(2, PoWidgetComponent_div_5_div_2_Template, 3, 3, "div", 17)(3, PoWidgetComponent_div_5_div_3_Template, 3, 3, "div", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.secondaryLabel);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.secondaryLabel);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.secondaryLabel);
  }
}
var PoWidgetComponent = class _PoWidgetComponent extends PoWidgetBaseComponent {
  get showTitleAction() {
    return !!this.titleAction.observers[0];
  }
  constructor(viewRef) {
    super();
  }
  ngOnInit() {
    this.setHeight(this.height);
  }
  hasTitleHelpOrSetting() {
    return !!this.title || !!this.help || !!this.setting.observers[0];
  }
  onClick(event) {
    if (this.click.observed && !this.disabled) {
      this.click.emit(event);
    }
  }
  onKeyDown(event) {
    if (this.click.observed && !this.disabled && (event.which === PoKeyCodeEnum.space || event.keyCode === PoKeyCodeEnum.space)) {
      this.click.emit(event);
      event.preventDefault();
    }
  }
  openHelp(event) {
    if (!this.disabled) {
      event.stopPropagation();
      window.open(this.help, "_blank");
    }
  }
  runPrimaryAction(event) {
    if (!this.disabled) {
      event.stopPropagation();
      this.primaryAction.emit();
    }
  }
  runSecondaryAction(event) {
    if (!this.disabled) {
      event.stopPropagation();
      this.secondaryAction.emit();
    }
  }
  runTitleAction(event) {
    if (!this.disabled) {
      event.stopPropagation();
      this.titleAction.emit();
    }
  }
  setHeight(height) {
    if (height) {
      let bodyHeight = height;
      const hasSettingOrHelp = this.setting.observers.length > 0 || this.help;
      const footerBorder = 1;
      const footerHeight = 40;
      const settingHeight = 37;
      const shadowHeight = 2;
      const titleHeight = 50;
      if (this.noShadow) {
        bodyHeight -= shadowHeight;
      }
      if (hasSettingOrHelp && !this.title) {
        bodyHeight -= settingHeight;
      }
      if (this.title) {
        bodyHeight -= titleHeight;
      }
      if (this.primaryLabel) {
        bodyHeight -= footerHeight + footerBorder;
      }
      this.containerHeight = `${bodyHeight}px`;
    } else {
      this.containerHeight = `auto`;
    }
  }
  settingOutput(event) {
    if (!this.disabled) {
      event.stopPropagation();
      this.setting.emit();
    }
  }
  static ɵfac = function PoWidgetComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoWidgetComponent)(ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoWidgetComponent,
    selectors: [["po-widget"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0$1,
    decls: 6,
    vars: 16,
    consts: [["noTitleAction", ""], [3, "click", "keydown", "tabindex"], ["class", "po-widget-header", 4, "ngIf"], ["p-no-border", "", 3, "p-height"], [1, "po-widget-body"], ["class", "po-widget-footer", 4, "ngIf"], [1, "po-widget-header"], ["class", "po-widget-title-action", 3, "click", 4, "ngIf", "ngIfElse"], ["class", "po-pull-right", 4, "ngIf"], [1, "po-widget-title-action", 3, "click"], [1, "po-pull-right"], ["p-icon", "ICON_SETTINGS", "class", "po-clickable", 3, "id", "click", 4, "ngIf"], ["p-icon", "ICON_HELP", "class", "po-clickable", 3, "id", "click", 4, "ngIf"], ["p-icon", "ICON_SETTINGS", 1, "po-clickable", 3, "click", "id"], ["p-icon", "ICON_HELP", 1, "po-clickable", 3, "click", "id"], [1, "po-widget-footer"], ["class", "po-widget-xl", 4, "ngIf"], ["class", "po-widget-md", 4, "ngIf"], [1, "po-widget-xl"], [1, "po-widget-action", 3, "click", "id"], [1, "po-widget-md"]],
    template: function PoWidgetComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 1);
        ɵɵlistener("click", function PoWidgetComponent_Template_div_click_0_listener($event) {
          return ctx.onClick($event);
        })("keydown", function PoWidgetComponent_Template_div_keydown_0_listener($event) {
          return ctx.onKeyDown($event);
        });
        ɵɵtemplate(1, PoWidgetComponent_div_1_Template, 5, 3, "div", 2);
        ɵɵelementStart(2, "po-container", 3)(3, "div", 4);
        ɵɵprojection(4);
        ɵɵelementEnd()();
        ɵɵtemplate(5, PoWidgetComponent_div_5_Template, 4, 3, "div", 5);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵstyleProp("background-image", ctx.background ? "url(" + ctx.background + ")" : void 0);
        ɵɵclassProp("po-clickable", ctx.click.observers.length)("po-widget", !ctx.primary)("po-widget-disabled", ctx.disabled)("po-widget-primary", ctx.primary)("po-widget-no-shadow", ctx.click.observers.length && ctx.noShadow);
        ɵɵproperty("tabindex", ctx.disabled || !ctx.click.observers.length ? -1 : 0);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasTitleHelpOrSetting());
        ɵɵadvance();
        ɵɵproperty("p-height", ctx.containerHeight);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.primaryLabel);
      }
    },
    dependencies: [NgIf, PoContainerComponent, PoIconComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoWidgetComponent, [{
    type: Component,
    args: [{
      selector: "po-widget",
      standalone: false,
      template: `<div
  [class.po-clickable]="click.observers.length"
  [class.po-widget]="!primary"
  [class.po-widget-disabled]="disabled"
  [class.po-widget-primary]="primary"
  [class.po-widget-no-shadow]="click.observers.length && noShadow"
  [style.background-image]="background ? 'url(' + background + ')' : undefined"
  (click)="onClick($event)"
  (keydown)="onKeyDown($event)"
  [tabindex]="disabled || !click.observers.length ? -1 : 0"
>
  <div *ngIf="hasTitleHelpOrSetting()" class="po-widget-header">
    <span *ngIf="showTitleAction; else noTitleAction" class="po-widget-title-action" (click)="runTitleAction($event)">
      {{ title }}
    </span>
    <ng-template #noTitleAction>{{ title }}</ng-template>

    <div *ngIf="setting.observers[0] || help" class="po-pull-right">
      <po-icon
        id="settingAction-{{ id }}"
        *ngIf="setting.observers[0]"
        p-icon="ICON_SETTINGS"
        class="po-clickable"
        (click)="settingOutput($event)"
      >
      </po-icon>
      <po-icon id="helpLink-{{ id }}" *ngIf="help" p-icon="ICON_HELP" (click)="openHelp($event)" class="po-clickable">
      </po-icon>
    </div>
  </div>

  <po-container p-no-border [p-height]="containerHeight">
    <div class="po-widget-body">
      <ng-content></ng-content>
    </div>
  </po-container>

  <div *ngIf="primaryLabel" class="po-widget-footer">
    <div class="po-widget-xl" *ngIf="!secondaryLabel">
      <a class="po-widget-action" id="primaryAct-{{ id }}" (click)="runPrimaryAction($event)">{{ primaryLabel }}</a>
    </div>

    <div class="po-widget-md" *ngIf="secondaryLabel">
      <a class="po-widget-action" id="primaryAct-{{ id }}" (click)="runPrimaryAction($event)">{{ primaryLabel }}</a>
    </div>
    <div class="po-widget-md" *ngIf="secondaryLabel">
      <a class="po-widget-action" id="secondaryAct-{{ id }}" (click)="runSecondaryAction($event)">{{
        secondaryLabel
      }}</a>
    </div>
  </div>
</div>
`
    }]
  }], () => [{
    type: ViewContainerRef
  }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoWidgetComponent, {
    className: "PoWidgetComponent",
    filePath: "lib/components/po-widget/po-widget.component.ts",
    lineNumber: 37
  });
})();
var PoWidgetModule = class _PoWidgetModule {
  static ɵfac = function PoWidgetModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoWidgetModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoWidgetModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, PoContainerModule, PoIconModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoWidgetModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoContainerModule, PoIconModule],
      exports: [PoWidgetComponent],
      declarations: [PoWidgetComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoWidgetModule, {
    declarations: [PoWidgetComponent],
    imports: [CommonModule, PoContainerModule, PoIconModule],
    exports: [PoWidgetComponent]
  });
})();
var PoComponentsModule = class _PoComponentsModule {
  static ɵfac = function PoComponentsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoComponentsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoComponentsModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [PoAccordionModule, PoAvatarModule, PoBreadcrumbModule, PoButtonModule, PoButtonGroupModule, PoCalendarModule, PoChartModule, PoContainerModule, PoDisclaimerGroupModule, PoDisclaimerModule, PoDividerModule, PoDropdownModule, PoDynamicModule, PoFieldModule, PoGaugeModule, PoGridModule, PoIconModule, PoInfoModule, PoListViewModule, PoListBoxModule, PoLoadingModule, PoLogoModule, PoMenuModule, PoMenuPanelModule, PoModalModule, PoNavbarModule, PoOverlayModule, PoPageModule, PoPopoverModule, PoPopupModule, PoProgressModule, PoSlideModule, PoStepperModule, PoTableModule, PoTabsModule, PoTagModule, PoToolbarModule, PoTreeViewModule, PoWidgetModule, PoLinkModule, PoLabelModule, PoImageModule, PoPageSlideModule, PoSwitchModule, PoSearchModule, PoBadgeModule, PoToasterModule, PoAccordionModule, PoAvatarModule, PoBreadcrumbModule, PoButtonModule, PoButtonGroupModule, PoCalendarModule, PoChartModule, PoContainerModule, PoDisclaimerGroupModule, PoDisclaimerModule, PoDividerModule, PoDropdownModule, PoDynamicModule, PoFieldModule, PoGaugeModule, PoGridModule, PoIconModule, PoInfoModule, PoListViewModule, PoListBoxModule, PoLoadingModule, PoLogoModule, PoMenuModule, PoMenuPanelModule, PoModalModule, PoNavbarModule, PoOverlayModule, PoPageModule, PoPopoverModule, PoPopupModule, PoProgressModule, PoSlideModule, PoStepperModule, PoTableModule, PoTabsModule, PoTagModule, PoToolbarModule, PoTreeViewModule, PoWidgetModule, PoLinkModule, PoLabelModule, PoImageModule, PoPageSlideModule, PoSwitchModule, PoSearchModule, PoBadgeModule, PoToasterModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComponentsModule, [{
    type: NgModule,
    args: [{
      imports: [PoAccordionModule, PoAvatarModule, PoBreadcrumbModule, PoButtonModule, PoButtonGroupModule, PoCalendarModule, PoChartModule, PoContainerModule, PoDisclaimerGroupModule, PoDisclaimerModule, PoDividerModule, PoDropdownModule, PoDynamicModule, PoFieldModule, PoGaugeModule, PoGridModule, PoIconModule, PoInfoModule, PoListViewModule, PoListBoxModule, PoLoadingModule, PoLogoModule, PoMenuModule, PoMenuPanelModule, PoModalModule, PoNavbarModule, PoOverlayModule, PoPageModule, PoPopoverModule, PoPopupModule, PoProgressModule, PoSlideModule, PoStepperModule, PoTableModule, PoTabsModule, PoTagModule, PoToolbarModule, PoTreeViewModule, PoWidgetModule, PoLinkModule, PoLabelModule, PoImageModule, PoPageSlideModule, PoSwitchModule, PoSearchModule, PoBadgeModule, PoToasterModule],
      exports: [PoAccordionModule, PoAvatarModule, PoBreadcrumbModule, PoButtonModule, PoButtonGroupModule, PoCalendarModule, PoChartModule, PoContainerModule, PoDisclaimerGroupModule, PoDisclaimerModule, PoDividerModule, PoDropdownModule, PoDynamicModule, PoFieldModule, PoGaugeModule, PoGridModule, PoIconModule, PoInfoModule, PoListViewModule, PoListBoxModule, PoLoadingModule, PoLogoModule, PoMenuModule, PoMenuPanelModule, PoModalModule, PoNavbarModule, PoOverlayModule, PoPageModule, PoPopoverModule, PoPopupModule, PoProgressModule, PoSlideModule, PoStepperModule, PoTableModule, PoTabsModule, PoTagModule, PoToolbarModule, PoTreeViewModule, PoWidgetModule, PoLinkModule, PoLabelModule, PoImageModule, PoPageSlideModule, PoSwitchModule, PoSearchModule, PoBadgeModule, PoToasterModule],
      providers: [],
      bootstrap: [],
      declarations: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoComponentsModule, {
    imports: [PoAccordionModule, PoAvatarModule, PoBreadcrumbModule, PoButtonModule, PoButtonGroupModule, PoCalendarModule, PoChartModule, PoContainerModule, PoDisclaimerGroupModule, PoDisclaimerModule, PoDividerModule, PoDropdownModule, PoDynamicModule, PoFieldModule, PoGaugeModule, PoGridModule, PoIconModule, PoInfoModule, PoListViewModule, PoListBoxModule, PoLoadingModule, PoLogoModule, PoMenuModule, PoMenuPanelModule, PoModalModule, PoNavbarModule, PoOverlayModule, PoPageModule, PoPopoverModule, PoPopupModule, PoProgressModule, PoSlideModule, PoStepperModule, PoTableModule, PoTabsModule, PoTagModule, PoToolbarModule, PoTreeViewModule, PoWidgetModule, PoLinkModule, PoLabelModule, PoImageModule, PoPageSlideModule, PoSwitchModule, PoSearchModule, PoBadgeModule, PoToasterModule],
    exports: [PoAccordionModule, PoAvatarModule, PoBreadcrumbModule, PoButtonModule, PoButtonGroupModule, PoCalendarModule, PoChartModule, PoContainerModule, PoDisclaimerGroupModule, PoDisclaimerModule, PoDividerModule, PoDropdownModule, PoDynamicModule, PoFieldModule, PoGaugeModule, PoGridModule, PoIconModule, PoInfoModule, PoListViewModule, PoListBoxModule, PoLoadingModule, PoLogoModule, PoMenuModule, PoMenuPanelModule, PoModalModule, PoNavbarModule, PoOverlayModule, PoPageModule, PoPopoverModule, PoPopupModule, PoProgressModule, PoSlideModule, PoStepperModule, PoTableModule, PoTabsModule, PoTagModule, PoToolbarModule, PoTreeViewModule, PoWidgetModule, PoLinkModule, PoLabelModule, PoImageModule, PoPageSlideModule, PoSwitchModule, PoSearchModule, PoBadgeModule, PoToasterModule]
  });
})();
var PoGuardsModule = class _PoGuardsModule {
  static ɵfac = function PoGuardsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoGuardsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoGuardsModule
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGuardsModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [],
      exports: [],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
var poHttpInterceptorDetailLiteralsDefault = {
  en: {
    closeButton: "Close",
    details: "Details",
    detail: "Detail",
    error: "Error",
    warning: "Warning",
    information: "Information",
    success: "Success"
  },
  es: {
    closeButton: "Cerrar",
    details: "Detalles",
    detail: "Detalle",
    error: "Error",
    warning: "Advertencia",
    information: "Informacion",
    success: "Éxito"
  },
  pt: {
    closeButton: "Fechar",
    details: "Detalhes",
    detail: "Detalhe",
    error: "Erro",
    warning: "Aviso",
    information: "Informação",
    success: "Sucesso"
  },
  ru: {
    closeButton: "Закрывать",
    details: "Детали",
    detail: "Деталь",
    error: "Ошибка",
    warning: "Предупреждение",
    information: "Информация",
    success: "Yспех"
  }
};
var _c02 = (a0) => ({
  detail: a0
});
var _c110 = () => ({});
function PoHttpInterceptorDetailComponent_po_accordion_2_po_accordion_item_1_ng_template_1_Template(rf, ctx) {
}
function PoHttpInterceptorDetailComponent_po_accordion_2_po_accordion_item_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-accordion-item", 7);
    ɵɵtemplate(1, PoHttpInterceptorDetailComponent_po_accordion_2_po_accordion_item_1_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    const body_r3 = ɵɵreference(6);
    ɵɵproperty("p-label", ctx_r1.formatDetailItemTitle(detail_r1));
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", body_r3)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c02, detail_r1));
  }
}
function PoHttpInterceptorDetailComponent_po_accordion_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-accordion", 5);
    ɵɵtemplate(1, PoHttpInterceptorDetailComponent_po_accordion_2_po_accordion_item_1_Template, 2, 5, "po-accordion-item", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.details);
  }
}
function PoHttpInterceptorDetailComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const body_r3 = ɵɵreference(6);
    ɵɵproperty("ngTemplateOutlet", body_r3)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c02, ctx_r1.details[0] || ɵɵpureFunction0(2, _c110)));
  }
}
function PoHttpInterceptorDetailComponent_ng_template_5_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵelement(1, "po-tag", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r4 = ɵɵnextContext().detail;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-color", ctx_r1.typeColor(detail_r4.type))("p-value", ctx_r1.typeValue(detail_r4.type));
  }
}
function PoHttpInterceptorDetailComponent_ng_template_5_p_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p")(1, "strong");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const detail_r4 = ɵɵnextContext().detail;
    ɵɵadvance(2);
    ɵɵtextInterpolate(detail_r4.code);
  }
}
function PoHttpInterceptorDetailComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoHttpInterceptorDetailComponent_ng_template_5_div_0_Template, 2, 2, "div", 9)(1, PoHttpInterceptorDetailComponent_ng_template_5_p_1_Template, 3, 1, "p", 10);
    ɵɵelementStart(2, "div", 3)(3, "p");
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const detail_r4 = ctx.detail;
    ɵɵproperty("ngIf", detail_r4.type);
    ɵɵadvance();
    ɵɵproperty("ngIf", detail_r4.detailTitle);
    ɵɵadvance(3);
    ɵɵtextInterpolate(detail_r4.detailedMessage);
  }
}
var colors = {
  success: "color-11",
  error: "color-07",
  warning: "color-08",
  info: ""
};
var PoHttpInterceptorDetailComponent = class _PoHttpInterceptorDetailComponent {
  languageService;
  modal;
  closed = new EventEmitter();
  details = [];
  title;
  language;
  literals;
  // eslint-disable-next-line @typescript-eslint/member-ordering
  primaryAction;
  constructor(languageService) {
    this.languageService = languageService;
    this.language = this.languageService?.getShortLanguage();
    this.literals = poHttpInterceptorDetailLiteralsDefault[this.language];
  }
  ngOnInit() {
    this.primaryAction = {
      action: () => this.close(),
      label: this.literals.closeButton
    };
  }
  set detail(details) {
    if (details && details.length) {
      this.details = this.filterByValidDetails(details);
    }
    this.title = this.formatTitle(this.details);
  }
  close() {
    this.modal.close();
    this.closed.emit();
  }
  formatDetailItemTitle(detail) {
    return detail.detailTitle ? detail.detailTitle : detail.code ? `${detail.code} - ${detail.message}` : detail.message;
  }
  open() {
    this.modal.open();
  }
  typeColor(type) {
    return colors[type];
  }
  typeValue(type) {
    return poHttpInterceptorDetailLiteralsDefault[this.language][type] || type;
  }
  addValidDetail(newDetails, detail) {
    return detail.message ? newDetails.concat(this.getValidDetailProperties(detail)) : newDetails;
  }
  getValidDetailProperties({
    code,
    message,
    detailedMessage,
    type,
    detailTitle
  }) {
    return detailTitle ? {
      code,
      message,
      detailedMessage,
      type,
      detailTitle
    } : {
      code,
      message,
      detailedMessage,
      type
    };
  }
  filterByValidDetails(details) {
    return details.reduce((newDetails, detail) => this.addValidDetail(newDetails, detail), []);
  }
  formatTitle(details) {
    return details.length > 1 ? `${this.literals.details} (${details.length})` : details.length === 1 ? this.formatDetailItemTitle(details[0]) : this.literals.detail;
  }
  static ɵfac = function PoHttpInterceptorDetailComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoHttpInterceptorDetailComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _PoHttpInterceptorDetailComponent,
    selectors: [["po-http-interceptor-detail"]],
    viewQuery: function PoHttpInterceptorDetailComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(PoModalComponent, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modal = _t.first);
      }
    },
    standalone: false,
    decls: 7,
    vars: 4,
    consts: [["elseBlock", ""], ["body", ""], ["p-hide-close", "", "p-size", "lg", 3, "p-primary-action", "p-title"], [1, "po-row"], ["class", "po-md-12 po-mt-1 po-mb-1", 4, "ngIf", "ngIfElse"], [1, "po-md-12", "po-mt-1", "po-mb-1"], [3, "p-label", 4, "ngFor", "ngForOf"], [3, "p-label"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "po-row po-mb-1", 4, "ngIf"], [4, "ngIf"], [1, "po-row", "po-mb-1"], [3, "p-color", "p-value"]],
    template: function PoHttpInterceptorDetailComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "po-modal", 2)(1, "div", 3);
        ɵɵtemplate(2, PoHttpInterceptorDetailComponent_po_accordion_2_Template, 2, 1, "po-accordion", 4);
        ɵɵelementEnd()();
        ɵɵtemplate(3, PoHttpInterceptorDetailComponent_ng_template_3_Template, 1, 5, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, PoHttpInterceptorDetailComponent_ng_template_5_Template, 5, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const elseBlock_r5 = ɵɵreference(4);
        ɵɵproperty("p-primary-action", ctx.primaryAction)("p-title", ctx.title);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.details.length > 1)("ngIfElse", elseBlock_r5);
      }
    },
    dependencies: [NgForOf, NgIf, NgTemplateOutlet, PoAccordionComponent, PoAccordionItemComponent, PoModalComponent, PoTagComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpInterceptorDetailComponent, [{
    type: Component,
    args: [{
      selector: "po-http-interceptor-detail",
      standalone: false,
      template: '<po-modal p-hide-close p-size="lg" [p-primary-action]="primaryAction" [p-title]="title">\n  <div class="po-row">\n    <po-accordion class="po-md-12 po-mt-1 po-mb-1" *ngIf="details.length > 1; else elseBlock">\n      <po-accordion-item *ngFor="let detail of details" [p-label]="formatDetailItemTitle(detail)">\n        <ng-template [ngTemplateOutlet]="body" [ngTemplateOutletContext]="{ detail }"></ng-template>\n      </po-accordion-item>\n    </po-accordion>\n  </div>\n</po-modal>\n\n<ng-template #elseBlock>\n  <ng-container [ngTemplateOutlet]="body" [ngTemplateOutletContext]="{ detail: details[0] || {} }"></ng-container>\n</ng-template>\n\n<ng-template #body let-detail="detail">\n  <div *ngIf="detail.type" class="po-row po-mb-1">\n    <po-tag [p-color]="typeColor(detail.type)" [p-value]="typeValue(detail.type)"></po-tag>\n  </div>\n\n  <p *ngIf="detail.detailTitle">\n    <strong>{{ detail.code }}</strong>\n  </p>\n\n  <div class="po-row">\n    <p>{{ detail.detailedMessage }}</p>\n  </div>\n</ng-template>\n'
    }]
  }], () => [{
    type: PoLanguageService
  }], {
    modal: [{
      type: ViewChild,
      args: [PoModalComponent, {
        static: true
      }]
    }]
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoHttpInterceptorDetailComponent, {
    className: "PoHttpInterceptorDetailComponent",
    filePath: "lib/interceptors/po-http-interceptor/po-http-interceptor-detail/po-http-interceptor-detail.component.ts",
    lineNumber: 24
  });
})();
var poHttpInterceptorLiterals = {
  pt: {
    help: "Ajuda",
    details: "Detalhes",
    serverNotResponse: "Servidor não está respondendo"
  },
  en: {
    help: "Help",
    details: "Details",
    serverNotResponse: "Server is not responding"
  },
  es: {
    help: "Ayuda",
    details: "Detalles",
    serverNotResponse: "El servidor no está respondiendo"
  },
  ru: {
    help: "Помогите",
    details: "Детали",
    serverNotResponse: "Сервер не отвечает"
  }
};
var NO_ERROR_HEADER_PARAM = "X-PO-No-Error";
var NO_MESSAGE_HEADER_PARAM = "X-PO-No-Message";
var PoHttpInterceptorBaseService = class {
  componentInjector;
  notification;
  languageService;
  notificationTypes = ["success", "warning", "error", "information"];
  literals;
  httpInterceptorDetailComponent = void 0;
  constructor(componentInjector, notification, languageService) {
    this.componentInjector = componentInjector;
    this.notification = notification;
    this.languageService = languageService;
    this.literals = poHttpInterceptorLiterals[this.languageService?.getShortLanguage()];
  }
  intercept(request, next) {
    const cloneRequest = request.clone();
    request = request && this.hasParameters(request) ? this.cloneRequestWithoutParameters(request) : request;
    return next.handle(request).pipe(tap((response) => {
      if (response instanceof HttpResponse) {
        this.processResponse(response, cloneRequest);
      }
    }, (error) => {
      this.processErrorResponse(error, cloneRequest);
    }));
  }
  processResponse(response, request) {
    const hasNoMessageParam = this.hasNoMessageParam(request);
    if (!hasNoMessageParam && response.body && response.body._messages) {
      const messages = response.body._messages;
      if (messages instanceof Array) {
        messages.forEach((message) => {
          this.showNotification(message);
        });
      } else {
        this.showNotification(messages);
      }
    }
  }
  processErrorResponse(response, request) {
    const errorResponse = response.status !== 0 ? response.error : {
      code: 0,
      message: this.literals.serverNotResponse,
      detailedMessage: response.message
    };
    const hasNoErrorParam = this.hasNoErrorParam(request);
    const hasNoMessageParam = this.hasNoMessageParam(request);
    const errorResponseValidTypes = this.notificationTypes.slice(1);
    if (errorResponse && errorResponse.message && !hasNoErrorParam && !hasNoMessageParam) {
      this.showNotification(__spreadProps(__spreadValues({}, errorResponse), {
        type: errorResponseValidTypes.includes(errorResponse.type) ? errorResponse.type : "error"
      }));
    }
  }
  cloneRequestWithoutParameters(request) {
    const headers = request.headers.delete(NO_ERROR_HEADER_PARAM).delete(NO_MESSAGE_HEADER_PARAM);
    return request.clone({
      headers
    });
  }
  createModal(responseMessage) {
    const details = responseMessage.details ? [responseMessage, ...responseMessage.details] : [responseMessage];
    this.httpInterceptorDetailComponent = this.componentInjector.createComponentInApplication(PoHttpInterceptorDetailComponent);
    this.httpInterceptorDetailComponent.instance.detail = details;
    this.httpInterceptorDetailComponent.instance.closed.subscribe(() => this.destroyModal());
    this.httpInterceptorDetailComponent.instance.open();
  }
  destroyModal() {
    if (this.httpInterceptorDetailComponent) {
      this.componentInjector.destroyComponentInApplication(this.httpInterceptorDetailComponent);
      this.httpInterceptorDetailComponent = void 0;
    }
  }
  hasMessage(responseMessage) {
    const hasMessageProperties = responseMessage.message;
    return responseMessage && hasMessageProperties;
  }
  hasNoErrorParam(request) {
    const noErrorParam = request && request.headers.get(NO_ERROR_HEADER_PARAM);
    return noErrorParam && noErrorParam.toString().toLocaleLowerCase() === "true";
  }
  hasNoMessageParam(request) {
    const noMessageParam = request && request.headers.get(NO_MESSAGE_HEADER_PARAM);
    return noMessageParam && noMessageParam.toString().toLocaleLowerCase() === "true";
  }
  hasParameters(request) {
    return request.headers.has(NO_ERROR_HEADER_PARAM) || request.headers.has(NO_MESSAGE_HEADER_PARAM);
  }
  showNotification(response) {
    if (!this.hasMessage(response)) {
      return;
    }
    const typeNotification = this.notificationTypes.includes(response.type) ? response.type : "information";
    const notificationAction = this.generateNotificationAction(response);
    this.notification[typeNotification]({
      message: response.message,
      actionLabel: notificationAction.label,
      action: notificationAction.action
    });
  }
  generateDetailModal(responseMessage) {
    return () => {
      if (!this.httpInterceptorDetailComponent) {
        this.createModal(responseMessage);
      }
    };
  }
  generateNotificationAction(responseMessage) {
    let notificationAction;
    let notificationLabel;
    if (responseMessage.helpUrl && !(responseMessage.detailedMessage || responseMessage.details)) {
      notificationLabel = this.literals.help;
      notificationAction = this.generateUrlHelpFunction(responseMessage.helpUrl);
    } else if (responseMessage.detailedMessage || responseMessage.details) {
      notificationLabel = this.literals.details;
      notificationAction = this.generateDetailModal(responseMessage);
    }
    return {
      label: notificationLabel,
      action: notificationAction
    };
  }
  generateUrlHelpFunction(helpUrl) {
    return () => {
      window.open(helpUrl, "_blank");
    };
  }
};
var PoHttpInterceptorService = class _PoHttpInterceptorService extends PoHttpInterceptorBaseService {
  constructor(notification, componentInjector, languageService) {
    super(componentInjector, notification, languageService);
  }
  static ɵfac = function PoHttpInterceptorService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoHttpInterceptorService)(ɵɵinject(PoNotificationService), ɵɵinject(PoComponentInjectorService), ɵɵinject(PoLanguageService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoHttpInterceptorService,
    factory: _PoHttpInterceptorService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpInterceptorService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PoNotificationService
  }, {
    type: PoComponentInjectorService
  }, {
    type: PoLanguageService
  }], null);
})();
var PoHttpInterceptorModule = class _PoHttpInterceptorModule {
  static ɵfac = function PoHttpInterceptorModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoHttpInterceptorModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoHttpInterceptorModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoHttpInterceptorService, PoNotificationService, {
      provide: HTTP_INTERCEPTORS,
      useClass: PoHttpInterceptorService,
      multi: true
    }],
    imports: [CommonModule, PoAccordionModule, PoModalModule, PoNotificationModule, PoTagModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpInterceptorModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoAccordionModule, PoModalModule, PoNotificationModule, PoTagModule],
      declarations: [PoHttpInterceptorDetailComponent],
      providers: [PoHttpInterceptorService, PoNotificationService, {
        provide: HTTP_INTERCEPTORS,
        useClass: PoHttpInterceptorService,
        multi: true
      }]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoHttpInterceptorModule, {
    declarations: [PoHttpInterceptorDetailComponent],
    imports: [CommonModule, PoAccordionModule, PoModalModule, PoNotificationModule, PoTagModule]
  });
})();
var PoHttpRequesControltService = class _PoHttpRequesControltService {
  controlHttpRequest = new Subject();
  getControlHttpRequest() {
    return this.controlHttpRequest.asObservable();
  }
  send(value = 0) {
    this.controlHttpRequest.next(value);
  }
  static ɵfac = function PoHttpRequesControltService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoHttpRequesControltService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoHttpRequesControltService,
    factory: _PoHttpRequesControltService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpRequesControltService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var noCountPendingRequests = "X-PO-No-Count-Pending-Requests";
var screenLock = "X-PO-Screen-Lock";
var PoHttpRequestInterceptorService = class _PoHttpRequestInterceptorService {
  controlHttpRequest;
  poComponentInjector;
  loadingOverlayComponent = void 0;
  pendingRequests = 0;
  overlayRequests = 0;
  constructor(controlHttpRequest, poComponentInjector) {
    this.controlHttpRequest = controlHttpRequest;
    this.poComponentInjector = poComponentInjector;
  }
  intercept(request, next) {
    const requestClone = request.clone();
    request = this.requestCloneWithoutHeaderParam([noCountPendingRequests, screenLock], request);
    this.setCountPendingRequests(true, requestClone);
    this.setCountOverlayRequests(true, requestClone);
    return next.handle(request).pipe(finalize(() => {
      this.setCountPendingRequests(false, requestClone);
      this.setCountOverlayRequests(false, requestClone);
    }));
  }
  getCountPendingRequests() {
    return this.controlHttpRequest.getControlHttpRequest();
  }
  buildLoading() {
    if (!this.loadingOverlayComponent) {
      this.loadingOverlayComponent = this.poComponentInjector.createComponentInApplication(PoLoadingOverlayComponent);
      this.loadingOverlayComponent.instance.screenLock = true;
      this.loadingOverlayComponent.instance.changeDetector.detectChanges();
    }
  }
  destroyLoading() {
    if (this.loadingOverlayComponent) {
      this.poComponentInjector.destroyComponentInApplication(this.loadingOverlayComponent);
      this.loadingOverlayComponent = void 0;
    }
  }
  requestCloneWithoutHeaderParam(headersParams, request) {
    let isRequestClone = false;
    headersParams.forEach((headerParam) => {
      if (request.headers.has(headerParam)) {
        request = request.clone({
          headers: request.headers.delete(headerParam)
        });
        isRequestClone = true;
      }
    });
    return isRequestClone ? request.clone({
      headers: request.headers
    }) : request;
  }
  setCountPendingRequests(isIncrement, request) {
    const hasCountPendingRequestHeaderParam = request.headers.has(noCountPendingRequests);
    const headerParam = request.headers.get(noCountPendingRequests);
    if (hasCountPendingRequestHeaderParam && headerParam.toString().toLowerCase() === "true") {
      return;
    }
    this.pendingRequests += isIncrement ? 1 : -1;
    this.controlHttpRequest.send(this.pendingRequests);
  }
  setCountOverlayRequests(isIncrement, request) {
    const hasOverlayRequestHeaderParam = request.headers.has(screenLock);
    if (hasOverlayRequestHeaderParam) {
      const headerParam = request.headers.get(screenLock);
      if (headerParam.toString().toLowerCase() === "false") {
        return;
      }
      this.overlayRequests += isIncrement ? 1 : -1;
      this.overlayRequests > 0 ? this.buildLoading() : this.destroyLoading();
    }
  }
  static ɵfac = function PoHttpRequestInterceptorService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoHttpRequestInterceptorService)(ɵɵinject(PoHttpRequesControltService), ɵɵinject(PoComponentInjectorService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _PoHttpRequestInterceptorService,
    factory: _PoHttpRequestInterceptorService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpRequestInterceptorService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PoHttpRequesControltService
  }, {
    type: PoComponentInjectorService
  }], null);
})();
var PoHttpRequestModule = class _PoHttpRequestModule {
  static ɵfac = function PoHttpRequestModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoHttpRequestModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoHttpRequestModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoHttpRequesControltService, PoHttpRequestInterceptorService, PoComponentInjectorService, {
      provide: HTTP_INTERCEPTORS,
      useClass: PoHttpRequestInterceptorService,
      multi: true
    }],
    imports: [PoLoadingModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpRequestModule, [{
    type: NgModule,
    args: [{
      imports: [PoLoadingModule],
      providers: [PoHttpRequesControltService, PoHttpRequestInterceptorService, PoComponentInjectorService, {
        provide: HTTP_INTERCEPTORS,
        useClass: PoHttpRequestInterceptorService,
        multi: true
      }]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoHttpRequestModule, {
    imports: [PoLoadingModule]
  });
})();
var PoInterceptorsModule = class _PoInterceptorsModule {
  static ɵfac = function PoInterceptorsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoInterceptorsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoInterceptorsModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [PoHttpInterceptorModule, PoHttpRequestModule, PoHttpInterceptorModule, PoHttpRequestModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInterceptorsModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [PoHttpInterceptorModule, PoHttpRequestModule],
      exports: [PoHttpInterceptorModule, PoHttpRequestModule],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoInterceptorsModule, {
    imports: [PoHttpInterceptorModule, PoHttpRequestModule],
    exports: [PoHttpInterceptorModule, PoHttpRequestModule]
  });
})();
var PoPipesModule = class _PoPipesModule {
  static ɵfac = function PoPipesModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoPipesModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoPipesModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [PoTimeModule, PoTimeModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPipesModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [PoTimeModule],
      exports: [PoTimeModule],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoPipesModule, {
    imports: [PoTimeModule],
    exports: [PoTimeModule]
  });
})();
var PoModule = class _PoModule {
  static ɵfac = function PoModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoModule
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PoNotificationService],
    imports: [PoComponentsModule, PoDirectivesModule, PoGuardsModule, PoInterceptorsModule, PoPipesModule, PoServicesModule, PoComponentsModule, PoDirectivesModule, PoInterceptorsModule, PoGuardsModule, PoPipesModule, PoServicesModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [PoComponentsModule, PoDirectivesModule, PoGuardsModule, PoInterceptorsModule, PoPipesModule, PoServicesModule],
      exports: [PoComponentsModule, PoDirectivesModule, PoInterceptorsModule, PoGuardsModule, PoPipesModule, PoServicesModule],
      providers: [PoNotificationService],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoModule, {
    imports: [PoComponentsModule, PoDirectivesModule, PoGuardsModule, PoInterceptorsModule, PoPipesModule, PoServicesModule],
    exports: [PoComponentsModule, PoDirectivesModule, PoInterceptorsModule, PoGuardsModule, PoPipesModule, PoServicesModule]
  });
})();
var ForceBooleanComponentEnum;
(function(ForceBooleanComponentEnum2) {
  ForceBooleanComponentEnum2["switch"] = "switch";
  ForceBooleanComponentEnum2["checkbox"] = "checkbox";
})(ForceBooleanComponentEnum || (ForceBooleanComponentEnum = {}));
var ForceOptionComponentEnum;
(function(ForceOptionComponentEnum2) {
  ForceOptionComponentEnum2["radioGroup"] = "radioGroup";
  ForceOptionComponentEnum2["select"] = "select";
})(ForceOptionComponentEnum || (ForceOptionComponentEnum = {}));
function validatePropertyOnLifeCycle(decoratorProperties, lifecycleName, callback) {
  const {
    target,
    property
  } = decoratorProperties;
  const emptyFunction = () => {
  };
  const lifecycleFunctionClone = target[lifecycleName] || emptyFunction;
  Object.defineProperty(target, lifecycleName, {
    value: function() {
      callback.call(this, property, target);
      lifecycleFunctionClone.call(this);
    }
  });
}
function changeValueByCallback(decoratorProperties, decoratorName, callback) {
  const {
    target,
    property,
    originalDescriptor
  } = decoratorProperties;
  const privatePropertyName = createPrivateProperty(target, property, decoratorName);
  return {
    get: getter(originalDescriptor, privatePropertyName),
    set: setter(originalDescriptor, callback, privatePropertyName)
  };
}
function setter(originalDescriptor, callback, privatePropertyName) {
  return function(value) {
    if (originalDescriptor && originalDescriptor.set) {
      originalDescriptor.set.bind(this)(callback(value));
    }
    this[privatePropertyName] = callback(value);
  };
}
function getter(originalDescriptor, privatePropName) {
  return function() {
    return originalDescriptor && originalDescriptor.get ? originalDescriptor.get.bind(this)() : this[privatePropName];
  };
}
function createPrivateProperty(target, propertyName, decoratorName) {
  const privatePropName = `$$__${propertyName}`;
  if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
    console.warn(`The prop "${privatePropName}" is already exist, it will be overrided by ${decoratorName} decorator.`);
  }
  Object.defineProperty(target, privatePropName, {
    configurable: true,
    writable: true
  });
  return privatePropName;
}
function InputBoolean() {
  return function(target, property, originalDescriptor) {
    const decoratorProperties = {
      target,
      property,
      originalDescriptor
    };
    return changeValueByCallback(decoratorProperties, "InputBoolean", convertToBoolean);
  };
}
function InputRequired() {
  return function(target, property) {
    const decoratorProperties = {
      target,
      property
    };
    validatePropertyOnLifeCycle(decoratorProperties, "ngOnInit", validateProperty);
  };
}
function validateProperty(property, target) {
  if (this[property] == null) {
    console.warn(`${target.constructor.name}: ${property} is required, but was not provided`);
  }
}
var I18N_CONFIG = new InjectionToken("I18N_CONFIG");
var PoI18nBaseService = class _PoI18nBaseService {
  config;
  http;
  languageService;
  varI18n = {};
  contextDefault;
  useCache = false;
  servicesContext = {};
  constructor(config, http, languageService) {
    this.config = config;
    this.http = http;
    this.languageService = languageService;
    this.setConfig(config);
  }
  /**
   * <a id="get-language"></a>
   * Método que retorna o idioma padrão ativo.
   *
   * A busca deste idioma pelo método será feita na seguinte ordem:
   *
   *   1 - o idioma que foi armazenado no *localStorage*, através do método [`setLanguage()`](documentation/po-i18n#setLanguage).
   *
   *   2 - o valor inserido no módulo do i18n através do parâmetro `config`, sendo o idioma inserido na propriedade
   * `language` da interface [`PoI18nConfigDefault`](documentation/po-i18n#poI18nConfigDefault).
   *
   *   3 - o idioma do navegador utilizado.
   *
   * > Caso o idioma do navegador não seja suportado pelo PO (`pt`, `en`, `es` ou `ru`), será retornado valor `pt`.
   *
   * @returns {string} sigla do idioma padrão.
   */
  getLanguage() {
    return this.languageService.getLanguage();
  }
  getLiterals(options = {}) {
    const language = options["language"] ? options["language"].toLowerCase() : this.getLanguage();
    const context = options["context"] ? options["context"] : this.contextDefault;
    const literals = options["literals"] ? options["literals"] : [];
    return new Observable((observer) => {
      if (this.servicesContext[context]) {
        this.getLiteralsFromContextService(language, context, literals, observer);
      } else {
        this.getLiteralsFromContextConstant(language, context, literals, observer);
      }
    });
  }
  /**
   * Método que retorna o idioma padrão ativo, com somente a abreviação do idioma (duas primeiras letras).
   * Por exemplo: "pt" ou "es".
   *
   * A busca deste idioma é baseada no método [**getLanguage()**](/documentation/po-i18n#get-language).
   *
   * @returns {string} sigla do idioma padrão.
   */
  getShortLanguage() {
    return this.languageService.getShortLanguage();
  }
  /**
   * <a id="setLanguage"></a>
   * Método para alterar o idioma padrão do módulo do i18n.
   *
   * Ao utilizar este método, o idioma ficará gravado no armazenamento local do navegador, que será utilizado pelo
   * serviço do `i18n` para buscar as literais no idioma padrão.
   *
   * @param {string} language Sigla do idioma.
   *
   * Esta sigla deve ser composta por duas letras representando o idioma,
   * podendo ser adicionado outras duas letras representando o país, por exemplo: `pt`, `pt-BR`, `pt-br`, `en` ou `en-US`.
   *
   * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
   *
   * @param {boolean} reload Indica se a página atual poderá ser recarregada após a alteração do idioma.
   *
   * Este recurso pode ser útil para os usuários que utilizam o método `getLiterals()` do serviço do i18n para poder
   * buscar novamente as literais no novo idioma configurado.
   */
  setLanguage(language, reload = false) {
    if (!isLanguage(language)) {
      return;
    }
    this.languageService.setLanguage(language);
    if (reload) {
      reloadCurrentPage();
    }
  }
  setConfig(config) {
    if (config["default"]) {
      this.languageService.setLanguageDefault(config["default"]["language"]);
      this.contextDefault = config["default"]["context"] ? config["default"]["context"] : "";
      this.useCache = config["default"]["cache"] ? config["default"]["cache"] : false;
    }
    if (config["contexts"]) {
      this.setVarI18n(config["contexts"]);
      if (!this.contextDefault) {
        for (const context in config["contexts"]) {
          if (this.config["contexts"].hasOwnProperty(context)) {
            this.contextDefault = context;
            break;
          }
        }
      }
    }
  }
  // Processo de busca de um contexto que contém serviço.
  //    1 - Procura na variável I18n deste serviço
  //    2 - Procura no local storage (Se o cache estiver definido como true na configuração do módulo)
  //    3 - Dispara o serviço, mesmo que já tenha encontrado no local storage, para garantir a atualização
  //    4 - Se nenhuma literal for encontrada, então busca em pt-br
  getLiteralsFromContextService(language, context, literals, observer, translations = {}, languageAlternative = null) {
    const languageSearch = languageAlternative ? languageAlternative : language;
    translations = this.mergeObject(translations, this.searchInVarI18n(languageSearch, context, literals));
    if (this.countObject(translations) > 0) {
      observer.next(translations);
    }
    this.getLiteralsLocalStorageAndCache(languageSearch, context, literals, observer, translations, languageAlternative);
  }
  // Procura no local storage e em seguida no serviço
  // Caso não encontre nem no serviço, recomeça a busca em pt-br
  getLiteralsLocalStorageAndCache(language, context, literals, observer, translations, languageAlternative = null) {
    const languageSearch = languageAlternative ? languageAlternative : language;
    let translationTemp;
    if (this.useCache) {
      translationTemp = this.searchInLocalStorage(languageSearch, context, literals);
      if (this.countObject(translationTemp) > 0) {
        this.updateVarI18n(language, context, translationTemp);
        translations = this.mergeObject(translationTemp, translations);
        observer.next(translations);
      }
    }
    this.getHttpService(this.servicesContext[context], languageSearch, literals).subscribe((response) => {
      if (response) {
        this.updateLocalStorage(language, context, response);
        this.updateVarI18n(language, context, response);
        translationTemp = this.searchInVarI18n(language, context, literals);
        translations = this.mergeObject(translationTemp, translations);
        observer.next(translations);
      }
      if (literals.length > this.countObject(translations)) {
        if (languageAlternative === "pt-br") {
          translations = this.completeFaultLiterals(language, context, literals, translations);
          this.updateLocalStorage(language, context, translations);
          this.updateVarI18n(language, context, translations);
          observer.next(translations);
        } else {
          this.getLiteralsFromContextService(language, context, literals, observer, translations, "pt-br");
        }
      }
    });
  }
  // Procura pela lista de literais
  // Se não encontrar todas, procura em pt-br
  getLiteralsFromContextConstant(language, context, literals, observer, translations = {}) {
    translations = this.mergeObject(translations, this.searchInVarI18n(language, context, literals));
    if (this.countObject(translations) > 0) {
      observer.next(translations);
    }
    if (literals.length > 0) {
      if (literals.length > this.countObject(translations)) {
        if (language === "pt-br") {
          translations = this.completeFaultLiterals(language, context, literals, translations);
          observer.next(translations);
        } else {
          this.getLiteralsFromContextConstant("pt-br", context, literals, observer, translations);
        }
      }
    } else {
      if (this.countObject(translations) === 0 && language !== "pt-br") {
        this.getLiteralsFromContextConstant("pt-br", context, literals, observer, translations);
      }
      observer.next(translations);
      observer.complete();
    }
  }
  // Busca pelas literais no local storage
  searchInLocalStorage(language, context, literals) {
    const translations = {};
    if (literals.length > 0) {
      for (let i = 0; i < literals.length; i++) {
        const literal = literals[i];
        const translation = localStorage.getItem(language + "-" + context + "-" + literal);
        if (translation) {
          translations[literal] = translation;
        }
      }
    }
    return translations;
  }
  // Busca pelas literais na variável do serviço
  searchInVarI18n(language, context, literals) {
    let translations = {};
    if (this.varI18n[language] && this.varI18n[language][context]) {
      const content = this.varI18n[language][context];
      if (literals.length > 0) {
        for (let i = 0; i < literals.length; i++) {
          const literal = literals[i];
          if (content.hasOwnProperty(literal)) {
            translations[literal] = content[literal];
          }
        }
      } else {
        translations = __spreadValues({}, content);
      }
    }
    return translations;
  }
  // Atualiza o local storage
  updateLocalStorage(language, context, data) {
    if (this.useCache) {
      for (const literal of Object.keys(data)) {
        localStorage.setItem(language + "-" + context + "-" + literal, data[literal]);
      }
    }
  }
  // Atualiza a variável local com as literais com os objetos passados na configuração
  setVarI18n(contexts) {
    for (const context of Object.keys(contexts)) {
      const contextContent = contexts[context];
      for (const language of Object.keys(contextContent)) {
        const languageContent = contextContent[language];
        if (language === "url") {
          this.servicesContext[context] = languageContent;
        } else {
          this.updateVarI18n(language, context, languageContent);
        }
      }
    }
  }
  // Atualiza a variável local com as literais idioma e contexto
  updateVarI18n(language, context, data) {
    language = language.toLowerCase();
    if (!this.varI18n[language]) {
      this.varI18n[language] = {
        [context]: {}
      };
    }
    if (!this.varI18n[language][context]) {
      this.varI18n[language][context] = {};
    }
    this.varI18n[language][context] = this.mergeObject(data, this.varI18n[language][context]);
  }
  getHttpService(url, language, literals) {
    let param = "?language=" + language;
    if (literals.length > 0) {
      param += "&literals=" + literals.join();
    }
    url = url.replace(/\/$/, "");
    return this.http.get(`${url}${param}`);
  }
  // Completa com o nome da literais, as que não foram encontradas
  completeFaultLiterals(language, context, literals, translations) {
    for (let i = 0; i < literals.length; i++) {
      const literal = literals[i];
      if (!translations[literal]) {
        translations[literal] = literal;
      }
    }
    return translations;
  }
  // Conta os atributos do objeto
  countObject(obj) {
    return Object.keys(obj).length;
  }
  // Faz o merge dos objetos, sempre dando preferência para o primeiro objeto de parâmetro
  mergeObject(objPermanent, obj) {
    return __spreadValues(__spreadValues({}, obj), objPermanent);
  }
  static ɵfac = function PoI18nBaseService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoI18nBaseService)(ɵɵdirectiveInject(I18N_CONFIG), ɵɵdirectiveInject(HttpClient), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _PoI18nBaseService
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoI18nBaseService, [{
    type: Directive
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [I18N_CONFIG]
    }]
  }, {
    type: HttpClient,
    decorators: [{
      type: Inject,
      args: [HttpClient]
    }]
  }, {
    type: PoLanguageService
  }], null);
})();
var PoI18nService = class _PoI18nService extends PoI18nBaseService {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoI18nService_BaseFactory;
    return function PoI18nService_Factory(__ngFactoryType__) {
      return (ɵPoI18nService_BaseFactory || (ɵPoI18nService_BaseFactory = ɵɵgetInheritedFactory(_PoI18nService)))(__ngFactoryType__ || _PoI18nService);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({
    token: _PoI18nService,
    factory: _PoI18nService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoI18nService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function returnPoI18nService(config, http, languageService) {
  return new PoI18nService(config, http, languageService);
}
var PoI18nModule = class _PoI18nModule {
  static config(config) {
    return {
      ngModule: _PoI18nModule,
      providers: [{
        provide: I18N_CONFIG,
        useValue: config
      }, provideAppInitializer(() => {
        const initializerFn = initializeLanguageDefault(inject(I18N_CONFIG), inject(PoLanguageService));
        return initializerFn();
      }), {
        provide: PoI18nService,
        useFactory: returnPoI18nService,
        deps: [I18N_CONFIG, HttpClient, PoLanguageService]
      }]
    };
  }
  static ɵfac = function PoI18nModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PoI18nModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PoI18nModule
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [PoLanguageModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoI18nModule, [{
    type: NgModule,
    args: [{
      imports: [PoLanguageModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoI18nModule, {
    imports: [PoLanguageModule]
  });
})();
function initializeLanguageDefault(config, languageService) {
  const setDefaultLanguage = () => {
    if (config.default.language) {
      languageService.setLanguageDefault(config.default.language);
    }
  };
  return setDefaultLanguage;
}

export {
  PoDividerSize,
  PoDividerComponent,
  PoDividerModule,
  ICONS_DICTIONARY,
  PoIconDictionary,
  AnimaliaIconDictionary,
  PoIconComponent,
  PoIconModule,
  PoTagOrientation,
  PoTagType,
  poLanguageDefault,
  poLocales,
  poLocaleDefault,
  poLocaleDecimalSeparatorList,
  poLocaleThousandSeparatorList,
  poLocaleDateSeparatorList,
  PoLanguageService,
  PO_CONTROL_POSITIONS,
  PoTooltipDirective,
  PoTagComponent,
  PoTooltipModule,
  PoTagModule,
  PoLanguageModule,
  PoAccordionItemComponent,
  PoAccordionComponent,
  PoAccordionModule,
  PoAvatarComponent,
  PoAvatarModule,
  PoBadgeComponent,
  PoBadgeModule,
  PoLinkComponent,
  PoOverlayComponent,
  PoLoadingIconComponent,
  PoLoadingComponent,
  PoLoadingOverlayComponent,
  PoCheckboxSize,
  PoLabelComponent,
  PoDirectivesModule,
  PoFieldContainerBottomComponent,
  PoFieldContainerComponent,
  PoCheckboxComponent,
  PoItemListComponent,
  PoSearchListComponent,
  PoListBoxComponent,
  PoPopupComponent,
  poBreadcrumbLiterals,
  PoBreadcrumbComponent,
  PoLinkModule,
  PoLabelModule,
  PoFieldContainerModule,
  PoCheckboxModule,
  PoOverlayModule,
  PoLoadingModule,
  PoListBoxModule,
  PoPopupModule,
  PoBreadcrumbModule,
  PoButtonType,
  PoButtonComponent,
  PoButtonModule,
  PoButtonGroupToggle,
  PoButtonGroupComponent,
  PoButtonGroupModule,
  PoCalendarMode,
  PoDateService,
  PoDateTimeModule,
  PoCalendarComponent,
  PoCalendarModule,
  PoChartType,
  PoChartLabelFormat,
  PoChartComponent,
  PoChartModule,
  PoContainerComponent,
  PoContainerModule,
  PoDisclaimerComponent,
  PoDisclaimerModule,
  PoDisclaimerGroupComponent,
  PoDisclaimerGroupModule,
  PoDropdownComponent,
  PoDropdownModule,
  PoCheckboxGroupComponent,
  PoCheckboxGroupModule,
  PoRadioComponent,
  PoRadioGroupComponent,
  PoRadioModule,
  PoRadioGroupModule,
  PoCleanComponent,
  PoCleanModule,
  PoMask,
  PoDatepickerIsoFormat,
  PoDatepickerComponent,
  PoDatepickerModule,
  PoModalFooterComponent,
  PoActiveOverlayService,
  PoModalComponent,
  PoModalModule,
  PoProgressStatus,
  PoProgressSize,
  PoProgressComponent,
  PoProgressModule,
  PoActiveOverlayModule,
  PoColorPaletteService,
  PoColorPaletteModule,
  PoComponentInjectorService,
  PoComponentInjectorModule,
  PoControlPositionModule,
  PoDialogType,
  poDialogAlertLiteralsDefault,
  poDialogConfirmLiteralsDefault,
  PoDialogComponent,
  PoDialogService,
  PoDialogModule,
  PoI18nPipe,
  PoMediaQueryService,
  PoMediaQueryModule,
  PoToasterMode,
  PoToasterOrientation,
  PoToasterType,
  poToasterLiterals,
  PoToasterComponent,
  PoToasterModule,
  PoNotificationModule,
  PoThemeA11yEnum,
  PoThemeTypeEnum,
  poThemeDefaultAA,
  poThemeDefaultAAA,
  poThemeDefaultActions,
  poThemeDefaultNeutrals,
  poThemeDefaultFeedback,
  poThemeDefaultBrands,
  poThemeDefaultLightValues,
  poThemeDefaultActionsDark,
  poThemeDefaultNeutralsDark,
  poThemeDefaultFeedbackDark,
  poThemeDefaultBrandsDark,
  poThemeDefaultDarkValues,
  poThemeDefaultLight,
  poThemeDefaultDark,
  poThemeDefault,
  PoThemeService,
  PoThemeModule,
  PoServicesModule,
  PoPopoverComponent,
  PoPopoverModule,
  PoTimePipe,
  PoTimeModule,
  PoPageSlideFooterComponent,
  poPageSlideLiteralsDefault,
  PoPageSlideComponent,
  PoPageSlideModule,
  PoSwitchLabelPosition,
  PoSwitchComponent,
  PoNotificationService,
  PoTableRowTemplateArrowDirection,
  PoSearchFilterMode,
  PoTableColumnSortType,
  PoTableColumnSpacing,
  PoTableCellTemplateDirective,
  PoTableColumnTemplateDirective,
  PoTableRowTemplateDirective,
  PoTableComponent,
  PoSwitchModule,
  PoTableColumnFrozenDirective,
  PoComboFilterMode,
  PoComboOptionTemplateDirective,
  PoComboComponent,
  PoDatepickerRangeComponent,
  PoDecimalComponent,
  PoEmailComponent,
  PoInputComponent,
  PoLoginComponent,
  PoDynamicFormComponent,
  PoLookupModalComponent,
  PoLookupComponent,
  PoMultiselectOptionTemplateDirective,
  PoMultiselectFilterMode,
  PoMultiselectComponent,
  PoNumberComponent,
  PoPasswordComponent,
  PoRichTextToolbarActions,
  PoUploadStatus,
  PoUploadFile,
  PoUploadComponent,
  PoUrlComponent,
  PoRichTextComponent,
  PoSelectComponent,
  PoTextareaComponent,
  PoSearchComponent,
  PoSearchModule,
  PoTableModule,
  PoFieldModule,
  PoInfoOrientation,
  PoInfoComponent,
  PoInfoModule,
  PoDynamicFieldType,
  PoDynamicSharedBase,
  PoDynamicContainerComponent,
  PoImageComponent,
  PoDynamicViewComponent,
  PoImageModule,
  PoDynamicModule,
  PoGaugeComponent,
  PoGaugeModule,
  PoGridComponent,
  PoGridModule,
  PoListViewContentTemplateDirective,
  PoListViewDetailTemplateDirective,
  PoListViewComponent,
  PoListViewModule,
  PoLogoComponent,
  PoLogoModule,
  PoMenuPanelComponent,
  PoMenuPanelModule,
  PoMenuHeaderTemplateDirective,
  PoMenuGlobalService,
  PoMenuComponent,
  PoMenuModule,
  PoNavbarComponent,
  PoNavbarModule,
  PoPageDefaultComponent,
  PoPageDetailComponent,
  PoPageEditComponent,
  PoPageListComponent,
  PoPageModule,
  PoSlideContentTemplateDirective,
  PoSlideComponent,
  PoSlideModule,
  PoStepperStatus,
  PoStepComponent,
  PoStepperOrientation,
  PoStepperComponent,
  PoStepperModule,
  PoTabsService,
  PoTabComponent,
  poTabsLiterals,
  PoTabsComponent,
  PoTabsModule,
  PoToolbarComponent,
  PoToolbarModule,
  PoTreeViewComponent,
  PoTreeViewModule,
  PoWidgetComponent,
  PoWidgetModule,
  PoComponentsModule,
  PoGuardsModule,
  PoHttpInterceptorService,
  PoHttpInterceptorModule,
  PoHttpRequestInterceptorService,
  PoHttpRequestModule,
  PoInterceptorsModule,
  PoPipesModule,
  PoModule,
  ForceBooleanComponentEnum,
  ForceOptionComponentEnum,
  InputBoolean,
  InputRequired,
  I18N_CONFIG,
  PoI18nService,
  returnPoI18nService,
  PoI18nModule,
  initializeLanguageDefault
};
//# sourceMappingURL=chunk-5NOTSCWO.js.map
